///////////////////////////////////////////////////////////////////////////
// jse.c - a portable implementation of (J)ava(S)cript(E)cmascript 6th edition
//
// Created by Mohsen Agsen on 1/21/14.
// Copyright (c) 2014 Anui. All rights reserved.
//
//
// This code can be used in flexible ways depending on #define
// The entire code is in a single file which can be made into:
// 
//  - A header file by #define JSE_API and including jse.c
//  - A pure implementation file by #define JSE_IMPL
//  - A main entry executable by #define JSE_MAIN
//
// The code is designed so that it's also easy to extract a jse.h
// from jse.c by getting all the text between #ifdef JSE_API
// and #endif // JSE_API 
//
///////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////////
// Portable header use #define JSE_API to only include header
/////////////////////////////////////////////////////////////////////////////////
// - .jserc script_path, try run script on syntax error
// - edie fullscreen portable editor / debugger
// - 14.2 ArrowFunction 
// - debugger gdb mode 
// - double free for method definition [[HomeObject]]
/////////////////////////////////////////////////////////////////////////////////

#ifdef JSE_MAIN
#define JSE_DEBUG 1
#endif

#ifdef JSE_API
#ifdef __cplusplus 
extern "C" {
#endif


#define LINENOISE 1



////////// Debugging toggles
#define     DEBUG_MEMORY            1
// #define     SCRATCH                 1

////////// version information
#define JSE_VERSION_MAJOR   0
#define JSE_VERSION_MINOR   22
#define JSE_BUILD_NUMBER    2
#define JSE_BUILD_INC       1

/////////// primitive types
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef char int8;
typedef short int16;
typedef int int32;
typedef uint16 uchar;
typedef double number;
typedef int bool_t;

//////// forward declarations
struct StrTag;
typedef struct StrTag Str;
struct DynStrTag;
typedef struct DynStrTag DynStr;
struct OptionsTag;
typedef struct OptionsTag Options;
struct JsTag;
typedef struct JsTag Js;
struct RealmTag;
typedef struct RealmTag Realm;
struct RefTag;
typedef struct RefTag Ref;
struct ValTag;
typedef struct ValTag Val;
struct CompletionTag;
typedef struct CompletionTag Completion;
struct EnvTag;
typedef struct EnvTag Env;
struct ColorsTag;
typedef struct ColorsTag Colors;
struct TokenizerTag;
typedef struct TokenizerTag Tokenizer;
struct VectorTag;
typedef struct VectorTag Vector;
struct StrMapTag;
typedef struct StrMapTag Strmap;
struct PropertyTag;
typedef struct PropertyTag Property;
struct ObjectTag;
typedef struct ObjectTag Object;
struct ListTag;
typedef struct ListTag List;
struct ItemTag;
typedef struct ItemTag Item;
struct PtrListTag;
typedef struct PtrListTag PtrList;
struct PtrItemTag;
typedef struct PtrItemTag PtrItem;
struct DataTag;
typedef struct DataTag Data;
struct ContextTag;
typedef struct ContextTag Context;
struct EnvMethodsTag;
typedef struct EnvMethodsTag EnvMethods;
struct DeclEnvTag;
typedef struct DeclEnvTag DeclEnv;
struct ObjEnvTag;
typedef struct ObjEnvTag ObjEnv;
struct FuncEnvTag;
typedef struct FuncEnvTag FuncEnv;
struct GlobalEnvTag;
typedef struct GlobalEnvTag GlobalEnv;
struct LexEnvTag;
typedef struct LexEnvTag LexEnv;
struct TaskTag;
typedef struct TaskTag Task;
struct TaskQueueTag;
typedef struct TaskQueueTag TaskQueue;
struct NodeFlagTag;
typedef struct NodeFlagTag NodeFlag;
struct ParseNodeTag;
typedef struct ParseNodeTag Node;
struct FuncDefTag;
typedef struct FuncDefTag FuncDef;
struct BlockDefTag;
typedef struct BlockDefTag BlockDef;
struct ParserTag;  
typedef struct  ParserTag Parser;
struct DebuggerTag;
typedef struct DebuggerTag Debugger;
struct BreakptTag;
typedef struct BreakptTag Breakpt;
struct vectag;
typedef struct vectag vec;
struct heaptag;
typedef struct heaptag heap;
struct mitemtag;
typedef struct mitemtag mitem;
struct typeheaptag;
typedef struct typeheaptag typeheap;
struct ctagtag;
typedef struct ctagtag ctag;

// memory typed heap indices
enum { VA, OB, ND, PR, IT, LS, TK, BD, NF, DS, RM, CM, PL, PI, RF, DM, 
       BN, OM, FM, LE, CX, TQ, TS, PA, FD, DX, DG, DC, EN, ST, DA, XX, SM, 
       SE, CT, FE, HEAPS };


//////// Method and Slot Symbol Constants
#define _GetPrototypeOf_        "[[GetPrototypeOf]]"
#define _SetPrototypeOf_        "[[SetPrototypeOf]]"
#define _IsExtensible_          "[[IsExtensible]]"
#define _PreventExtensions_     "[[PreventExtensions]]"
#define _GetOwnProperty_        "[[GetOwnProperty]]"
#define _HasProperty_           "[[HasProperty]]"
#define _Get_                   "[[Get]]"
#define _Set_                   "[[Set]]"
#define _Delete_                "[[Delete]]"
#define _DefineOwnProperty_     "[[DefineOwnProperty]]"
#define _Enumerate_             "[[Enumerate]]"
#define _OwnPropertyKeys_       "[[OwnPropertyKeys]]"
#define _Call_                  "[[Call]]"
#define _Construct_             "[[Construct]]"
#define _ErrorData_             "[[ErrorData]]"
#define _DateValue_             "[[DateValue]]"
#define _RegExpMatcher_         "[[RegExpMatcher]]"       
#define _OriginalSource_        "[[OriginalSource]]"
#define _OriginalFlags_         "[[OriginalFlags]]"
#define _Extensible_            "[[Extensible]]"

#define _Destruct_              "[[Destruct]]"              

#define _BooleanData_           "[[BooleanData]]"
#define _NumberData_            "[[NumberData]]"
#define _StringData_            "[[StringData]]"
#define _SymbolData_            "[[SymbolData]]"

#define _BoundTargetFunction_   "[[BoundTargetFunction]]"
#define _Realm_                 "[[Realm]]"
#define _Parser_                "[[Parser]]"
#define _Steps_                 "[[Steps]]"

#define _IteratedList_          "[[IteratedList]]"
#define _IteratorNextIndex_     "[[IteratorNextIndex]]"

#define _HomeObject_            "[[HomeObject]]"
#define _ThisMode_              "[[ThisMode]]"
#define _NeedsSuper_            "[[NeedsSuper]]"
#define _MethodName_            "[[MethodName]]"
#define _Environment_           "[[Environment]]"
#define _Strict_                "[[Strict]]"
#define _FunctionKind_          "[[FunctionKind]]"
#define _ConstructorKind_       "[[ConstructorKind]]"
#define _Code_                  "[[Code]]"
#define _FormalParams_          "[[FormalParams]]"

#define _BoundArguments_        "[[BoundArguments]]"
#define _BoundThis_             "[[BoundThis]]"
#define _BoundTargetFunction    "[[BoundTargetFunction]]"

#define _ArrayInitState_        "[[ArrayInitState]]"

#define _IteratedObject_        "[[IteratedObject]]"
#define _ArrayIteratorNextIndex_ "[[ArrayIteratorNextIndex]]"
#define _ArrayIteratorKind_     "[[ArrayIteratorKind]]"

#define _StringData_            "[[StringData]]"

#define _ParameterMap_          "[[ParameterMap]]"

#define _Name_                  "[[Name]]"

#define _ViewArrayBuffer_       "[[ViewArrayBuffer]]"
#define _ArrayLength_           "[[ArrayLength]]"
#define _ByteOffset_            "[[ByteOffset]]"
#define _ByteLength_            "[[ByteLength]]"
#define _TypedArrayName_        "[[TypedArrayName]]"
#define _TypedArrayConstructorName_        "[[TypedArrayConstructorName]]"
#define _IntegerIndexedReadOnly "[[InteggerIndexedReadOnly]]"

#define _ArrayBufferData_       "[[ArrayBufferData]]"
#define _ArrayBufferByteLength_ "[[ArrayBufferByteLength]]"

#define _ProxyTarget_           "[[ProxyTarget]]"
#define _ProxyHandler_          "[[ProxyHandler]]"

#define _IteratedString_        "[[IteratedString]]"
#define _StringIteratorNextIndex_   "[[StringIteratorNextIndex]]"


#define _ConversionFunc_        "[[ConversionFunction]]"
#define _ConsName_              "[[Name]]"

/////// boolean values
enum bool_vals {
    FALSE = 0,
    TRUE = 1
};

///////// Js
struct ColorsTag {
    // console Colors
    char* normal;
    char* red;
    char* green;
    char* yellow;
    char* blue;
    char* magenta;
    char* cyan;
    char* white;
};


#define         DEBUG_LEVEL_NONE            0
#define         DEBUG_LEVEL_TOKENIZE        1
#define         DEBUG_LEVEL_PARSE           2
#define         MAX_PATH                    4096

struct OptionsTag {
    char*   command;
    char*   file;
    bool_t  watcher;
    bool_t  colors;
    bool_t  verbose;
    bool_t  quiet;
    bool_t  lines;
    bool_t  memory;
    bool_t  runtime;
    bool_t  debug;
    bool_t  opml;
    bool_t  opmlUseLR;
    bool_t  noHeader;
    bool_t  github;
    bool_t  ni;
    bool_t  genTags;
    bool_t  recursive;
    bool_t  functions;
    bool_t  tailInsert;         // Insert properties at the end of an object
    bool_t  debugLog;
    bool_t  callGraph;
    int     start;
    int     num;
    int     margin;
    char*   port;
    char*   outputFile;
    char    script_path[MAX_PATH];
};

#define NNU      (1 << 0)       // No Number cons
#define NFN      (1 << 1)       // No Function cons
#define NBL      (1 << 2)       // No Boolean cons
#define NSY      (1 << 3)       // No Symbol cons
#define NER      (1 << 4)       // No Error cons
#define NMT      (1 << 5)       // No Math obj
#define NDT      (1 << 6)       // No Date cons
#define NGF      (1 << 7)       // No global functions
#define NST      (1 << 8)       // No string functions
#define NAR      (1 << 9)       // No array functions
#define NTA      (1 << 10)      // No typed array functions
#define NAT      (1 << 11)      // No typed arrays other than In8Array
#define NRE      (1 << 12)      // No RegExp
#define NJS      (1 << 13)      // No JSON

#define NNN      (NNU | NFN | NBL | NSY | NER | NMT | NDT | NGF | NST | NAR | NTA | NRE | NJS)
#define ONLY(x)    (NNN & ~x)

struct JsTag {
    number                   localTZA;              // For test only, NAN if not set
    uint32                   noInit;                // No init flag list
    typeheap*                memory;
    int                      nextObject;
    Options                  options;
    int                      debugLevel;
    uint32                   total;                    // Total bytes allocated
    Colors                   colors;
    Debugger*                debugger;

    number                   loopLimit;

    /////// Keyword table
    Strmap*                  keywords;

    /////// ctags list
    ctag*                    ctags;
    
    /////// 6.1.5.1 Well Known Symbols
    Val* hasInstance;                  // @@hasInstance
    Val* isConcatSpreadable;           // ....
    Val* species;
    Val* isRegExp;                     //
    Val* match;
    Val* iterator;
    Val* toPrimitive;
    Val* toStringTag;
    Val* replace;
    Val* unscopables;
    Val* prototype;
    Val* search;
    Val* split;

    //////// Well known string constants
    Val* strLength;
    Val* strEmpty;
    Val* strCallee;
    Val* strCaller;
    Val* strArguments;
    Val* strGetPrototypeOf;
    Val* strSetPrototypeOf;
    Val* strIsExtensible;
    Val* strPreventExtensions;
    Val* strGetOwnPropertyDescriptor;
    Val* strDefineProperty;
    Val* strHas;
    Val* strGet;
    Val* strSet;
    Val* strDeleteProperty;
    Val* strEnumerate;
    Val* strOwnKeys;
    Val* strApply;
    Val* strConstruct;
    Val* strNext;
    Val* strZero;
    Val* strOne;
    Val* strFrozen;
    Val* strName;
    Val* strThrow;
    Val* strReturn;
    Val* strSealed;
    Val* strPrototype;
    Val* strMessage;
    
    Context*               currentContext;
    TaskQueue*             loadingTasks;
    TaskQueue*             promiseTasks;
    EnvMethods*            declEnvMethods;           // Declarative Env record methods
    EnvMethods*            objEnvMethods;
    EnvMethods*            funcEnvMethods;
    EnvMethods*            globalEnvMethods;
    
    int                     testResult;
};

#define NOT_IMPL    FALSE

number now();

#define  LOOP_START(e)      number __t1 = now();

#define  LOOP_CHECK(e)      number __dt = now() - __t1;\
                            if( __dt > e->loopLimit) \
                                RET(ThrowRangeError(e, "loop timeout", 0,0));

void JsInit(Js* e, bool_t createContext);
int JsClear(Js* e);
void JsColors(Js* e, int on);
void JsCreateSymbols(Js* e);
void JsFreeSymbols(Js* e);

///////// String 
struct StrTag {
    int length;
    uchar chars[0];
};
Str* StrNewLength(Js* e, int len);
Str* StrNewChars(Js* e, char* c);
bool_t StrEqChars(Js* e, Str* str, char* c);
bool_t StrEqStr(Js* e, Str* s1, Str* s2);
char* StrGetChars(Js* e, Str* s);
void StrDel(Js* e, Str* s);
Str* StrClone(Js* e, Str* s);
bool_t StrPrefix(Js* e, Str* s1, Str* s2);
void StrPrint(Js* e, Str* s);
void StrPrintLn(Js* e, Str* s);
uint32 StrLen(Js* e, Str* s);
char* StrDecode(Js* e, Str* s);
char* StrDecodeNoEscape(Js* e, Str* s);
#define MATCH_NO_CASE       0x01            // Use case insensitive matching
#define MATCH_TLA           0x02            // Match TLAs for words
bool_t StrStr(Js* e, Str* s1, Str* s2, uint32 flags);
uint32 StrSize(Js* e, Str* s);
Str* StrFromUChars(Js* e, uchar* chars);
uchar* UCharsFromStr(Js* e, Str* s);
void UCharsDel(Js* e, uchar* chars);

void ErrorFromObj(Parser* p, Val* v);

///////// Dynamic String (DynStr)
struct DynStrTag {
    int capacity;
    int current;
    Str* str;
};

#define DynStrNew(e,c) _DynStrNew(e, c, __LINE__)

DynStr* _DynStrNew(Js* e, int capacity, int line);
void DynStrClear(Js* e, DynStr* ds);
void DynStrAdd(Js* e, DynStr* ds, uchar c);
void DynStrAddStr(Js* e, DynStr* ds, Str* s);
void DynStrAddStrA(Js* e, DynStr* ds, char* s);
void DynStrDel(Js* e, DynStr* ds);
Str* DynStrGet(Js* e, DynStr* ds);
int DynStrIndex(Js* e, DynStr* ds);
void DynStrWriteA(Js* e, DynStr* ds, char* s, int count);
int DynStrReadA(Js* e, DynStr* ds, char* buffer, int count);
void DynStrReset(Js* e, DynStr* ds);


///////// Ref
struct RefTag {
    Val*                base;
    Val*                name;
    bool_t              strict;
    Val*                thisValue;
};
Ref* RefNew(Js* e, Val* b, Val* n, bool_t s, Val* tv);
void RefDelete(Js* e, Ref* r);
bool_t RegGetEqNum(Js* e, Val* r, number n);
bool_t RegGetAbrupt(Js* e, Val* r);

///////// value
enum val_types {
    TYPE_FREE = 0,
    TYPE_UNDEF,
    TYPE_NULL,
    TYPE_BOOL,
    TYPE_NUM,
    TYPE_STR,
    TYPE_OBJ,
    TYPE_REF,       // reference value
    TYPE_ENV,       // environment record
    TYPE_COMP,      // completion
    TYPE_DESC,       // property descriptor
    TYPE_LIST,        // List of vals
    TYPE_LEX,           // lexical environment
    TYPE_PTR,      // arbitrary pointer value (e.g. Realm, ... etc)
    TYPE_SYMA,     // symbol reference
    TYPE_REALM,      // Realm reference
    TYPE_DATA,      // Just like TYPE_PTR but owned by Val*
    TYPE_BLOCK      // DataBlock
};

struct ValTag {
    uint8   type;
    union {
        char*           descA;      // For a symbol reference
        bool_t          b;
        number          num;
        Str*            str;                 // not allowed to be NULL if TYPE_STR
        Object*         obj;                  // not allowed to be NULL if TYPE_OBJ
        Ref*            Ref;
        Completion*     completion;
        Env*            env;
        Property*       desc;                 // property descriptor
        List*           list;
        void*           ptr;
        Data*           block;
        LexEnv*         lex;
        Realm*          realm;
    };
};

void ValInit(Val* v);
void ValInitNum(Val* v, number n);
void ValInitStrA(Js* e, Val* v, char* s);
void ValInitNull(Val* v);
void ValInitBool(Val* v, bool_t b);
void ValInitRef(Js* e, Val* v, Ref* r);
void ValInitComp(Js* r, Val* v, Completion* c);
void ValClear(Js* e, Val* v);
bool_t ValIsPrimitive(Val* v);
bool_t ValIsObject(Val* v);
bool_t ValIsNull(Val* v);
bool_t ValIsUndef(Val* v);
bool_t ValIsTrueDel(Js* e, Val* v);
bool_t ValIsNumDel(Js* e, Val* v, number n);
bool_t ValIsNum(Js* e, Val* v, number n);
bool_t ValIsStrADel(Js* e, Val* v, char* c);
bool_t ValIsNullDel(Js* e, Val* v);
bool_t ValIsTrue(Js* e, Val* v);
bool_t ValIsAbrupt(Js* e, Val* v);
bool_t ValEqStrA(Js* e, Val* v, char* s);
bool_t VallAllEq(Js* e, Val* v1, Val* v2);
Val* ValNewDesc(Js* e);
Val* ValNewList(Js* e, List* l);
Val* ValNewListEmpty(Js* e);
Val* _ValNew(Js* e, int line);
#define ValNew(e)   _ValNew(e, __LINE__)
void ValPrint(Js* e, Val* v, bool_t detail, int line);
void ValPrintLn(Js* e, char* prefix, Val* v, bool_t detail);
void vpl(Js* e, Val* v);
#define ValNewNum(e,n) _ValNewNum(e, n, __LINE__)
Val* _ValNewNum(Js* e, number n, int line);
Val* ValNewStr(Js* e, Str* s);
Val* ValNewStrA(Js* e, char* s);
Val* ValAddStr(Js* e, Val* d, Val* s, bool_t del_d);
Val* ValAddStrA(Js* e, Val* d, char* s, bool_t del_d);
Val* ValNewSymbol(Js* e, char* s);
#define ValNewNull(e) _ValNewNull(e,__LINE__)
Val* _ValNewNull(Js* e, int line);
#define ValNewBool(e, v) _ValNewBool(e, v, __LINE__)
Val* _ValNewBool(Js* e, bool_t b, int line);
#define ValNewObject(e) _ValNewObject(e,__LINE__)
Val* _ValNewObject(Js* e, int line);
Val* ValNewRealm(Js* e, Realm* r);
Val* ValNewRef(Js* e, Ref* r);
Val* ValNewRefA(Js* e, Val* b, char* n, bool_t s, Val* tv);
Val* ValNewRefU(Js* e, Val* b, Val* n, bool_t s, Val* tv);
#define ValNewComp(e,c) _ValNewComp(e,c,__LINE__)
Val* _ValNewComp(Js* e, Completion* c, int line);
#define ValNewCompA(e,t,v,l) _ValNewCompA(e,t,v,l,__LINE__)
Val* _ValNewCompA(Js* e, int type, Val* v, char* label, int line);
#define ValNewCompU(e,t,v,l) _ValNewCompU(e,t,v,l, __LINE__)
Val* _ValNewCompU(Js* e, int type, Val* v, Val* label, int line);
Val* ValNewEnv(Js* e, Env* en);
Val* ValNewLex(Js* e, LexEnv* ev);
#define ValNewPtr(e, r) _ValNewPtr(e, r, __LINE__)
Val* _ValNewPtr(Js* e, void* r, int line);
void ValDel(Js* e, Val* v);
void ValSet(Js* e, Val* dest, Val* src);
void ValAssign(Js* e, Val** dest, Val* src);
#define ValClone(e,v)   _ValClone(e,v,__LINE__)
Val* _ValClone(Js* e, Val* v, int line);


Val* SymbolEntryNew(Js* e, Str* str);
Val* SymbolEntryNewA(Js* e, char* str);
void SymbolEntryClear(Js* e);


/////////// Vector
struct VectorTag {
    int count;                                  // Number of items
    int capacity;                               // Capacity for items (always >= count)
    int size;                                   // Size of each Item in bytes
    char* data;                                 // Buffer data
    float growth;                               // Growth factor when capacity exhausted
    int reallocs;                               // How many reallocations
};


#define VectorNew(e,c,s,g) _VectorNew(e,c,s,g, __LINE__)
Vector* _VectorNew(Js* e, int capacity, int size, float growth, int line);
void* VectorGet(Js* e, Vector* da, int index);
void* VectorInsert(Js* e, Vector* da, void* Item, int offset);
void VectorRemove(Js* e, Vector* da, int offset);
void VectorAppend(Js* e, Vector* d, Vector* s, bool_t delS);
void VectorPut(Js* e, Vector* da, int index, void* Item);
void VectorInsertMulti(Js* e, Vector* da, int count, void* items);
void VectorInsertStr(Js* e, Vector* da, Str* s);
int VectorCount(Js* e, Vector* da);
void VectorDel(Js* e, Vector* da);
void VectorReset(Js* e, Vector* da);
Str* VectorNextStr(Js* e, Vector* da, Str* start);
int VectorGetReallocCount(Js* e, Vector* da);


/////////// vec - growable list of items (unstable pointers)
struct vectag {
    int count;                                  // Number of items
    int capacity;                               // Capacity for items (always >= count)
    int size;                                   // Size of each Item in bytes
    char* data;                                 // Buffer data
    float growth;                               // Growth factor when capacity exhausted
    int reallocs;                               // How many reallocations
};

vec* vec_new(int capacity, int size, float growth);
void* vec_get(vec* v, int index);
void* vec_add(vec* v);
void vec_del(vec* v);

struct mitemtag {
#ifdef DEBUG_MEMORY
    int line;
#endif
    mitem* next_free;
};


struct typeheaptag {
    char* name;
    heap* data;
    int block_cap;
};

struct heaptag {
    vec* blocks;
    uint32 item_size;
    uint32 block_cap;
    mitem* next_free;
    int allocs;
};

heap* hnew(int blockCap, uint32 itemSize);
void hdel(heap* h);
void* _halloc(heap* h, int line);
void* _hallocsize(heap* h, int size, int line);
#define halloc(h)   _halloc(h, __LINE__)
void hfree(heap* h, void* item);
typedef void (*hiterfunc)(void* item, void* ctx);
void hiter(heap* h, hiterfunc fn, void* ctx);
void gc(Js* e, Object* root);


/////////// ctags support
struct ctagtag {
    Str*    name;
    Str*    file;
    Str*    grep;
    struct ctagtag* next;       // Next entry in list
};

#include <stdio.h>
#include <assert.h>
void CtagsAddFunction(Js* e, Parser* p, int nameToken, int endToken);
void CtagsPrint(Js* e, FILE* fp);
void CtagsDel(Js* e);

////////// Strmap
Strmap* StrmapNew(Js* e, int keyCapacity, int valCapacity, int size, float growth);
void* StrmapGet(Js* e, Strmap* sm, Str* key);
void* StrmapGetA(Js* e, Strmap* sm, char* key);
void StrmapPut(Js* e, Strmap* sm, Str* key, void* Val);
void StrmapPutA(Js* e, Strmap* sm, char* key, void* Val);
void StrmapDel(Js* e, Strmap* sm);
void StrmapReset(Js* e, Strmap* sm);
void StrmapMatch(Js* e, Strmap* sm, Str* substring, Vector* List, uint32 flags);
int StrmapGetReallocCount(Js* e, Strmap* sm);

///////// Tokenizer
///////// Tokenizer errors
enum tok_errors {
    TOK_NO_ERROR = 0,
    TOK_NOT_FOUND = -1,
    TOK_NO_LINE = -1
};

///////// _tok types
enum tok_types {
    TOK_IDENTIFIER, TOK_KEYWORD,    TOK_PUNCTUATOR, TOK_NUMLIT, TOK_COMMENT,
    TOK_WORD,       TOK_REGEX,      TOK_STRLIT,     TOK_LINETERM,
    TOK_TEMPLIT,    TOK_TEMPHEAD,   TOK_TEMPMID,    TOK_TEMPTAIL, 
    TOK_SPC_RALIGN, TOK_SPC_BLOCK,  TOK_TAB, TOK_EOF
};

/////////// _tok keyword ids
enum {
    id_none = 0,
    id_break = 1,       id_do = 10,         id_in = 19,             id_typeof = 28,
    id_case = 2,        id_else = 11,       id_instanceof = 20,     id_var = 29,
    id_catch = 3,       id_export = 12,     id_new = 21,            id_void = 30,
    id_class = 4,       id_extends = 13,    id_return = 22,         id_while = 31,
    id_const = 5,       id_finally = 14,    id_super = 23,          id_with = 32,
    id_continue = 6,    id_for = 15,        id_switch = 24,         id_yield = 33,
    id_debugger = 7,    id_function = 16,   id_this = 25,           id_let = 34,
    id_default = 8,     id_if = 17,         id_throw = 26,          id_module = 35,
    id_delete = 9,      id_import = 18,     id_try = 27,            id_of = 36,

    id_enum = 100,
    id_implements = 101, id_package = 103,    id_protected = 105,      id_static = 107,
    id_interface = 102,  id_private = 104,    id_public = 106,

    id_lbrace = 200,     id_lpar = 208,   id_rpar = 216,   id_lbracket = 224,   id_rbracket = 232,   id_dot = 240,
    id_dotdotdot = 201,  id_semi = 209,   id_comma = 217,  id_lt = 225,         id_gt = 233,         id_lte = 241,
    id_gte = 202,        id_eqeq = 210,   id_ne = 218,     id_eqeqeq = 226,     id_neqeq = 234,      
    id_plus = 203,       id_minus = 211,  id_mult = 219,   id_mod = 227,        id_plusplus = 235,   id_minusminus = 242,
    id_lshift = 204,     id_rshift = 212, id_rshifta = 220,id_and = 228,        id_or = 236,         id_caret = 243,
    id_not = 205,        id_tilde = 213,  id_andand = 221, id_oror = 229,       id_question = 237,   id_colon = 244,
    id_eq = 206,         id_pluseq = 214, id_minuseq = 222,id_multeq = 230,     id_modeq = 238,      id_lshifteq = 245,
    id_rshifteq = 207,   id_rshiftaeq=215,id_andeq = 223,  id_oreq = 231,       id_careteq = 239,    id_arrow = 246,

    id_div = 300,        id_diveq = 301,

    id_rbrace = 400,

    id_null = 500,

    id_true = 600,
    id_false = 601,

    id_get = 701,
    id_set = 702   
};


// Create Tokenizer. A single Tokenizer can be used multiple times
Tokenizer* TkNew(Js* e);

// Validate the tokenizer to support range tokenization.
bool_t TkValidateToken(Js* e, Tokenizer* tk, int forToken);
bool_t TkValidateLine(Js* e, Tokenizer* tk, int line);
bool_t TkValidateOffset(Js* e, Tokenizer* tk, int offset);

// Free created Tokenizer
void TkDel(Js* e, Tokenizer* tk);

// tokenize a string stream. Length can be -1 and the Tokenizer will compute it
// Returns the number of _tokization errors or 0 if succeeded. The string
// is not kept by the Tokenizer
int TkTokenize(Js* e, Tokenizer* tk, uchar* source, int length, int script, int colorizer);
int TkReplace(Js* e, Tokenizer* tk, int oldStart, int oldEnd, int newStart, int newEnd, uchar* source, int count, int viewEndLine);
int TkReplaceA(Js* e, Tokenizer* tk, int oldStart, int oldEnd, int newStart, int newEnd, char* source, int viewEndLine);

int TkTokenizeS(Js* e, Tokenizer* tk, Str* source, int script, int colorizer);
int TkTokenizeA(Js* e, Tokenizer* tk, char* source, int length, int script, int colorizer);

// Get the error string for a given Tokenizer. String must be copied if
// needing to keep a reference
char* TkGetError(Js* e, Tokenizer* tk);
int TkGetErrorLine(Js* e, Tokenizer* tk);
int TkGetErrorCol(Js* e, Tokenizer* tk);

// Get the number of _tokization lines
int TkGetLineCount(Js* e, Tokenizer* tk);

// Get the maximum column width of all lines _tokenized
int TkGetMaxWidth(Js* e, Tokenizer* tk);

// Get the widest line number
int TkGetWidestLine(Js* e, Tokenizer* tk);

// Get the width of the widest token
int TkGetWidestToken(Js* e, Tokenizer* tk);

// Get the index of the single changed _tok or TOK_NOT_FOUND if
// no _toks have changed or more than one _tok has changed
int TkGetChangedTok(Js* e, Tokenizer* tk);

// Get the line number (0 based) from a given location in the source string
int TkGetLineFromOffset(Js* e, Tokenizer* tk, int location);

// Get the total number of tokens
int TkGetCount(Js* e, Tokenizer* tk);

// Get the number of _toks for a given line
int TkGetTokCount(Js* e, Tokenizer* tk, int line);


// Get the _tok index given a line and index into the line. The _tok
// index is then used to Get information about a given _tok
int TkGetTokIndex(Js* e, Tokenizer* tk, int line, int index);

// Get the previous _tok
int TkGetPrevTok(Js* e, Tokenizer* tk, int _tok, int skipNewLine);

// Get the next _tok
int TkGetNextTok(Js* e, Tokenizer* tk, int _tok, int skipNewLine);

// Get the line number for a given _tok index (1 based)
int TkGetTokLine(Js* e, Tokenizer* tk, int _tok);

// Get the _tok string starting location in the source string. Location and length
// can be used by callers to obtain the actual _tok text from their source
// string since the Tokenizer doesn't keep a copy of the source
int TkGetTokOffset(Js* e, Tokenizer* tk, int _tok);

// Get the _tok string length in the source string
int TkGetTokLen(Js* e, Tokenizer* tk, int _tok);

// Get the type of a given _tok
int TkGetTokType(Js* e, Tokenizer* tk, int _tok);

// Get the token flags
uint32 TkGetTokFlags(Js* e, Tokenizer* tk, int tok);

// If the _tok is a keyword, Get the keyword id of the _tok's keyword
int TkGetTokKeyword(Js* e, Tokenizer* tk, int _tok);

// Get the _tok's column in the source text
int TkGetTokCol(Js* e, Tokenizer* tk, int _tok);

// Get the _tok numeric Val
double TkGetTokNumVal(Js* e, Tokenizer* tk, int _tok);

// Get the _tok string Val
Str* TkGetTokStr(Js* e, Tokenizer* tk, int _tok);

// Get the _tok raw string Val
Str* TkGetTokRawStr(Js* e, Tokenizer* tk, int _tok);

// Get line start _tok
int TkGetLineStartTok(Js* e, Tokenizer* tk, int line);

// Get line end _tok
int TkGetLineEndTok(Js* e, Tokenizer* tk, int line);

// Get line location in source
int TkGetLineOffset(Js* e, Tokenizer* tk, int line);

// Get line length in source
int TkGetLineLen(Js* e, Tokenizer* tk, int line);

// Get reallocation count
int TkGetReallocCount(Js* e, Tokenizer* tk);

// Get a _tok index given a location in text
int TkGetTokFromOffset(Js* e, Tokenizer* tk, int location);

// Get a _tok index of next function
int TkGetNextFuncTok(Js* e, Tokenizer* tk, int start, int* next);

// Return List of matches from keywords and identifiers to a given substring
Vector* TkMatch(Js* e, Tokenizer* tk, int index, Str* substring, uint32 flags);
Vector* TkMatchA(Js* e, Tokenizer* tk, int index, char* substring, uint32 flags);


// Return a matching token index for a given token or TOK_NOT_FOUND
int TkGetMatchingTok(Js* e, Tokenizer* tk, int tok);

// Return previous or next keyword or return TOK_NOT_FOUND
int TkGetPrevKeyword(Js* e, Tokenizer* tk, int tok, int kid);
int TkGetNextKeyword(Js* e, Tokenizer* tk, int tok, int kid);

// Return previous or next dot keyword or return TOK_NOT_FOUND
int TkGetPrevDot(Js* e, Tokenizer* tk, int tok);
int TkGetNextDot(Js* e, Tokenizer* tk, int tok);

// returns TRUE if the keyword is a punctuator
bool_t TkIsPunctuator(Js* e,Tokenizer* tk, int tok);
bool_t TkIsDivPunctuator(Js* e,Tokenizer* tk, int tok);
bool_t TkIsRightBracePunctuator(Js* e,Tokenizer* tk, int tok);
bool_t TkIsFunction(Js* e, Tokenizer* tk, int tok);
bool_t TkIsConst(Js* e, Tokenizer* tk, int tok);

// _tokenize a string stream. Length can be -1 and the Tokenizer will compute it
// Returns the number of _tokization errors or 0 if succeeded. The string
// is not kept by the Tokenizer. The outline Tokenizer is used to make line
// entries with each line having all words as _toks of a given type depending
// on the number of leading spaces as follows:
// 0 leading spaces TOK_IDENTIFIER
// 1 leading space TOK_KEYWORD
// 2 leading spaces TOK_NUMLIT
// 3+ leading spaces TOK_COMMENT
int TkTokenizeOutline(Js* e, Tokenizer* tk, uchar* source, int length, int script);
int TkTokenizeOutlineA(Js* e, Tokenizer* tk, char* source, int length, int script);

void TkPrintToken(Js* e, Tokenizer* tk, int tok, bool_t verbose);
void TkPrint(Js* e, Tokenizer* tk, List* extra, int extraPad, bool_t verbose);

#define ValNewStrId(e,tk,tok) _ValNewStrId(e,tk,tok, __LINE__)

Val* _ValNewStrId(Js* e, Tokenizer* tk, int tok, int line);

// Limits and constants
#define TOK_MAX_WORD              1024        // Any word longer results error
#define TOK_MIN_TOKENS            512         // Default number of _toks
#define TOK_MIN_LINES             256         // Default number of lines
#define TOK_MAX_ERROR             1024        // Error string
#define TOK_MIN_STRING_CHARS      4096        // String literal character capacity
#define TOK_MIN_IDENTIFIERS       4           // Start with 4 identifiers per hash bucket
#define TOK_MIN_IDENTIFIER_CHARS  409         // Identifier character capacity
#define TOK_MIN_MATCHES_CHARS     2048        // Match string capacity

#define TOK_ZWNJ                  0x200C      // Zero width non joiner Unicode
#define TOK_ZWJ                   0x200D      // Zero width joiner Unicdoe
#define TOK_BOM                   0xFEFF      // Byte order mark

// Keyword data structure
typedef struct {
    const char*        text;                       // Keyword text
    int             kid;                        // Keyword id
} KeyDef;

#define TF_NUM_EXP              0x1             // Token is a number with exponent
#define TF_NUM_HEX              0x2             // Token is a number in hex form
#define TF_NUM_BIN              0x4             // Token is a number in binary form
#define TF_NUM_OCT              0x8             // Token is a number in octal form

// _tok data structure
typedef struct {
    int             line;                       // _tok line (1 based)
    int             location;                   // _tok offset in source
    int             length;                     // _tok length in source
    int             type;                       // _tok type
    int             column;                     // _tok text column (1 based)
    uint32          flags;                      // TF_*
    int             flag_offset;                 // For regular expressions
    union {
        int             keyword;                // _tok keyword
        double          Val;                    // _tok numeric Val
        int             string;                 // Index in string array
    };
    int             raw;                    // For template literal raw
} Token;

// Line data structure
typedef struct {
    int             first;                 // Index of first _tok
    int             last;                  // Index of last _tok
    int             location;                   // Line location in source text
    int             length;                     // Line length in source text
} Line;

// Tokenizer data structure
struct TokenizerTag {
    Vector*             tokens;           // Dynamic array of _toks
    Vector*             lines;            // Dynamic array of lines
    Vector*             strings;          // Dynamic array of string literals
    Strmap*             identifiers;      // String map of identifiers to _tok index
    Vector*             matches;          // Match List
    
    int             tempEndToken;           // TkReplace end token marker
    int             tempEndLine;            // TkReplace end line marker
    int             tempLineCount;          // TkReplace temp count to fool caller

    bool_t          jsonMode;     // Used for JSON.parse
    int             maxWidth;                   // Maximum column width
    int             widestLine;
    int             widestToken;          // Widest token length         
    
    DynStr*      word;
    
    char          error[TOK_MAX_ERROR];   // Last error string
    int           errorLine;
    int           errorCol;
    bool_t        needFullTok;              // If invalid tokenizer needs a full retokenize
    
    int             changedTok;               // Index of changed _tok
    
    int             current;                // Current index in source
    uchar*        input;                    // Source input
    int             column;                 // Current column
    int             line;                   // Current line
    int             offset;                 // TODO: Is this needed?
    int             wordCol;               // TODO: Is this needed?
    int             max;                    // Length of input
    int             scriptIndex;
    int             colorizer;
    Str*            source;                 // In cases where tokenizer owns source
    
};

// Keyword table
static KeyDef keywords[] = {
    { "break", id_break },       { "do", id_do },             { "in", id_in },                 { "typeof", id_typeof },
    { "case", id_case },         { "else", id_else },         { "instanceof", id_instanceof }, { "var", id_var },
    { "catch", id_catch },       { "export", id_export },     { "new", id_new },               { "void", id_void },
    { "class", id_class },       { "extends", id_extends },   { "return", id_return },         { "while", id_while },
    { "const", id_const },       { "finally", id_finally },   { "super", id_super },           { "with", id_with },
    { "continue", id_continue }, { "for", id_for },           { "switch", id_switch },         { "yield", id_yield },
    { "debugger", id_debugger }, { "function", id_function }, { "this", id_this },             { "let", id_let },
    { "default", id_default},    {"if", id_if },              { "throw", id_throw },           { "module", id_module },
    { "delete", id_delete },     {"import", id_import },      { "try", id_try },               { "of", id_of },
    { "enum", id_enum },
    { "implements", id_implements }, { "package", id_package },    { "protected", id_protected },      { "static", id_static },
    { "interface", id_interface },   { "private", id_private },    { "public", id_public },
    { "{", id_lbrace },      { "(", id_lpar },         { ")", id_rpar },      { "[", id_lbracket },   { "]", id_rbracket },   { ".", id_dot },
    { "...", id_dotdotdot }, { ";", id_semi },         { ",", id_comma },     { "<", id_lt },         { ">", id_gt },         { "<=", id_lte },
    { ">=", id_gte },        { "==", id_eqeq },        { "!=", id_ne },       { "===", id_eqeqeq },   { "!==", id_neqeq },      
    { "+", id_plus },        { "-", id_minus },        { "*", id_mult },      { "%", id_mod },        { "++", id_plusplus },  { "--",  id_minusminus },
    { "<<", id_lshift },     { ">>", id_rshift },      { ">>>", id_rshifta }, { "&", id_and },        { "|", id_or  },        { "^", id_caret },
    { "!", id_not },         { "~", id_tilde },        { "&&", id_andand  },  { "||", id_oror },      { "?", id_question },   { ":", id_colon },
    { "=", id_eq },          { "+=", id_pluseq },      { "-=", id_minuseq },  { "*=", id_multeq },    { "%=", id_modeq },     { "<<=", id_lshifteq },
    { ">>=", id_rshifteq },  { ">>>=", id_rshiftaeq }, { "&=", id_andeq },    { "|=", id_oreq },      { "^=", id_careteq },   { "=>", id_arrow },
    { "/", id_div },         { "/=", id_diveq },
    { "}", id_rbrace },
    { "null", id_null },
    { "true", id_true },
    { "false", id_false }  ,

    { "get", id_get},
    { "set", id_set}
};


// Internal function prototypes
void TkAdvance(Js* e, Tokenizer* tk, int n);
void TkNextLine(Js* e, Tokenizer* tk);
void TkNewWord(Js* e, Tokenizer* tk);
int TkSetError(Js* e, Tokenizer* tk, char* sz, int line, int column);
void TkBegin(Js* e, Tokenizer* tk, uchar* inp, int index, int length);
int TkTokenizeSpace(Js* e, Tokenizer* tk);
int TkIsSpace(Tokenizer* tk, uchar c);
int TkIsWordStart(uchar c);
int TkIsWordChar(uchar c);
int TkIsPuncSolo(uchar c);
int TkIsPuncTerm(uchar c);
int TkIsLineTerm(uchar c);
int TkIsHexDigit(uchar c);
int TkIsOctDigit(uchar c);
int TkIsBinDigit(uchar c);
int TkIsAlpha(uchar c);
int TkIsStrDelim(uchar c);
int TkIsNum(uchar ch);
int TkIsAlNum(uchar c);
uchar TkHexVal(uchar c);
int TkTokenizeComment(Js* e, Tokenizer* tk);
int TkIsIdentifier(Str* s);
Token* TkAddTok(Js* e, Tokenizer* tk, int type, int line, int col, int start, int end);
int TkTokenizeLineTerm(Js* e, Tokenizer* tk);
int TkIsNumConstPrefix(uchar c);
int TkAddToWord(Js* e, Tokenizer*tk, uchar c);
int TkTokenizeNum(Js* e, Tokenizer* tk);
int TkIsNumOp(Token* t);
int TkTokenizeRegEx(Js* e, Tokenizer* tk);
int TkTokenizeStr(Js* e, Tokenizer* tk);
void TkTokenizeAny(Js* e, Tokenizer* tk);
int TkTokenizeWord(Js* e, Tokenizer* tk);
int TkTokenizeNext(Js* e, Tokenizer* tk);
int TkTokenizeTemplateLiteral(Js* e, Tokenizer* tk);
int TkHasError(Js* e, Tokenizer* tk);
int TkNeedFull(Js* e, Tokenizer* tk);
void TkEnd(Js* e, Tokenizer* tk);
bool_t TokIsId(Js* e, Tokenizer* tk, Node* n, char* id);


/////// unicode
uint32 GetUtf16CodePoint(uchar* chars);

uint32 Utf16Decode(uchar lead, uchar trail);
bool_t Utf16Encode(uint32 ch, uchar* c1, uchar* c2);

/////// Property 6.1.7.1
enum prop_flags {
    PROP_WRITEABLE = 0x1,
    PROP_NOT_WRITEABLE = 0x2,
    PROP_ENUMERABLE = 0x4,
    PROP_NOT_ENUMERABLE = 0x8,
    PROP_CONFIGURABLE = 0x10,
    PROP_NOT_CONFIGURABLE = 0x20
};
struct PropertyTag {
    Val* name;              // property name
    bool_t ownName;        // true if property owns the name
    Val* value;             // not needed for accessor properties
    uint32 flags;           //
                            // writable: false, can't set value
                            // enumerable: false, not in for in enumeration
                            // configurable: false, can't del, can't change
                            // to accessor, can't change attributes
                            // other than value, can't change
                            // writable to false
    Val* get;               // accessor property getter
    Val* set;               // accessor property setter
    Val* origin;            //
    struct PropertyTag* next;  // linked List
};

bool_t PropHasWritable(Js* e, Property* p);
void PropSetWritable(Js* e, Property* p, bool_t w);
bool_t PropIsWritable(Js* e, Property* p);

bool_t PropHasEnumerable(Js* e, Property* p);
void PropSetEnumerable(Js* e, Property* p, bool_t w);
bool_t PropIsEnumerable(Js* e, Property* p);

bool_t PropHasConfigurable(Js* e, Property* p);
void PropSetConfigurable(Js* e, Property* p, bool_t w);
bool_t PropIsConfigurable(Js* e, Property* p);

void PropInit(Js* e, Property* p);
void PropClear(Js* e, Property* p);
Property* PropNew(Js* e);
Property* PropClone(Js* e, Property* p);
bool_t PropEq(Js* e, Property* p1, Property* p2);
void PropDel(Js* e, Property* p);
void PropSetName(Js* e, Property* p, Val* n, bool_t own);
void PropSetValue(Js* e, Property* p, Val* v);
#define PropGetValue(e, p) _PropGetValue(e,p,__LINE__)
Val* _PropGetValue(Js* e, Property* p, int line);
Val* DescNew(Js* e, Val* v, bool_t c, bool_t en, bool_t w, bool_t del_v);

////// 6.2.4
bool_t IsDataDesc(Js* e, Val* v);
bool_t IsAccessorDesc(Js* e, Property* p);
bool_t PropIsData(Js* e, Property* p);
bool_t PropIsGeneric(Js* e, Property* p);
Val* FromPropertyDesc(Js* e, Val* prop);
Val* ToPropertyDesc(Js* e, Val* o);
Val* CompletePropertyDesc(Js* e, Val* desc, Val* like_desc);

/////// methods 6.1.7.2
typedef Val* (*GetPrototypeOfPtr)(Js* e, Val* o);
typedef Val* (*SetPrototypeOfPtr)(Js* e, Val* o, Val* proto);
typedef Val* (*IsExtensiblePtr)(Js* e, Val* o);
typedef Val* (*PreventExtensionsPtr)(Js* e, Val* o);
typedef Val* (*GetOwnPropertyPtr)(Js* e, Val* o, Val* key);
typedef Val* (*HasPropertyPtr)(Js* e, Val* o, Val* key);
typedef Val* (*GetPtr)(Js* e, Val* o, Val* key, Val* receiver);
typedef Val* (*SetPtr)(Js* e, Val* o, Val* key, Val* v, Val* receiver);
typedef Val* (*DeletePtr)(Js* e, Val* o, Val* key);
typedef Val* (*DefineOwnPropertyPtr)(Js* e, Val* o, Val* key, Val* desc);
typedef Val* (*EnumeratePtr)(Js* e, Val* o);
typedef Val* (*OwnPropertyKeysPtr)(Js* e, Val* o);
typedef Val* (*CallPtr)(Js* e, Val* o, Val* othis, Val* args);
typedef Val* (*ConstructPtr)(Js* e, Val* o, Val* args, Val* newTarget);
typedef void (*CollectPtr)(Js* e, Object* o);
typedef Object* (*create_t)(Js* e);


Val* DoGetPrototypeOf(Js* e, Val* o);
Val* DoSetPrototypeOf(Js* e, Val* o, Val* proto);
Val* DoIsExtensible(Js* e, Val* o);
Val* DoPreventExtensions(Js* e, Val* o);
Val* DoGetOwnProperty(Js* e, Val* o, Val* key);
Val* DoHasProperty(Js* e, Val* o, Val* key);
Val* DoGet(Js* e, Val* o, Val* key, Val* receiver);
Val* DoSet(Js* e, Val* o, Val* key, Val* v, Val* receiver);
Val* DoDelete(Js* e, Val* o, Val* key);
Val* DoDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* DoEnumerate(Js* e, Val* o);
Val* DoOwnPropertyKeys(Js* e, Val* o);
Val* DoCall(Js* e, Val* o, Val* othis, Val* args);
Val* DoConstruct(Js* e, Val* o, Val* args, Val* newTarget);

///////// object 6.1.7
enum {
    OBJ_EXTENSIBLE  = 0x01000000,       // properties can be added / removed
    OBJ_MARK        = 0x02000000,
    OBJ_ARRAY       = 0x04000000,       // @opt object is an array
    OBJ_ALLNUM      = 0x08000000,       // @opt all properties numeric
    OBJ_CONT        = 0x10000000,       // @opt contiguous array
    OBJ_IDMASK      = 0x00ffffff        // Mask used for object ID
};

#define MARK(o)  { (o->flags) |= OBJ_MARK; }
#define MARKED(o) ((o->flags & OBJ_MARK) != 0)
#define UNMARK(o) { (o->flags) &= ~OBJ_MARK; }
#define ID(o) ( (o->flags & OBJ_IDMASK))
#define ALLOCATED(o) (ID(o) > 0)

#define OBJ_FREE    0x00000000          // if ObjectTag.flags == OBJ_FREE it's not allocated


struct ObjectTag {
    uint32 refs;
    uint32 flags;
    Property* properties;
    Property* tail;
    Val* prototype;
    Property* slots;
    Property* methods;
};

void ObjectSetMethod(Js* e, Object* o, char* key, void* value, bool_t check);
void* ObjectGetMethod(Js* e, Object* o, char* key);
Property* ObjectGetMethodRef(Js* e, Object* o, char* key);
void ObjectSetSlot(Js* e, Object* o, char* key, Val* v, bool_t check, bool_t delv);
void ObjectSetSlotNoCopy(Js* e, Object* o, char* key, Val* v, bool_t check);
Val* ObjectGetSlot(Js* e, Object* o, char* key);
Val* ObjectGetSlotUndef(Js* e, Object* o, char* key);
void *ObjectGetSlotPtr(Js* e, Val* o, char* key);
Property* ObjectGetSlotRef(Js* e, Object* o, char* key);
uint32 Retain(Js* e, Object* o);
uint32 Release(Js* e, Object* o);

#define ObjectNew(e) _ObjectNew(e, __LINE__)
Object* _ObjectNew(Js* e, int line);
void ObjectPrint(Js* e, Object* o, bool_t detail);
void ObjectInit(Js* e, Object* o);
void ObjectClear(Js* e, Object* o);
void ObjectDelete(Js* e, Object* o);
bool_t ObjectSetANum(Js* e, Val* o, char* name, number n);
bool_t ObjectIs(Js* e, Val* o, Val* constructor);
bool_t ValIsThrow(Js* e, Val* o, Val* cons);
void ObjectSetFlag(Js* e, Object* o, uint32 flag);
void ObjectClearFlag(Js* e, Object* o, uint32 flag);
bool_t ObjectHasFlag(Js* e, Object* o, uint32 flag);
void ObjectSetProto(Js* e, Val* o, Val* proto);


/////// completion type 6.2.2
enum {
    COMP_NORMAL,
    COMP_BREAK,
    COMP_CONTINUE,
    COMP_RETURN,
    COMP_THROW
};

struct CompletionTag {
    int type;       // COMP_NORMAL ... etc.
    Val* value;     // completion owns value
    Val* target;  // labeled jumps or NULL if none
    bool_t empty;   // Completion never had an actual value assigned
};

Completion* CompNew(Js* e, int type, Val* v, Val* label);
void CompDel(Js* e, Completion* c);
Val* CompGetValue(Js* e, Completion* c);
bool_t CompIsAbrupt(Js* e, Completion* c);


//////// List
struct ItemTag {
    Val* value;             // items do not own the value, the List will clear them
    struct ItemTag* next;
};

struct ListTag {
    int count;
    Item* head;
    Item* tail;
};

List* ListNew(Js* e);
int ListGetCount(Js* e, List* l);
void ListAddValue(Js* e, List* l, Val* v);
Val* ListGetValue(Js* e, List* l, int index);
void ListDel(Js* e, List* l);
void ListDelItem(Js* e, List* l, Val* v);
void ListRemoveLast(Js* e, List* l);
bool_t ListHasValue(Js* e, List* l, Val* v);
List* ListClone(Js* e, List* l);

///////// PtrList is like list but for pointers
struct PtrItemTag {
    void* value;             // items do not own the value, the List will clear them
    struct PtrItemTag* next;
};

struct PtrListTag {
    int count;
    PtrItem* head;
    PtrItem* tail;
};

#define PtrListNew(e) _PtrListNew(e, __LINE__)
PtrList* _PtrListNew(Js* e, int line);
int PtrListCount(Js* e, PtrList* l);
PtrList* PtrListAdd(Js* e, PtrList* l, void* v);
void PtrListPrepend(Js* e, PtrList* l, void* v);
void* PtrListGet(Js* e, PtrList* l, int index);
void PtrListDel(Js* e, PtrList* l);
bool_t PtrListHas(Js* e, PtrList* l, void* v);
PtrList* PtrListCat(Js* e, PtrList* l, PtrList* r, bool_t delR);


//////// Ref part 2
Val* RefGetBase(Js* e, Val* r);
Val* RefGetReferencedName(Js* e, Val* r);
bool_t RefIsStrict(Js* e, Val* r);
bool_t RefHasPrimitiveBase(Js* e, Val* r);
bool_t RefIsPropRef(Js* e, Val* r);
bool_t RefIsUnresolvable(Js* e, Val* r);
bool_t RefIsSuper(Js* e, Val* r);
Val* GetValue(Js* e, Val* v);
Val* PutValue(Js* e, Val* v, Val* w);
Val* RefGetThis(Js* e, Val* v);

////// throw functions
Val* ThrowRefError(Js* e, char* prefix, Val* m, char* suffix);
Val* ThrowURIError(Js* e, char* prefix, Val* m, char* suffix);
Val* ThrowTypeError(Js* e, char* prefix, Val* m, char* suffix);
Val* ThrowRangeError(Js* e, char* prefix, Val* m, char* suffix);
Val* ThrowError(Js* e, char* prefix, Val* m, char* suffix);


/////// Data 6.26
struct DataTag {
    int refs;
    uint8* data;
    uint32 size;
};

Data* DataCreate(Js* e, uint32 size);
Val* CreateByteDataBlock(Js* e, Val* size);
Val* DataCopyBytes(Js* e, Data* to_block, int to_index, Data* from_block, int from_index, int count);
void DataDel(Js* e, Data* db);

///// 7 abstract operations
Val* GetGlobalObject(Js* e);
bool_t HasA(Js* e, Val* o, char* n);


///// 7.1 type conversion
Val* ToPrimitive(Js* e, Val* v, Val* preferred_type);
Val* OrdinaryToPrimitive(Js* e, Val* o, Val* hint);
Val* ToBoolean(Js* e, Val* v);
Val* ToNumber(Js* e, Val* v);
Val* ToInteger(Js* e, Val* v);
Val* ToInt32(Js* e, Val* v);
Val* ToUint32(Js* e, Val* v);
Val* ToInt16(Js* e, Val* v);
Val* ToUint16(Js* e, Val* v);
Val* ToInt8(Js* e, Val* v);
Val* ToUint8(Js* e, Val* v);
Val* ToUint8Clamp(Js* e, Val* v);
Val* ToString(Js* e, Val* v);
Val* ToPropKey(Js* e, Val* v);
Val* ToLength(Js* e, Val* v);
Val* ToObject(Js* e, Val* v);


////// 7.2 Testing and Comparison Operations
Val* SameValue(Js* e, Val* x, Val* y);
Val* RequireObjectCoercible(Js* e, Val* a);
Val* SameValueZero(Js* e, Val* x, Val* y);
Val* IsConstructor(Js* e, Val* a);
Val* IsPropKey(Js* e, Val* a);
Val* IsExtensible(Js* e, Val* a);
Val* IsCallable(Js* e, Val* v);
bool_t IsCallableBool(Js* e, Val* v);

Val* AbstractRelational(Js* e, Val* x, Val* y, bool_t left_first);
Val* AbstractEquality(Js* e, Val* x, Val* y);
Val* StrictEquality(Js* e, Val* x, Val* y);


/////// 7.3 operations on objects
Val* Get(Js* e, Val* o, Val* p);
Val* Put(Js* e, Val* o, Val* p, Val* v, bool_t strict);
Val* CreateDataProp(Js* e, Val* o, Val* p, Val* v);
Val* CreateDataPropOrThrow(Js* e, Val* o, Val* p, Val* v);
Val* DefinePropOrThrow(Js* e, Val* o, Val* p, Val* desc);
Val* DeletePropOrThrow(Js* e, Val* o, Val* p);
Val* GetMethod(Js* e, Val* o, Val* p);
Val* HasProp(Js* e, Val* o, Val* p);
Val* HasOwnProp(Js* e, Val* o, Val* p);
Val* Invoke(Js* e,Val* o, Val* p, Val* args);
Val* SetIntegrityLevel(Js* e, Val* o, Val* level);
Val* TestIntegrityLevel(Js* e, Val* o, Val* level);
Val* CreateArrayFromList(Js* e, Val* elements);
Val* CreateListFromArrayLike(Js* e, Val* obj);
Val* OrdinaryHasInstance(Js* e, Val* c, Val* o);
Val* GetPrototypeFromConstructor(Js* e, Val* cons, Val* def_proto);
Val* Construct(Js* e, Val* f, Val* args, Val* newTarget);
Realm* GetFunctionRealm(Js* e, Val* obj);

Val* GetA(Js* e, Val* o, char* n);
void DelA(Js* e, Val* o, char* n);
void PutA(Js* e, Val* o, char* n, Val* v, bool_t del_v);
void ObjectPutA(Js* e, Val* o, char* n, Val* v);
Val* ObjectGetA(Js* e, Val* o, char* n);

//////// 7.4 Operations on iterator objects
Val* GetIterator(Js* e, Val* obj, Val* method);
Val* CheckIterable(Js* e, Val* obj);
Val* IteratorNext(Js* e, Val* iterator, Val* value);
Val* IteratorComplete(Js* e, Val* iter_result);
Val* IteratorValue(Js* e, Val* iter_result);
Val* IteratorStep(Js* e, Val* iterator);
Val* CreateResultObject(Js* e, Val* value, Val* done);
Val* CreateListIterator(Js* e, Val* List);
Val* ListIteratorNext(Js* e, Val* othis);
Val* CreateEmptyIterator(Js* e);


//////// 7.5 Operations on promise objects
Val* AllocatePromise(Js* e, Val* proto);
Val* InitializePromise(Js* e, Val* promise, Val* executor);
Val* PromiseNew(Js* e, Val* executor);
Val* CreatePromiseCapability(Js* e, Val* promise, Val* proto);
Val* PromiseBuiltInCapability(Js* e);
Val* PromiseOf(Js* e, Val* value);
Val* PromiseAll(Js* e, Val* promise_list);
Val* PromiseCatch(Js* e, Val* promise, Val* rejected_action);
Val* PromiseThen(Js* e, Val* promise, Val* resolved_action, Val* rejected_action);


///////// 8.1 Lexical Environments
typedef Val* (*HasBindingPtr)(Js* e, Env* er, Val* n);
typedef Val* (*CreateMutableBindingPtr)(Js* e, Env* er, Val* n, bool_t d);
typedef Val* (*CreateImmutableBindingPtr)(Js* e, Env* er, Val* n);
typedef Val* (*InitializeBindingPtr)(Js* e, Env* er, Val* n, Val* v);
typedef Val* (*SetMutableBindingPtr)(Js* e, Env* er, Val* n, Val* v, bool_t s);
typedef Val* (*GetBindingValuePtr)(Js* e, Env* er, Val* n, bool_t s);
typedef Val* (*DeleteBindingPtr)(Js* e, Env* er, Val* n);
typedef Val* (*HasThisBindingPtr)(Js* e, Env* er);
typedef Val* (*HasSuperBindingPtr)(Js* e, Env* er);
typedef Val* (*WithBaseObjectPtr)(Js* e, Env* er);
typedef bool_t (*DestructPtr)(Js* e, Env* er);
typedef Val* (*GetThisBindingPtr)(Js* e, Env* er);
typedef Val* (*GetSuperBasePtr)(Js* e, Env* er);
typedef Val* (*BindThisValuePtr)(Js* e, Env* er, Val* v);
typedef Val* (*HasVarDeclPtr)(Js* e, Env* er, Val* n);
typedef Val* (*HasLexDeclPtr)(Js* e, Env* er, Val* n);
typedef Val* (*CanDeclareGlobalFuncPtr)(Js* e, Env* er, Val* n);
typedef Val* (*CanDeclareGlobalVarPtr)(Js* e, Env* er, Val* n);
typedef Val* (*CreateGlobalVarBindingPtr)(Js* e, Env* er, Val* n, bool_t d);
typedef Val* (*CreateGlobalFuncBindingPtr)(Js* e, Env* er, Val* n, Val* v, bool_t d);


struct EnvMethodsTag {
    HasBindingPtr                   hasBinding;
    CreateMutableBindingPtr        createMutableBinding;
    CreateImmutableBindingPtr      createImmutableBinding;
    InitializeBindingPtr            initializeBinding;
    SetMutableBindingPtr           setMutableBinding;
    GetBindingValuePtr             getBindingValue;
    DeleteBindingPtr                deleteBinding;
    HasThisBindingPtr              hasThisBinding;
    HasSuperBindingPtr             hasSuperBinding;
    WithBaseObjectPtr              withBaseObject;
    DestructPtr                      destruct;
    GetThisBindingPtr              getThisBinding;
    GetSuperBasePtr                getSuperBase;
    BindThisValuePtr               bindThisValue;
    HasVarDeclPtr                  hasVarDecl;
    HasLexDeclPtr                  hasLexDecl;
    CanDeclareGlobalVarPtr           canDeclGlobalVar;
    CanDeclareGlobalFuncPtr          canDeclGlobalFunc;
    CreateGlobalVarBindingPtr     createGlobalVarBinding;
    CreateGlobalFuncBindingPtr    createGlobalFuncBinding;
};

struct EnvTag {
    EnvMethods* vtable;
};

void EnvDel(Js* e, Env* v);

enum {
    BINDING_MUTABLE = 0x01,
    BINDING_CAN_DELETE = 0x02
};

struct envBindingTag {
    Val*    name;
    uint32  flags;
    Val*    value;
    struct envBindingTag* next;
};
typedef struct envBindingTag Binding;

struct DeclEnvTag {
    Env super;              // inherits from Env
    Binding* bindings;
};


EnvMethods* DeclEnvMethodsNew(Js* e);
void DeclEnvMethodsDel(Js* e, EnvMethods* em);
Val* DeclEnvHasBinding(Js* e, Env* er, Val* n);
Val* DeclEnvCreateMutableBinding(Js* e, Env* er, Val* n, bool_t d);
Val* DeclEnvCreateImmutableBinding(Js* e, Env* er, Val* n);
Val* DeclEnvInitializeBinding(Js* e, Env* er, Val* n, Val* v);
Val* DeclEnvSetMutableBinding(Js* e, Env* er, Val* n, Val* v, bool_t s);
Val* DeclEnvGetBindingValue(Js* e, Env* er, Val* n, bool_t s);
Val* DeclEnvDeleteBinding(Js* e, Env* er, Val* n);
Val* DeclEnvHasThisBinding(Js* e, Env* er);
Val* DeclEnvHasSuperBinding(Js* e, Env* er);
Val* DeclEnvWithBaseObject(Js* e, Env* er);
bool_t DeclEnvDestruct(Js* e, Env* er);
Env* DeclEnvNew(Js* e);


struct ObjEnvTag {
    Env super;              // inherits from Env
    Val* bindingObj;
    List* unscopables;
    bool_t withEnv;
};

EnvMethods* ObjEnvMethodsNew(Js* e);
void ObjEnvMethodsDel(Js* e, EnvMethods* em);
Val* ObjEnvHasBinding(Js* e, Env* er, Val* n);
Val* ObjEnvCreateMutableBinding(Js* e, Env* er, Val* n, bool_t d);
Val* ObjEnvCreateImmutableBinding(Js* e, Env* er, Val* n);
Val* ObjEnvInitializeBinding(Js* e, Env* er, Val* n, Val* v);
Val* ObjEnvSetMutableBinding(Js* e, Env* er, Val* n, Val* v, bool_t s);
Val* ObjEnvGetBindingValue(Js* e, Env* er, Val* n, bool_t s);
Val* ObjEnvDeleteBinding(Js* e, Env* er, Val* n);
Val* ObjEnvHasThisBinding(Js* e, Env* er);
Val* ObjEnvHasSuperBinding(Js* e, Env* er);
Val* ObjEnvWithBaseObject(Js* e, Env* er);
bool_t ObjEnvDestruct(Js* e, Env* er);
Env* ObjEnvNew(Js* e, Val* o, bool_t w);


#define BINDING_STATUS_UNINITIALIZED        0
#define BINDING_STATUS_LEXICAL              1
#define BINDING_STATUS_INITIALIZED          2


struct FuncEnvTag {
    DeclEnv super;         // inherits from DeclEnv
    Val* thisValue;
    Val* thisBindingStatus;
    Val* functionObject;
    Val* homeObj;
    Val* newTarget;         // Created using [[Construct]] => value : undefined
};

EnvMethods* FuncEnvMethodsNew(Js* e);
void FuncEnvMethodsDel(Js* e, EnvMethods* em);
Val* FuncEnvBindThisValue(Js* e, Env* er, Val* v);
Val* FuncEnvHasThisBinding(Js* e, Env* er);
Val* FuncEnvGetThisBinding(Js* e, Env* er);
Val* FuncEnvGetSuperBase(Js* e, Env* er);
bool_t FuncEnvDestruct(Js* e, Env* er);
Val* FuncEnvGetThisBinding(Js* e, Env* er);
Val* FuncEnvGetSuperBase(Js* e, Env* er);
Val* FuncEnvHasSuperBinding(Js* e, Env* er);

Env* FuncEnvNew(Js* e);

struct GlobalEnvTag {
    EnvMethods* vtable;
    ObjEnv*    objRec;
    DeclEnv*   dclRec;
    List*       varNames;
};

EnvMethods* GlobalEnvMethodsNew(Js* e);
void GlobalEnvMethodsDel(Js* e, EnvMethods* em);
Val* GlobalEnvHasBinding(Js* e, Env* er, Val* n);
Val* GlobalEnvCreateMutableBinding(Js* e, Env* er, Val* n, bool_t d);
Val* GlobalEnvCreateImmutableBinding(Js* e, Env* er, Val* n);
Val* GlobalEnvInitializeBinding(Js* e, Env* er, Val* n, Val* v);
Val* GlobalEnvSetMutableBinding(Js* e, Env* er, Val* n, Val* v, bool_t s);
Val* GlobalEnvGetBindingValue(Js* e, Env* er, Val* n, bool_t s);
Val* GlobalEnvDeleteBinding(Js* e, Env* er, Val* n);
Val* GlobalEnvHasThisBinding(Js* e, Env* er);
Val* GlobalEnvHasSuperBinding(Js* e, Env* er);
Val* GlobalEnvWithBaseObject(Js* e, Env* er);
bool_t GlobalEnvDestruct(Js* e, Env* er);
Val* GlobalEnvGetThisBinding(Js* e, Env* er);
Val* GlobalEnvGetSuperBase(Js* e, Env* er);
Val* GlobalEnvHasVarDecl(Js* e, Env* er, Val* n);
Val* GlobalEnvHasLexDecl(Js* e, Env* er, Val* n);
Val* GlobalEnvCanDeclGlobalVar(Js* e, Env* er, Val* n);
Val* GlobalEnvCanDeclGlobalFunc(Js* e, Env* er, Val* n);
Val* GlobalEnvCreateGlobalVarBinding(Js* e, Env* er, Val* n, bool_t d);
Val* GlobalEnvCreateGlobalFuncBinding(Js* e, Env* er, Val* n, Val* v, bool_t d);
#define GlobalEnvNew(e,de,oe) _GlobalEnvNew(e, de, oe, __LINE__);
Env* _GlobalEnvNew(Js* e, Env* de, Env* oe, int line);

struct LexEnvTag {
    int referenceCount;
    Env* envRec;
    Val* outer;
};


#define LexEnvNew(e) _LexEnvNew(e, __LINE__)
LexEnv* _LexEnvNew(Js* e, int line);
void LexEnvRetain(Js* e, LexEnv* le);
void LexEnvRelease(Js* e, LexEnv* le);
void LexEnvDel(Js* e, LexEnv* le);
Val* GetIdentifierRef(Js* e, Val* lex, Val* name, bool_t strict);
Val* NewDeclEnv(Js* e, Val* E);
Val* NewObjEnv(Js* e, Val* o, Val* E);
Val* NewFunctionEnvironment(Js* e, Val* f, Val* newTarget);


//////// 8.2 Code Realms
struct RealmTag {
    uint32 referenceCount;
    bool_t complete;                    // Initialization is complete on this realm
                                        // for prototype objects
    
    //////// 22.2.1 TypeArrayIntrinsic
    Val* typedArrayIntrinsic;

    /////// 6.1.7.4 well known intrinsic objects
    Val* objectConstructor;
    Val* objectPrototype;
    Val* objProto_toString;
    Val* functionConstructor;
    Val* functionPrototype;
    Val* arrayConstructor;
    Val* arrayPrototype;
    Val* arrayIteratorPrototype;
    Val* stringConstructor;
    Val* stringPrototype;
    Val* stringIteratorPrototype;
    Val* booleanObject;
    Val* booleanPrototype;
    Val* numberObject;
    Val* numberPrototype;
    Val* dateObject;
    Val* datePrototype;
    Val* regExpConstructor;
    Val* regExpPrototype;
    Val* mapObject;
    Val* mapPrototype;
    Val* mapIteratorPrototype;
    Val* weakMapObject;
    Val* weakMapPrototype;
    Val* setObject;
    Val* setPrototype;
    Val* weakSetObject;
    Val* weakSetPrototype;
    Val* setIteratorPrototype;
    Val* generatorFunctionObject;
    Val* generatorObject;
    Val* generatorPrototype;
    Val* errorObject;
    Val* evalErrorObject;
    Val* rangeErrorObject;
    Val* referenceErrorObject;
    Val* syntaxErrorObject;
    Val* typeErrorObject;
    Val* uriErrorObject;
    Val* errorPrototype;
    Val* evalErrorPrototype;
    Val* rangeErrorPrototype;
    Val* referenceErrorPrototype;
    Val* syntaxErrorPrototype;
    Val* typeErrorPrototype;
    Val* uriErrorPrototype;
    Val* arrayBufferConstructor;
    Val* arrayBufferPrototype;
    Val* typedArrayObject;
    Val* typedArrayPrototype;
    
    Val* int8ArrayObject;
    Val* int8ArrayPrototype;
    Val* uint8ArrayObject;
    Val* uint8ArrayPrototype;
    Val* uint8ClampedArrayObject;
    Val* uint8ClampedArrayPrototype;
    Val* int16ArrayObject;
    Val* int16ArrayPrototype;
    Val* uint16ArrayObject;
    Val* uint16ArrayPrototype;
    Val* int32ArrayObject;
    Val* int32ArrayPrototype;
    Val* uint32ArrayObject;
    Val* uint32ArrayPrototype;
    Val* float32ArrayObject;
    Val* float32ArrayPrototype;
    Val* float64ArrayObject;
    Val* float64ArrayPrototype;


    Val* dataViewObject;
    Val* dataViewPrototype;
    Val* throwTypeErrorFunction;
    Val* symbolConstructor;
    Val* symbolPrototype;
    ///////////////////////////////////////////////////////
    
    Val* globalThis;
    Val* globalEnv;
    Val* directEvanTranslate;
    Val *directEvalFallback;
    Val* indirectEval;
    Val* function;
    Val* loader;
};

#define RealmNew(e) _RealmNew(e, __LINE__)
Realm* _RealmNew(Js* e, int line);
void RealmComplete(Js* e, Realm* r);
Realm* CurrentRealm(Js* e);
void RealmInit(Js* e, Realm* r);
void RealmDelete(Js* e, Realm* r);
Realm* RealmRetain(Js* e, Realm* r);
void RealmRelease(Js* e, Realm* r);

////////// 8.3 Execution Contexts
struct ContextTag {
    int ref_count;      // reference count
    Realm* realm;
    Val* lex;           // lexical_environment
    Val* vars;          // vars environment
    Val* generator;     // generator object
    Val* function;
    bool_t own_vars;    // vars is different than lex
    struct ContextTag* prev;
};
Context* ContextNew(Js* e, Realm* r, Val* gen, bool_t deferEnv);
void ContextDelete(Js* e, Context* ctx);
void ContextRetain(Js* e, Context* ctx);   // use ContextDelete() to release
bool_t ContextIsSuspended(Js* e, Context* ctx);
Val* ResolveBinding(Js* e, Val* name, bool_t strict);
Val* GetThisEnv(Js* e);
Val* GetNewTarget(Js* e);
Val* ResolveThisBinding(Js* e);
Val* GetGlobalObject(Js* e);

//////////// 8.4 Tasks and Task Queues
typedef void (*TaskFuncPtr)(Js* e, List* args);

struct TaskTag {
    TaskFuncPtr   taskName;
    List*       args;
    Realm*      realm;
    Task*       next;
};

struct TaskQueueTag {
    char*       name;
    Task*       tasks;
};

TaskQueue* TaskQueueNew(Js* e, char* name);
void TaskQueueDel(Js* e, TaskQueue* q);

Val* EnqueueTask(Js* e, Val* queue, TaskFuncPtr tf, List* args);
void NextTask(Js* e, Val* result);


////// 9.1 ordinary object methods
Val* OrdinaryGetPrototypeOf(Js* e, Val* o);
Val* OrdinarySetPrototypeOf(Js* e, Val* o, Val* proto);
Val* OrdinaryIsExtensible(Js* e, Val* o);
Val* OrdinaryPreventExtensions(Js* e, Val* o);
Val* OrdinaryGetOwnProperty(Js* e, Val* o, Val* key);
Val* OrdinaryHasProperty(Js* e, Val* o, Val* key);
Val* OrdinaryGet(Js* e, Val* o, Val* key, Val* receiver);
Val* OrdinarySet(Js* e, Val* o, Val* key, Val* v, Val* receiver);
Val* OrdinaryDelete(Js* e, Val* o, Val* key);
Val* OrdinaryDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* OrdinaryEnumerate(Js* e, Val* o);
Val* OrdinaryOwnPropertyKeys(Js* e, Val* o);
Val* OrdinaryCall(Js* e, Val* o, Val* othis, Val* args);
Val* OrdinaryConstruct(Js* e, Val* o, Val* args);

#define ObjectCreate(e,p,d) _ObjectCreate(e,p,d,__LINE__)
Val* _ObjectCreate(Js* e, Val* proto, Val* data_list, int line);
Val* OrdinaryCreateFromConstructor(Js* e, Val* cons, Val* def_proto, Val* data_list);
Val* ObjectConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);

////// 9.2 function object methods
Val* FunctionGetOwnProperty(Js* e, Val* o, Val* key);
Val* PrepareForOrdinaryCall(Js* e, Val* f, Val* newTarget);
Val* OrdinaryCallBindThis(Js* e, Val* f, Val* calleeContext, Val* thisArg);
Val* FunctionCall(Js* e, Val* o, Val* othis, Val* args);
Val* FunctionConstruct(Js* e, Val* o, Val* args, Val* newTarget);
bool_t FunctionIsStrict(Js* e, Val* func);

Val* ThrowTypeErrorCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);


////// 9.3 Builtin Function Objects
typedef Val* (*StepsPtr)(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
Val* CreateBuiltinFunction(Js* e, Realm* realm, StepsPtr steps);


/////// 9.4.1 BoundFunction Objects
Val* BoundFunctionCall(Js* e, Val* o, Val* othis, Val* args);
Val* BoundFunctionConstruct(Js* e, Val* o, Val* args, Val* newTarget);
Val* BoundFunctionCreate(Js* e, Val* targetFunc, Val* boundThis, Val* boundArgs);

////// 9.4.2 Array Exotic Objects
#define ArrayCreate(e,l,p) _ArrayCreate(e,l,p,__LINE__)
Val* _ArrayCreate(Js* e, Val* length, Val* proto, int line);
#define ArrayCreateN(e, n) _ArrayCreateN(e, n, __LINE__)
Val* _ArrayCreateN(Js* e, int n, int line);
Val* ArrayDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* ArraySetLength(Js* e, Val* a, Val* desc);
Val* CreateArrayIterator(Js* e, Val* array, Val* kind);
void ArraySetN(Js* e, Val* arr, int idx, Val* v, bool_t del);

////// 9.4.3 String Exotic Objects
Val* StringCreate(Js* e, Val* proto, Val* str);
Val* StringGetOwnProperty(Js* e, Val* o, Val* key);
Val* StringDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* StringEnumerate(Js* e, Val* o);
Val* StringOwnPropertyKeys(Js* e, Val* o);

////// 9.4.4 Arguments Exotic Objects
Val* InstantiateArgumentsObject(Js* e,Val* args);
void CompleteStrictArgumentsObject(Js* e,Val* obj, Val* func, Node* formals, Val* env);
void CompleteMappedArgumentsObject(Js* e,Val* ao, Val* func, Node* formals, Val* env);
Val* MakeArgGetter(Js* e, Val* name, Val* env);
Val* MakeArgSetter(Js* e, Val* name, Val* env);
Val* ArgumentsGet(Js* e, Val* o, Val* key, Val* receiver);
Val* ArgumentsGetOwnProperty(Js* e, Val* o, Val* key);
Val* ArgumentsDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* ArgumentsDelete(Js* e, Val* o, Val* key);

////// 9.4.5 Integer Indexed Exotic Objects A
Val* IntegerIndexedGetOwnProperty(Js* e, Val* o, Val* key);
Val* IntegerIndexedDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* IntegerIndexedGet(Js* e, Val* o, Val* key, Val* receiver);
Val* IntegerIndexedSet(Js* e, Val* o, Val* key, Val* v, Val* receiver);
Val* IntegerIndexedEnumerate(Js* e, Val* o);
Val* IntegerIndexedOwnPropertyKeys(Js* e, Val* o);
Val* IntegerIndexedObjectCreate(Js* e, Val* proto);
Val* IntegerIndexedElementGet(Js* e, Val* o, int index);
Val* IntegerIndexedElementSet(Js* e, Val* o, int index, Val* value);


/////// 9.5 Proxy Objects 
Val* ProxyCreate(Js* e, Val* target, Val* handler);
Val* ProxyGetPrototypeOf(Js* e, Val* o);
Val* ProxySetPrototypeOf(Js* e, Val* o, Val* proto);
Val* ProxyIsExtensible(Js* e, Val* o);
Val* ProxyPreventExtensions(Js* e, Val* o);
Val* ProxyGetOwnProperty(Js* e, Val* o, Val* key);
Val* ProxyHasProperty(Js* e, Val* o, Val* key);
Val* ProxyGet(Js* e, Val* o, Val* key, Val* receiver);
Val* ProxySet(Js* e, Val* o, Val* key, Val* v, Val* receiver);
Val* ProxyDelete(Js* e, Val* o, Val* key);
Val* ProxyDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc);
Val* ProxyEnumerate(Js* e, Val* o);
Val* ProxyOwnPropertyKeys(Js* e, Val* o);
Val* ProxyCall(Js* e, Val* o, Val* othis, Val* args);
Val* ProxyConstruct(Js* e, Val* o, Val* args, Val* newTarget);

// @todo: Move these to buffer objects when implemented
#define ELEMENT_TYPE_NONE               0
#define ELEMENT_TYPE_INT8               1
#define ELEMENT_TYPE_UINT8              2
#define ELEMENT_TYPE_UINT8_CLAMPED      3
#define ELEMENT_TYPE_INT16              4
#define ELEMENT_TYPE_UINT16             5
#define ELEMENT_TYPE_INT32              6
#define ELEMENT_TYPE_UINT32             7
#define ELEMENT_TYPE_FLOAT32            8
#define ELEMENT_TYPE_FLOAT64            9

struct TypedArrayConsDataTag {
    char *constructorName;
    int elementType;
    int elementSize;
};
typedef struct TypedArrayConsDataTag TypedArrayConsData;

int ElementSizeFromConstructor(Js* e, Val* arrayTypeName);
int ElementTypeFromConstructor(Js* e, Val* arrayTypeName);
int ElementSizeFromType(Js* e, int elementType);
Val* GetValueFromBuffer(Js* e, Val* buffer, int indexedPosition, int elementType, bool_t* isLittleEndian);
Val* SetValueInBuffer(Js* e, Val* buffer, int indexedPosition, int elementType, Val* numValue, bool_t* isLittleEndian);


///////  Parser
#define MAX_PARSE_ERROR                         2048
#define MAX_FILE_NAME                           2048

struct NodeFlagTag {
    void*   flag;
    struct NodeFlagTag* next;
};

#define NODE_TEMPLATE_CALL                      0x01            // Node represents a template call
struct ParseNodeTag {
    int            token;                       // token index
    Node*          left;                        // left child
    Node*          right;                       // right child
    Val*           extra;                       // e.g. callSiteObject
    Parser*        p;
    NodeFlag*      flags;
};


struct FuncDefTag {
    Val* name;
    int line;
    int startToken;
    int endToken;
    BlockDef* block;
    FuncDef* parent;
    FuncDef* next;
};

struct BlockDefTag {
    int start;
    int end;
    BlockDef* parent;
    BlockDef* next;
};

struct ParserTag {
    Js*             e;                          // engine 
    Tokenizer*      tk;                         // associated tokenizer
    char            error[MAX_PARSE_ERROR];     // syntax errors
    bool_t          stop;                       // Stop parsing
    int             next;                       // next token
    Node*           root;                       // root parse node
    Str*            source;
    bool_t          retain;                     // Retain source and delete
    char            fileName[MAX_FILE_NAME];
    int             fileIndex;
    FuncDef*        functions;
    BlockDef*       blocks;
    FuncDef*        currentFunc;
    BlockDef*       currentBlock;
    int             refCount;                   // Parsers can be held by functions

    Val*            calls;                      // Call graph when requested with --calls
};

FuncDef* FuncDefNew(Parser* p);
FuncDef* FuncDefFind(Parser* p, int line);
void FuncDefDel(Parser* p, FuncDef* fd);
BlockDef* BlockDefNew(Parser* p);
void BlockDefDel(Parser* p, BlockDef* bd);

Parser* ParserNew(Js* e);
void ParserRetain(Parser* p);
void ParserDel(Parser* p);
void ParserFree(Parser* p);
void ParserSetFileName(Parser* p, char* fileName);
Node* NodeNew(Parser* p);
void NodeDel(Parser* p, Node* n);
void NodePrint(Parser* p, Node* n, int level);
void NodeSetFlag(Parser* p, Node* n, void* flag);
void NodeClearFlag(Parser* p, Node* n, void* flag);
NodeFlag* NodeHasFlag(Parser* p, Node* n, void* flag);

////// Parser flags
#define PSTRICT             (1 << 0)
#define PDEFAULT            (1 << 1)
#define PNOYIELD            (1 << 2)
#define PNOLET              (1 << 3)
#define PMUSTINIT           (1 << 4)        // const must initialize

Node* Script(Parser* p, uint32 flags);
Node* StatementList(Parser* p, int start, uint32 flags);
Node* Statement(Parser* p, int start, uint32 flags);

Val* Run(Js* e, Str* source, uint32 flags);
Val* RunA(Js* e, char* text, uint32 flags);
Val* Parse(Parser* p, Str* source, bool_t retain, uint32 flags);
Val* ParseA(Parser* p, char* source, uint32 flags);
Val* Eval(Parser* e, Node* n, uint32 flags);
typedef void(*globalInit)(Js* e, Val* global, Realm* r);
Val* ScriptEval(Parser* p, Realm* realm, bool_t deletableBindings, uint32 flags, globalInit init);
Node* SyntaxError(Parser* p, char* err);


int NumberOfParameters(Js* e, Node* list);
int ExpectedArgCount(Parser* p, Node* params);
PtrList* BoundNames(Parser* p, Node* d);
PtrList* VarScopedDeclarations(Parser* p, Node* block);
PtrList* VarDeclaredNames(Parser* p, Node* n);
Node* _LexicalDeclaration(Js* e, Node* n);
bool_t IsConstantDeclaration(Parser* p, Node* n);
bool_t IsGeneratorDeclaration(Parser* p, Node* n);
bool_t IsBindingIdentifier(Parser* p, Node* param);


////////// Simple JsonParsing
Val* JsonParse(Js* e, Tokenizer* tk, int *next);
Val* JsonStringify(Js* e, Val* v);
void jprintf(Js* e, bool_t ext, const char * format, ... );



void InitArrayIteratorPrototype(Js* e, Val* aip);
void InitArrayPrototype(Js* e, Val* ap);


//////////// Debugger
typedef int (*listenFunc)(Js* e, void* fd, int count);
typedef int (*readFunc)(Js* e, void* socket, char* buffer, int count);
typedef int (*writeFunc)(Js* e, void* socket, char* buffer, int count);
typedef void* (*acceptFunc)(Js* e, int handle);
typedef void (*closeFunc)(Js* e, void* socket);
typedef void* (*initFunc)(Js* e, void* d);
typedef void (*printFunc)(Js* e, bool_t ext, const char * format, ... );
typedef void (*vprintFunc)(Js* e, char* prefix, Val* v, bool_t detail);

typedef struct {
    Tokenizer* tk;
    Parser* p;
    Realm* r;
    bool_t running;
    Val* req;
    Val* seq;
    Val* command;
    Val* arguments;
    Val* type;
    int rs;
    Val* refs;
    bool_t shouldExit;
    bool_t appendCR;
    listenFunc listen;
    readFunc read;
    writeFunc write;
    acceptFunc accept;
    closeFunc close;
    printFunc print;
    vprintFunc vprint;
    initFunc init;
    bool_t sentConnected;
    void *sock;
    void* evalInit;             // ScriptEval() initializer
    int autoSeq; 
    bool_t mainEnd;
    bool_t quickMode;
    Val* appendResponse;
    int lastLine;
    List* files;                // List of file name strings
} DebugContext;

#define DEBUG_STOP      0
#define DEBUG_BREAK     1
#define DEBUG_CONTINUE  2
#define DEBUG_IN        3
#define DEBUG_OUT       4
#define DEBUG_OVER      5

#define DEBUG_NOLINE    -1
#define DEBUG_MAX_CONDITION     64
#define DEBUG_NOTFOUND  -1

struct BreakptTag {
    int file;
    int line;
    bool_t enabled;
    char condition[DEBUG_MAX_CONDITION];
};

struct DebuggerTag {
    DebugContext* context;
    uint32 state;
    int targetLine;               // For step over / in
    Context* targetContext;       // For step in
    Vector* Breakpts;
};

Debugger* DebuggerNew(Js* e, DebugContext* dc);
void DebuggerDel(Js* e, Debugger* dbg);
int DebuggerFindBreakpt(Js* e, int file, int line);
int DebuggerAddBreakpt(Js* e, int file, int line);
void DebuggerRemoveBreakpt(Js* e, int index);
void DebuggerEnableBreakpt(Js* e, int index);
void DebuggerDisableBreakpt(Js* e, int index);
bool_t DebuggerBreakptEnabled(Js* e, int index);
bool_t DebuggerCheckBreakpt(Js* e, int file, int line);
void DebuggerClearAllBreakpts(Js* e);
bool_t DebuggerTick(Parser* p);

#define STRING_MAP_HASH_MAX       256

struct StrMapTag {
    Vector* hash[STRING_MAP_HASH_MAX];      // Hash table of dynamic arrays
    Vector* keys;                           // Dynamic array of key strings
    int capacity;
    float growth;
    int size;
};

typedef struct {
    char* name;
    StepsPtr func;
    int length;
} NativeMethod;

#define METHCOUNT(a) (sizeof(a) /sizeof(NativeMethod))


#define IFD(x) if(x) ValDel(e,x)

#define IFZ(x) if(x) ValDel(e,x); x = NULL;

#define RET_VAL(x) {\
    ret = x;\
    x = NULL;\
    goto exit;\
}\


#define RET(x) \
{\
    ret = x;\
    goto exit;\
}\

#define RET_IF_AB(v)\
    if(ValIsAbrupt(e, v)) {\
        ret = ValClone(e,v);\
        goto exit;\
    }\
    if(v->type == TYPE_COMP) {\
        Completion* c = (Completion*) v->completion;\
        Val* v2 = ValClone(e, c->value);\
        ValDel(e, v);\
        v = v2;\
    }\


#define RET_IF_ABRUPT(v)     \
    if(ValIsAbrupt(e, v))\
        return ValClone(e,v);\
    if(v->type == TYPE_COMP) {\
        Completion* c = (Completion*) v->completion;\
        v = c->value;\
    }\

#define RET_IF_ABRUPT_CV1(v,D)     \
    if(ValIsAbrupt(e, v)) {\
        ValDel(e, D);\
        return v;\
    }\
    if(v->type == TYPE_COMP) {\
        Completion* c = (Completion*) v->completion;\
        v = c->value;\
    }\

#define RET_IF_ABRUPT_CV2(v,v1,v2)     \
    if(ValIsAbrupt(e, v)) {\
        ValDel(e, v1);\
        ValDel(e, v2);\
        return v;\
    }\
    if(v->type == TYPE_COMP) {\
        Completion* c = (Completion*) v->completion;\
        v = c->value;\
    }\

#define RET_IF_ABRUPT_CV3(v,v1,v2,v3)     \
    if(ValIsAbrupt(e, v)) {\
        ValDel(e, v1);\
        ValDel(e, v2);\
        ValDel(e, v3);\
        return v;\
    }\
    if(v->type == TYPE_COMP) {\
        Completion* c = (Completion*) v->completion;\
        v = c->value;\
    }\


#define RET_IF_ABRUPT_CV2_L(v,p,g,l)     \
    if(ValIsAbrupt(e, v)) {\
        ValDel(e, p);\
        ValDel(e, g);\
        ListDel(e, l);\
        return v;\
    }\
    if(v->type == TYPE_COMP) {\
        Completion* c = (Completion*) v->completion;\
        v = c->value;\
    }\


#ifdef __cplusplus
}
#endif

#endif // JSE_API
/////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
// Test infrastructure
#ifdef JSE_TEST
#include <stdlib.h>

int MainTest(Js* e);
#define ok(t, c, d) _ok(t, c, d, __LINE__)

#else

#define ok(t,c,d)
#define MainTest(e)

#endif // JSE_TEST
/////////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////////
// Portable implementation use #define JSE_IMPL for implementation
//
#ifdef JSE_IMPL

#include <stdlib.h>
#include <memory.h>
#include <math.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
#include <float.h>
#include <limits.h>

#ifdef LINENOISE    
#include "linenoise.h"
#include "linenoise.c"    
#endif


void jprintf(Js* e, bool_t ext, const char * format, ... ) {
    if(!e->options.quiet) {
        char buffer[2048];
        va_list args;
        va_start (args, format);
        vsprintf (buffer,format, args);
        if(e->options.outputFile) {
            FILE* fp = fopen(e->options.outputFile, "a");
            if(!fp) {
                printf("\nerror %s output file not found\n", e->options.outputFile);
                exit(-1);
            }
            fprintf(fp, "%s", buffer);
            fclose(fp);
        }
        else {
            printf("%s", buffer);
        }
        va_end (args);
    }
    if(ext)
        exit(-1);
}


///////// Macros



void JsInitHeap(Js* e, int index, char* name, int size, int blockCap) {
    e->memory[index].name = name;
    e->memory[index].data = hnew(blockCap, size);
}

int ___allocs = 0;

void* _malloc(size_t size) {
    ___allocs++;
    return malloc(size);
}

void _free(void* ptr) {
    ___allocs--;
    free(ptr);
}

///////// Js
void JsInit(Js* e, bool_t createContext) {
    e->noInit = 0;
    e->localTZA = NAN;
    e->ctags = NULL;
    e->loopLimit = 1000*2;
    e->memory = _malloc(sizeof(typeheap) * HEAPS);
    JsInitHeap(e, VA, "Val", sizeof(Val), 4000);
    JsInitHeap(e, OB, "Object", sizeof(Object), 1000);
    JsInitHeap(e, ND, "Node", sizeof(Node), 100);
    JsInitHeap(e, PR, "Property", sizeof(Property), 2000);
    JsInitHeap(e, IT, "Item", sizeof(Item), 100);
    JsInitHeap(e, LS, "List", sizeof(List), 30);
    JsInitHeap(e, TK, "Tokenizer", sizeof(Tokenizer), 0);
    JsInitHeap(e, BD, "BlockDef", sizeof(BlockDef), 10);
    JsInitHeap(e, NF, "NodeFlags", sizeof(NodeFlag), 100);
    JsInitHeap(e, DS, "DynStr", sizeof(DynStr), 100);
    JsInitHeap(e, RM, "Realm", sizeof(Realm), 0);
    JsInitHeap(e, CM, "Completion", sizeof(Completion), 10);
    JsInitHeap(e, PL, "PtrList", sizeof(PtrList), 10);
    JsInitHeap(e, PI, "PtrItem", sizeof(PtrItem), 5);
    JsInitHeap(e, RF, "Ref", sizeof(Ref), 10);
    JsInitHeap(e, DM, "EnvMethods", sizeof(EnvMethods), 0);
    JsInitHeap(e, BN, "Binding", sizeof(Binding), 5);
    JsInitHeap(e, OM, "EnvMethods (OM)", sizeof(EnvMethods), 0);    
    JsInitHeap(e, FM, "EnvMethods (FM)", sizeof(EnvMethods), 0);    
    JsInitHeap(e, LE, "LexEnv", sizeof(LexEnv), 10);    
    JsInitHeap(e, CX, "Context", sizeof(Context), 10);    
    JsInitHeap(e, TQ, "TaskQueue", sizeof(TaskQueue), 0);    
    JsInitHeap(e, TS, "Task", sizeof(Task), 0);    
    JsInitHeap(e, PA, "Parser", sizeof(Parser), 0);    
    JsInitHeap(e, FD, "FuncDef", sizeof(FuncDef), 0);
    JsInitHeap(e, DX, "Data", sizeof(Data), 0);
    JsInitHeap(e, DG, "Debugger", sizeof(Debugger), 0);
    JsInitHeap(e, DC, "DebugContext", sizeof(DebugContext), 0);
    JsInitHeap(e, FE, "FuncEnv", sizeof(FuncEnv), 1);
    JsInitHeap(e, EN, "Environment", 0, 0);
    JsInitHeap(e, ST, "String", 0, 0);
    JsInitHeap(e, DA, "Data", 0, 0);
    JsInitHeap(e, XX, "Other", 0, 0);
    JsInitHeap(e, SM, "StrMap", sizeof(Strmap), 10);
    JsInitHeap(e, SE, "SymbolEntry", sizeof(Str*), 100);
    JsInitHeap(e, CT, "Ctag", sizeof(ctag), 100);

    e->nextObject = 1;
    e->debugger = NULL;
    e->options.command = NULL;
    e->options.file = NULL;
    e->options.watcher = FALSE;
    e->options.quiet = FALSE;
    e->options.verbose = FALSE;
    e->options.colors = FALSE;
    e->options.lines = FALSE;
    e->options.memory = FALSE;
    e->options.runtime = FALSE;
    e->options.debug = FALSE;
    e->options.start = -1;
    e->options.num = -1;
    e->options.margin = 80;
    e->options.port = "4747";
    e->options.outputFile = NULL;
    e->options.opmlUseLR = FALSE;
    e->options.opml = FALSE;
    e->options.callGraph = FALSE;
    e->options.noHeader = FALSE;
    e->options.github = FALSE;
    e->options.ni = FALSE;
    e->options.genTags  = FALSE;
    e->options.recursive = FALSE;
    e->options.functions = FALSE;
    e->options.tailInsert = TRUE;
    e->options.debugLog = FALSE;
    e->options.script_path[0] = 0;
    JsColors(e, FALSE);

    e->total = 0;
    JsCreateSymbols(e);

    /////// Initialize the keyword table    
    e->keywords = StrmapNew(e, TOK_MIN_IDENTIFIER_CHARS, TOK_MIN_IDENTIFIERS, sizeof(int), 2.0);
    for(int k = 0; k < sizeof(keywords) / sizeof(KeyDef); k++) {
        KeyDef* kd = &keywords[k];
        Str* key = StrNewChars(e, (char*) kd->text);
        StrmapPut(e, e->keywords, key, &kd->kid);
        StrDel(e, key);
    }

    e->debugLevel = DEBUG_LEVEL_NONE;

    e->strLength = ValNewStrA(e, "length");
    e->strEmpty = ValNewStrA(e, "");
    e->strCallee = ValNewStrA(e, "callee");
    e->strCaller = ValNewStrA(e, "caller");
    e->strArguments = ValNewStrA(e, "arguments");
    
    e->strGetPrototypeOf = ValNewStrA(e, "getPrototypeOf");
    e->strSetPrototypeOf = ValNewStrA(e, "setPrototypeOf");
    e->strIsExtensible = ValNewStrA(e, "isExtensible");
    e->strPreventExtensions = ValNewStrA(e, "preventExtensions");
    e->strGetOwnPropertyDescriptor = ValNewStrA(e, "getOwnPropertyDescriptor");
    e->strDefineProperty = ValNewStrA(e, "defineProperty");
    e->strHas = ValNewStrA(e, "has");
    e->strGet = ValNewStrA(e, "get");
    e->strSet = ValNewStrA(e, "set");
    e->strDeleteProperty = ValNewStrA(e, "deleteProperty");
    e->strEnumerate = ValNewStrA(e, "enumerate");
    e->strOwnKeys = ValNewStrA(e, "ownKeys");
    e->strApply = ValNewStrA(e, "apply");
    e->strConstruct = ValNewStrA(e, "construct");
    e->strNext = ValNewStrA(e, "next");
    e->strZero = ValNewStrA(e, "0");
    e->strOne = ValNewStrA(e, "1");
    e->strFrozen = ValNewStrA(e, "frozen");
    e->strName = ValNewStrA(e, "name");
    e->strThrow = ValNewStrA(e, "throw");
    e->strReturn = ValNewStrA(e, "return");
    e->strSealed = ValNewStrA(e, "sealed");
    e->strPrototype = ValNewStrA(e, "prototype");
    e->strMessage = ValNewStrA(e, "message");

    
    e->declEnvMethods = DeclEnvMethodsNew(e);
    e->objEnvMethods = ObjEnvMethodsNew(e);
    e->funcEnvMethods = FuncEnvMethodsNew(e);
    e->globalEnvMethods = GlobalEnvMethodsNew(e);
    e->currentContext = NULL;
    if(createContext)
        e->currentContext = ContextNew(e, NULL, NULL, FALSE);
    e->loadingTasks = TaskQueueNew(e, "LoadingTasks");
    e->promiseTasks = TaskQueueNew(e, "PromiseTasks");
}


void hcountvused(void* item, void* data) {
    Val* v = (Val*) item;
    if(v->type == TYPE_FREE)
        return;
    int* pi = (int*) data;
    (*pi)++;
}

void hcountoused(void* item, void* data) {
    Object* o = (Object*) item;
    char* p = (char*) item;
    p -= sizeof(mitem);    
    if(o->flags == OBJ_FREE)
        return;
    int* pi = (int*) data;
    (*pi)++;
}

void hcount(void* item, void* data) {
    int* pi = (int*) data;
    (*pi)++;
}

void hvprint(void* item, void* data) {
    Val* v = (Val*) item;
    if(v->type == TYPE_FREE)
        return;
    Js* e = (Js*) data;

#ifdef DEBUG_MEMORY
    char* p = (char*) item;
    p -= sizeof(mitem);
    mitem* mi = (mitem*) p;
    ValPrint(e, v, 0, -1);
    jprintf(e, 0, " line: %d\n", mi->line);
#else
    vpl(e, v);    
#endif
}

void hoprint(void* item, void* data) {
    Object* o = (Object*) item;
    if(o->flags == OBJ_FREE)
        return;
    char* p = (char*) item;
    p -= sizeof(mitem);
#ifdef DEBUG_MEMORY
    mitem* mi = (mitem*) p;
#endif
    Js* e = (Js*) data;
    jprintf(e, 0, " object(0x%x)", o);
    // ObjectPrint(e, o, 0);
#ifdef DEBUG_MEMORY
    jprintf(e, 0, " line: %d\n", mi->line);
#else
    jprintf(e, 0, "\n");
#endif
}


void hprintvalues(Js* e) {
    // print any leaked values
    hiter(e->memory[VA].data, hvprint, e);
    // print value heap summary
    int all = 0;
    int used = 0;
    heap* h = e->memory[VA].data;
    hiter(h, hcount, &all);
    hiter(h, hcountvused, &used);
    printf("values [delta: %d, blocks:%d, alloc:%d, used:%d]\n",h->allocs, h->blocks->count, all, used);
}

void hprintobjects(Js* e) {
    // print any leaked objects
    hiter(e->memory[OB].data, hoprint, e);
    int all = 0;
    int used = 0;
    // print object heap summary
    heap* h = e->memory[OB].data;
    hiter(h, hcount, &all);
    hiter(h, hcountoused, &used);
    int delta = h->allocs;
    printf("objects [delta: %d, blocks:%d, alloc:%d, used:%d]\n", delta, h->blocks->count, all, used);
}

#ifdef DEBUG_MEMORY
void JsPrintLeaked(void* item, void* ctx) {
    char* pi = (char*) item;
    pi -= sizeof(mitem);
    mitem* mi = (mitem*) pi;
    char* name = (char*) ctx;
    if(mi->line) {
        printf("%s leaked on line: %d %lx\n", name, mi->line, (long int) item);
    }
}
#endif


int JsMemCheck(Js* e, int level) {
    int total = 0;
    for(int i=0; i < HEAPS; i++) {
        typeheap* th = &e->memory[i];
        total += th->data->allocs;
        if(th->data->allocs && level > 1) {
            jprintf(e, 0, "%s %d leaks\n", th->name, th->data->allocs);
#ifdef DEBUG_MEMORY
            if(level > 2)
                hiter(th->data, JsPrintLeaked, th->name);
#endif            
        }
    }

    if(e->options.memory && level > 2) {
        for(int i=0; i < HEAPS; i++) {
            heap* h = e->memory[i].data;
            int blocks = (h->blocks) ? h->blocks->count : 0;
            jprintf(e, 0, "%-16s: %d blocks\n", e->memory[i].name, blocks);
        }
    }
    return total;
}

int JsClear(Js* e) {
    Object* root = NULL;
    if(e->currentContext && e->currentContext->realm)
        root = e->currentContext->realm->globalThis->obj;

    ContextDelete(e, e->currentContext);
    TaskQueueDel(e, e->loadingTasks);
    TaskQueueDel(e, e->promiseTasks);
    JsFreeSymbols(e);
    CtagsDel(e);
    StrmapDel(e, e->keywords);
    ValDel(e, e->strLength);
    ValDel(e, e->strEmpty);
    ValDel(e, e->strCallee);
    ValDel(e, e->strCaller);
    ValDel(e, e->strArguments);
    
    ValDel(e, e->strGetPrototypeOf);
    ValDel(e, e->strSetPrototypeOf);
    ValDel(e, e->strIsExtensible);
    ValDel(e, e->strPreventExtensions);
    ValDel(e, e->strGetOwnPropertyDescriptor);
    ValDel(e, e->strDefineProperty);
    ValDel(e, e->strHas);
    ValDel(e, e->strGet);
    ValDel(e, e->strSet);
    ValDel(e, e->strDeleteProperty);
    ValDel(e, e->strEnumerate);
    ValDel(e, e->strOwnKeys);
    ValDel(e, e->strApply);
    ValDel(e, e->strConstruct);
    ValDel(e, e->strNext);
    ValDel(e, e->strZero);
    ValDel(e, e->strOne);
    ValDel(e, e->strFrozen);
    ValDel(e, e->strName);
    ValDel(e, e->strThrow);
    ValDel(e, e->strReturn);
    ValDel(e, e->strSealed);
    ValDel(e, e->strPrototype);
    ValDel(e, e->strMessage);
    
    gc(e, root);

    // We must delete these after GC since there might be objects collected
    // with [[Environment]] properties which would cause vtables
    // to be called to destruct .. etc.
    DeclEnvMethodsDel(e, e->declEnvMethods);
    ObjEnvMethodsDel(e, e->objEnvMethods);
    FuncEnvMethodsDel(e, e->funcEnvMethods);
    GlobalEnvMethodsDel(e, e->globalEnvMethods);
    
    int leaks = JsMemCheck(e, 3);

    for(int i = 0; i < HEAPS; i++) {
        hdel(e->memory[i].data);        
    }
    _free(e->memory);    
    return leaks;
}

void JsColors(Js* e, int on) {
    if(on) {
        e->colors.normal = "\x1B[0m";
        e->colors.red = "\x1B[31m";
        e->colors.green = "\x1B[32m";
        e->colors.yellow = "\x1B[33m";
        e->colors.blue = "\x1B[34m";
        e->colors.magenta = "\x1B[35m";
        e->colors.cyan = "\x1B[36m";
        e->colors.white = "\x1B[37m";
    }
    else {
        e->colors.normal = "";
        e->colors.red = "";
        e->colors.green = "";
        e->colors.yellow = "";
        e->colors.blue = "";
        e->colors.magenta = "";
        e->colors.cyan = "";
        e->colors.white = "";
    }
}

void JsCreateSymbols(Js* e) {
    e->hasInstance = ValNewSymbol(e,"Symbol.hasInstance");
    e->isConcatSpreadable = ValNewSymbol(e, "Symbol.isConcatSpreadable");
    e->species = ValNewSymbol(e, "Symbol.species");
    e->match = ValNewSymbol(e, "Symbol.match");
    e->replace = ValNewSymbol(e, "Symbol.replace");
    e->isRegExp = ValNewSymbol(e, "Symbol.isRegExp");
    e->iterator = ValNewSymbol(e, "Symbol.iterator");
    e->toPrimitive = ValNewSymbol(e, "Symbol.toPrimitive");
    e->toStringTag = ValNewSymbol(e, "Symbol.toStringTag");
    e->unscopables = ValNewSymbol(e, "Symbol.unscopables");
    e->prototype = ValNewStrA(e, "prototype");
    e->search = ValNewSymbol(e, "Symbol.search");
    e->split = ValNewSymbol(e, "Symbol.split");
}

void JsFreeSymbols(Js* e) {
    ValDel(e, e->hasInstance);
    ValDel(e, e->isConcatSpreadable);
    ValDel(e, e->species);
    ValDel(e, e->match);
    ValDel(e, e->replace);
    ValDel(e, e->isRegExp);
    ValDel(e, e->iterator);
    ValDel(e, e->toPrimitive);
    ValDel(e, e->toStringTag);
    ValDel(e, e->unscopables);
    ValDel(e, e->prototype);
    ValDel(e, e->search);
    ValDel(e, e->split);
}


///////// String 
Str* StrNewLength(Js* e, int len) {
    Str* s = _hallocsize(e->memory[XX].data, sizeof(Str) + sizeof(uchar)*len, __LINE__);
    s->length = len;
    return s;
}

void StrDel(Js* e, Str* s) {
    hfree(e->memory[XX].data, s);
}

Str* StrNewChars(Js* e, char* c) {
    int len = (int) strlen(c);
    Str* s = StrNewLength(e, len);
    for(int i=0; i < len; i++)
        s->chars[i] = c[i];
    return s;
}

Str* StrFromUChars(Js* e, uchar* chars) {
    int len = 0;
    uchar* p = chars;
    while(*p++)
        len++;
    Str* s = StrNewLength(e, len);
    p = chars;
    uchar* d = s->chars;
    while(*p) 
        *d++ = *p++;
    return s;
}

uchar* UCharsFromStr(Js* e, Str* s) {
    uchar* chars = _hallocsize(e->memory[ST].data, sizeof(uchar)*(s->length+1), __LINE__);
    uchar* sp = s->chars;
    uchar* dp = chars;
    for(int i=0; i < s->length; i++)
        *dp++ = *sp++;
    *dp = 0;
    return chars;
}

void UCharsDel(Js* e, uchar* chars) {
    hfree(e->memory[ST].data, chars);
}

bool_t StrEqChars(Js* e, Str* str, char* c) {
    int i =0;
    for(uchar* ucp = str->chars; i < str->length; i++, ucp++) {
        if(!*c)
            return FALSE;
        if(*c != (char) *ucp)
            return FALSE;
        c++;
    }
    
    if(*c == 0 && i == str->length)
        return TRUE;
    return FALSE;
}

bool_t StrEqStr(Js* e, Str* s1, Str* s2) {
    if(s1->length != s2->length)
        return FALSE;

    uchar* u1 = s1->chars, *u2 = s2->chars;
    for(int i=0; i < s1->length; i++) {
        if(*u1 != *u2)
            return FALSE;
        u1++;
        u2++;
    }
    return TRUE;
}

char* StrGetChars(Js* e, Str* s) {
    char* c = _hallocsize(e->memory[ST].data, s->length+1, __LINE__);
    uchar* uc = s->chars;
    char* ret = c;
    for(int i=0; i < s->length; i++) {
        *c++ = (char) *uc++;
    }
    *c = 0;
    return ret;
}


Str* StrClone(Js* e, Str* s) {
    Str* s2 = StrNewLength(e, s->length);
    uchar* ud = s2->chars;
    uchar* us = s->chars;
    for(int i=0; i < s->length; i++)
        *ud++ = *us++;
    return s2;
}

bool_t StrPrefix(Js* e, Str* s1, Str* s2) {
    if(s1->length > s2->length)
        return FALSE;
    uchar* u1 = s1->chars;
    uchar* u2 = s2->chars;
    for(int i=0; i < s1->length; i++) {
        if(*u1 != *u2)
            return FALSE;
    }
    return TRUE;
}

void StrPrint(Js* e, Str* s) {
    char* chars = StrDecode(e, s);
    jprintf(e,0,"%s", chars);
    hfree(e->memory[ST].data, chars);
}

void StrPrintLn(Js* e, Str* s) {
    StrPrint(e, s);
    jprintf(e,0,"\n");
}

uint32 StrSize(Js* e, Str* s) {
    return s->length*sizeof(uchar) + sizeof(struct StrTag);
}

uint32 StrLen(Js* e, Str* s) {
    return s->length;
}

char* StrDecodeNoEscape(Js* e, Str* s) {
    int total = s->length + 1;
    char* ret = _hallocsize(e->memory[ST].data, total, __LINE__);
    for(int i=0; i < s->length; i++) {
        ret[i] = s->chars[i];
    }
    ret[s->length] = 0;
    return ret;
}

char* StrDecode(Js* e, Str* s) {
    // compute count of characters needing escape
    int countEscape2 = 0;
    int countEscape6 = 0;
    int countRegular = 0;
    for(int i=0; i < s->length; i++) {
        uchar c = s->chars[i];
        if(c == '\n' || c == '\r' || c == '\t')
            countEscape2++;
        else if(c == '\0' || c > 255)
            countEscape6++;    
        else
            countRegular++;
    }

    int total = countRegular + countEscape6*6 + countEscape2*2 + 1;
    char* ret = _hallocsize(e->memory[ST].data, total, __LINE__);
    int retIndex = 0;
    for(int i=0; i < s->length; i++) {
        uchar c = s->chars[i];
        if(c == '\n') {
            ret[retIndex++] = '\\';
            ret[retIndex++] = 'n';
        }
        else if (c == '\r') {
            ret[retIndex++] = '\\';
            ret[retIndex++] = 'r';
        }
        else if ( c == '\t') {
            ret[retIndex++] = '\\';
            ret[retIndex++] = 't';            
        }
        else if(c == '\0' || c > 255) {
            sprintf(ret + retIndex, "\\u%04x", c);
            retIndex += 6;
        }
        else {
            ret[retIndex++] = c;
        }
    }
    ret[retIndex] = '\0';
    return ret;
}

uchar UCharLower(uchar c) {
    if(c >= 'A' && c <= 'Z')
        return ((c - 'A') + 'a');
    return c;
}

bool_t StrStr(Js* e, Str* s1, Str* s2, uint32 flags) {
    int l1 = StrLen(e, s1);
    int l2 = StrLen(e, s2);
    if(l2 > l1)
        return FALSE;
    for(int i1 = 0; i1 < l1; i1++) {
        uchar* c1 = s1->chars+i1;
        uchar* c2 = s2->chars;


        int i2;
        for(i2 = 0; i2 < l2; i2++) {
            if(i2 + i1 > l1)
                return FALSE;

            uchar ch1 = c1[i2];
            uchar ch2 = c2[i2];
            if(flags & MATCH_NO_CASE) {
                ch1 = UCharLower(ch1);
                ch2 = UCharLower(ch2);
            }            
            if(ch1 != ch2)
                break;
        }
        
        if(i2 == l2)
            return TRUE;
    }
    return FALSE;
}



////////// DynStr
DynStr* _DynStrNew(Js* e, int capacity, int line) {
    DynStr* ds = (DynStr*) _halloc(e->memory[DS].data, line);
    ds->capacity = capacity;
    ds->current = 0;
    ds->str = StrNewLength(e, capacity);
    ds->str->length = 0;
    return ds;
}

void DynStrClear(Js* e, DynStr* ds) {
    ds->str->length = 0;
    ds->current = 0;
}

void DynStrAdd(Js* e, DynStr* ds, uchar c) {
    int len = ds->str->length;
    if(len >= ds->capacity) {
        ds->capacity *= 2;
        Str* s2 = StrNewLength(e, ds->capacity);
        s2->length = len;
        memcpy(&s2->chars[0], &ds->str->chars[0], len*sizeof(uchar));
        Str* ts = ds->str;
        ds->str = s2;
        StrDel(e, ts);
    }
    ds->str->chars[ds->str->length++] = c;
}

void DynStrAddStr(Js* e, DynStr* ds, Str* s) {
    // @todo: This is inefficient
    for(int i=0; i < s->length; i++) {
        DynStrAdd(e, ds, s->chars[i]);
    }
}

void DynStrAddStrA(Js* e, DynStr* ds, char* s) {
    while(*s)
        DynStrAdd(e, ds, (uchar) *s++);
}

void DynStrDel(Js* e, DynStr* ds) {
    if(ds->str)
        StrDel(e, ds->str);
    hfree(e->memory[DS].data, ds);
}

Str* DynStrGet(Js* e, DynStr* ds) {
    return ds->str;
}

int DynStrIndex(Js* e, DynStr* ds) {
    return ds->str->length;
}

void DynStrWriteA(Js* e, DynStr* ds, char* s, int count) {
    for(int i=0; i < count; i++)
        DynStrAdd(e, ds, (uchar) *s++);
}

int DynStrReadA(Js* e, DynStr* ds, char* buffer, int count) {
    int read = 0;
    if(ds->current >= ds->str->length)
        return read;

    for(read = 0; ds->current < ds->str->length && read < count; read++) {
        uchar uc = ds->str->chars[ds->current];
        *buffer++ = (char) uc;
        ds->current++;
    }
    return read;
}

void DynStrReset(Js* e, DynStr* ds) {
    ds->current = 0;
}

///////////////

Realm* CurrentRealm(Js* e) {
    assert(e->currentContext);
    return e->currentContext->realm;
}


///////// Val
void ValInit(Val* v) {
    v->type = TYPE_UNDEF;
}

void ValInitNum(Val* v, number n) {
    v->type = TYPE_NUM;
    v->num = n;
}

// string not allowed to be null
void ValInitStrA(Js* e, Val* v, char* s) {
    assert(s);
    v->type = TYPE_STR;
    v->str = StrNewChars(e, s);
}

void ValInitSymbol(Js* e, Val* v, char* s) {
    v->type = TYPE_SYMA;
    v->descA = s;
}


void ValInitRef(Js* e, Val* v, Ref* r) {
    v->type = TYPE_REF;
    v->Ref = r;
}

void ValInitComp(Js* e, Val* v, Completion* c) {
    v->type = TYPE_COMP;
    v->completion = c;
}


void ValInitNull(Val* v) {
    v->type = TYPE_NULL;
}

void ValInitBool(Val* v, bool_t b) {
    v->type = TYPE_BOOL;
    v->b = b;
}

void ValClear(Js* e, Val* v) {
    switch(v->type) {
        case TYPE_BLOCK:
            v->block->refs--;
            if(v->block->refs <= 0)
                DataDel(e, v->block);
            break;
        case TYPE_DATA:
            hfree(e->memory[DA].data, v->ptr);
            break;
        case TYPE_STR:
            StrDel(e, v->str);
            break;
        case TYPE_SYMA:
            break;
        case TYPE_REF:
            RefDelete(e, v->Ref);
            break;
        case TYPE_COMP:
            CompDel(e, v->completion);
            break;
        case TYPE_OBJ:
            Release(e, v->obj);
            break;
        case TYPE_LEX:
            LexEnvRelease(e, v->lex);
            break;
        case TYPE_REALM:
            RealmRelease(e, v->realm);
            break;
        case TYPE_DESC:
            PropDel(e, v->desc);
            break;
        case TYPE_LIST:
            ListDel(e, v->list);
            break;
    }
    v->type = TYPE_UNDEF;
}

bool_t ValIsPrimitive(Val* v) {
    int t = v->type;
    return (t != TYPE_OBJ && t != TYPE_ENV && t != TYPE_REF
            && t != TYPE_PTR && t != TYPE_LEX && t != TYPE_DATA && t != TYPE_BLOCK);
}

bool_t ValIsObject(Val* v) {
    return (v && v->type == TYPE_OBJ);
}

bool_t ValIsNull(Val* v) {
    return (v == NULL || v->type == TYPE_NULL);
}

bool_t ValIsUndef(Val* v) {
    return (v == NULL || v->type == TYPE_UNDEF);
}

bool_t ValIsTrueDel(Js* e, Val* v) {
    bool_t ret = FALSE;
    if(v->type == TYPE_BOOL && v->b)
        ret = TRUE;
    ValDel(e, v);
    return ret;
}

bool_t ValIsNumDel(Js* e, Val* v, number n) {
    bool_t ret = FALSE;

    if(v->type == TYPE_NUM && v->num == n)
        ret = TRUE;

    if(v->type == TYPE_NUM && isnan(v->num) && isnan(n))
        ret = TRUE;
    
    if(v->type == TYPE_COMP && v->completion->value->type == TYPE_NUM &&
        v->completion->value->num == n)
        ret = TRUE;

    ValDel(e, v);
    return ret;
}

bool_t ValIsNum(Js* e, Val* v, number n) {
    bool_t ret = FALSE;
    if(v->type == TYPE_NUM && v->num == n)
        ret = TRUE;
    return ret;
}

bool_t ValIsStrADel(Js* e, Val* v, char* c) {
    bool_t ret = ValEqStrA(e, v, c);
    ValDel(e, v);
    return ret;
}

bool_t ValIsNullDel(Js* e, Val* v) {
    bool_t ret = FALSE;
    if(v->type == TYPE_NULL)
        ret =TRUE;
    ValDel(e, v);
    return ret;
}

bool_t ValIsTrue(Js* e, Val* v) {
    if(!v)
        return FALSE;
    bool_t ret = FALSE;
    if(v->type == TYPE_BOOL && v->b)
        ret = TRUE;
    return ret;
}

bool_t ValEqStrA(Js* e, Val* v, char* s) {
    if(!v) return FALSE;
    if(v->type == TYPE_STR)
        return (StrEqChars(e, v->str, s));
    if(v->type == TYPE_SYMA)
        return (v->descA == s);
    return FALSE;
}

bool_t ValIsAbrupt(Js* e, Val* v) {
    if(!v)
        return FALSE;
    if(v->type != TYPE_COMP)
        return FALSE;
    return CompIsAbrupt(e, (Completion*) v->completion);
}

bool_t ValIsException(Js* e, Val* v) {
    if(v->type == TYPE_COMP && v->completion->type == COMP_THROW)
        return TRUE;
    return FALSE;
}

bool_t VallAllEq(Js* e, Val* v1, Val* v2) {
    if(!v1 && !v2)
        return TRUE;
    
    if(v1->type != v2->type)
        return FALSE;
    
    switch(v1->type) {
        case TYPE_BOOL:
            return (v1->b == v2->b);
        case TYPE_UNDEF:
        case TYPE_NULL:
            return TRUE;
        case TYPE_NUM:
            return(v1->num == v2->num);
        case TYPE_OBJ:
            return (v1->obj == v2->obj);
        case TYPE_STR:
            return (StrEqStr(e, v1->str, v2->str));
        case TYPE_SYMA:
            return (v1->descA ==  v2->descA);
        case TYPE_REF:
            return (v1->Ref == v2->Ref);
        case TYPE_COMP:
            return (v1->completion == v2->completion);
        case TYPE_ENV:
            return (v1->env == v2->env);
        case TYPE_LEX:
            return (v1->lex == v2->lex);
        case TYPE_DESC:
            return PropEq(e, v1->desc, v2->desc);
    }
    return FALSE;
}

void ValCompPrint(Js* e, Val* v) {
    jprintf(e,0,"[completion:");
    Completion* c = v->completion;
    switch(c->type) {
        case COMP_NORMAL:
            jprintf(e,0,"normal] ");
            break;
        case COMP_RETURN:
            jprintf(e,0,"return] ");
            break;
        case COMP_BREAK:
            jprintf(e,0,"break] ");
            break;
        case COMP_CONTINUE:
            jprintf(e,0,"continue] ");
            break;
        case COMP_THROW:
            jprintf(e,0,"throw] ");
            break;
    }
    ValPrint(e, c->value, FALSE,-1);
}

void ValPrintLn(Js* e, char* prefix, Val* v, bool_t detail) {
    if(!v) return;
    if(e->options.quiet)
        return;
    jprintf(e,0,"%s ", prefix);
    ValPrint(e, v, detail,-1);
    jprintf(e,0,"\n");
}

void vpl(Js* e, Val* v) {
    return ValPrintLn(e, "v:", v,1);
}

bool_t isneg(number n);

void ValPrint(Js* e, Val* v, bool_t detail, int line) {
    if(!v)
        return;
    if(e->options.quiet)
        return;

    if(line > 0) {
        jprintf(e, 0, "%s%d ", e->colors.cyan, line);
    }
    switch(v->type) {
        case TYPE_FREE:
            jprintf(e,0,"%sfree", e->colors.red);
            break;
        case TYPE_BOOL:
            jprintf(e,0,"%s%s", e->colors.cyan, (v->b) ? "true" : "false");
            break;
        case TYPE_UNDEF:
            jprintf(e,0,"%sundefined", e->colors.cyan);
            break;
        case TYPE_NULL:
            jprintf(e,0,"%snull", e->colors.cyan);
            break;
        case TYPE_NUM: {
                Val* s = ToString(e, v);
                jprintf(e,0,"%s", e->colors.green);
                StrPrint(e, s->str);
                ValDel(e, s);
            }
            break;
        case TYPE_OBJ:
            ObjectPrint(e, v->obj, detail);
            break;
        case TYPE_STR:
            jprintf(e, 0, "%s", e->colors.red);
            StrPrint(e, v->str);
            break;
        case TYPE_SYMA:
        {
            if(!v->descA) jprintf(e,0,"<null>");
            else {
                jprintf(e,0,"%s\'%s\'", e->colors.blue, v->descA);
            }
        }
        break;
        case TYPE_REF:
            jprintf(e,0,"[reference]");
            break;
        case TYPE_COMP:
            ValCompPrint(e, v);
            break;
        case TYPE_LEX:
            jprintf(e,0,"[lex]");
            return;
        case TYPE_ENV:
            jprintf(e,0,"[Env]");
            break;
        case TYPE_DESC:
            jprintf(e,0,"[desc]");
            break; 
        case TYPE_LIST:
            jprintf(e,0,"[List]");
            break;
        case TYPE_PTR:
            jprintf(e,0,"[ptr]");
            break;
        case TYPE_DATA:
            jprintf(e,0,"[data]");
            break;
        case TYPE_BLOCK:
            jprintf(e,0, "[block]");
            break;
        
    }

    jprintf(e,0,"%s", e->colors.normal);
}


Val* _ValNew(Js* e, int line) {
    Val* v = _halloc(e->memory[VA].data, line);
    ValInit(v);
    return v;
}
Val* ValNewDesc(Js* e) {
    Val* v = ValNew(e);
    Property* p = PropNew(e);
    v->type = TYPE_DESC;
    v->desc = p;
    return v;
}

Val* ValNewList(Js* e, List* l) {
    Val* v = ValNew(e);
    v->type = TYPE_LIST;
    v->list = l;
    return v;
}

Val* ValNewListEmpty(Js* e) {
    List* l = ListNew(e);
    return ValNewList(e, l);
}

Val* _ValNewNum(Js* e, number n, int line) {
    Val* v = _ValNew(e, line);
    ValInitNum(v, n);
    return v;
}

Val* ValNewStr(Js* e, Str* s) {
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = StrClone(e, s);
    return v;
}

Str* StrAddCharUChar(Js* e, char* d, Str* s) {
    size_t sl = StrLen(e, s);
    size_t dl = strlen(d);
    Str* uc = StrNewLength(e, (int) sl+ (int) dl);
    uchar* cp = uc->chars;
    uchar* sp = cp;
    while(*d) {
        *cp++ = *sp++;
    }
    cp = uc->chars + dl;
    for(int i=0; i < sl; i++) {
        *cp++ = *sp++;
    }
    return uc;
}

Str* StrAddCharChar(Js* e, char* d, char* s) {
    size_t sl = strlen(s);
    size_t dl = strlen(d);
    Str* uc = StrNewLength(e, (int) sl+ (int) dl);
    uchar* cp = uc->chars;
    while(*d) {
        *cp++ = *s++;
    }
    cp = uc->chars + dl;
    while(*s) {
        *cp++ = *s++;
    }
    return uc;
}

Str* StrAddUCharChar(Js* e, Str* d, char* s) {
    size_t sl = strlen(s);
    size_t dl = StrLen(e, d);

    Str* retStr = StrNewLength(e, (int) sl+ (int) dl);
    uchar* retChars = retStr->chars;
    uchar* sc = d->chars;
    for(int i=0; i < dl; i++) {
        *retChars++ = *sc++;
    }
    while(*s) {
        *retChars++ = *s++;
    }
    return retStr;
}

Str* StrAddUCharUChar(Js* e, Str* d, Str* s) {
    size_t sl = StrLen(e, s);
    size_t dl = StrLen(e, d);
    Str* uc = StrNewLength(e, (int) sl+ (int) dl);
    uchar* cp = uc->chars;
    uchar* sp = d->chars;
    for(int i=0; i < dl; i++) {
        *cp++ = *sp++;
    }
    sp = s->chars;
    for(int i=0; i < sl; i++) {
        *cp++ = *sp++;
    }
    return uc;
}

Val* ValAddStr(Js* e, Val* d, Val* s, bool_t del_d) {
    Str* uc;
    
    if(s->type == TYPE_SYMA && d->type == TYPE_SYMA)
        uc = StrAddCharChar(e, d->descA, s->descA);
    else if(s->type == TYPE_SYMA && d->type == TYPE_STR)
        uc = StrAddUCharChar(e, d->str, s->descA);
    else if(s->type == TYPE_STR && d->type == TYPE_SYMA)
        uc = StrAddCharUChar(e, d->descA, s->str);
    else if(s->type == TYPE_STR && d->type == TYPE_STR)
        uc = StrAddUCharUChar(e, d->str, s->str);
    else
        assert(FALSE);
    
    Val* ret = ValNewStr(e, uc);
    StrDel(e, uc);
    if(del_d) ValDel(e, d);
    return ret;
}

Val* ValAddStrA(Js* e, Val* d, char* s, bool_t del_d) {
    Str* uc;
    if(d->type == TYPE_SYMA)
        uc = StrAddCharChar(e, d->descA, s);
    else
        uc = StrAddUCharChar(e, d->str, s);
    Val* ret = ValNew(e);
    ret->type = TYPE_STR;
    ret->str = uc;
    if(del_d) ValDel(e, d);
    return ret;
}

Val* ValNewStrA(Js* e, char* s) {
    Val* v = ValNew(e);
    ValInitStrA(e, v, s);
    return v;
}

Val* ValNewSymbol(Js* e, char* s) {
    Val* v = ValNew(e);
    ValInitSymbol(e, v, s);
    return v;
}

Val* _ValNewObject(Js* e, int line) {
    Val* v = _ValNew(e, line);
    Object* o = _ObjectNew(e, line);
    v->type = TYPE_OBJ;
    v->obj = o;
    return v;
}

Val* ValNewRealm(Js* e, Realm* r) {
    Val* v = ValNew(e);
    v->type = TYPE_REALM;
    v->realm = r;
    RealmRetain(e, r);
    return v;
}

Val* ValNewEnv(Js* e, Env* ev) {
    Val* r = ValNew(e);
    r->type = TYPE_ENV;
    r->env = ev;
    return r;
}

Val* ValNewLex(Js* e, LexEnv* ev) {
    Val* r = ValNew(e);
    r->type = TYPE_LEX;
    r->lex = ev;
    return r;
}

Val* _ValNewPtr(Js* e, void* p, int line) {
    Val* v = _ValNew(e, line);
    v->type = TYPE_PTR;
    v->ptr = p;
    return v;
}

Val* ValNewData(Js* e, int size) {
    Val* v = ValNew(e);
    v->type = TYPE_DATA;
    v->ptr = _hallocsize(e->memory[DA].data, size, __LINE__);
    return v;
}

Val* ValNewRef(Js* e, Ref* r) {
    Val* v = ValNew(e);
    ValInitRef(e, v, r);
    return v;
}

Val* ValNewRefA(Js* e, Val* b, char* n, bool_t s, Val* tv) {
    Val* un = ValNewStrA(e, n);
    Val* ret = ValNewRefU(e, b, un, s, tv);
    ValDel(e, un);
    return ret;
}

Val* ValNewRefU(Js* e, Val* b, Val* n, bool_t s, Val* tv) {
    Ref* r = RefNew(e, b, n, s, tv);
    return ValNewRef(e, r);
}


Val* _ValNewComp(Js* e, Completion* c, int line) {
    Val* v = _ValNew(e, line);
    ValInitComp(e, v, c);
    return v;
}

Val* _ValNewCompA(Js* e, int type, Val* v, char* label, int line) {
    Val* ul = NULL;
    if(label)
        ul =  ValNewStrA(e, label); // StrNewChars(e, label);
    Val* ret = _ValNewCompU(e, type, v, ul, line);
    if(label)
        ValDel(e, ul);
    return ret;
}

Val* _ValNewCompU(Js* e, int type, Val* v, Val* label, int line) {
    Completion* c = CompNew(e, type, v, label);
    return _ValNewComp(e, c, line);
}


Val* _ValNewNull(Js* e, int line) {
    Val* v = _ValNew(e, line);
    ValInitNull(v);
    return v;
}

Val* _ValNewBool(Js* e, bool_t b, int line) {
    Val* v = _ValNew(e, line);
    ValInitBool(v, b);
    return v;
}

void ValDel(Js* e, Val* v) {
    if(!v) return;
    
    // @todo: *** FIX ***
    if(v->type == TYPE_FREE) {
        jprintf(e, 0, "[warning] value already free\n");
        return;
    }
    
    assert(v->type != TYPE_FREE);
    ValClear(e, v);
    v->type = TYPE_FREE;
    hfree(e->memory[VA].data, v);
}


void ValSet(Js* e, Val* dest, Val* src) {
    ValClear(e, dest);
    
    if(!src) return;
    
    dest->type = src->type;
    
    switch(src->type) {
        case TYPE_BOOL:
            dest->b = src->b;
            break;
        case TYPE_NULL:
            break;
        case TYPE_NUM:
            dest->num = src->num;
            break;
        case TYPE_OBJ:
            dest->obj = src->obj;
            Retain(e, src->obj);
            break;
        case TYPE_REALM:
            dest->realm = src->realm;
            RealmRetain(e, src->realm);
            break;
        case TYPE_STR:
            dest->str = StrClone(e, src->str);
            break;
        case TYPE_SYMA:
            dest->descA = src->descA;
            break;
        case TYPE_REF:
            {
                Ref* r = (Ref*) src->Ref;
                dest->Ref = RefNew(e, r->base, r->name, r->strict, r->thisValue);
            }
            break;
        case TYPE_COMP:
            {
                Completion* c = (Completion*) src->completion;
                dest->completion = CompNew(e, c->type, c->value, c->target);
            }
            break;
        case TYPE_ENV:
            dest->env = src->env;
            break;
        case TYPE_LEX:
            dest->lex = src->lex;
            LexEnvRetain(e, src->lex);
            break;
        case TYPE_UNDEF:
            break;
        case TYPE_DESC:
            dest->desc = PropClone(e, src->desc);
            break;
        case TYPE_PTR:
            dest->ptr = src->ptr;
            break;
        case TYPE_LIST:
            dest->list = ListClone(e, src->list);
            break;
        case TYPE_BLOCK:
            dest->block = src->block;
            src->block->refs++;
            break;
        default:
            assert(FALSE);
            break;
    }
}

void ValAssign(Js* e, Val** dest, Val* src) {
    if(*dest)
        ValDel(e, *dest);
    *dest = ValClone(e, src);
}

Val* _ValClone(Js* e, Val* v, int line) {
    if(!v)
        return NULL;
    Val *ret = _ValNew(e, line);
    ValSet(e, ret, v);
    return ret;
}
////////// SymbolEntry
Val* SymbolEntryNew(Js* e, Str* str) {
    Str* clone = StrClone(e, str);
    Str** se = halloc(e->memory[SE].data);
    *se = clone;
    return ValNewSymbol(e, (char*) clone);
}

Val* SymbolEntryNewA(Js* e, char* str) {
    Str* clone = StrNewChars(e, str);
     Str** se = halloc(e->memory[SE].data);
    *se = clone;
    return ValNewSymbol(e, (char*) clone);
}

void SymbolEntryDel(void* item, void* ctx) {
    Str** se = (Str**) item;
    Js* e = (Js*) ctx;
    StrDel(e, *se);
    *se = NULL;
    hfree(e->memory[SE].data, item);
}

void SymbolEntryClear(Js* e) {
    hiter(e->memory[SE].data, SymbolEntryDel, e);
}


////////// Vector

Vector* _VectorNew(Js *e, int capacity, int size, float growth, int line) {
    Vector* da = (Vector*) _hallocsize(e->memory[DA].data, sizeof(Vector), line);
    da->count = 0;
    da->capacity = capacity;
    da->size = size;
    da->growth = growth;
    da->data = _hallocsize(e->memory[XX].data, capacity * size, line);
    da->reallocs = 0;
    return da;
}


void* VectorGet(Js* e, Vector* da, int index) {
    if(!da)
        return NULL;
    
    Vector* d = (Vector*) da;
    
    if(index < 0 || index >= d->count)
        return NULL;
    
    return &d->data[index* d->size];
}

void* VectorInsert(Js* e, Vector* da, void* Item, int offset) {
    if(!da)
        return NULL;
    
    Vector* d = (Vector*) da;
    
    if(d->count >= d->capacity) {
        float fcap = ((float) d->capacity) * d->growth;
        int icap = (int) fcap;
        d->capacity = icap;
        d->data = realloc(d->data, d->capacity * d->size);
        d->reallocs++;
    }
    
    char* data = &d->data[d->size*d->count];
    memcpy(data + offset, Item, d->size - offset);
    d->count++;
    return data;
}

void VectorRemove(Js* e, Vector* d, int index) {
    if(!d)
        return;
    
    int max = d->count - 1;
    if(index >= max) {
        d->count--;
        return;
    }

    char* target = &d->data[d->size*index];
    char* source = &d->data[d->size*(index+1)];
    memcpy(target, source, d->size);
    d->count--;
}

// @todo: Do something more efficient
void VectorAppend(Js* e, Vector* d, Vector* s, bool_t delS) {
    int count = s->count;
    for(int i=0; i < count; i++) {
        VectorInsert(e, d, VectorGet(e, s, i),0);
    }
    if(delS)
        VectorDel(e, s);
}

void VectorReset(Js* e, Vector* da) {
    if(!da)
        return;
    
    Vector* d = (Vector*) da;
    
    d->count = 0;
}

void VectorPut(Js* e, Vector* da, int index, void* Item) {
    if(!da)
        return;
    
    Vector* d = (Vector*) da;
    
    if(index >= d->count) {
        return;
    }
    
    void* data = &d->data[index * d->size];
    memcpy(data, Item, d->size);
}


// @todo: this is somewhat dangerous, but VectorInsertMulti only takes
//        multiples (count) of a given size (2 in this case)
//        and we need to account for the size of the StrTag header
//        size
void VectorInsertStr(Js* e, Vector* da, Str* s) {
    uint32 count = sizeof(struct StrTag) / sizeof(uchar) + s->length;
    VectorInsertMulti(e, da, count, s);
}

void VectorInsertMulti(Js* e, Vector* da, int count, void* items) {
    if(!da || !items)
        return;
    
    
    Vector* d = (Vector*) da;
    if( d->count + count >= d->capacity) {
        float fcap = ((float) (d->capacity + count)) * d->growth;
        int icap = (int) fcap;
        d->capacity = icap;
        d->data = realloc(d->data, d->capacity * d->size);
        d->reallocs++;
    }

    memcpy(&d->data[d->size*d->count], items, d->size*count);
    d->count += count;
}

int VectorCount(Js* e, Vector* da) {
    if(!da)
        return 0;
    Vector* d = (Vector*) da;
    return d->count;
}

int VectorGetReallocCount(Js* e, Vector* da) {
    if(!da)
        return 0;
    
    Vector* d = (Vector*) da;
    return d->reallocs;
}

void VectorDel(Js* e, Vector* da) {
    if(!da)
        return;
    Vector* d = (Vector*) da;
    hfree(e->memory[XX].data, d->data);
    hfree(e->memory[DA].data, d);
}

Str* VectorNextStr(Js* e, Vector* da, Str* start) {
    if(!da)
        return NULL;
    
    Vector* d = (Vector*) da;
    
    if(start == NULL)
        return (Str*) d->data;
    
    char* next = (char*) start + StrSize(e, start);
    char* end = d->data + d->count * d->size;
    
    if(next >= end)
        return NULL;
    
    return (Str*) next;
}


/////// vec
vec* vec_new(int capacity, int size, float growth) {
    vec* v = (vec*) _malloc(sizeof(vec));
    v->count = 0;
    v->capacity = capacity;
    v->size = size;
    v->growth = growth;
    v->data = _malloc(capacity * size);
    memset(v->data, 0, capacity*size);
    v->reallocs = 0;
    return v;
}

void* vec_get(vec* v, int index) {
    return &v->data[index* v->size];
}

void* vec_add(vec* d) {
    if(d->count >= d->capacity) {
        float fcap = ((float) d->capacity) * d->growth;
        int icap = (int) fcap;
        d->capacity = icap;
        d->data = realloc(d->data, d->capacity * d->size);
        d->reallocs++;
    }
    
    char* data = &d->data[d->size*d->count];
    d->count++;
    return data;
}

void vec_del(vec* da) {
    _free(da->data);
    _free(da);
}

heap* hnew(int blockCap, uint32 itemSize) {
    heap* h = (heap*) _malloc(sizeof(heap));

    h->allocs = 0;
    if(blockCap == 0) {
        h->item_size = itemSize;
        h->block_cap = 0;
        h->blocks = 0;
        h->next_free = NULL;
        return h;
    }

    // Add memory item header to size
    itemSize += sizeof(mitem);

    // Start with one block vector
    h->blocks = vec_new(10, sizeof(vec*), 2.0);
    // A block is a vector that does not grow so we can provide
    // stable pointers back to callers
    vec* block = vec_new(blockCap, itemSize, 0);
    vec** pblock = vec_add(h->blocks);
    *pblock = block;
    h->next_free = NULL;
    h->item_size = itemSize;
    h->block_cap = blockCap;
    return h;
}

void hdel(heap* h) {
    if(h->blocks) {
        // Loop over all blocks and deleted each block
        for(int i=0; i < h->blocks->count; i++) {
            vec** pblock = vec_get(h->blocks, i);
            vec_del(*pblock);
        }
        // Then delete the blocks vector
        vec_del(h->blocks);
    }
    _free(h);
}

void* _hallocsize(heap* h, int size, int line) {
    assert(h->block_cap == 0);
    h->allocs++;
    return _malloc(size);
}

void* _halloc(heap* h, int line) {
    mitem* mi = NULL;
    h->allocs++;
    if(h->block_cap == 0)
        return _malloc(h->item_size);

    // if we have a next_free, return it after rewiring
    if(h->next_free) {
        mi = (mitem*) h->next_free;
        h->next_free = mi->next_free;
        goto exit;
    }

    // Now loop over all blocks looking for a block with available storage
    for(int i=0; i < h->blocks->count; i++) {
        vec** pblock = vec_get(h->blocks, i);
        vec* block = *pblock;
        if(block->count < block->capacity) {
            mi = vec_add(block);
            goto exit;
        }
    }

    // We do not have enough blocks, must allocate a new block
    vec* block = vec_new(h->block_cap, h->item_size, 0);
    vec** pblock = vec_add(h->blocks);
    *pblock = block;
    mi = vec_add(block);
exit:    
#ifdef DEBUG_MEMORY
    mi->line = line;
#endif    
    mi->next_free = NULL;
     char* ptr = (char*) mi;
    return ptr + sizeof(mitem);           
}

void hfree(heap* h, void* item) {
    char* p = (char*) item;
    h->allocs--;
    assert(h->allocs >= 0);
    if(h->block_cap == 0) {
        _free(item);
        return;
    }
    p -= sizeof(mitem);
    mitem* mi = (mitem*) p;
#ifdef DEBUG_MEMORY
    mi->line = 0;
#endif    
    mi->next_free = h->next_free;
    h->next_free = mi;
}

// typedef void (*hiterfunc)(void* item);
void hiter(heap* h, hiterfunc fn, void* ctx) {
    if(!h->blocks)
        return;
    for(int i=0; i < h->blocks->count; i++) {
        vec** pblock = vec_get(h->blocks, i);
        vec* block = *pblock;
        for(int j=0; j < block->count; j++) {
            mitem* mi = vec_get(block, j);
            char* p = (char*) mi;
            p += sizeof(mitem);
            fn(p, ctx);
        }
    }    
}

Object* gcobjval(Val* v) {
    if(!v) return NULL;
    if(v->type == TYPE_REF && v->Ref->base->type == TYPE_OBJ)
        return v->Ref->base->obj;
    if(v->type == TYPE_COMP && v->completion->value->type == TYPE_OBJ)
        return v->completion->value->obj;    
    if(v->type != TYPE_OBJ)
        return NULL;
    return v->obj;
}


// delete any makred objects, unmark marked objects
void gcsweep(void* item, void* ctx) {
    Object* o = (Object*) item;
    Js* e = (Js*) ctx;
    if(!MARKED(o) && ALLOCATED(o)) {
//        printf("collecting %d\n", ID(o));
        ObjectDelete(e, o);
    }
    UNMARK(o);
}

void gcpush(vec* v, Object* o) {
    MARK(o);
    Object** x = vec_add(v);
    *x = o;
}

Object* gcpop(vec* v) {
    assert(v->count > 0);
    Object** x = vec_get(v, v->count-1);
    v->count--;
    return *x;
}


void gc(Js* e, Object* root) {
    if(!root) {
        if(e && e->currentContext && e->currentContext->realm)
            root = e->currentContext->realm->globalThis->obj;

        if(!root) {
            hiter(e->memory[OB].data, gcsweep, e);
            return;
        }
    }
    // Create a stack to use to push all objects that are reachable
    vec* stack = vec_new(100, sizeof(Object*), 2);      
    gcpush(stack, root);
    MARK(root);

    while(TRUE) {
        if(stack->count == 0)
            break;

        // pop top of stack
        Object* current = (Object*) gcpop(stack);

        // Loop over all properties and push any reachable object properties
        for(Property* p = current->properties; p; p = p->next) {
            Object* target =  gcobjval(p->value);
            // Note can't push marked objects since this causes an infinite amount
            // of pushing on the gcheap stack
            if(target && !MARKED(target)) {
                gcpush(stack, target);
            }

            // Make sure to mark setter and getter function objects
            if(p->value == NULL) {
                if(p->get && !MARKED(p->get->obj))
                    gcpush(stack, p->get->obj);

                if(p->set && !MARKED(p->set->obj))
                    gcpush(stack, p->set->obj);
            }
        }

        // Also mark the prototype of this reachable object
        Val* p = current->prototype;
        if(p && p->type == TYPE_OBJ && !MARKED(p->obj)) {
            gcpush(stack, p->obj);
        }

        // Loop over all slots and push any reachable object properties
        for(Property* p = current->slots; p; p = p->next) {
            Object* target =  gcobjval(p->value);
            // Note can't push marked objects since this causes an infinite amount
            // of pushing on the gcheap stack
            if(target && !MARKED(target)) {
                gcpush(stack, target);
            }
        }

    }

    vec_del(stack);

    // Delete any objects not marked
    hiter(e->memory[OB].data, gcsweep, e);
}

/////////// Ctags
number StringCompare(Js* e, Str* x, Str* y);
bool_t CtagLt(Js* e, ctag* t1, ctag* t2) {
    return (StringCompare(e, t1->name, t2->name) < 0);
}

void CtagsDel(Js* e) {
    for(ctag* t = e->ctags; t; ) {
        StrDel(e, t->name);
        StrDel(e, t->file);
        StrDel(e, t->grep);
        ctag* n = t->next;
        hfree(e->memory[CT].data, t);
        t = n;
    }
    e->ctags = 0;
}

void CtagsAddFunction(Js* e, Parser* p, int nameToken, int endToken) {
    if(!e->options.genTags)
        return;

    Tokenizer* tk = p->tk;
    // Create the tag
    ctag* t = halloc(e->memory[CT].data);

    // Establish the name
    int ns = TkGetTokOffset(e, tk, nameToken);
    int nl = TkGetTokLen(e, tk, nameToken);
    t->name = StrNewLength(e, nl);
    for(int i=0; i < nl; i++) 
        t->name->chars[i] = tk->input[ns+i];

    // Establish the file
    t->file = StrNewChars(e, p->fileName);

    // Establish the grep
    int line = TkGetTokLine(e, tk, endToken);
    int gst = TkGetLineStartTok(e, tk, line);
    int gs = TkGetTokOffset(e, tk, gst);
    int ge = TkGetTokOffset(e, tk, endToken) + TkGetTokLen(e, tk, endToken);
    int gl = ge - gs;
    t->grep = StrNewLength(e, gl);
    for(int i=0; i < gl; i++)
        t->grep->chars[i] = tk->input[gs + i];
    t->next = NULL;
    // Sort insert into ctags list
    if(!e->ctags) {
        e->ctags = t;
        return;
    }
    ctag* prev = NULL;
    for(ctag* x = e->ctags; x; x = x->next) {
        if(CtagLt(e, x, t)) {
            prev = x;
            continue;
        }

        if(!prev) {
            t->next = e->ctags;
            e->ctags = t;
            return;
        }
        t->next = prev->next;
        prev->next = t;
        return;
    }
    prev->next = t;

}

void fprintstr(FILE* fp, Str* s) {
    for(int i=0; i < s->length; i++) 
        fputc(s->chars[i], fp);
}

void CtagsPrint(Js* e, FILE* out) {
    const char* TAB = "\t";
    Str* PREFIX = StrNewChars(e, "/^");
    Str* SUFFIX = StrNewChars(e, "/;\"");
    for(ctag* t = e->ctags; t; t = t->next) {
        fprintstr(out, t->name);
        fprintf(out, "%s", TAB);
        fprintstr(out, t->file);
        fprintf(out, "%s", TAB);
        fprintstr(out, PREFIX);
        fprintstr(out, t->grep);
        fprintstr(out, SUFFIX);
        fprintf(out, "\n");
    }
    StrDel(e, PREFIX);
    StrDel(e, SUFFIX);
}

/////////// Strmap


Strmap* StrmapNew(Js* e, int keyCapacity, int valCapacity, int size, float growth) {
    Strmap* sm = _halloc(e->memory[SM].data, sizeof(Strmap));
    memset(sm->hash, 0, sizeof(Strmap));
    sm->capacity = valCapacity;
    
    // Add the size of an int (to index into the key strings) to each Item
    sm->size = size + sizeof(int);
    sm->growth = growth;
    
    sm->keys = VectorNew(e, keyCapacity, sizeof(uchar), 2.0);
    return (Strmap*) sm;
}


int StrmapHash(Js* e, Str* key);
int StrmapHash(Js* e, Str* key) {
    int hash = 0;
    uchar* p = key->chars;

    for(int i=0; i < key->length; i++) {
        hash += *p++;
    }
    
    hash = hash % STRING_MAP_HASH_MAX;
    return hash;
}

void* StrmapGetA(Js* e, Strmap* sm, char* key) {
    Str* ku = StrNewChars(e, key);
    void* ret = StrmapGet(e, sm, ku);
    StrDel(e, ku);
    return ret;
}

void* StrmapGet(Js* e, Strmap* sm, Str* key) {
    if(!key)
        return NULL;
    
    int hash = StrmapHash(e, key);
    Strmap* s = (Strmap*) sm;
    if(!s)
        return NULL;
    // if(!s->hash)
    //     return NULL;
    Vector* da = s->hash[hash];
    if(da == NULL) {
        return NULL;
    }

    int count = VectorCount(e, da);
    for(int c = 0; c < count; c++) {
        int* ip = VectorGet(e, da, c);
        Str* sp = VectorGet(e, s->keys, *ip);
        if(StrEqStr(e, sp, key)) {
            return (ip + 1);
        }
    }
    return NULL;
}

void StrmapPutA(Js* e, Strmap* sm, char* key, void* Val) {
    Str* ukey = StrNewChars(e, key);
    StrmapPut(e, sm, ukey, Val);
    StrDel(e, ukey);
}

void StrmapPut(Js* e, Strmap* sm, Str* key, void* Val) {
    int hash = StrmapHash(e, key);
    Strmap* s = (Strmap*) sm;
    
    Vector* da = s->hash[hash];
    if(da == NULL) {
        da = VectorNew(e, s->capacity, s->size, s->growth);
        s->hash[hash] = da;
    }
    int index = VectorCount(e, s->keys) ;
    VectorInsertStr(e, s->keys, key);
    int* ip = VectorInsert(e, da, Val, sizeof(int));
    *ip = index;    
    return;
}

void StrmapDel(Js* e, Strmap* sm) {
    Strmap* s = (Strmap*) sm;
    
    for(int h = 0; h < STRING_MAP_HASH_MAX; h++) {
        if(s->hash[h]) {
            VectorDel(e, s->hash[h]);
        }
    }
    
    VectorDel(e, s->keys);
    hfree(e->memory[SM].data, sm );
}

void StrmapReset(Js* e, Strmap* sm) {
    Strmap* s = (Strmap*) sm;
    
    VectorReset(e, s->keys);
    for(int h = 0; h < STRING_MAP_HASH_MAX; h++) {
        if(s->hash[h]) {
            VectorReset(e, s->hash[h]);
        }
    }
}

int StrmapGetReallocCount(Js* e, Strmap* sm) {
    Strmap* s = (Strmap*) sm;
    
    VectorReset(e, s->keys);
    int count = 0;
    for(int h = 0; h < STRING_MAP_HASH_MAX; h++) {
        if(s->hash[h]) {
            count += VectorGetReallocCount(e, s->hash[h]);
        }
    }
    return count;
}

void StrmapMatch(Js* e, Strmap* sm, Str* substring, Vector* List, uint32 flags) {
    Strmap* s = (Strmap*) sm;
    for(int h = 0; h < STRING_MAP_HASH_MAX; h++) {
        if(s->hash[h]) {
            int ic = VectorCount(e, s->hash[h]);
            for(int c = 0; c < ic; c++) {
                int* ip = VectorGet(e, s->hash[h], c);
                if(!ip) continue;   // @todo
                Str* sp = VectorGet(e, s->keys, *ip);
                if(!sp) continue;
                if(StrStr(e, sp, substring, flags)) {
                    VectorInsertStr(e, List, sp);
                }
            }
        }
    }
}


/////////// Tokenizer

// Advance current by N characters
void TkAdvance(Js* e, Tokenizer* tk, int n) {
    tk->current += n;
    tk->column += n;
}

// Mark start of a new line
void TkNextLine(Js* e, Tokenizer* tk) {
    if(tk->column > tk->maxWidth) {
        tk->maxWidth = tk->column;
        tk->widestLine = tk->line;
    }
    tk->line++;
    
    int line = tk->line - 1;
    if(line >= 0) {
        Line* previous = VectorGet(e, tk->lines, line); // xxxx line-1);
        previous->length = tk->current - previous->location;
    }
    Line tl;
    tl.location = tk->current;
    tl.first = -1;
    tl.last = -1;
    VectorInsert(e, tk->lines, &tl, 0);
    
    tk->column = 0;
}

// Start a new word
void TkNewWord(Js* e, Tokenizer* tk) {
    DynStrClear(e, tk->word);
    tk->wordCol = tk->column;
    tk->offset = tk->current;
}

// Set current error
int TkSetError(Js* e, Tokenizer* tk, char* sz, int line, int column) {
    // sprintf(tk->error, "%s line: %d column: %d", sz, line, column);
    strcpy(tk->error, sz);
    tk->errorLine = line;
    tk->errorCol = column;

    if(e->debugLevel == DEBUG_LEVEL_TOKENIZE)
        jprintf(e,0,"%s\n", tk->error);
    return 1;
}

// Start to _tokenize
void TkBegin(Js* e, Tokenizer* tk, uchar* inp, int index, int length) {
    tk->scriptIndex = index;
    tk->maxWidth = -1;
    tk->widestLine = -1;
    tk->widestToken = 0;

    VectorReset(e, tk->tokens);
    VectorReset(e, tk->strings);
    VectorReset(e, tk->lines);
    StrmapReset(e, tk->identifiers);
    
    
    tk->error[0] = '\0';

    tk->input = inp;

    tk->current = 0;
    tk->column = 0;
    tk->line = 0;
    TkNewWord(e, tk);
    
    // This is NOT needed and will cause problems when being called with 
    // a legal string of length 0
    // if(length == 0) {
    //     uchar* c = inp;
    //     while(*c) {
    //         length++;
    //         c++;
    //     }
    // }
        
    tk->max = length;
    
    // Add the starting data to line 0 only if we have input (or colorizer to habdle EOF)
    if(*inp || tk->colorizer) {
        Line tl;
        tl.location = 0;
        tl.first = 0;
        tl.last = 0;
        VectorInsert(e, tk->lines, &tl, 0);
    }
    return;
}

// Returns true if the character is a space
int TkIsSpace(Tokenizer* tk, uchar c) {
    if(tk && tk->jsonMode) {
        if( c == 0x9)
            return 1;
        if( c == TOK_BOM || c == 0xa0)
            return 0;
        
        if(c >= 0x00 && c <= 0x1f && c != 0x9)
            return 0;
    }
    switch(c)
    {
    case    TOK_BOM:
    case    0x9:
    case    0xb:
    case    0xc:
    case    0x20:
    case    0xa0:
    case    0xd:

    // Unicode USP characters
    case    0x1680:
    case    0x2000:
    case    0x2001:
    case    0x2002:
    case    0x2003:
    case    0x2004:
    case    0x2005:
    case    0x2006:
    case    0x2007:
    case    0x2008:
    case    0x2009:
    case    0x200A:
    case    0x202F:
        return 1;
    case    0x205F:
    case    0x3000:
        if(tk && tk->colorizer)
            return 0;
        return 1;
    // case    0x2028:
    // case    0x2029:
        return 1;
    case    TOK_ZWJ:    // 0x200D -- Craig: 9/26/14 - handle zwj characters in strings in the tokenizer
    case    TOK_ZWNJ:   // 0x200C -- Craig: 9/26/14 - handle zwnj characters in strings in the tokenizer
        if(tk && tk->colorizer)
            return 1;
        return 0;
    }
    
    // This is fixing a problem where a bogus
    // character is getting into the stream
//    if( c < 0 )
//        return 1;
    
    return 0;
}

// Skip spaces
int TkTokenizeSpace(Js* e, Tokenizer* tk) {
    uchar c;
    c = tk->input[tk->current];
    if(!TkIsSpace(tk, c))
        return 0;

    while(TkIsSpace(tk, c) && tk->current < tk->max)
    {
        // Colorizer generates TOK_TAB instead of simply skipping
        if(tk->colorizer && c == 0x9) {
            TkAddTok(e, tk, TOK_TAB, tk->line, tk->column, tk->current, tk->current+1);
        }
        TkAdvance(e, tk, 1);
        if(tk->current >= tk->max)
            break;
        c = tk->input[tk->current];
    }
    return 1;
}

// Returns true if the character is a legal word start
int TkIsWordStart(uchar c) {
    if(TkIsAlpha(c))
        return 1;

    if(c == '_' || c == '$')
        return 1;

    return 0;
}

int TkHasError(Js* e, Tokenizer* tk) {
    return (tk->error[0] != '\0');
}

// Returns 1 if the character is a legal word character
int TkIsWordChar(uchar c) {
    if(TkIsWordStart(c) || TkIsNum(c))
        return 1;
    switch(c) {
        case TOK_ZWJ:
        case TOK_ZWNJ:
            return 1;
    }
    return 0;
}

// Returns 1 if a punctuator
int TkIsPuncSolo(uchar c) {
    switch(c)
    {
        // 2012-01-21 shark@anui.com added '(' and ')' to handle (v>10)&&(x<20) 
        case '(':
        case ')':

        case    '[':
        case    ']':
        //            case    '^':
        //            case    '%':
        case    '.':
        case    '}':
        case    '{':
            return 1;
    }
    return 0;
}

// Returns 1 if it terminates a punctuator
int TkIsPuncTerm(uchar c) {
    switch(c)
    {
    case    '=':
    case    '>':
    case    '<':
    case    '+':
    case    '-':
    case    '|':
    case    '&':
        return 0;
    }
    return 1;
}

// Returns 1 if line terminator
int TkIsLineTerm(uchar c) {
    switch(c) {
        case    0xd:
        case    0x2028:
        case    0x2029:
        case    0xa:
        return 1;
    }
    return 0;
}

// Returns 1 if a hex digit
int TkIsOctDigit(uchar c) {
    return (c >= '0' && c <= '7');
}

// Returns 1 if a hex digit
int TkIsHexDigit(uchar c) {
    if(TkIsNum(c))
        return 1;

    if(c >= 'A' && c <= 'F')
        return 1;

    if(c >= 'a' && c <= 'f')
        return 1;

    return 0;
}

// Returns 1 if a binary digit
int TkIsBinDigit(uchar c) {
    return (c == '0' || c == '1');
}

// Returns 1 if alpha character
int TkIsAlpha(uchar c) {
    if( (c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z'))
        return 1;
    return 0;
}

// Returns 1 if string delimiter
int TkIsStrDelim(uchar c) {
    if(c == '\'' || c == '\"')
        return 1;
    return 0;
}

// Returns 1 if number / decimal
int TkIsNum(uchar ch) {
    if(ch >= '0' && ch <= '9')
        return 1;
    return 0;
}

// Returns 1 if alpha numeric
int TkIsAlNum(uchar c) {
    if(TkIsNum(c) || TkIsAlpha(c))
        return 1;
    return 0;
}

// Get hex Val of character
uchar TkHexVal(uchar c) {
    if(c >= 'a' && c <= 'f')
        c = 10 + (c - 'a');
    else if(c >= 'A' && c <= 'F')
        c = 10 + (c - 'A');
    else if(c >= '0' && c <= '9')
        c = c - '0';
    return c;
}

// Returns 1 if string is an identifier
int TkIsIdentifier(Str* s) {
    uchar c = s->chars[0];
    
    if(!TkIsWordStart(c))
        return 0;

    for(int l=1 ; l < s->length ; l++)
    {
        c = s->chars[l];
        if(!TkIsWordChar(c))
            return 0;
    }
    return 1;
}

// Add other type _tok
Token* TkAddTok(Js* e, Tokenizer* tk, int type, int line, int col, int start, int end) {
    Token t;
    
    t.line = line;
    t.location = start;
    t.length = end - start;
    if(t.length > tk->widestToken)
        tk->widestToken = t.length;
    t.type = type;
    t.column = col;
    t.string = -1;
    t.raw = -1;
    t.flags = 0;
    
    // Update line information
// xxxxxxx    line--;
    int tidx = VectorCount(e, tk->tokens);
    
    Line* tl = VectorGet(e, tk->lines, line);
    
    // If we don't have a tl, we need to add one (means we're
    // second tokenize on an initial empty string)
    if(!tl) {
        Line l;
        l.location = 0;
        l.first = 0;
        l.last = 0;
        VectorInsert(e, tk->lines, &l, 0);
        tl = VectorGet(e, tk->lines, line);
    }
    if(tl->first < 0) {
        tl->first = tidx;
    }
    tl->last = tidx;
    
    Token* ret = VectorInsert(e, tk->tokens, &t, 0);

    if(e->debugLevel == DEBUG_LEVEL_TOKENIZE) {
        TkPrintToken(e, tk, tidx, TRUE);
        jprintf(e,0,"\n");
    }
    return ret;
}

// Tokenize inner (comment or string literal) spaces
int TkTokenizeInnerSpace(Js* e, int type, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    while(c && TkIsSpace(tk, c)) {
        TkAdvance(e, tk, 1);
        c = tk->input[tk->current];
    }
    return 0;
}

// Tokenize inner (comment or string literal) word
int TkTokenizeInnerWord(Js* e, int type, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    if(!TkIsWordStart(c))
        return 0;
    
    TkNewWord(e, tk);
    while(c && TkIsWordChar(c)) {
        TkAddToWord(e, tk, c);
        TkAdvance(e, tk, 1);
        c = tk->input[tk->current];
    }
    TkAddTok(e, tk, type, tk->line, tk->wordCol, tk->offset, tk->current);
    return 1;
}

// Tokenize inner (comment or string literal) line term
int TkTokenizeInnerLineTerm(Js* e, int type, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    if(TkIsLineTerm(c)) {
        return TkTokenizeLineTerm(e, tk);
    }
    return 0;
}

// Tokenize inner (comment or string literal) number
int TkTokenizeInnerNum(Js* e, int type, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    if(!TkIsNum(c))
        return 0;
    
    TkNewWord(e, tk);
    while(c && TkIsNum(c)) {
        TkAddToWord(e, tk, c);
        TkAdvance(e, tk, 1);
        c = tk->input[tk->current];
    }
    TkAddTok(e, tk, type, tk->line, tk->wordCol, tk->offset, tk->current);
    return 1;
}

int TkTokenizeInnerPunct(Tokenizer* tk, uchar c) {
    if(TkIsNum(c))
        return FALSE;
    if(TkIsWordChar(c))
        return FALSE;
    if(TkIsLineTerm(c))
        return FALSE;
    if(TkIsSpace(tk, c))
        return FALSE;
    return TRUE;
}

// Tokenize inner (comment or string literal) other
int TkTokenizeInnerOther(Js* e, int type, Tokenizer* tk, uchar ignore) {
    uchar c = tk->input[tk->current];
    
    // special case '\' where we always advance 2 and then return
    // this is to make it easier to deal with string literal escapes
    if(c == '\\') {
        TkNewWord(e, tk);
        TkAdvance(e, tk, 1);
        c = tk->input[tk->current];
        if(c) {
            TkAddToWord(e, tk, c);
            TkAdvance(e, tk, 1);
        }
        TkAddTok(e, tk, type, tk->line, tk->wordCol, tk->offset, tk->current);
        return 1;
    }
    
    if(!TkTokenizeInnerPunct(tk, c) || c == ignore)
        return 0;
    
    TkNewWord(e, tk);
    while(tk->current < tk->max && TkTokenizeInnerPunct(tk, c) && c != ignore && c != '\\') {
        TkAddToWord(e, tk, c);
        TkAdvance(e, tk, 1);
        if(tk->current < tk->max)
            c = tk->input[tk->current];
    }
    TkAddTok(e, tk, type, tk->line, tk->wordCol, tk->offset, tk->current);
    return 1;
}

// Tokenize comments into word chunks (colorizer only)
int TkTokenizeCommentColor(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];

    if(c == '/' && tk->input[tk->current+1] == '/') {
        TkNewWord(e, tk);
        TkAddToWord(e, tk, '/');
        TkAddToWord(e, tk, '/');
        TkAdvance(e, tk, 2);
        TkAddTok(e, tk, TOK_COMMENT, tk->line, tk->wordCol, tk->offset, tk->current);
        
        while(tk->current < tk->max) {
            TkTokenizeInnerSpace(e, TOK_COMMENT, tk);
            
            if(TkTokenizeInnerLineTerm(e, TOK_COMMENT, tk)) {
               return 1;
            }
            
            if(TkTokenizeInnerWord(e, TOK_COMMENT, tk))
                continue;

            if(TkTokenizeInnerNum(e, TOK_COMMENT, tk))
                continue;
            
            TkTokenizeInnerOther(e, TOK_COMMENT, tk,0);
        }
        return 1;
    }

    if(c == '/' && tk->input[tk->current+1] == '*') {
        TkNewWord(e, tk);
        TkAddToWord(e, tk, '/');
        TkAddToWord(e, tk, '*');
        TkAdvance(e, tk, 2);
        TkAddTok(e, tk, TOK_COMMENT, tk->line, tk->wordCol, tk->offset, tk->current);
        
        while(tk->current < tk->max) {
            TkTokenizeInnerSpace(e, TOK_COMMENT, tk);

            if(TkTokenizeInnerLineTerm(e, TOK_COMMENT, tk))
                continue;
            
            c = tk->input[tk->current];
            if(c == '*') {
                if(tk->input[tk->current+1] == '/') {
                    TkNewWord(e, tk);
                    TkAddToWord(e, tk, '/');
                    TkAddToWord(e, tk, '*');
                    TkAdvance(e, tk, 2);
                    TkAddTok(e, tk, TOK_COMMENT, tk->line, tk->wordCol, tk->offset, tk->current);
                    return 1;
                }
                else {
                    // #52 hang if we have a comment /**
                    TkNewWord(e, tk);
                    TkAdvance(e, tk, 1);
                    TkAddToWord(e, tk, c);
                    TkAddTok(e, tk, TOK_COMMENT, tk->line, tk->wordCol, tk->offset, tk->current);
                    continue;
                }
            }
    
            if(TkTokenizeInnerWord(e, TOK_COMMENT, tk))
                continue;

            if(TkTokenizeInnerNum(e, TOK_COMMENT, tk))
                continue;;

            TkTokenizeInnerOther(e, TOK_COMMENT, tk, '*');
        }
        return TkSetError(e, tk, "Unterminated comment", tk->line, tk->column);
    }
    return 0;
}


// Return 1 if we _tokenized a comment
int TkTokenizeComment(Js* e, Tokenizer* tk) {
    if(tk->colorizer)
        return TkTokenizeCommentColor(e, tk);
    
    uchar c = tk->input[tk->current];

    if(c == '/' && tk->input[tk->current+1] == '/') {
        TkNewWord(e, tk);
        TkAdvance(e, tk, 2);

        while(tk->current < tk->max) {
            c = tk->input[tk->current];
            TkAdvance(e, tk, 1);
            if(TkIsLineTerm(c)) {
                // TkNextLine(e, tk);
                // Always add a LINETERM
                // Rewind
                tk->current--;
                return TkTokenizeLineTerm(e, tk);
            }
        }

        return 1;       // The LINETERM will be inserted by the tokenizer for end of file
    }

    if(c == '/' && tk->input[tk->current+1] == '*') {
        TkNewWord(e, tk);
        TkAdvance(e, tk, 2);
        bool_t hasLineTerm = FALSE;
        while(tk->current < tk->max) {
            c = tk->input[tk->current];
            if(TkIsLineTerm(c)) {
                if(!hasLineTerm) {
                    hasLineTerm = TRUE;
                    TkTokenizeLineTerm(e, tk);
                }
                else
                    TkNextLine(e, tk);
            }

            if(c == '*' && tk->input[tk->current+1] == '/') {
                TkAdvance(e, tk, 2);
                return 1;
            }
            TkAdvance(e, tk, 1);
        }
        
        return TkSetError(e, tk, "Unterminated comment", tk->line, tk->column);
    }

    return 0;
}

int TkTokenizeLineTerm(Js* e, Tokenizer* tk) {
    uchar c;
    c = tk->input[tk->current];

    if(tk->jsonMode &&  ( c == 0x2028 || c == 0x2029))
        return 0;
    
    if(!TkIsLineTerm(c))
        return 0;

    TkNewWord(e, tk);                  // Must advance offset
    while(TkIsLineTerm(c) && tk->current < tk->max)
    {
        TkAddTok(e, tk, TOK_LINETERM, tk->line, tk->wordCol, tk->offset, tk->offset+1);

        if(c == 0x0a && tk->current < (tk->max-1) && tk->input[tk->current+1] == 0xd) {
            TkAdvance(e, tk,1);
        }
        TkAdvance(e, tk, 1);                 // advance first so that column resets back to 1
        
        // increment the offset here so we don't Put the line term _tok at the wrong offset
        tk->offset++;
        TkNextLine(e, tk);
        if(tk->current >= tk->max)
            break;
        c = tk->input[tk->current];
    }
    return 1;
}

int TkIsNumConstPrefix(uchar c) {
    return (c == '-' || c == '+');
}

int TkAddToWord(Js* e, Tokenizer*tk, uchar c) {
    DynStrAdd(e, tk->word, c);
    return 1;
}

double TkNumFromOct(Str* word) {
    unsigned int n;
    uchar* p = word->chars;
    uchar c;
    int start = 0;

    // skip leading 0b if present
    if(p[0] == '0' && (p[1] == 'o' || p[1] == 'O')) {
        p += 2;
        start = 2;
    }
    
    n = 0;
    for(int i=start; i < word->length; i++) {
        c = *p;
        n = (n << 3) + (c - '0');
        p++;
    }
    return (double) n;
}

double TkNumFromBin(Str* word) {
    unsigned int n;
    uchar* p = word->chars;
    uchar c;
    int start = 0;

    // skip leading 0b if present
    if(p[0] == '0' && (p[1] == 'b' || p[1] == 'B')) {
        p += 2;
        start = 2;
    }
    
    n = 0;
    for(int i=start; i < word->length; i++) {
        c = *p;
        n = (n << 1) + (c - '0');
        p++;
    }
    return (double) n;
}

double TkNumFromHex(Str* word) {
    unsigned int n;

    uchar* p = word->chars;
    uchar c;
    int start = 0;

    // 20131026 mohsen@anui.com - skip leading 0x if present
    if(p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
        p += 2;
        start = 2;
    }
    
    n = 0;

    for(int i=start; i < word->length; i++) {
        c = *p;

        if(c >= 'a' && c <= 'f') {
            n = 16*n + (c - 'a' + 10);
        }

        if(c >= 'A' && c <= 'F') {
            n = 16*n + (c - 'A' + 10);
        }

        if(c >= '0' && c <= '9') {
            n = 16*n + (c - '0');
        }
        p++;

    }

    return (double) n;
}

double TkNumFromWord(Str* word) {
    double mult = 10.0;
    double res = 0.0;
    uchar* p = word->chars;
    
    for(int i=0; i < word->length; i++) {
        uchar c = *p;

        // handle nnn.xxxe+zzz
        if(c == 'e' || c == 'E') {
            double ten = 0;
            double ns = 1;
            
            p++;
            i++;
            
            mult = 1;
            if(*p == '+') {
                p++;
                i++;
            }
            else if(*p == '-') {
                ns = -1;
                p++;
                i++;
            }
            
            for(int j=i; j < word->length; j++) {
                c = *p;
                int xxx = c;
                ten = ten*mult + (double) (xxx - '0');
                mult *= 10;
                p++;
                i = j;
            }
            
            ten *= ns;
            double n =  res * pow(10, ten);
            return n;
        }

        if(c == '.') {
            long double frac = 0;
            mult = 1;
            p++;
            for(int j=i+1; j < word->length && *p != 'e' && *p != 'E'; j++)
            {
                c = *p;
                double F = (double) (c - '0');
                frac = frac * 10.0;
                frac = frac + F;
                mult *= 10;
                p++;
                i = j;
            }
        
            double n = res + frac / mult;
            
            res = n;        // must be have exponent
            continue;
        }

        if(c >= 0 && c <= '9')
        {
            res = res * mult + (double) (c - '0');
        }
        p++;
    }
    return res;
}

int TkIsNumOp(Token* t) {
    if(t->type == TOK_LINETERM)
        return 1;
        
    if(t->type != TOK_KEYWORD)
        return 0;
        
    switch(t->keyword) {
         case id_gte:
         case id_eqeq:
         case id_ne:
         case id_eqeqeq:
         case id_neqeq:

         case id_plus:
         case id_minus:
         case id_mult:
         case id_mod:

         case id_lshift:
         case id_rshift:
         case id_rshifta:
         case id_and:
         case id_or:
         case id_caret:

         case id_not:
         case id_tilde:
         case id_andand:
         case id_oror:

         case id_eq:
         case id_pluseq:
         case id_minuseq:
         case id_multeq:
         case id_modeq:
         case id_lshifteq:

         case id_rshifteq:
         case id_rshiftaeq:
         case id_andeq:
         case id_oreq:
         case id_careteq:

         case id_div:
         case id_diveq:
         case id_comma:
         case id_lbracket:
            return 1;
    }
    return 0;
}

int TkTokenizeNum(Js* e, Tokenizer* tk) {
    uchar c;
    c = tk->input[tk->current];
    int hasPrefix = 0;             // true if prefix '+' or '-' present
    uint32 flags = 0;

    // Hex number
    if(c=='0')
    {
        uchar c2 = tk->input[tk->current+1];
        if(c2 == 'x' || c2 == 'X') {
            TkNewWord(e, tk);
            flags |= TF_NUM_HEX;
            // 20131026 mohsen@anui.com - need to add the 0x to the word otherwise the editor
            // gets confused. TkNumFromHex should ignore the leading 0x
            TkAddToWord(e, tk, '0');
            TkAddToWord(e, tk, c2);
            int start = tk->offset;
            
            TkAdvance(e, tk, 2);
            c = tk->input[tk->current];
            while(TkIsHexDigit(c) && tk->current < tk->max) {
                TkAddToWord(e, tk, c);
                TkAdvance(e, tk, 1);
                c = tk->input[tk->current];
            }
            
            double n = TkNumFromHex(DynStrGet(e, tk->word));
            
            // 20131026 mohsen@anui.com - see above, use the '0x' at the start and end at tk->current
            // used to be tk->offset + tk->wordIndex);
            Token* t = TkAddTok(e, tk, TOK_NUMLIT, tk->line, tk->wordCol, start, tk->current);
            t->Val = n;
            t->flags |= flags;
            return 1;
        }
        if(c2 == 'b' || c2 == 'B') {
            flags |= TF_NUM_BIN;
            TkNewWord(e, tk);
            TkAddToWord(e, tk, '0');
            TkAddToWord(e, tk, c2);
            int start = tk->offset;
            TkAdvance(e, tk, 2);
            c = tk->input[tk->current];
            while(TkIsBinDigit(c) && tk->current < tk->max) {
                TkAddToWord(e, tk, c);
                TkAdvance(e, tk, 1);
                if(tk->current >= tk->max) break;
                c = tk->input[tk->current];
            }
            
            double n = TkNumFromBin(DynStrGet(e, tk->word));
            Token* t = TkAddTok(e, tk, TOK_NUMLIT, tk->line, tk->wordCol, start, tk->current);
            t->Val = n;
            t->flags |= flags;
            return 1;
        }
        if(c2 == 'o' || c2 == 'O') {
            flags |= TF_NUM_OCT;
            TkNewWord(e, tk);
            TkAddToWord(e, tk, '0');
            TkAddToWord(e, tk, c2);
            int start = tk->offset;
            TkAdvance(e, tk, 2);
            c = tk->input[tk->current];
            while(TkIsOctDigit(c) && tk->current < tk->max) {
                TkAddToWord(e, tk, c);
                TkAdvance(e, tk, 1);
                c = tk->input[tk->current];
            }
            
            double n = TkNumFromOct(DynStrGet(e, tk->word));
            Token* t = TkAddTok(e, tk, TOK_NUMLIT, tk->line, tk->wordCol, start, tk->current);
            t->Val = n;
            t->flags |= flags;
            return 1;
        }


    }

    // mohsena 20110120 - allow for '-' prefix for numlit
    // mohsena 20110306 - allow for '-<literal>' not to be confused with numlit
    // shark@anui.com - 2011-11-13 - support '+' prefix in addition to '-'
    double mult = 1.0;
    if(TkIsNumConstPrefix(c) && tk->current < tk->max && TkIsNum(tk->input[tk->current+1]))
    {
        // shark@anui.com 2011-11-12 - only treat negative numbers as constants
        // if preceeded by *, +, -, /, %
        int tcount = VectorCount(e, tk->tokens);
        if(tcount > 0) {
            Token* last = VectorGet(e, tk->tokens, tcount-1); //  &tk->tokens[tcount - 1];
            if(TkIsNumOp(last)) {
                hasPrefix = 1;
                TkAdvance(e, tk, 1);
                mult = (c == '-') ? -1.0 : 1.0;
                c = tk->input[tk->current];
            }
        }
    }

    int hasDot = 0;
    int hasExp = 0;
    if(c == '.') {
        if(tk->current < tk->max-1) {
            if(!TkIsNum(tk->input[tk->current+1]))
                return 0;
            // If we are in colorizer mode, we ignore hasDot to 
            // allow for multiple 1.2.3.4 patterns in documents
            if(!tk->colorizer)
                hasDot = 1;
        }
    }
    
    // Is Number
    if(TkIsNum(c) || c == '.')
    {
        TkNewWord(e, tk);

        if(!tk->colorizer && c == '.')  // See above for allowing multiple dots in color mode
            hasDot = 1;
            
        while(tk->current < tk->max) {
            TkAddToWord(e, tk, c);
            TkAdvance(e, tk, 1);
            if(tk->current >= tk->max)
                c = 0;
            else
                c = tk->input[tk->current];
            if(c == 'e' || c == 'E')
            {
                flags |= TF_NUM_EXP;
                if(hasExp)
                    return TkSetError(e, tk, "Invalid number format", tk->line, tk->column);
                hasExp = 1;
                TkAddToWord(e, tk, c);
                TkAdvance(e, tk, 1);
                c = tk->input[tk->current];
                if(c == '+' || c == '-')
                {
                    TkAddToWord(e, tk, c);
                    TkAdvance(e, tk, 1);
                }
                c = tk->input[tk->current];
                continue;
            }

            // If we already have a '.' then the next '.' counts as a method call separator            
            if(c == '.' && !hasDot) {
                if(hasExp) {
                    return TkSetError(e, tk, "Invalid number format", tk->line, tk->column);
                }

                if(hasDot) {
                    return TkSetError(e, tk, "Invalid number format", tk->line, tk->column);
                }
                if(!tk->colorizer)  // see above
                    hasDot = 1;
                continue;
            }
            if(TkIsNum(c))
                continue;
            else {
                double n = mult * TkNumFromWord(DynStrGet(e, tk->word));
                
                // fix shark@anui.com 2011-11-12 - if the multiplier is negative, adjust the starting
                // column to account for the minus sign
                int adjust = 0;
                if(hasPrefix) {
                    tk->wordCol--;
                    tk->offset--;
                    adjust = 1;
                }
                Token* t = TkAddTok(e, tk, TOK_NUMLIT, tk->line, tk->wordCol, tk->offset, tk->offset + 
                                    DynStrIndex(e,tk->word) + adjust);
                t->Val = n;
                t->flags |= flags;
                break;
            }
        }
        return 1;
    }
    else
        return 0;
}

// Create Tokenizer. A single Tokenizer can be used multiple times
Tokenizer* TkNew(Js* e) {
    Tokenizer* tk = (Tokenizer*) halloc(e->memory[TK].data);
    
    if(!tk)
        return NULL;
    tk->maxWidth = 0;
    tk->widestLine = -1;

    tk->tempEndToken = -1;
    tk->tempLineCount = -1;
    tk->tempEndLine = -1;
    tk->jsonMode = FALSE;
    tk->needFullTok = FALSE;

    tk->source = NULL;
    tk->lines = VectorNew(e, TOK_MIN_LINES, sizeof(Line), 2.0);
    tk->tokens = VectorNew(e, TOK_MIN_TOKENS, sizeof(Token), 2.0);
    tk->strings = VectorNew(e, TOK_MIN_STRING_CHARS, sizeof(uchar), 2.0);
    tk->matches = VectorNew(e, TOK_MIN_MATCHES_CHARS, sizeof(uchar), 2.0);

    tk->identifiers = StrmapNew(e, TOK_MIN_IDENTIFIER_CHARS, TOK_MIN_IDENTIFIERS, sizeof(int), 2.0);
    
    tk->word = DynStrNew(e, TOK_MAX_WORD);
    tk->error[0] = '\0';
    
    tk->changedTok = TOK_NOT_FOUND;
    
    tk->current = 0;
    tk->input = NULL;
    tk->column = 0;
    tk->line = 0;
    tk->offset = 0;
    
    tk->colorizer = 1;
    return (Tokenizer*) tk;
}

bool_t TkNeedFull(Js* e, Tokenizer* tk) {
    return tk->needFullTok;
}

bool_t TkRebuild(Js* e, Tokenizer* tk) {
    // printf("jse Tokenizer Rebuild called\n");
    tk->needFullTok = TRUE;
    // We don't own the source, then fail
    return FALSE;    
}

// Validate the tokenizer to support range tokenization.
bool_t TkValidateToken(Js* e, Tokenizer* tk, int forToken) {
    // We are not in range tokenize, it's OK
    if(tk->tempEndToken < 0)
        return TRUE;

    // Token is less than the tempEnd, it's OK
    if(forToken <= tk->tempEndToken) 
        return TRUE;

    // We own the source, then retokenize and declare OK
    if(tk->source) {
        TkTokenizeS(e, tk, StrClone(e, tk->source), 0, 1);
        return TRUE;
    }
    
    return TkRebuild(e, tk);
}

bool_t TkValidateLine(Js* e, Tokenizer* tk, int line) {
    // We are not in range tokenize, it's OK
    if(tk->tempEndLine < 0)
        return TRUE;

    // Line is less than or equal end
    if(line <= tk->tempEndLine)
        return TRUE;

    // We own the source, then retokenize and declare OK
    if(tk->source) {
        TkTokenizeS(e, tk, StrClone(e, tk->source), 0, 1);
        return TRUE;
    }
    
    return TkRebuild(e, tk);

}

bool_t TkValidateOffset(Js* e, Tokenizer* tk, int offset) {
    // We are not in range tokenize, it's OK
    if(tk->tempEndLine < 0)
        return TRUE;

    // Get the last line end offset
    int last = tk->tempEndLine;
    int end = TkGetLineOffset(e, tk, last) + TkGetLineLen(e, tk, last);

    // We are before it, OK
    if(offset < end)
        return TRUE;

    // We own the source, then retokenize and declare OK
    if(tk->source) {
        TkTokenizeS(e, tk, StrClone(e, tk->source), 0, 1);
        return TRUE;
    }
    return TkRebuild(e, tk);
}

// Free created Tokenizer
void TkDel(Js* e, Tokenizer* tk) {
    Tokenizer* t = (Tokenizer*) tk;
    VectorDel(e, t->tokens);
    VectorDel(e, t->strings);
    VectorDel(e, t->matches);
    VectorDel(e, t->lines);
    StrmapDel(e, t->identifiers);
    DynStrDel(e, t->word);
    
    if(tk->source)
        StrDel(e, tk->source);
    hfree(e->memory[TK].data, t);
}

// Get line start _tok
int TkGetLineStartTok(Js* e, Tokenizer* tk, int line) {
    Tokenizer* t = (Tokenizer*) tk;
    int lines = VectorCount(e, t->lines);
    if (line >= lines || line < 0) {
        return TOK_NOT_FOUND;
    }
    Line* tl = VectorGet(e, t->lines, line);
    return tl->first;
}

// Get a _tok index given a location in text
int TkGetTokFromOffset(Js* e, Tokenizer* tk, int location) {
    // Get the line from the location
    int line = TkGetLineFromOffset(e, tk, location);
    if (line == TOK_NO_LINE) {
        return TOK_NOT_FOUND;
    }
    
    // Loop through getting _toks for this line and check for location
    for(int _tok = TkGetLineStartTok(e, tk, line); _tok != TOK_NOT_FOUND; _tok++) {
        int start = TkGetTokOffset(e, tk, _tok);
        int end = TkGetTokLen(e, tk, _tok) + start;
        
        // Got to new line
        if(TkGetTokLine(e, tk, _tok) != line) {
            break;
        }
        
        if(location >= start && location < end) {
            return _tok;
        }
    }
    return TOK_NOT_FOUND;
}

// Get a _tok index of next function
int TkGetNextFuncTok(Js* e, Tokenizer* tk, int start, int* next) {
    Tokenizer* t = (Tokenizer*) tk;
    Vector* _toks = t->tokens;
    int count = VectorCount(e, _toks);
    
    // Loop over all _toks
    for(int i=start; i < count; i++) {
        Token* tok = (Token*) VectorGet(e, _toks, i);
        // Find a function _tok
        if(tok->type == TOK_KEYWORD && tok->keyword == id_function) {
            // Check the _tok after to see if it's an identifier
            if(i < count -1) {
                Token* id = (Token*) VectorGet(e, _toks, i+1);
                if(id->type == TOK_IDENTIFIER) {
                    *next = i+1;
                    return i+1;
                }
            }

            // check the _tok before if it's an equal or colon and then the preceeding
            // is an identifier matching the name
            if(i > 2) {
                Token* eq = (Token*) VectorGet(e, _toks,i-1);
                Token* id = (Token*) VectorGet(e, _toks, i-2);
                if(eq->type == TOK_KEYWORD &&
                (eq->keyword == id_eq || eq->keyword == id_colon) &&
                   id->type == TOK_IDENTIFIER) {
                   *next = i+1;
                    return i-2;
               }
            }
        }
    }
    return TOK_NOT_FOUND;
}

// Get line end _tok
int TkGetLineEndTok(Js* e, Tokenizer* tk, int line) {
    Tokenizer* t = (Tokenizer*) tk;
    Line* tl = VectorGet(e, t->lines, line);
    if(!tl)
        return -1;
    return tl->last;
}

// Get line location in source
int TkGetLineOffset(Js* e, Tokenizer* tk, int line) {
    Tokenizer* t = (Tokenizer*) tk;
    if(!t->lines) return -1;
    
    if(line >= VectorCount(e, t->lines)) return -1;

    Line* tl = VectorGet(e, t->lines, line);
    if(!tl)
        return -1;
    return tl->location;
}

// Get line length in source
int TkGetLineLen(Js* e, Tokenizer* tk, int line) {
    Tokenizer* t = (Tokenizer*) tk;
    Line* tl = VectorGet(e, t->lines, line);
    if(!tl)
        return -1;
    return tl->length;
}


//
// Tokenize a range of text. This causes all lines above and including new added lines to be
// accurate but line count and all lines after become invalidated... tempLineCount is
// used to return a semi-accurate line count and tempEndToken is used to detect and fully tokenize
//
// viewEndLine - used to indicate where the view ends so not worth going past it
// newEnd - however to track the number of lines added, the caller must also supply
//                   the end offset of text change and the tokenizer will ensure that it will
//                   tokenize up to that offset to ensure that tempLineCount is accurate
//
int TkReplace(Js* e, Tokenizer* tk, int oldStart, int oldEnd, int newStart, int newEnd, uchar* source, int count, int viewEndLine) {
    // Save the source
    tk->input = source;
    tk->max = count;

    // Keep the original last token index so that we can call TkEnd if we do get past it
    int originalLastToken = tk->tokens->count;

    // No need to reset strings or identifiers since the editor will call
    // full TkTokenize on idle which will fix all the strings and identifiers anyway
    // VectorReset(e, tk->strings);
    // StrmapReset(e, tk->identifiers);

    // Get starting line and end line
    int startLine = TkGetLineFromOffset(e, tk, oldStart);
    int endLine = TkGetLineFromOffset(e, tk, oldEnd);

    // @todo: adjust start line to handle being inside string, template, or multi-line comments
    int lineCount = TkGetLineCount(e, tk);

    // Adjust line count by lines that will be removed
    int removedLineCount = endLine - startLine + 1;

    // Adjust startOffset to be beginning of the start line
    int startOffset = TkGetLineOffset(e, tk, startLine);
    int startToken = TkGetLineStartTok(e, tk, startLine);

    // Remove all tokens at and after startOffset
    tk->tokens->count = startToken;             // @todo: leaks?

    // Remove all lines at and after startLine
    tk->lines->count = startLine + 1;           // @todo: leaks?

    // Set incremental positions
    tk->current = startOffset;
    tk->column = 0;
    tk->line = startLine;
    TkNewWord(e, tk);


    // Save starting line count so we know how many we added
    bool_t endOffsetReached = FALSE;
    while(TkTokenizeNext(e, tk)) {
        // See if we have gone past the end offset
        if(tk->tokens->count > newEnd)
            endOffsetReached = TRUE;

        // If the line count is greater than stopAfter then bail
        if(TkGetLineCount(e, tk) > viewEndLine && viewEndLine >= 0 && endOffsetReached)
            break;
    }

    // Set the last tokenized line
    tk->tempEndLine = tk->line;

    // Set the tempEndToken to be the current token count
    tk->tempEndToken = tk->tokens->count-1;

    // Compute added lines
    // int addedLines = tk->lines->count - startLine;
    int addedLines = TkGetLineFromOffset(e, tk, newEnd) - TkGetLineFromOffset(e, tk, newStart) + 1;

    // Set the tempLineCount to be the current line count
    tk->tempLineCount =  lineCount + addedLines - removedLineCount;

    // If we have reached the last token, then we should call TkEnd to properly mark end of file
    if(tk->tokens->count >= (originalLastToken-1)) {
        TkEnd(e, tk);

    }

    // printf("jse TkReplace(os:%d, oe:%d, ns:%d, ne:%d) => %d added, %d removed, %d total, %d tempEnd\n", 
        // oldStart, oldEnd, newStart, newEnd, addedLines, removedLineCount, tk->tempLineCount, tk->tempEndToken);
    return 1;
}

// _tokenize a string stream. Length can be -1 and the Tokenizer will compute it
// Returns the number of _tokization errors or 0 if succeeded. The string
// is not kept by the Tokenizer
int TkTokenize(Js* e, Tokenizer* tk, uchar* source, int length, int script, int colorizer) {

// int ac = e->allocs;
    if(length < 0) {
        uchar* cp = source;
        length = 0;
        while(*cp) {
            length++;
            cp++;
        }
    }
    Tokenizer* t = (Tokenizer*) tk;
    t->colorizer = colorizer;               // must indicate colorizer first for empty input
    TkBegin(e, tk, source, script, length);
    while(TkTokenizeNext(e, tk)) {
    }

    TkEnd(e, tk);
    
// int d = e->allocs;
// jprintf(e,0,"\nengine alloc delta: %d", d - ac);
    return 1;
}

int TkReplaceA(Js* e, Tokenizer* tk,int oldStart, int oldEnd, int newStart, int newEnd, char* source, int viewEndLine) {
    Str* su = StrNewChars(e, source);
    int r = TkReplace(e, tk, oldStart, oldEnd, newStart, newEnd, su->chars, su->length, viewEndLine);
    StrDel(e, su);
    return r;
}

int TkTokenizeA(Js* e, Tokenizer* tk, char* source, int length, int script, int colorizer) {
    Str* su = StrNewChars(e, source);
    return TkTokenizeS(e, tk, su, script, colorizer);
}

int TkTokenizeS(Js* e, Tokenizer* tk, Str* source, int script, int colorizer) {
    if(tk->source) {
        StrDel(e, tk->source);
    }
    tk->source = source;
    return TkTokenize(e, tk, source->chars, source->length, script, colorizer);
}

int TkTokenizeOutline(Js* e, Tokenizer* tk, uchar* source, int length, int script) {
    TkBegin(e, tk, source, script, length);
    Tokenizer* t = (Tokenizer*) tk;
    
    
    // While we have more characters
    while(t->current < t->max) {
    
        // Compute level based on leading spaces
        int level = 0;
        uchar c;
        c = t->input[t->current];
        while(TkIsSpace(tk, c) && t->current < t->max) {
            TkAdvance(e, t, 1);
            c = t->input[t->current];
            level++;
        }

        if(t->current >= t->max)
            break;
                
        // Create a new word
        TkNewWord(e, t);
        // Advance to end of line
        while(!TkIsLineTerm(c) && t->current < t->max) {
            TkAddToWord(e, t, c);
            TkAdvance(e, t, 1);
            c = t->input[t->current];
        }
        
        int type = TOK_COMMENT;
        switch(level) {
            case 0:
                type = TOK_IDENTIFIER;
                break;
            case 1:
                type = TOK_KEYWORD;
                break;
            case 2:
                type = TOK_NUMLIT;
                break;
        }
        
        TkAddTok(e, t, type, t->line, t->wordCol, t->offset, t->offset + t->word->str->length);
        if(t->current < t->max)
            TkTokenizeLineTerm(e, t);
    }
    TkEnd(e, tk);
    return 1;

}

int TkTokenizeOutlineA(Js* e, Tokenizer* tk, char* source, int length, int script) {

    if(tk->source) {
        StrDel(e, tk->source);
    }
    Str* su = StrNewChars(e, source);
    tk->source = su;    
    int ret = TkTokenizeOutline(e, tk, su->chars, su->length, script);
    return ret;
}

// Get the error string for a given Tokenizer. String must be copied if
// needing to keep a reference
char* TkGetError(Js* e, Tokenizer* tk) {
    Tokenizer* t = (Tokenizer*) tk;
    return t->error;
}

int TkGetErrorLine(Js* e, Tokenizer* tk) {
    return tk->errorLine;
}

int TkGetErrorCol(Js* e, Tokenizer* tk) {
    return tk->errorCol;
}

// Get the number of _tokization lines
int TkGetLineCount(Js* e, Tokenizer* tk) {
    if(tk->tempLineCount >= 0)
        return tk->tempLineCount;
    return VectorCount(e, tk->lines);
}

// Get the maximum column width of all lines _tokenized
int TkGetMaxWidth(Js* e, Tokenizer* tk) {
    Tokenizer* t = (Tokenizer*) tk;
    return t->maxWidth;
}

int TkGetWidestLine(Js* e, Tokenizer* tk) {
    Tokenizer* t = (Tokenizer*) tk;
    return t->widestLine;
}


// Get the width of the widest token
int TkGetWidestToken(Js* e, Tokenizer* tk) {
    return tk->widestToken;   
}

// Get the index of the single changed _tok or TOK_NOT_FOUND if
// no _toks have changed or more than one _tok has changed
int TkGetChangedTok(Js* e, Tokenizer* tk) {
    Tokenizer* t = (Tokenizer*) tk;
    return t->changedTok;
}

// Get the line number (0 based) from a given location in the source string
int TkGetLineFromOffset(Js* e, Tokenizer* tk, int location) {
    Tokenizer* t = (Tokenizer*) tk;
    
    if(!TkValidateOffset(e, tk, location)) {
        tk->needFullTok = TRUE;
        return -1;
    }
    

    int count = VectorCount(e, t->lines);
    for(int l = 0; l < count; l++) {
        Line* tl = VectorGet(e, t->lines, l);
        int so = tl->location;
        
        int eo = tl->location + tl->length;

        // Dolphin: 8/4/12 - Handle the case where the cursor at the start of the last line versus the end of the previous line
        if (location == eo) {
            if (l == count - 1) {
                return l;
            } else {
                return l + 1;
            }
        }
        
        if(location >= so && location < eo) {
            return l;
        }
    }
    
    return TOK_NO_LINE;
}

int TkGetCount(Js* e, Tokenizer* tk) {
    if(tk->tempLineCount >= 0)
        return TkSetError(e, tk, "Out of range", -1, -1);

    return VectorCount(e, tk->tokens);
}

// Get the number of _toks for a given line
int TkGetTokCount(Js* e, Tokenizer* tk, int line) {
    if(line == TOK_NO_LINE)
        return 0;

    if(!TkValidateLine(e, tk, line))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    
    if(line >= VectorCount(e, t->lines))
        return 0;
        
    Line* tl = VectorGet(e, t->lines, line);
    Token* st = VectorGet(e, t->tokens, tl->first);
    if(!st)
        return 0;
    Token* et = VectorGet(e, t->tokens, tl->last);
    if(!et)
        return 0;
    return (int) (et - st + 1);
}

// Get the _tok index given a line and index into the line. The _tok
// index is then used to Get information about a given _tok
int TkGetTokIndex(Js* e, Tokenizer* tk, int line, int index) {
    if(line < 0)
        return TOK_NOT_FOUND;
    if(index < 0)
        return TOK_NOT_FOUND;

    if(!TkValidateLine(e, tk, line))
        return TkSetError(e, tk, "Out of range", -1, -1);
    
    Tokenizer* t = (Tokenizer*) tk;
    if (line >= VectorCount(e, t->lines)) {
        return TOK_NOT_FOUND;
    }
    Line* tl = VectorGet(e, t->lines, line);
    if(tl->first + index < tl->last)
        return tl->first + index;
    return TOK_NOT_FOUND;
}

// Get the line number for a given _tok index (1 based)
int TkGetTokLine(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return _tok;

    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens,_tok);
    if(!k) {
        return TOK_NO_LINE;
    }
    return k->line;
}

// Get the _tok string starting location in the source string. Location and length
// can be used by callers to obtain the actual _tok text from their source
// string since the Tokenizer doesn't keep a copy of the source
int TkGetTokOffset(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return _tok;

    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens, _tok);
    if (k != NULL) {
        return k->location;
    } else {
        return -1;
    }

}

// Get the _tok string length in the source string
int TkGetTokLen(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return _tok;

    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens, _tok);
    if(!k)
        return 0;
    return k->length;
}

// Get the type of a given _tok
int TkGetTokType(Js* e, Tokenizer* tk, int tok) {
    if(tok < 0)
        return tok;

    if(!TkValidateToken(e, tk, tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    int count = VectorCount(e, t->tokens);
    if (tok == TOK_NOT_FOUND || tok >= count) {
        return TOK_NOT_FOUND;
    }
    Token* k = VectorGet(e, t->tokens, tok);
    return k->type;

}

uint32 TkGetTokFlags(Js* e, Tokenizer* tk, int tok) {
    if(tok < 0)
        return 0;

    if(!TkValidateToken(e, tk, tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    int count = VectorCount(e, t->tokens);
    if (tok == TOK_NOT_FOUND || tok >= count) {
        return 0;
    }
    Token* k = VectorGet(e, t->tokens, tok);
    return k->flags;
}

void TkSetTokFlag(Js* e, Tokenizer* tk, int tok, uint32 flag) {
    if(!TkValidateToken(e, tk, tok)) {
        TkSetError(e, tk, "Out of range", -1, -1);
        return;
    }

    if(tok < 0 || tok >= VectorCount(e, tk->tokens))
        return;
    Token* k = VectorGet(e, tk->tokens, tok);
    k->flags |= flag;
}

void TkClearTokFlag(Js* e, Tokenizer* tk, int tok, uint32 flag) {
    if(!TkValidateToken(e, tk, tok)) {
        TkSetError(e, tk, "Out of range", -1, -1);
        return;
    }

    if(tok < 0 || tok >= VectorCount(e, tk->tokens))
        return;
    Token* k = VectorGet(e, tk->tokens, tok);
    k->flags &= ~flag;
}

bool_t TkIsTokFlag(Js* e, Tokenizer* tk, int tok, uint32 flag) {
    if(!TkValidateToken(e, tk, tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    if(tok < 0 || tok >= VectorCount(e, tk->tokens))
        return FALSE;
    Token* k = VectorGet(e, tk->tokens, tok);
    return ( (k->flags & flag) != 0);
}


// If the _tok is a keyword, Get the keyword id of the _tok's keyword
int TkGetTokKeyword(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return _tok;

    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    if(TkGetTokType(e, tk, _tok) != TOK_KEYWORD)
        return id_none;

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens, _tok);
    return k->keyword;
}

// Get the _tok's column in the source text
int TkGetTokCol(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return _tok;
    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens, _tok);
    return k->column;

}

// Get the _tok numeric Val
double TkGetTokNumVal(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return 0.0;
    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens, _tok);
    return k->Val;
}

// Get the string Val for the _tok
Str* TkGetTokStr(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return NULL;

    // We never allow this during incremental tokenization
    if(tk->tempLineCount >= 0) {
        TkSetError(e, tk, "Out of range", -1, -1);
        return NULL;
    }

    Tokenizer* t = (Tokenizer*) tk;
    Token* k = VectorGet(e, t->tokens, _tok);
    return VectorGet(e, t->strings, k->string);
}

Str* TkGetTokRawStr(Js* e, Tokenizer* tk, int _tok) {
    if(_tok < 0)
        return NULL;

    // We never allow this during incremental tokenization
    if(tk->tempLineCount >= 0) {
        TkSetError(e, tk, "Out of range", -1, -1);
        return NULL;
    }

    Token* k = VectorGet(e, tk->tokens, _tok);
    if(k->raw < 0)
        return NULL;
    return VectorGet(e, tk->strings, k->raw);
}

// Get the previous _tok
int TkGetPrevTok(Js* e, Tokenizer* tk, int _tok, int skipNewLine) {
    if(_tok < 0)
        return _tok;

    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* k = (Tokenizer*) tk;
    
    for(_tok--; _tok >= 0; _tok--) {
        if(!skipNewLine)
            return _tok;
            
        Token* t = VectorGet(e, k->tokens, _tok);

        if(t->type == TOK_LINETERM)
            continue;
        return _tok;
    }
    return TOK_NOT_FOUND;
}

// Get the next _tok
int TkGetNextTok(Js* e, Tokenizer* tk, int _tok, int skipNewLine) {
    if(_tok < 0)
        return _tok;

    if(!TkValidateToken(e, tk, _tok))
        return TkSetError(e, tk, "Out of range", -1, -1);

    Tokenizer* k = (Tokenizer*) tk;
    
    int count = VectorCount(e, k->tokens);
    for(_tok++; _tok < count ; _tok++) {
        if(!skipNewLine)
            return _tok;
            
        Token* t = VectorGet(e, k->tokens, _tok);
        if(t->type == TOK_LINETERM)
            continue;
        return _tok;
    }
    return TOK_NOT_FOUND;
}

int TkRegExFlags(Js* e, Tokenizer* tk);
int TkRegExBody(Js* e, Tokenizer* tk);
int TkRegExChars(Js* e, Tokenizer* tk);
int TkRegExChar(Js* e, Tokenizer* tk);
int TkRegExNonTerminator(Js* e, Tokenizer* tk);
int TkRegExBackslashSequence(Js* e, Tokenizer* tk);
int TkRegExClass(Js* e, Tokenizer* tk);
int TkRegExLiteral(Js* e, Tokenizer* tk, int* fo);
int TkRegExClassChar(Js* e, Tokenizer* tk);
int TkRegExClassFirstChar(Js* e, Tokenizer* tk);
int TkRegExClassChars(Js* e, Tokenizer* tk);
int TkRegExIdentifierPart(Js* e, Tokenizer* tk);
int TkSourceChar(Js* e, Tokenizer* tk);
int TkIsLineTerminator(uchar c);
int TkUnicodeEscapeSeq(Js* e, Tokenizer* tk);

int TkIsLineTerminator(uchar c) {
    if(c == '\r' || c == '\n')
        return 1;
    return 0;
}

int TkSourceChar(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    if(c != 0 && tk->current < tk->max-1) {
        TkAdvance(e, tk,1);
        return 1;
    }
    
    return 0;
}

int TkRegExIdentifierPart(Js* e, Tokenizer* tk) {
    while(tk->current < tk->max) {
        uchar c = tk->input[tk->current];
        if(c == '$' || c == '_')
            TkAdvance(e, tk,1);
        else if(TkIsAlNum(c))
            TkAdvance(e, tk,1);            
        else if(!TkUnicodeEscapeSeq(e, tk)) {
            break;
        }
    }
    return 1;
}

int TkUnicodeEscapeSeq(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    if(c != '\\')
        return 0;
    int temp = tk->current;
    
    TkAdvance(e, tk,1);
    if(tk->current >= tk->max || tk->input[tk->current] != 'u') {
        tk->current = temp;
        return 0;
    }

    for(int i = 0; i < 4; i ++) {
        TkAdvance(e, tk,1);
        if(tk->current >= tk->max || !TkIsHexDigit(tk->input[tk->current])) {
            tk->current = temp;
            return 0;
        }
    }
    TkAdvance(e, tk,1);
    return 1;
}

int TkRegExLiteral(Js* e, Tokenizer* tk, int* fo) {

    //
    // although this is not in the spec, we must distinguish between regular
    // expression literals and mathematical experssions that contain two
    // forward slashes in them (e.g. x = 5 / 3*2 / 1;
    //        
    if(tk->current > 0) {
        int s = VectorCount(e, tk->tokens);// tk->tokens.size();
        if(s < 1)
            return 0;
        Token* last = VectorGet(e, tk->tokens, s-1); // tk->get_tok(s-1);
        if(last->type == TOK_IDENTIFIER || last->type == TOK_STRLIT || last->type == TOK_NUMLIT)
        return 0;
        
        // 20120906 shark@anui.com - only support RegEx literals if the previous
        // _tok is not a right parenthesis
        if(last->type == TOK_KEYWORD && last->keyword == id_rpar)
            return 0;
            
        // 20120907 shark@anui.com we also have to account for a[0]/2, b=4/3;
        // so disallow RegEx literal if the previous _tok is a ']'
        if(last->type == TOK_KEYWORD && last->keyword == id_rbracket)
            return 0;            
    }
    int temp = tk->current;
    uchar c = tk->input[tk->current];
    if(c != '/') {
        tk->current = temp;
        return 0;
    }
        
    TkAdvance(e, tk,1);
    int res = TkRegExBody(e, tk);
    if(!res) {
        tk->current = temp;
        return 0;
    }

    c = tk->input[tk->current];
    if(c != '/') {
        tk->current = temp;
        return 0;
    }
    
    *fo = tk->current - temp;
    TkAdvance(e, tk,1);
    return TkRegExFlags(e, tk);
}

int TkRegExBody(Js* e, Tokenizer* tk) {
    int temp = tk->current;
    int res = TkRegExClassFirstChar(e, tk);
    
    if(!res) {
        tk->current = temp;
        return 0;
    }
        
    return TkRegExChars(e, tk);
}

int TkRegExChars(Js* e, Tokenizer* tk) {
    while(TkRegExChar(e, tk));
    return 1;
}

int TkRegExClassFirstChar(Js* e, Tokenizer* tk) {
    int temp = tk->current;
    uchar c = tk->input[tk->current];
    int res = TkRegExNonTerminator(e, tk);
    
    if(res && c != '*' && c != '\\' && c != '/' && c != '[')
        return 1;
        
    tk->current = temp;
    res = TkRegExBackslashSequence(e, tk);
    if(res)
        return res;
        
    tk->current = temp;
    return TkRegExClass(e, tk);
}

int TkRegExChar(Js* e, Tokenizer* tk) {
    int temp = tk->current;
    uchar c = tk->input[tk->current];
    int res = TkRegExNonTerminator(e, tk);
    if(res && c != '\\' && c != '/' && c != '[')
        return 1;
        
    tk->current = temp;
    res = TkRegExBackslashSequence(e, tk);
    if(res)
        return res;
        
    tk->current = temp;
    return TkRegExClass(e, tk);
}

int TkRegExBackslashSequence(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    if(c != '\\')
        return 0;
        
    TkAdvance(e, tk,1);
    return TkRegExNonTerminator(e, tk);
}

int TkRegExNonTerminator(Js* e, Tokenizer* tk) {
    int temp = tk->current;
    uchar c = tk->input[tk->current];

    int res = TkSourceChar(e, tk);
    if(res && ! TkIsLineTerminator(c))
        return 1;
    tk->current = temp;
    return 0;
}

int TkRegExClass(Js* e, Tokenizer* tk) {
    int temp = tk->current;
    uchar c = tk->input[tk->current];
    
    if(c != '[') {
        tk->current = temp;
        return 0;
    }
        
    TkAdvance(e, tk,1);
    int res = TkRegExClassChars(e, tk);
    if(!res) {
        tk->current = temp;
        return 0;
    }
    
    c = tk->input[tk->current];
    if(c != ']') {
        tk->current = temp;
        return 0;
    }
        
    TkAdvance(e, tk,1);
    return 1;
}

int TkRegExClassChars(Js* e, Tokenizer* tk) {
    while(TkRegExClassChar(e, tk));
    return 1;
}

int TkRegExClassChar(Js* e, Tokenizer* tk) {
    int temp = tk->current;
    uchar c = tk->input[tk->current];
    int res = TkRegExNonTerminator(e, tk);
    if(res && c != ']' && c != '\\')
        return 1;
    
    tk->current = temp;
    return TkRegExBackslashSequence(e, tk);
}

int TkRegExFlags(Js* e, Tokenizer* tk) {
    TkRegExIdentifierPart(e, tk);
    return 1;
}

int TkTokenizeRegEx(Js* e, Tokenizer* tk) {
    int start = tk->current;
    int flag_offset;
    int res = TkRegExLiteral(e, tk, &flag_offset);
    if(res) {
        // capture string between start and current as a tregex
        TkNewWord(e, tk);
        
        for(int i=start; i < tk->current; i++) {
            TkAddToWord(e, tk, tk->input[i]);
        }
                
        if(!tk->colorizer) {
            int offset = VectorCount(e, tk->strings);
            VectorInsertStr(e, tk->strings, DynStrGet(e, tk->word));
            Token* t = TkAddTok(e, tk, TOK_REGEX, tk->line, tk->wordCol, start, tk->current);
            t->flag_offset = flag_offset;
            t->string = offset;
        }
        else {
            Token* t = TkAddTok(e, tk, TOK_REGEX, tk->line, tk->wordCol, start, tk->current);
            t->flag_offset = flag_offset;
        }
                
        return 1;
    }
    tk->current = start;
    return 0;
}

int TkTokenizeStrColor(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];

    if(c != '\'' && c != '\"' && c != '`')
        return 0;

    uchar term = c;
    TkNewWord(e, tk);
    TkAddToWord(e, tk, c);
    TkAdvance(e, tk, 1);
    TkAddTok(e, tk, TOK_STRLIT, tk->line, tk->wordCol, tk->offset, tk->current);
    c = tk->input[tk->current];

    // If the file ends here, we don't add another string terminator token
    if(tk->current >= tk->max)
        return 1;

    while( tk->current < tk->max && c != term) {
        TkTokenizeInnerSpace(e, TOK_STRLIT, tk);
        if(TkTokenizeInnerLineTerm(e, TOK_STRLIT, tk))
            continue;
        if(TkTokenizeInnerNum(e, TOK_STRLIT, tk))
            continue;
        if(TkTokenizeInnerWord(e, TOK_STRLIT, tk))
            continue;
        TkTokenizeInnerOther(e, TOK_STRLIT, tk, term);
        c = tk->input[tk->current];
    }
    TkNewWord(e, tk);
    TkAddToWord(e, tk, c);
    TkAdvance(e, tk, 1);
    TkAddTok(e, tk, TOK_STRLIT, tk->line, tk->wordCol, tk->offset, tk->current);
    
    return 1;
}

bool_t IsHex(uchar c) {
    return TkIsHexDigit(c);
}
bool_t IsHex4(uchar d1, uchar d2, uchar d3, uchar d4) {
    return IsHex(d1) && IsHex(d2) && IsHex(d3) && IsHex(d4);
}

int TkTokenizeStrEscape(Js* e, Tokenizer* tk) {
    uchar c2 = tk->input[tk->current+1];
    switch(c2) {
    case    '\'':
    case    '"':
    case    '\\':
        TkAddToWord(e, tk, c2);
        TkAdvance(e, tk, 1);
        break;
    case    'b':
        TkAddToWord(e, tk,0x0008);
        TkAdvance(e, tk, 1);
        break;
    case    'f':
        TkAddToWord(e, tk, 0x000c);
        TkAdvance(e, tk, 1);
        break;
    case    'n':
        TkAddToWord(e, tk, 0x000a);
        TkAdvance(e, tk, 1);
        break;
    case    'r':
        TkAddToWord(e, tk, 0x000d);
        TkAdvance(e, tk, 1);
        break;
    case    't':
        TkAddToWord(e, tk, 0x0009);
        TkAdvance(e, tk, 1);
        break;
    case    'v':
        TkAddToWord(e, tk, 0x0008);
        TkAdvance(e, tk, 1);
        break;
    case    'x': {
        uchar d1, d2;
        TkAdvance(e, tk, 2);
        d1 = tk->input[tk->current];
        d2 = tk->input[tk->current+1];
        TkAddToWord(e, tk, (uchar) (TkHexVal(d1)*16 + TkHexVal(d2)));
        TkAdvance(e, tk, 1);
        }
        break;
    case    '0':
        TkAddToWord(e, tk, 0);
        TkAdvance(e, tk, 1);
        break;
    case    'u': {
        uchar d1, d2, d3, d4;
        TkAdvance(e, tk, 2);
        d1 = tk->input[tk->current];
        if(d1 == '{') {
            TkAdvance(e, tk,1);
            d1 = tk->input[tk->current];
            uint32 result = 0;
            while(TRUE) {
                if(d1 == '}')
                    break;
                if(!TkIsHexDigit(d1)) {
                    return TkSetError(e, tk, "Invalid string escape", tk->line, tk->column);
                }
                result = (result << 4) + TkHexVal(d1);
                TkAdvance(e, tk, 1);
                d1 = tk->input[tk->current];
            }
            uchar cu1, cu2;
            bool_t two = Utf16Encode(result, &cu1, &cu2);
            TkAddToWord(e, tk, cu1);
            if(two)
                TkAddToWord(e, tk, cu2);
            TkAdvance(e, tk, 1);
        }
        else {
            d2 = tk->input[tk->current+1];
            d3 = tk->input[tk->current+2];
            d4 = tk->input[tk->current+3];
            if(!IsHex4(d1, d2, d3, d4))
                return TkSetError(e, tk, "Invalid hex escape", tk->line, tk->column);
            uchar c4 = (uchar) (TkHexVal(d1)*4096+TkHexVal(d2)*256+TkHexVal(d3)*16+TkHexVal(d4));
            TkAddToWord(e, tk, c4);
            tk->current += 3;
        }
        }
        break;
        case '\r':
        case '\n':
        {
            TkAdvance(e, tk, 1);
            while(tk->current < tk->max) {
                uchar c = tk->input[tk->current];
                if(!TkIsLineTerm(c)) {
                    tk->current--;
                    break;
                }
                TkAdvance(e, tk,1);
            }
        }
        break; 
    }   
    return 1;
}

int TkTokenizeStr(Js* e, Tokenizer* tk) {
    if(tk->colorizer)
        return TkTokenizeStrColor(e, tk);
        
    uchar c = tk->input[tk->current];

    if(tk->jsonMode && c == '\'')
        return 0;

    if(c == '\'' || c == '\"')
    {
        uchar term = c;                        // Terminator

        TkNewWord(e, tk);
        while(1)
        {
            TkAdvance(e, tk, 1);
            if(tk->current >= tk->max) {
                return TkSetError(e, tk, "Unterminated string", tk->line, tk->column);
            }

            c = tk->input[tk->current];
            if(TkIsLineTerm(c)) {
            
                // The colorizer treats unterminated strings differently, it basically adds
                // it as a string _tok to make typing cleaner
                if(tk->colorizer || tk->jsonMode)
                    term = c;
                else
                    return TkSetError(e, tk, "Unterminated string", tk->line, tk->column);
            }

            if(c == '\\') {
                int res = TkTokenizeStrEscape(e, tk);
                if(res) {
                    continue;
                }
                if(tk->colorizer)
                    term = c;
                else
                    return TkSetError(e, tk, "Unrecognized string escape sequence", tk->line, tk->column);
                continue;
            }

            if(c == term) { // Add the string _tok
                
                // Get the index the string will go into
                int idx = VectorCount(e, tk->strings);
                VectorInsertStr(e, tk->strings, DynStrGet(e, tk->word));
                Token* tok = TkAddTok(e, tk, TOK_STRLIT, tk->line, tk->wordCol, tk->offset, tk->current+1);
                tok->string = idx;
                
                // We only advance if we didn't add the line due to a line term
                if(!TkIsLineTerm(c))
                    TkAdvance(e, tk, 1);
                break;
            }
            if(tk->jsonMode && c <= 0x1f)
                return TkSetError(e, tk, "Invalid JSON string", tk->line, tk->column);
            TkAddToWord(e, tk,c);
        }
        return 1;
    }
    else
        return 0;
}

int TkOffsetIs(Js* e, Tokenizer* tk, int offset, uchar c) {
    if(tk->current < (tk->max - offset)) {
        if(tk->input[tk->current+offset] == c)
            return TRUE;
    }
    return FALSE;
}
int TkPeek(Js* e, Tokenizer* tk, uchar c) {
    return TkOffsetIs(e, tk, 1, c);
}

void TkAddTemplateToken(Js* e, Tokenizer* tk, int type, DynStr* word, DynStr* raw) {
    // Special case, we have to allow adding an empty TOK_TEMPHEAD even if
    // its associated string is empty
    if(!word->str->length && !raw->str->length && type != TOK_TEMPHEAD)
        return;

    int idx = VectorCount(e, tk->strings);
    VectorInsertStr(e, tk->strings, DynStrGet(e, word));
    Token* tok = TkAddTok(e, tk, type, tk->line, tk->wordCol, tk->offset, tk->current+1);
    tok->string = idx;
    idx = VectorCount(e, tk->strings);
    VectorInsertStr(e, tk->strings, DynStrGet(e, raw));    
    tok->raw = idx;
}

int TkTokenizeTemplateLiteral(Js* e, Tokenizer* tk) {
    if(tk->colorizer)
        return TkTokenizeStrColor(e, tk);

    if(tk->current >= tk->max)
        return 0;

    uchar c = tk->input[tk->current];
    if(c != '`')
        return 0;

    bool_t hasSubstitutions = FALSE;
    bool_t headAdded = FALSE;

    TkNewWord(e, tk);
    DynStr* raw = DynStrNew(e,TOK_MAX_WORD);    

    TkAdvance(e, tk, 1);
    while(tk->current < tk->max) {
        c = tk->input[tk->current];
        if(c == '`') 
            break;

        if(TkIsLineTerm(c)) {
            TkNextLine(e, tk);            
        }

        // Found a substitution
        if(c == '$' && TkPeek(e,tk,'{')) {
            hasSubstitutions = TRUE;
            if(!headAdded) {
                headAdded = TRUE;
                TkAddTemplateToken(e, tk, TOK_TEMPHEAD, tk->word, raw);
            }
            else {
                TkAddTemplateToken(e, tk, TOK_TEMPMID, tk->word, raw);
            }
            TkNewWord(e, tk);
            DynStrClear(e, raw);
            TkAdvance(e, tk,2);
            while(tk->current < tk->max) {
                if(TkHasError(e, tk))
                    return 0;
                c = tk->input[tk->current];
                if(c == '`') {
                    return TkSetError(e, tk, "Unterminated template literal substitution",tk->line, tk->column);
                }
                if(c == '}')
                    break;
                TkTokenizeSpace(e, tk);
                if(TkTokenizeComment(e, tk)) 
                    continue;
                if(TkTokenizeLineTerm(e, tk)) 
                    continue;
                if(TkTokenizeNum(e, tk))
                    continue;
                if(TkTokenizeStr(e, tk)) 
                    continue;
                if(TkTokenizeRegEx(e, tk)) 
                    continue;
                if(TkTokenizeWord(e, tk))
                    continue;
            }
            TkAdvance(e, tk,1);
            TkNewWord(e, tk);
            DynStrClear(e, raw);
            continue;
        }


        // RAW characters always added as is
        DynStrAdd(e, raw, c);

        // Escape characters added to word encoded
        if(c == '\\') {
            int cur = tk->current;
            TkTokenizeStrEscape(e, tk);
            if(TkHasError(e, tk)) 
                break;
            // TokenizeStrEscape leaves current at the last character of the escape
            // sequence since it was designed for TokenizeStr() which advances
            // on continue... So we move forward here
            tk->current++;
            
            // Add all the characters we didn't add to raw
            for(int i=cur+1; i < tk->current; i++)
                DynStrAdd(e, raw, tk->input[i]);
        }
        else {
            DynStrAdd(e, tk->word, c);
            TkAdvance(e, tk, 1);
        }
    }
    
    if(TkHasError(e, tk)) {
        DynStrDel(e, raw);
        return 0;
    }

    if(hasSubstitutions) {
        TkAddTemplateToken(e, tk, TOK_TEMPTAIL, tk->word, raw);
    }
    else {
        TkAddTemplateToken(e, tk, TOK_TEMPLIT, tk->word, raw);
    }
    DynStrDel(e, raw);
    TkAdvance(e, tk,1);
    return 1;
}


void TkTokenizeAny(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];
    TkNewWord(e, tk);

    while(1) {
        TkAddToWord(e, tk, c);
        if(TkIsPuncSolo(c)) {
            TkAdvance(e, tk, 1);
            break;
        }

        TkAdvance(e, tk, 1);
        if(tk->current >= tk->max)
            break;

        c = tk->input[tk->current];

        // Special case -N change mohsen@mobicore.com 20060928
        if(c == '-' && tk->current > 0 && tk->input[tk->current-1] != '-')
            break;

        if(tk->current >= tk->max)
            break;
        if(TkIsLineTerm(c)) {
            break;
        }
    }
    TkAddTok(e, tk, TOK_WORD, tk->line, tk->wordCol, tk->offset, tk->offset + DynStrIndex(e,tk->word));
}


bool_t TkIsUnicodeEscape4(Js* e, Tokenizer* tk, uchar* cu) {
    int start = tk->current;
    if(start >= tk->max)
        return FALSE;

    uchar c = tk->input[start];
    if(c != '\\')
        return FALSE;

    start++;
    if(start >= tk->max)
        return FALSE;    
    c = tk->input[start];    
    if(c != 'u')
        return FALSE;

    uint32 result = 0;

    for(int i=0; i < 4; i++) {
        start++;
        if(start >= tk->max)
            return FALSE;    
        c = tk->input[start];
        if(! TkIsHexDigit(c))
            return FALSE;
        result = (result << 4) +  TkHexVal(c);
    }

    if(cu)
        *cu = (uchar) result;
    return TRUE;
}

bool_t TkIsUnicodeEscapeBrace(Js* e, Tokenizer* tk, uchar* cu1, uchar* cu2, bool_t* two, int* adv) {
    int start = tk->current;
    if(start >= tk->max)
        return FALSE;

    uchar c = tk->input[start];
    if(c != '\\')
        return FALSE;
    start++;
    if(start >= tk->max)
        return FALSE;    
    c = tk->input[start];    
    if(c != 'u')
        return FALSE;
    start++;
    if(start >= tk->max)
        return FALSE;    
    c = tk->input[start];    
    if(c != '{')
        return FALSE;

    uint32 result = 0;

    while(TRUE) {
        start++;
        if(start >= tk->max)
            return FALSE;    
        c = tk->input[start];
        if(c == '}')
            break;
        if(! TkIsHexDigit(c))
            return FALSE;
        result = (result << 4) + TkHexVal(c);
    }

    if(two) {
        *two = Utf16Encode(result, cu1, cu2);
    }
    if(adv)
        *adv = (start - tk->current);
    return TRUE;
}

bool_t TkIsUnicodeEscape(Js* e, Tokenizer* tk, uchar* cu1, uchar* cu2, bool_t* twoCodes, int *adv) {
    if(twoCodes)
        *twoCodes = FALSE;


    if(TkIsUnicodeEscape4(e, tk, cu1)) {
        if(adv)
            *adv = 6;
        return TRUE;
    }
    
    return TkIsUnicodeEscapeBrace(e,tk, cu1, cu2, twoCodes, adv);
}


// Used to handle post keyword insertion for areas like automatic semi insertion
void TkProcessKeyword(Js* e, Tokenizer* tk, int kid) {
    if(tk->colorizer)
        return;
    switch(kid) {
        case id_continue:
        case id_break:
        case id_return:
        case id_throw:
        case id_yield:
        case id_module:
            break;
        default:
            return;
    }
    if(tk->current < tk->max) {
        uchar c = tk->input[tk->current];
        if(TkIsLineTerm(c)) {
            Token* tok = TkAddTok(e, tk, TOK_KEYWORD, tk->line, tk->wordCol, tk->offset, 
                tk->offset + DynStrIndex(e,tk->word));
            tok->keyword = id_semi;
        }
    }
}

int TkTokenizeWord(Js* e, Tokenizer* tk) {
    uchar c = tk->input[tk->current];

    uchar cu1, cu2;
    bool_t hasTwo = FALSE;
    int adv = 0;
    bool_t hasUnicode = TkIsUnicodeEscape(e, tk,&cu1,&cu2, &hasTwo, &adv);      
    if(TkIsWordStart(c) || hasUnicode) {
        TkNewWord(e, tk);

        if(hasUnicode) {
            TkAddToWord(e, tk, cu1);
            if(hasTwo) {
                TkAddToWord(e, tk, cu2);
            }
            TkAdvance(e, tk,adv);
        }
        else {
            TkAddToWord(e, tk,c);
            TkAdvance(e, tk,1);            
        }
        while(1) {
            if(tk->current >= tk->max)
                break;

            c = tk->input[tk->current];

            bool_t uni, two = FALSE;
            uni = TkIsUnicodeEscape(e,tk,&cu1,&cu2, &two, &adv);
            if(!TkIsWordChar(c) && !uni)
                break;

            if(uni) {
                hasUnicode = TRUE;
                TkAddToWord(e, tk, cu1);
                if(two) {
                    TkAddToWord(e, tk, cu2);
                }
                TkAdvance(e, tk,adv);
            }
            else {
                TkAddToWord(e, tk,c);
                TkAdvance(e, tk,1);
            }
        }
    }
    else {
        TkNewWord(e, tk);

        while(1) {

            TkAddToWord(e, tk,c);

            // Special case dot dot dot
            if(c == '.' && TkPeek(e, tk, '.') && TkOffsetIs(e, tk, 2, '.')) {
                TkAddToWord(e, tk, '.');
                TkAddToWord(e, tk, '.');
                TkAdvance(e, tk, 3);
                break;
            }
            if(TkIsPuncSolo(c))
            {
                TkAdvance(e, tk,1);
                break;
            }

            TkAdvance(e, tk,1);
            if(tk->current >= tk->max)
                break;

            c = tk->input[tk->current];

            // Special case -N change mohsen@mobicore.com 20060928
            if(c == '-' && tk->current > 0 && tk->input[tk->current-1] != '-')
                break;

            // 2011-11-17 - shark@anui.com Special case +N change
            if(c == '+' && tk->current > 0 && tk->input[tk->current-1] != '+')
                break;

            if(tk->current >= tk->max || TkIsPuncTerm(c))
                break;
        }
    }

    // Is Keyword or punctuator
    int* pkid = StrmapGet(e, e->keywords, DynStrGet(e, tk->word));
    if(pkid) {
        Token* tok = TkAddTok(e, tk, TOK_KEYWORD, tk->line, tk->wordCol, tk->offset, 
                tk->offset + DynStrIndex(e,tk->word));
        tok->keyword = *pkid;
        TkProcessKeyword(e, tk, *pkid);
    }
    else {

        if(tk->colorizer) {
            int tidx = VectorCount(e, tk->tokens);
            TkAddTok(e, tk, TOK_IDENTIFIER, tk->line, tk->wordCol, tk->offset, 
                        tk->offset + DynStrIndex(e,tk->word));
            StrmapPut(e, tk->identifiers, DynStrGet(e, tk->word), &tidx);
        }
        else if(!TkIsIdentifier(DynStrGet(e, tk->word))) {
            return TkSetError(e, tk, "Expected identifier",tk->line, tk->column);
        }

        else {
            Token* tok = TkAddTok(e, tk, TOK_IDENTIFIER, tk->line, tk->wordCol, tk->offset, 
                    tk->offset + DynStrIndex(e,tk->word));
            if(hasUnicode) {
                int idx = VectorCount(e, tk->strings);
                VectorInsertStr(e, tk->strings, DynStrGet(e, tk->word));
                tok->string = idx;                
            }
        }
    }
    return 1;
}

int TkTokenizeNext(Js* e, Tokenizer* tk) {
    if(tk->current >= tk->max)
        return 0;

    TkTokenizeSpace(e, tk);
    if(tk->current >= tk->max) {
        return 0;
    }

    
    // #186 special handling for 0x3000 TOK_SPC_RALIGN, and 0x205F TOK_SPC_BLOCK
    if(tk->colorizer) {
        // Note below using tk->current not tk->offset since that's only set on TkNewWord
        uchar c = tk->input[tk->current];
        if(c == 0x3000) {
            TkAddTok(e, tk, TOK_SPC_RALIGN, tk->line, tk->wordCol, tk->current, tk->current+1);            
            TkAdvance(e, tk, 1);
            return 1;
        }
        else if(c == 0x205f) {
            TkAddTok(e, tk, TOK_SPC_BLOCK, tk->line, tk->wordCol, tk->current, tk->current+1);            
            TkAdvance(e, tk, 1);
            return 1;
        }
    }

    int last_current = tk->current;
    int last_column = tk->column;

    if(TkTokenizeComment(e, tk)) {
        if(!TkHasError(e,  tk) || tk->current >= tk->max)
            return 1;
    }

    if(TkTokenizeLineTerm(e, tk)) {
        if(!TkHasError(e,  tk))
            return 1;
    }

    if(TkTokenizeNum(e, tk)) {
        if(!TkHasError(e,  tk))
            return 1;
    }

    if(TkTokenizeStr(e, tk)) {
        if(!TkHasError(e,  tk))
            return 1;
    }
     
    if(TkTokenizeTemplateLiteral(e, tk)) {
        if(!TkHasError(e,  tk))
            return 1;
    }
    if(TkTokenizeRegEx(e, tk)) {
        if(!TkHasError(e,  tk))
            return 1;
    }
        
    if(TkTokenizeWord(e, tk)) {
        if(!TkHasError(e,  tk))
            return 1;
    }
        
    if(tk->colorizer) {
        tk->error[0] = 0;
        tk->current = last_current;
        tk->column = last_column;
        TkTokenizeAny(e, tk);
        return 1;
    }
    return 0;
}

bool_t TkLastLineEmpty(Js* e, Tokenizer* tk) {
    if(!tk->source)
        return FALSE;
    int lastLine = TkGetLineCount(e, tk) -1;

    // Only one line in the file, empty means we have no source
    if(lastLine == 0)
        return (tk->source->length == 0);

    // Otherwise, get the end offset of the line before last
    int prevLine = lastLine-1;
    int prevLen = TkGetLineLen(e, tk, prevLine);
    int prevStart = TkGetLineOffset(e, tk, prevLine);
    int prevEnd = prevStart + prevLen;
    if(prevEnd < tk->max)
        return FALSE;
    return TRUE;
}

void TkEnd(Js* e, Tokenizer* tk) {
    // Since we are now clean, reset all temp / range based tokenization stuff
    tk->tempEndToken = -1;
    tk->tempLineCount = -1;
    tk->tempEndLine = -1;
    tk->needFullTok = FALSE;

    // If we have no source, don't add anything here (unless colorizer is on for EOF)
    if(tk->input[0] == '\0') {
        if(tk->colorizer) {
            tk->offset = tk->current;
            TkAddTok(e, tk, TOK_EOF, tk->line, tk->wordCol, tk->offset, tk->offset);   
        }
        return;
    }

    // Update the last line end offset
    Line* tl = VectorGet(e, tk->lines, tk->line); // xxxxxx -1);
    tl->length = tk->current - tl->location;

    // Don't add end of file newLine _toks if the last _tok in the text
    // is a newLine
    // #220 140630 Don't auto add if in colorizer mode
    if(!tk->colorizer && TkGetTokType(e, tk, tl->last) != TOK_LINETERM) {
        // special case - add the newLine _tok at the end of the file to overlap
        // with the last actual _tok so we never index out of range in the text
        // of the line
        tk->offset = tk->current;
        // add a line term _tok in case we need it to complete parsing for auto-semi
        TkAddTok(e, tk, TOK_LINETERM, tk->line, tk->wordCol, tk->offset, tk->offset+1);
    }
    else {
        // #259 insert a TOK_EOF token at the end of the file always in colorizer mode
        tk->offset = tk->current;
        TkAddTok(e, tk, TOK_EOF, tk->line, tk->wordCol, tk->offset, tk->offset);   
    }

    // printf("jse Full Tokenize called\n");

}

bool_t TokIsId(Js* e, Tokenizer* tk, Node* n, char* id) {
    if(!n) return FALSE;

    int type = TkGetTokType(e, tk, n->token);


    if(type == TOK_KEYWORD) {
        int k = TkGetTokKeyword(e, tk, n->token);
        KeyDef* kd = &keywords[k];
        for(int i=0; i < sizeof(keywords)/sizeof(KeyDef); i++) {
            KeyDef* kd = &keywords[i];
            if(kd->kid == k)
                return (strcmp(kd->text, id)==0);
        }

        if(strcmp(kd->text, id) == 0) {
            return TRUE;
        }
    }

    if (type != TOK_IDENTIFIER)
        return FALSE;
    Val* uid = ValNewStrId(e, tk, n->token);
    bool_t ret = ValEqStrA(e, uid, id);
    ValDel(e, uid);
    return ret;
}

void TkPrintToken(Js* e, Tokenizer* t, int tok, bool_t verbose) {
    Tokenizer* tk = (Tokenizer*) t;
    int type = TkGetTokType(e, tk, tok);
    int start = TkGetTokOffset(e, tk, tok);
    int len = TkGetTokLen(e, tk, tok);
    int line = TkGetTokLine(e, tk, tok);
    int col = TkGetTokCol(e, tk, tok);
    int end = start + len;
    
    if(verbose) {
        jprintf(e,0,"[%d] (%d,%d) line:%d col:%d", tok, start, end-start, line, col);
    }
    
    if(type == TOK_KEYWORD && TkIsPunctuator(e, tk, tok))
        type = TOK_PUNCTUATOR;
    
    switch(type) {
        case TOK_SPC_RALIGN:
            jprintf(e,0,"%s%s", e->colors.green, (verbose) ? " <ralign> ":"");
            break;
        case TOK_SPC_BLOCK:
            jprintf(e,0,"%s%s", e->colors.green, (verbose) ? " <block> ":"");
            break;        
        case TOK_COMMENT:
            jprintf(e,0,"%s%s", e->colors.green, (verbose) ? " <comment> ":"");
            break;
        case TOK_IDENTIFIER:
            jprintf(e,0,"%s%s", e->colors.normal, (verbose) ? " <identifier> ":"");
            break;
        case TOK_KEYWORD:
            jprintf(e,0,"%s%s", e->colors.cyan, (verbose) ? " <keyword> ":"");
            break;
        case TOK_LINETERM:
            jprintf(e,0,"%s%s", e->colors.cyan, (verbose) ? " <lineterm> "  : "\n");
            break;
        case TOK_STRLIT:
            jprintf(e,0,"%s%s", e->colors.red, (verbose) ? " <strlit> " : "");
            break;
        case TOK_TEMPLIT:
            jprintf(e,0,"%s%s", e->colors.red, (verbose) ? " <template> " : "");
            break;
        case TOK_TEMPHEAD:
            jprintf(e,0,"%s%s", e->colors.red, (verbose) ? " <temphead> " : "");
            break;
        case TOK_TEMPMID:
            jprintf(e,0,"%s%s", e->colors.red, (verbose) ? " <tempmid> " : "");
            break;
        case TOK_TEMPTAIL:
            jprintf(e,0,"%s%s", e->colors.red, (verbose) ? " <temptail> " : "");
            break;            
        case TOK_NUMLIT:
            jprintf(e,0,"%s%s", e->colors.green, (verbose) ? " <numlit> " : "");
            break;
        case TOK_REGEX:
            jprintf(e,0,"%s%s", e->colors.red, (verbose) ? " <regex> ": "");
            break;
        case TOK_PUNCTUATOR:
            jprintf(e,0,"%s%s", e->colors.white, (verbose) ? " <punct> " : "");
            break;
        case TOK_WORD:
            jprintf(e,0,"%s%s", e->colors.white, (verbose) ? " <word> " : "");
            break;
        default:
            break;
    }
    
    if(type == TOK_LINETERM) {
        jprintf(e,0,"");
    }
    else {
        for(int i=start; i < end; i++) {
            jprintf(e,0,"%c", (char) tk->input[i]);
        }
    }
    jprintf(e,0,"%s", e->colors.normal);
}


void print_spaces(Js* e, int count) {
    for(int i=0; i < count; i++) {
        jprintf(e, 0, " ");
    }
}

void TkPrint(Js* e, Tokenizer* tk, List* extra, int extraPad, bool_t v) {
    bool_t verbose = e->options.verbose || v;
    int lines = TkGetLineCount(e, tk);
    int last_offset = 0;
    int start = (e->options.start > 0) ? e->options.start-1 : 0;
    int count = (e->options.num > 0) ? e->options.num : lines;
    int end = start + count;

    if(e->options.start > 0) {
        int lineStartTok = TkGetLineStartTok(e, tk, start);
        last_offset = TkGetTokOffset(e, tk, lineStartTok);
    }
    for(int l = start; l < end; l++) {
        int line = l+1;

        if(verbose)
            jprintf(e,0,"%sLine %s%04d\n",e->colors.white, e->colors.white, line);
        else if(e->options.lines)
            jprintf(e,0,"%s%04d ", e->colors.white, line);
        int tokens = TkGetTokCount(e, tk, l);
        int tok = TkGetLineStartTok(e, tk, l);
        
        int chars = 0;
        for(int t = 1; t <= tokens; t++) {
            if(!verbose) {
                int token_offset = TkGetTokOffset(e, tk, tok);
                int spaces = token_offset - last_offset;
                chars += spaces;
                print_spaces(e, spaces);
                last_offset = token_offset + TkGetTokLen(e, tk, tok);
            }

            if(TkGetTokType(e, tk, tok) == TOK_LINETERM) {
                if(extra) {
                    while(chars < extraPad) {
                        jprintf(e,0," ");
                        chars++;
                    }
                    if(l < ListGetCount(e, extra)) {
                        Val* v = ListGetValue(e, extra, l);
                        if(!ValIsUndef(v))
                            ValPrint(e, v, FALSE,-1);
                        ValDel(e, v);
                    }
                }
            }
            TkPrintToken(e, tk, tok, verbose);
            chars += TkGetTokLen(e, tk, tok);
            if(verbose)
                jprintf(e,0,"\n");
            tok = TkGetNextTok(e, tk, tok, 0);
        }
    }
}


Vector* TkMatch(Js* e, Tokenizer*tk, int index, Str* substring, uint32 flags) {
    if(tk->tempLineCount >= 0 && tk->tempEndToken >= 0) {
        tk->needFullTok = TRUE;
        return NULL;
    }
    Tokenizer* t = (Tokenizer*) tk;

    VectorReset(e, t->matches);
    StrmapMatch(e, e->keywords, substring, t->matches, flags);
    StrmapMatch(e, t->identifiers, substring, t->matches, flags);
    return t->matches;
}

Vector* TkMatchA(Js* e, Tokenizer*tk, int index, char* substring, uint32 flags) {
    Str* su = StrNewChars(e, substring);
    Vector* da = TkMatch(e, tk, index, su, flags);
    StrDel(e, su);
    return da;
}

int TkIsSameKeyword(Js* e, Tokenizer* tk, int t1, int t2) {
    if(TkGetTokType(e, tk, t1) != TOK_KEYWORD || TkGetTokType(e, tk, t2) != TOK_KEYWORD)
        return FALSE;
    return (TkGetTokKeyword(e, tk, t1) == TkGetTokKeyword(e, tk, t2));
}

int tk_is_opposite_keyword(Js* e, Tokenizer* tk, int t1, int t2) {
    if(TkGetTokType(e, tk, t1) != TOK_KEYWORD || TkGetTokType(e, tk, t2) != TOK_KEYWORD)
        return FALSE;
    int k1 = TkGetTokKeyword(e, tk, t1);
    int k2 = TkGetTokKeyword(e, tk, t2);
    
    if(k1 == id_lbrace && k2 == id_rbrace)
        return TRUE;
    
    if(k1 == id_rbrace && k2 == id_lbrace)
        return TRUE;
    
    if(k1 == id_lbracket && k2 == id_rbracket)
        return TRUE;
    
    if(k1 == id_rbracket && k2 == id_lbracket)
        return TRUE;
    
    if(k1 == id_lpar && k2 == id_rpar)
        return TRUE;
    
    if(k1 == id_rpar && k2 == id_lpar)
        return TRUE;
    
    return FALSE;
}

int TkNextOpen(Js* e, Tokenizer* tk, int tok) {
    int count = VectorCount(e, tk->tokens);
    for(int i = tok+1; i < count; i++) {
        if(TkGetTokType(e, tk, i) == TOK_KEYWORD) {
            int k = TkGetTokKeyword(e, tk, i);
            if(k == id_lbrace || k == id_lbracket || k == id_lpar)
                return i;
        }
    }
    return TOK_NOT_FOUND;
}

int TkNextClose(Js* e, Tokenizer* tk, int tok) {
    int count = VectorCount(e, tk->tokens);
    for(int i = tok+1; i < count; i++) {
        if(TkGetTokType(e, tk, i) == TOK_KEYWORD) {
            int k = TkGetTokKeyword(e, tk, i);
            if(k == id_rbrace || k == id_rbracket || k == id_rpar)
                return i;
        }
    }
    return TOK_NOT_FOUND;
}

int TkGetMatchingTok(Js* e, Tokenizer* _tk, int tok) {
    if(tok < 0)
        return tok;
    
    Tokenizer* tk = (Tokenizer*) _tk;
    
    // case 1 - not on a keyword
    if(TkGetTokType(e, tk, tok) != TOK_KEYWORD) {
        int t1 = tok;
        tok = TkNextOpen(e, tk, tok);
        if(tok == TOK_NOT_FOUND) {
            return TkNextClose(e, tk, t1);
        }
    }
    
    int k1 = TkGetTokKeyword(e, tk, tok);

    // case 2 - on a keyword but not open or close
    if(k1 != id_lpar && k1 != id_lbracket && k1 != id_lbrace &&
        k1 != id_rpar && k1 != id_rbracket && k1 != id_rbrace) {
        tok = TkNextOpen(e, tk, tok);
        if(tok == TOK_NOT_FOUND)
            return TOK_NOT_FOUND;
    }
    int back = FALSE;
    
    if(k1 == id_rpar || k1 == id_rbracket || k1 == id_rbrace)
        back = TRUE;
    
    int same_count = 0;
    int count = VectorCount(e, tk->tokens);
    if(back) {
        for(int i=tok-1; i >= 0; i--) {
            if(TkIsSameKeyword(e, tk, tok, i))
                same_count++;
            if(tk_is_opposite_keyword(e, tk, tok, i)) {
                same_count--;
                if(same_count < 0)
                    return i;
            }
        }
    }
    else {
        for(int i=tok+1; i < count; i++) {
            if(TkIsSameKeyword(e, tk, tok, i))
                same_count++;
            if(tk_is_opposite_keyword(e, tk, tok, i)) {
                same_count--;
                if(same_count < 0)
                    return i;
            }
        }
    }
    return TOK_NOT_FOUND;
}


int TkGetPrevKeyword(Js* e, Tokenizer* _tk, int tok, int kid) {
    if(tok < 0)
        return tok;
    Tokenizer* tk = (Tokenizer*) _tk;
    for(int i=tok-1; i >= 0; i--) {
        if(TkGetTokType(e, tk, i) != TOK_KEYWORD)
            continue;
        
        if(TkGetTokKeyword(e, tk, i) == kid)
            return i;
    }
    return TOK_NOT_FOUND;
}

int TkGetNextKeyword(Js* e, Tokenizer* _tk, int tok, int kid) {
    if(tok < 0)
        return tok;
    Tokenizer* tk = (Tokenizer*) _tk;
    
    int count = VectorCount(e, tk->tokens);
    for(int i=tok+1; i < count; i++) {
        if(TkGetTokType(e, tk, i) != TOK_KEYWORD)
            continue;
        
        if(TkGetTokKeyword(e, tk, i) == kid)
            return i;
    }
    return TOK_NOT_FOUND;
}

// Return previous or next dot keyword or return TOK_NOT_FOUND
int TkGetPrevDot(Js* e, Tokenizer* tk, int tok) {
    return TkGetPrevKeyword(e, tk, tok, id_dot);
}

int TkGetNextDot(Js* e, Tokenizer* tk, int tok) {
    return TkGetNextKeyword(e, tk, tok, id_dot);
}


bool_t TkIsPunctuator(Js* e,Tokenizer* tk, int tok) {
    if(tok < 0)
        return FALSE;
    
    int type = TkGetTokType(e, tk, tok);
    if(type != TOK_KEYWORD)
        return FALSE;
    
    int kid = TkGetTokKeyword(e, tk, tok);    
    return (kid >= id_lbrace && kid <= id_rbrace);
}


bool_t TkIsDivPunctuator(Js* e,Tokenizer* tk, int tok) {
    if(tok < 0)
        return FALSE;
    int type = TkGetTokType(e, tk, tok);
    if(type != TOK_KEYWORD)
        return FALSE;
    
    int kid = TkGetTokKeyword(e, tk, tok);
    return (kid >= id_div && kid <= id_diveq);
}

bool_t TkIsRightBracePunctuator(Js* e,Tokenizer* tk, int tok) {
    if(tok < 0)
        return FALSE;

    int type = TkGetTokType(e, tk, tok);
    if(type != TOK_KEYWORD)
        return FALSE;    
    int kid = TkGetTokKeyword(e, tk, tok);
    return (kid == id_rbrace);
}

bool_t TkIsFunction(Js* e, Tokenizer* tk, int tok) {
    if(TkGetTokType(e, tk, tok) != TOK_IDENTIFIER)
        return FALSE;
    if(TkGetTokKeyword(e, tk, tok+1) == id_lpar)
        return TRUE;
    return FALSE;
}

bool_t TkIsConst(Js* e, Tokenizer* tk, int tok) {
    if(TkGetTokType(e, tk, tok) != TOK_IDENTIFIER)
        return FALSE;
    int start = TkGetTokOffset(e, tk, tok);
    int end = start + TkGetTokLen(e, tk, tok);
    uchar c = tk->input[start];

    if(c == '#')
        return TRUE;

    if(!TkIsAlpha(c))
        return FALSE;
    for(int i=start; i < end; i++) {
        uchar c = tk->input[i];
        if(TkIsAlpha(c) && c >= 'a' && c <= 'z')
            return FALSE;
    }
    return TRUE;    
}

int TkGetReallocCount(Js* e, Tokenizer* tk) {
    Tokenizer* t = (Tokenizer*) tk;
    
    int count = VectorGetReallocCount(e, t->tokens);
    count += VectorGetReallocCount(e, t->strings);
    count += VectorGetReallocCount(e, t->lines);
    count += VectorGetReallocCount(e, t->matches);
    count += StrmapGetReallocCount(e, t->identifiers);
    
    return count;
}


////////// 6.1.4 - Get the unicode point from a string at a given position
uint32 GetUtf16CodePoint(uchar* chars) {
    uchar c1 = *chars;
    if(!c1)
        return 0;
    
    if( (c1 >= 0 && c1 <= 0xD7ff ) || (c1 >= 0xE000 && c1 <= 0xFFFF) )
        return c1;
       
    uchar c2 = *(chars+1);
    
    if( (c1 >= 0xD800 && c1 <= 0xDBFF) && (c2 >= 0xDC00 && c2 <= 0xDFFF) )
        return (c1 - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;
    
    return c1;
}

bool_t Utf16Encode(uint32 cp, uchar* cu1, uchar* cu2) {
    assert(0 <= cp && cp <= 0x10ffff);
    if(cp <= 65535) {
        *cu1 = cp;
        return FALSE;
    }    
    *cu1 = floor((cp - 65535) / 1024) + 0xD800;
    *cu2 = ((cp - 65535) % 1024) + 0xDC00;
    return TRUE;
}

uint32 Utf16Decode(uchar lead, uchar trail) {
    assert( (0xD800 <= lead) && (lead <= 0xDBFF) && (0xDC00 <= trail) && (trail <= 0xDFFF));
    uint32 l = (uint32) lead;
    uint32 t = (uint32) trail;
    uint32 cp = (l - 0xD800)*1024 + (t - 0xDC00) + 0x10000;
    return cp;
}



///////// Property
bool_t PropHas(Js* e, Property* p, uint32 yes, uint32 no) {
    uint32 f = yes | no;
    if(p->flags & f)
        return TRUE;
    return FALSE;
}

void PropSet(Js* e, Property* p, uint32 yes, uint32 no, bool_t v) {
    if(v) {
        p->flags &= ~no;
        p->flags |= yes;
    }
    else {
        p->flags &= ~yes;
        p->flags |= no;
    }
}

bool_t PropIs(Js* e, Property* p, uint32 f) {
    return ( (p->flags & f) != 0);
}

bool_t PropHasWritable(Js* e, Property* p) {
    return PropHas(e, p, PROP_WRITEABLE, PROP_NOT_WRITEABLE);
}

void PropSetWritable(Js* e, Property* p, bool_t w) {
    return PropSet(e, p, PROP_WRITEABLE, PROP_NOT_WRITEABLE, w);
}

bool_t PropIsWritable(Js* e, Property* p) {
    return PropIs(e, p, PROP_WRITEABLE);
}

bool_t PropHasEnumerable(Js* e, Property* p) {
    return PropHas(e, p, PROP_ENUMERABLE, PROP_NOT_ENUMERABLE);
}

void PropSetEnumerable(Js* e, Property* p, bool_t w) {
    return PropSet(e, p, PROP_ENUMERABLE, PROP_NOT_ENUMERABLE, w);
}

bool_t PropIsEnumerable(Js* e, Property* p) {
    return PropIs(e, p, PROP_ENUMERABLE);
}


bool_t PropHasConfigurable(Js* e, Property* p) {
    return PropHas(e, p, PROP_CONFIGURABLE, PROP_NOT_CONFIGURABLE);
}

void PropSetConfigurable(Js* e, Property* p, bool_t w) {
    return PropSet(e, p, PROP_CONFIGURABLE, PROP_NOT_CONFIGURABLE, w);
}

bool_t PropIsConfigurable(Js* e, Property* p) {
    return PropIs(e, p, PROP_CONFIGURABLE);
}



void PropInit(Js* e, Property* p) {
    p->value = NULL;
    p->get = NULL;
    p->set = NULL;
    p->flags = 0;
    p->next = NULL;
    p->name = NULL;
    p->origin = NULL;
}

void PropClear(Js* e, Property* p) {
    if(p->value)
        ValDel(e, p->value);
    if(p->get)
        ValDel(e, p->get);
    if(p->set)
        ValDel(e, p->set);
    if(p->name && p->ownName)
        ValDel(e, p->name);
    if(p->origin)
        ValDel(e, p->origin);
    p->flags = 0;
    p->name = NULL;
    p->ownName = FALSE;
    p->value = NULL;
    p->set = NULL;
    p->get = NULL;
    p->origin = NULL;
    p->next = NULL;
}

Property* PropNew(Js* e) {
    Property* p = (Property*) halloc(e->memory[PR].data);
    PropInit(e, p);
    return p;
}

void PropDel(Js* e, Property* p) {
    PropClear(e, p);
    hfree(e->memory[PR].data, p);
}

Property* PropClone(Js* e, Property* p) {
    Property* r = PropNew(e);
    r->ownName = TRUE;
    r->name = ValClone(e, p->name);
    r->value = ValClone(e, p->value);
    r->flags = p->flags;
    r->set = ValClone(e, p->set);
    r->get = ValClone(e, p->get);
    r->origin = ValClone(e, p->origin);
    return r;
}

bool_t PropEq(Js* e, Property* p1, Property* p2) {
    if(p1->flags != p2->flags)
        return FALSE;
    
    Val* r = SameValue(e, p1->value, p2->value);
    if(!ValIsTrueDel(e, r))
        return FALSE;
    
    r = SameValue(e, p1->set, p2->set);
    if(!ValIsTrueDel(e, r))
        return FALSE;

    r = SameValue(e, p1->get, p2->get);
    if(!ValIsTrueDel(e, r))
        return FALSE;
    
    r = SameValue(e, p1->origin, p2->origin);
    if(!ValIsTrueDel(e, r))
        return FALSE;

    r = SameValue(e, p1->name, p2->name);
    if(!ValIsTrueDel(e, r))
        return FALSE;

    return TRUE;
}


void PropSetName(Js* e, Property* p, Val* n, bool_t own) {
    if(p->name && p->ownName)
        ValDel(e, p->name);
    
    p->ownName = own;
    if(p->ownName) {
        p->name = ValClone(e, n);
    }
    else {
        p->name = n;
    }
}

void PropSetValue(Js* e, Property* p, Val* v) {
    ValAssign(e, &p->value, v);
}

Val* _PropGetValue(Js* e, Property* p, int line) {
    return _ValClone(e, p->value, line);
}

Val* DescNew(Js* e, Val* v, bool_t c, bool_t en, bool_t w, bool_t del_v) {
    Val* d = ValNewDesc(e);
    PropSetEnumerable(e, d->desc, en);
    PropSetConfigurable(e, d->desc, c);
    PropSetWritable(e, d->desc, w);
    PropSetValue(e, d->desc, v);
    if(del_v) ValDel(e, v);
    return d;
}

////// 6.2.4
bool_t IsAccessorDesc(Js* e, Property* p) {
    if(!p)
        return FALSE;
    if(p->set == NULL && p->get == NULL)
        return FALSE;
    return TRUE;
}

bool_t IsDataDesc(Js* e, Val* v) {
    if(!v) return FALSE;
    if(v->type != TYPE_DESC && v->type != TYPE_DESC) return FALSE;
    return PropIsData(e, v->desc);
}

bool_t PropIsData(Js* e, Property* p) {
    if(!p)
        return FALSE;
    if(p->value == NULL && ! PropHasWritable(e, p))
        return FALSE;
    return TRUE;
}

bool_t PropIsGeneric(Js* e, Property* p) {
    if(!p)
        return FALSE;
    if(!IsAccessorDesc(e, p) && !PropIsData(e, p))
        return TRUE;
    return FALSE;
}

void define_own_propa(Js* e, Val* o, char* n, Val* v, bool_t wr, bool_t en, bool_t cf) {
    Val* d = ValNewDesc(e);
    PropSetValue(e, d->desc, v);
    if(wr)
        PropSetWritable(e, d->desc, wr);
    if(en)
        PropSetEnumerable(e, d->desc, en);
    if(cf)
        PropSetConfigurable(e, d->desc, cf);
    Val* p = ValNewStrA(e, n);
    PropSetName(e, d->desc, p, TRUE);
    Val* ret = OrdinaryDefineOwnProperty(e, o, p, d);
    ValDel(e, p);
    ValDel(e, d);
    ValDel(e, ret);
}

Val* FromPropertyDesc(Js* e, Val* prop) {
    if(ValIsUndef(prop))
        return ValClone(e, prop);
    Property* p = prop->desc;
    if(!p)
        return ValNew(e);
    if(p->origin)
        return ValClone(e, p->origin);
    Val* obj = ValNewObject(e);
    if(p->value)
        define_own_propa(e, obj, "value", p->value, TRUE, TRUE, TRUE);

    if(PropHasWritable(e,p)) {
        Val* bv = ValNewBool(e, PropIsWritable(e,p));
        define_own_propa(e, obj, "writable", bv, TRUE, TRUE, TRUE);
        ValDel(e, bv);
    }
    if(p->get)
        define_own_propa(e, obj, "get", p->get, TRUE, TRUE, TRUE);
    if(p->set)
        define_own_propa(e, obj, "set", p->set, TRUE, TRUE, TRUE);
    if(PropHasEnumerable(e,p)) {
        Val* bv = ValNewBool(e, PropIsEnumerable(e,p));
        define_own_propa(e, obj, "enumerable", bv, TRUE, TRUE, TRUE);
        ValDel(e, bv);
    }
    if(PropHasConfigurable(e,p)) {
        Val* bv = ValNewBool(e, PropIsConfigurable(e,p));
        define_own_propa(e, obj, "configurable", bv, TRUE, TRUE, TRUE);
        ValDel(e, bv);
    }
    return obj;
}


Val* ToPropertyDesc(Js* e, Val* obj) {
    RET_IF_ABRUPT(obj);
    if(obj->type != TYPE_OBJ)
        return ThrowTypeError(e, "Not an object", 0,0);
    Val* desc = ValNewDesc(e);
    Property* p = desc->desc;

    if(HasA(e, obj, "enumerable")) {
        Val* en = GetA(e, obj, "enumerable");
        RET_IF_ABRUPT_CV1(en, desc);
        Val* b = ToBoolean(e, en);
        PropSetEnumerable(e,p, b->b);
        ValDel(e, b);
        ValDel(e, en);
    }
    
    if(HasA(e, obj, "configurable")) {
        Val* cf = GetA(e, obj, "configurable");
        RET_IF_ABRUPT_CV1(cf, desc);
        Val* b = ToBoolean(e, cf);
        PropSetConfigurable(e,p,b->b);
        ValDel(e, b);
        ValDel(e, cf);
    }
    if(HasA(e, obj, "value")) {
        Val* Val = GetA(e, obj, "value");
        RET_IF_ABRUPT_CV1(Val, desc);
        p->value = Val;         // it's a clone so no need to clone
    }
    
    if(HasA(e, obj, "writable")) {
        Val* writable = GetA(e, obj, "writable");
        RET_IF_ABRUPT_CV1(writable, desc);
        Val* b = ToBoolean(e, writable);
        PropSetWritable(e,p, b->b);
        ValDel(e, b);
        ValDel(e, writable);
    }
    
    if(HasA(e, obj, "get")) {
        Val* getter = GetA(e, obj, "get");
        RET_IF_ABRUPT_CV1(getter, desc);
        if(getter->type != TYPE_UNDEF && !IsCallableBool(e, getter)) {
            ValDel(e, getter);
            ValDel(e, desc);
            return ThrowTypeError(e, "getter not callable", 0,0);
        }
        p->get = getter;        // no need to clone and delete
    }

    if(HasA(e, obj, "set")) {
        Val* setter = GetA(e, obj, "set");
        RET_IF_ABRUPT_CV1(setter, desc);
        if(setter->type != TYPE_UNDEF && !IsCallableBool(e, setter)) {
            ValDel(e, setter);
            ValDel(e, desc);
            return ThrowTypeError(e, "setter not callable",0,0);
        }
        p->set = setter;        // no need to clone and delete
    }
    
    if(p->set || p->get) {
        if(p->value || PropIsWritable(e,p)) {
            ValDel(e, desc);
            return ThrowTypeError(e, "property writable", 0,0);
        }
    }
    p->origin = ValClone(e, obj);
    return desc;
}

bool_t IsDesc(Val* v) {
    return v->type == TYPE_DESC;
}

Val* CompletePropertyDesc(Js* e, Val* desc, Val* like) {
    assert(IsDesc(like) || like->type == TYPE_UNDEF);
    RET_IF_ABRUPT(desc);
    assert(IsDesc(desc));
    
    bool_t delLike = FALSE;
    if(like->type == TYPE_UNDEF) {
        delLike = TRUE;
        like = ValNewDesc(e);
    }
    
    Property* p = desc->desc;
    if(PropIsGeneric(e, p) || PropIsData(e, p)) {
        if(!p->value)
            p->value = ValClone(e, like->desc->value);
        if(! PropHasWritable(e,p))
            PropSetWritable(e, p, PropIsWritable(e, like->desc));
    }
    else {
        if(!p->get)
            p->get = ValClone(e, like->desc->get);
        if(!p->set)
            p->set = ValClone(e, like->desc->set);
    }
    if(! PropHasEnumerable(e, p))
        PropSetEnumerable(e, p, PropIsEnumerable(e, like->desc));
    if(! PropHasConfigurable(e, p))
        PropSetConfigurable(e, p, PropIsConfigurable(e, like->desc));
    
    if(delLike)
        ValDel(e, like);
    return desc;
}

////////// methods
Val* DoGetPrototypeOf(Js* e, Val* o) {
    GetPrototypeOfPtr func = (GetPrototypeOfPtr) ObjectGetMethod(e, o->obj, _GetPrototypeOf_);
    if(!func)
        return OrdinaryGetPrototypeOf(e, o);
    return func(e, o);
}

Val* DoSetPrototypeOf(Js* e, Val* o, Val* proto) {
    SetPrototypeOfPtr func = (SetPrototypeOfPtr) ObjectGetMethod(e, o->obj, _SetPrototypeOf_);
    if(!func)
        return OrdinarySetPrototypeOf(e, o, proto);
    return func(e, o, proto);

}

Val* DoIsExtensible(Js* e, Val* o) {
    IsExtensiblePtr func = (IsExtensiblePtr) ObjectGetMethod(e, o->obj, _IsExtensible_);
    if(!func)
        return OrdinaryIsExtensible(e, o);
    return func(e, o);
}

Val* DoPreventExtensions(Js* e, Val* o) {
    PreventExtensionsPtr func = (PreventExtensionsPtr) ObjectGetMethod(e, o->obj, _PreventExtensions_);
    if(!func)
        return OrdinaryPreventExtensions(e, o);
    return func(e, o);
}

Val* DoGetOwnProperty(Js* e, Val* o, Val* key) {
    GetOwnPropertyPtr func = (GetOwnPropertyPtr) ObjectGetMethod(e, o->obj, _GetOwnProperty_);
    if(!func)
        return OrdinaryGetOwnProperty(e, o, key);
    return func(e, o, key);
}

Val* DoHasProperty(Js* e, Val* o, Val* key) {
    HasPropertyPtr func = (HasPropertyPtr) ObjectGetMethod(e, o->obj, _HasProperty_);
    if(!func)
        return OrdinaryHasProperty(e, o, key);
    return func(e, o, key);
}

Val* DoGet(Js* e, Val* o, Val* key, Val* receiver) {
    GetPtr func = (GetPtr) ObjectGetMethod(e, o->obj, _Get_);
    if(!func)
        return OrdinaryGet(e, o, key, receiver);
    return func(e, o, key, receiver);
}

Val* DoSet(Js* e, Val* o, Val* key, Val* v, Val* receiver) {
    SetPtr func = (SetPtr) ObjectGetMethod(e, o->obj, _Set_);
    if(!func)
        return OrdinarySet(e, o, key, v, receiver);
    return func(e, o, key, v, receiver);
}

Val* DoDelete(Js* e, Val* o, Val* key) {
    DeletePtr func = (DeletePtr) ObjectGetMethod(e, o->obj, _Delete_);
    if(!func)
        return OrdinaryDelete(e, o, key);
    return func(e, o, key);
}

Val* DoDefineOwnProperty(Js* e, Val* o, Val* key, Val* desc) {
    DefineOwnPropertyPtr func = (DefineOwnPropertyPtr) ObjectGetMethod(e, o->obj, _DefineOwnProperty_);
    if(!func)
        return OrdinaryDefineOwnProperty(e, o, key, desc);
    return func(e, o, key, desc);
}

Val* DoEnumerate(Js* e, Val* o) {
    EnumeratePtr func = (EnumeratePtr) ObjectGetMethod(e, o->obj, _Enumerate_);
    if(!func)
        return OrdinaryEnumerate(e, o);
    return func(e, o);
}

Val* DoOwnPropertyKeys(Js* e, Val* o) {
    OwnPropertyKeysPtr func = (OwnPropertyKeysPtr) ObjectGetMethod(e, o->obj, _OwnPropertyKeys_);
    if(!func)
        return OrdinaryOwnPropertyKeys(e, o);
    return func(e, o);
}

Val* DoCall(Js* e, Val* o, Val* othis, Val* args) {
    CallPtr func = (CallPtr) ObjectGetMethod(e, o->obj, _Call_);
    if(!func)
        return OrdinaryCall(e, o, othis, args);
    return func(e, o, othis, args);
}

Val* DoConstruct(Js* e, Val* o, Val* args, Val* newTarget) {
    ConstructPtr func = (ConstructPtr) ObjectGetMethod(e, o->obj, _Construct_);
    if(!func)
        return OrdinaryConstruct(e, o, args);
    return func(e, o, args, newTarget);
}



//////// object
void ObjectSetMethod(Js* e, Object* o, char* key, void* value, bool_t check) {
    Property* ret = NULL;
    if(check) {
        ret = ObjectGetMethodRef(e, o, key);
    }

    if(!ret) {
        ret = PropNew(e);
        ret->next = o->methods;
        o->methods = ret;
        Val vkey;
        ValInitSymbol(e, &vkey, key);
        PropSetName(e, ret, &vkey, TRUE);
    }
    Val* v = ValNewPtr(e, value);
    PropSetValue(e, ret, v);
    ValDel(e, v);
}

void* ObjectGetMethod(Js* e, Object* o, char* key) {
    for(Property* m = o->methods; m != NULL; m = m->next) {
        assert(m->name->type == TYPE_SYMA);
        assert(m->value->type == TYPE_PTR);
        if(m->name->descA == key)
            return m->value->ptr;
    }
    return NULL;
}

Property* ObjectGetMethodRef(Js* e, Object* o, char* key) {
    for(Property* m = o->methods; m != NULL; m = m->next) {
        assert(m->name->type == TYPE_SYMA);
        assert(m->value->type == TYPE_PTR);
        if(m->name->descA == key)
            return m;
    }
    return NULL;
}

void ObjectSetSlot(Js* e, Object* o, char* key, Val* v, bool_t check, bool_t delv) {
    Property* ret = NULL;
    if(check) {
        ret = ObjectGetSlotRef(e, o, key);
    }

    if(!ret) {
        ret = PropNew(e);
        ret->next = o->slots;
        o->slots = ret;
        Val vkey;
        ValInitSymbol(e, &vkey, key);
        PropSetName(e, ret, &vkey, TRUE);
    }
    PropSetValue(e, ret, v);
    if(delv) ValDel(e, v);
}

void ObjectSetSlotNoCopy(Js* e, Object* o, char* key, Val* v, bool_t check) {
    Property* ret = NULL;
    if(check) {
        ret = ObjectGetSlotRef(e, o, key);
    }

    if(!ret) {
        ret = PropNew(e);
        ret->next = o->slots;
        o->slots = ret;
        Val vkey;
        ValInitSymbol(e, &vkey, key);
        PropSetName(e, ret, &vkey, TRUE);
    }
    ValDel(e, ret->value);
    ret->value = v;
}

Val* ObjectGetSlot(Js* e, Object* o, char* key) {
    for(Property* s = o->slots; s != NULL; s = s->next) {
        assert(s->name->type == TYPE_SYMA);
        if(s->name->descA == key)
            return s->value;
    }
    return NULL;
}

Val* ObjectGetSlotUndef(Js* e, Object* o, char* key) {
    Val* ret = ObjectGetSlot(e, o, key);
    if(ret) return ValClone(e, ret);
    return ValNew(e);
}

void *ObjectGetSlotPtr(Js* e, Val* o, char* key) {
    if(o->type == TYPE_NULL)
        return NULL;
    assert(o->type == TYPE_OBJ);
    Val* vp = ObjectGetSlot(e, o->obj, key);
    if(!vp)
        return NULL;
    assert(vp->type == TYPE_PTR);
    return vp->ptr;
}

Property* ObjectGetSlotRef(Js* e, Object* o, char* key) {
    for(Property* s = o->slots; s != NULL; s = s->next) {
        assert(s->name->type == TYPE_SYMA);
        if(s->name->descA == key)
            return s;
    }
    return NULL;
}

uint32 Retain(Js* e, Object* o) {
    o->refs++;
    return o->refs;
}

uint32 Release(Js* e, Object* o) {
    // if the object is already _free, we don't do anything here
    if(o->flags == OBJ_FREE)
        return 0;
    
    o->refs--;
    if(o->refs == 0) {
        ObjectDelete(e, o);
        return 0;
    }
    return o->refs;
}

Object* _ObjectNew(Js* e, int line) {
    Object* o = (Object*) _halloc(e->memory[OB].data, line);
    ObjectInit(e, o);
    return o;
}

void ObjectPrint(Js* e, Object* o, bool_t detail) {
    jprintf(e,0,"%s[object %d%s]", e->colors.green, ID(o), (MARKED(o)) ? " marked" : "");
    if(!detail) {
        //jprintf(e, 0, "\n");
        return;
    }
    
    if(!o->properties) {
        jprintf(e,0,"{}");
        return;
    }
    
    jprintf(e,0," {\n");
    for(Property* p = o->properties; p; p = p->next) {
        char* pn8 = NULL;
        bool_t sym = FALSE;
        if(p->name->type == TYPE_SYMA) {
            sym = TRUE;
            pn8 = p->name->descA;
        }
        else 
            pn8 = StrDecode(e, p->name->str);
        jprintf(e,0,"   %s: ", pn8);
        if(!sym)
            hfree(e->memory[ST].data, pn8);
        ValPrint(e, p->value, FALSE,-1);
        jprintf(e,0,"%s", (p->next) ? ",\n" : "");
    }
    jprintf(e,0,"\n}\n");
}

void ObjectSetFlag(Js* e, Object* o, uint32 flag) {
    o->flags |= flag;
}

void ObjectClearFlag(Js* e, Object* o, uint32 flag) {
    o->flags &= ~flag;
}

bool_t ObjectHasFlag(Js* e, Object* o, uint32 flag) {
    return ((o->flags & flag) != 0);
}


void ObjectSetProto(Js* e, Val* o, Val* proto) {
    assert(proto);
    assert(o->type == TYPE_OBJ);
    Val* ret = DoSetPrototypeOf(e, o, proto);
    ValDel(e, ret);
}

void ObjectInit(Js* e, Object* o) {
    o->properties = NULL;
    o->tail = NULL;
    o->flags = e->nextObject++;
    ObjectSetFlag(e, o, OBJ_EXTENSIBLE);
    o->prototype = ValNewNull(e);
    o->methods = NULL;
    o->slots = NULL;
    o->refs = 1;
}

void ObjectClear(Js* e, Object* o) {
    Property* p = o->properties;
    
    while(p != NULL) {
        Property* next = p->next;
        PropDel(e, p);
        p = next;
    }

    ValDel(e, o->prototype);
    
    for(Property* m = o->methods; m; ) {
        Property* n = m->next;
        PropDel(e, m);
        m = n;
    }
    
    for(Property* s = o->slots; s; ) {
        Property* n = s->next;
        PropDel(e, s);
        s = n;
    }
}

void ObjectDelete(Js* e, Object* o) {
    if(o->flags == OBJ_FREE)
        return;
    
//    printf("deleting %d\n", ID(o));
    // If the object has a destructor we call it
    CollectPtr destructor = ObjectGetMethod(e, o, _Destruct_);
    if(destructor) {
        destructor(e, o);
    }
    // Set the flag before we clear so we can handle cycles
    o->flags = OBJ_FREE;
    ObjectClear(e, o);
    hfree(e->memory[OB].data, o);
}

bool_t ObjectSetANum(Js* e, Val* o, char* name, number n) {
    if(o->type != TYPE_OBJ)
        return FALSE;
    Val* uname = ValNewStrA(e, name);
    Val vn;
    ValInitNum(&vn, n);
    Val* ret = DoSet(e, o, uname, &vn, o);
    ValDel(e, uname);
    bool_t rb = ret->b;
    ValDel(e, ret);
    return rb;
}

bool_t ObjectIs(Js* e, Val* o, Val* constructor) {
    if(o->type != TYPE_OBJ) return FALSE;
    Val* consProto = DoGet(e, constructor, e->prototype, NULL);
    Val* ret = SameValue(e, o->obj->prototype, consProto);
    ValDel(e, consProto);
    return ValIsTrueDel(e, ret);
    // @todo - use OrdinaryHasInstance()?
//    Val* ret = OrdinaryHasInstance(e, constructor, o);
//    return ValIsTrueDel(e, ret);
}

bool_t ValIsThrow(Js* e, Val* o, Val* cons) {
    if(o->type != TYPE_COMP)
        return FALSE;
    if(o->completion->type != COMP_THROW)
        return FALSE;
    if(o->completion->value->type != TYPE_OBJ)
        return FALSE;
    return ObjectIs(e, o->completion->value, cons);
}




/////// 6.1.7.4 well known intrinsic objects

Val* NativeFuncNew(Js* e, Val* proto, StepsPtr call) {
    Val* f = ObjectCreate(e, proto, NULL);
    ObjectSetMethod(e, f->obj, _Call_, call, FALSE);
    return f;
}


void TypeRegister(Js* e, Realm* realm, char* name, StepsPtr create, Val** obj, Val** proto) {
    if(!*proto) {
        *proto = ValNewObject(e);
        ValDel(e, DoSetPrototypeOf(e, *proto, realm->objectPrototype));
    }
    *obj = ValNewObject(e);
    Val* o = *obj;
    if(create) {        ////// Set the "prototype" and @@creator properties
        Val* r = DoSet(e, o, e->prototype, *proto, o);
        ValDel(e, r);
    }
    if(name) {          ////// Set the global name if supplied
        Val* n = ValNewStrA(e, name);
        LexEnv* le = (LexEnv*) realm->globalEnv->env;
        Env* ge = le->envRec;
        Val* r = ge->vtable->createGlobalVarBinding(e, ge, n, FALSE);
        ValDel(e, r);
        r = ge->vtable->setMutableBinding(e, ge, n, o, FALSE);
        ValDel(e, r);
        ValDel(e, n);
    }
}


Val* ObjProto_toStringCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ValNew(e);  // @todo: implement
}

Val* FunctionConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
Val* BooleanConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
Val* NumberConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
Val* StringConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
Val* ArrayConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
Val* RegExpConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget);
//////// Realm
void RealmInitIntrinsics(Js* e, Realm* i) {
    TypeRegister(e, i, NULL /*Object*/,          ObjectConstructor, &i->objectConstructor,    &i->objectPrototype);
    TypeRegister(e, i, NULL /*Function*/,        ObjectConstructor, &i->functionConstructor,  &i->functionPrototype);
    TypeRegister(e, i, NULL /*Boolean*/,  ObjectConstructor, &i->booleanObject,        &i->booleanPrototype);
    TypeRegister(e, i, NULL /*Array*/,           ObjectConstructor, &i->arrayConstructor,     &i->arrayPrototype);
    TypeRegister(e, i, NULL /* String*/,          ObjectConstructor, &i->stringConstructor,    &i->stringPrototype);
    TypeRegister(e, i, NULL /*Number*/,          ObjectConstructor, &i->numberObject,         &i->numberPrototype);
    TypeRegister(e, i, NULL /*Date*/,            ObjectConstructor, &i->dateObject,           &i->datePrototype);
    TypeRegister(e, i, NULL /* RegExp */,   ObjectConstructor, &i->regExpConstructor,         &i->regExpPrototype);
    TypeRegister(e, i, "Map",             ObjectConstructor, &i->mapObject,            &i->mapPrototype);
    TypeRegister(e, i, "WeakMap",         ObjectConstructor, &i->weakMapObject,        &i->weakMapPrototype);
    TypeRegister(e, i, "Set",             ObjectConstructor, &i->setObject,            &i->setPrototype);
    TypeRegister(e, i, "WeakSet",         ObjectConstructor, &i->weakSetObject,        &i->weakSetPrototype);
    TypeRegister(e, i, "Generator",       ObjectConstructor, &i->generatorObject,      &i->generatorPrototype);
    TypeRegister(e, i, NULL /*Error*/,           ObjectConstructor, &i->errorObject,          &i->errorPrototype);
    TypeRegister(e, i, NULL /*EvalError*/,       ObjectConstructor, &i->evalErrorObject,      &i->evalErrorPrototype);
    TypeRegister(e, i, NULL/*RangeError*/,      ObjectConstructor, &i->rangeErrorObject,     &i->rangeErrorPrototype);
    TypeRegister(e, i, NULL/*ReferenceError*/,  ObjectConstructor, &i->referenceErrorObject, &i->referenceErrorPrototype);
    TypeRegister(e, i, NULL/*SyntaxError*/,     ObjectConstructor, &i->syntaxErrorObject,    &i->syntaxErrorPrototype);
    TypeRegister(e, i, NULL/*TypeError*/,       ObjectConstructor, &i->typeErrorObject,      &i->typeErrorPrototype);
    TypeRegister(e, i, NULL/*URIError*/,        ObjectConstructor, &i->uriErrorObject,       &i->uriErrorPrototype);

    TypeRegister(e, i, NULL /*"ArrayBuffer"*/,     ObjectConstructor, &i->arrayBufferConstructor,    &i->arrayBufferPrototype);
    TypeRegister(e, i, "TypedArray",      ObjectConstructor, &i->typedArrayObject,     &i->typedArrayPrototype);
    TypeRegister(e, i, NULL /*Int8Array*/,       ObjectConstructor, &i->int8ArrayObject,      &i->int8ArrayPrototype);
    
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->uint8ArrayObject,      &i->uint8ArrayPrototype);
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->uint8ClampedArrayObject,      &i->uint8ClampedArrayPrototype);
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->int16ArrayObject,      &i->int16ArrayPrototype);
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->uint16ArrayObject,      &i->uint16ArrayPrototype);
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->int32ArrayObject,      &i->int32ArrayPrototype);
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->uint32ArrayObject,      &i->uint32ArrayPrototype);    
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->float32ArrayObject,      &i->float32ArrayPrototype);    
    TypeRegister(e, i, NULL ,       ObjectConstructor, &i->float64ArrayObject,      &i->float64ArrayPrototype);        

    TypeRegister(e, i, "DataView",        ObjectConstructor, &i->dataViewObject,       &i->dataViewPrototype);
    TypeRegister(e, i, NULL, /*"Symbol"*/          ObjectConstructor, &i->symbolConstructor,    &i->symbolPrototype);
    
    i->objProto_toString =              NativeFuncNew(e, i->objectPrototype, ObjProto_toStringCall);
    i->throwTypeErrorFunction =         NativeFuncNew(e, i->objectPrototype, ThrowTypeErrorCall);
    Val* R = DoPreventExtensions(e, i->throwTypeErrorFunction);
    ValDel(e, R);
    
    i->arrayIteratorPrototype =         ObjectCreate(e, i->objectPrototype, NULL);
    i->stringIteratorPrototype =        ObjectCreate(e, i->objectPrototype, NULL);
    i->mapIteratorPrototype =           ObjectCreate(e, i->objectPrototype, NULL);
    i->setIteratorPrototype =           ObjectCreate(e, i->objectPrototype, NULL);
    i->generatorFunctionObject =        ObjectCreate(e, i->objectPrototype, NULL);
}

void RealmDeleteIntrinsics(Js* e, Realm* i) {
    ValDel(e, i->typedArrayIntrinsic);

    ValDel(e, i->objectConstructor);
    
    ValDel(e, i->functionConstructor);
    ValDel(e, i->functionPrototype);
    
    ValDel(e, i->arrayConstructor);
    ValDel(e, i->arrayPrototype);
    
    ValDel(e, i->stringConstructor);
    ValDel(e, i->stringPrototype);
    
    ValDel(e, i->booleanObject);
    ValDel(e, i->booleanPrototype);
    
    ValDel(e, i->numberObject);
    ValDel(e, i->numberPrototype);
    
    ValDel(e, i->dateObject);
    ValDel(e, i->datePrototype);
    
    ValDel(e, i->regExpConstructor);
    ValDel(e, i->regExpPrototype);
    
    ValDel(e, i->mapObject);
    ValDel(e, i->mapPrototype);
    
    ValDel(e, i->weakMapObject);
    ValDel(e, i->weakMapPrototype);
    
    ValDel(e, i->setObject);
    ValDel(e, i->setPrototype);
    
    ValDel(e, i->weakSetObject);
    ValDel(e, i->weakSetPrototype);
    
    
    ValDel(e, i->generatorObject);
    ValDel(e, i->generatorPrototype);
    
    ValDel(e, i->errorObject);
    ValDel(e, i->errorPrototype);
    
    ValDel(e, i->evalErrorObject);
    ValDel(e, i->evalErrorPrototype);
    
    ValDel(e, i->rangeErrorObject);
    ValDel(e, i->rangeErrorPrototype);
    
    ValDel(e, i->referenceErrorObject);
    ValDel(e, i->referenceErrorPrototype);
    
    ValDel(e, i->syntaxErrorObject);
    ValDel(e, i->syntaxErrorPrototype);
    
    ValDel(e, i->typeErrorObject);
    ValDel(e, i->typeErrorPrototype);
    
    ValDel(e, i->uriErrorObject);
    ValDel(e, i->uriErrorPrototype);
    
    ValDel(e, i->arrayBufferConstructor);
    ValDel(e, i->arrayBufferPrototype);
    
    ValDel(e, i->typedArrayObject);
    ValDel(e, i->typedArrayPrototype);
    
    ValDel(e, i->int8ArrayObject);
    ValDel(e, i->int8ArrayPrototype);

    ValDel(e, i->uint8ArrayObject);
    ValDel(e, i->uint8ArrayPrototype);
    ValDel(e, i->uint8ClampedArrayObject);
    ValDel(e, i->uint8ClampedArrayPrototype);
    ValDel(e, i->int16ArrayObject);
    ValDel(e, i->int16ArrayPrototype);
    ValDel(e, i->uint16ArrayObject);
    ValDel(e, i->uint16ArrayPrototype);
    ValDel(e, i->int32ArrayObject);
    ValDel(e, i->int32ArrayPrototype);
    ValDel(e, i->uint32ArrayObject);
    ValDel(e, i->uint32ArrayPrototype);
    ValDel(e, i->float32ArrayObject);
    ValDel(e, i->float32ArrayPrototype);
    ValDel(e, i->float64ArrayObject);
    ValDel(e, i->float64ArrayPrototype);

    ValDel(e, i->dataViewObject);
    ValDel(e, i->dataViewPrototype);
    
    
    ValDel(e, i->symbolConstructor);
    ValDel(e, i->symbolPrototype);
    
    ValDel(e, i->objProto_toString);
    ValDel(e, i->throwTypeErrorFunction);
    ValDel(e, i->arrayIteratorPrototype);
    ValDel(e, i->stringIteratorPrototype);
    ValDel(e, i->mapIteratorPrototype);
    ValDel(e, i->setIteratorPrototype);
    ValDel(e, i->generatorFunctionObject);
    
    ValDel(e, i->objectPrototype);
}

Val* RealmGetIntrinsic(Js* e, Realm* r, Val* name) {
    assert(name->type == TYPE_STR);
    if(StrEqChars(e, name->str, "%objectPrototype%")) return ValClone(e, r->objectPrototype);
    if(StrEqChars(e, name->str, "%stringPrototype%")) return ValClone(e, r->stringPrototype);
    if(StrEqChars(e, name->str, "%Object%")) return ValClone(e, r->objectConstructor);
    if(StrEqChars(e, name->str, "%Function%")) return ValClone(e, r->functionConstructor);
    if(StrEqChars(e, name->str, "%functionPrototype%")) return ValClone(e, r->functionPrototype);
    if(StrEqChars(e, name->str, "%Array%")) return ValClone(e, r->arrayConstructor);
    if(StrEqChars(e, name->str, "%arrayPrototype%")) return ValClone(e, r->arrayPrototype);
    if(StrEqChars(e, name->str, "%String%")) return ValClone(e, r->stringConstructor);
    if(StrEqChars(e, name->str, "%stringPrototype%")) return ValClone(e, r->stringPrototype);
    if(StrEqChars(e, name->str, "%Boolean%")) return ValClone(e, r->booleanObject);
    if(StrEqChars(e, name->str, "%booleanPrototype%")) return ValClone(e, r->booleanPrototype);
    if(StrEqChars(e, name->str, "%Number%")) return ValClone(e, r->numberObject);
    if(StrEqChars(e, name->str, "%Date%")) return ValClone(e, r->dateObject);
    if(StrEqChars(e, name->str, "%datePrototype%")) return ValClone(e, r->datePrototype);
    if(StrEqChars(e, name->str, "%RegExp%")) return ValClone(e, r->regExpConstructor);
    if(StrEqChars(e, name->str, "%regExpPrototype%")) return ValClone(e, r->regExpPrototype);
    if(StrEqChars(e, name->str, "%Map%")) return ValClone(e, r->mapObject);
    if(StrEqChars(e, name->str, "%mapPrototype%")) return ValClone(e, r->mapPrototype);
    if(StrEqChars(e, name->str, "%WeakMap%")) return ValClone(e, r->weakMapObject);
    if(StrEqChars(e, name->str, "%weakMapPrototype%")) return ValClone(e, r->weakMapPrototype);
    if(StrEqChars(e, name->str, "%Set%")) return ValClone(e, r->setObject);
    if(StrEqChars(e, name->str, "%setPrototype%")) return ValClone(e, r->setPrototype);
    if(StrEqChars(e, name->str, "%WeakSet%")) return ValClone(e, r->weakSetObject);
    if(StrEqChars(e, name->str, "%weakSetPrototype%")) return ValClone(e, r->weakSetPrototype);
    if(StrEqChars(e, name->str, "%Generator%")) return ValClone(e, r->generatorObject);
    if(StrEqChars(e, name->str, "%generatorPrototype%")) return ValClone(e, r->generatorPrototype);
    if(StrEqChars(e, name->str, "%Error%")) return ValClone(e, r->errorObject);
    if(StrEqChars(e, name->str, "%errorPrototype%")) return ValClone(e, r->errorPrototype);
    if(StrEqChars(e, name->str, "%EvalError%")) return ValClone(e, r->evalErrorObject);
    if(StrEqChars(e, name->str, "%evalErrorPrototype%")) return ValClone(e, r->evalErrorPrototype);
    if(StrEqChars(e, name->str, "%RangeError%")) return ValClone(e, r->rangeErrorObject);
    if(StrEqChars(e, name->str, "%rangeErrorPrototype%")) return ValClone(e, r->rangeErrorPrototype);
    if(StrEqChars(e, name->str, "%ReferenceError%")) return ValClone(e, r->referenceErrorObject);
    if(StrEqChars(e, name->str, "%referenceErrorPrototype%")) return ValClone(e, r->referenceErrorPrototype);
    if(StrEqChars(e, name->str, "%SyntaxError%")) return ValClone(e, r->syntaxErrorObject);
    if(StrEqChars(e, name->str, "%syntaxErrorPrototype%")) return ValClone(e, r->syntaxErrorPrototype);
    if(StrEqChars(e, name->str, "%TypeError%")) return ValClone(e, r->typeErrorObject);
    if(StrEqChars(e, name->str, "%typeErrorPrototype%")) return ValClone(e, r->typeErrorPrototype);
    if(StrEqChars(e, name->str, "%URIError%")) return ValClone(e, r->uriErrorObject);
    if(StrEqChars(e, name->str, "%uriErrorPrototype%")) return ValClone(e, r->uriErrorPrototype);
    if(StrEqChars(e, name->str, "%ArrayBuffer%")) return ValClone(e, r->arrayBufferConstructor);
    if(StrEqChars(e, name->str, "%arrayBufferPrototype%")) return ValClone(e, r->arrayBufferPrototype);
    if(StrEqChars(e, name->str, "%TypedArray%")) return ValClone(e, r->typedArrayObject);
    if(StrEqChars(e, name->str, "%typedArrayPrototype%")) return ValClone(e, r->typedArrayPrototype);
    if(StrEqChars(e, name->str, "%Int8Array%")) return ValClone(e, r->int8ArrayObject);
    if(StrEqChars(e, name->str, "%int8ArrayPrototype%")) return ValClone(e, r->int8ArrayPrototype);
    if(StrEqChars(e, name->str, "%DataView%")) return ValClone(e, r->dataViewObject);
    if(StrEqChars(e, name->str, "%dataViewPrototype%")) return ValClone(e, r->dataViewPrototype);
    if(StrEqChars(e, name->str, "%symbolConstructor%")) return ValClone(e, r->symbolConstructor);
    if(StrEqChars(e, name->str, "%symbolPrototype%")) return ValClone(e, r->symbolPrototype);
    if(StrEqChars(e, name->str, "%objProto_toString%")) return ValClone(e, r->objProto_toString);
    if(StrEqChars(e, name->str, "%throwTypeErrorFunction%")) return ValClone(e, r->throwTypeErrorFunction);
    if(StrEqChars(e, name->str, "%arrayIteratorPrototype%")) return ValClone(e, r->arrayIteratorPrototype);
    if(StrEqChars(e, name->str, "%stringIteratorPrototype%")) return ValClone(e, r->stringIteratorPrototype);
    if(StrEqChars(e, name->str, "%mapIteratorPrototype%")) return ValClone(e, r->mapIteratorPrototype);
    if(StrEqChars(e, name->str, "%setIteratorPrototype%")) return ValClone(e, r->setIteratorPrototype);
    if(StrEqChars(e, name->str, "%GeneratorFunction%")) return ValClone(e, r->generatorFunctionObject);
    
    return ValNew(e);
}

void InitGlobalObject(Js* e, Val* global, Realm* realm);
void RealmInit(Js* e, Realm* r) {
    // we need to explicitly pass the object prototype here since the Realm
    // is not yet completed
    r->globalThis = ValNewObject(e);

    Env* de = DeclEnvNew(e);
    Env* oe = ObjEnvNew(e, r->globalThis, FALSE);
    Env* ge = GlobalEnvNew(e, de, oe);
    LexEnv* lex = LexEnvNew(e);
    lex->outer = NULL;
    lex->envRec = ge;
    r->globalEnv = ValNewLex(e, lex);
    
    // @note: 8.2.1 specifies NULL as a prototype
    // ObjectSetProto(e, r->globalThis, r->objectPrototype);
    r->directEvalFallback = ValNew(e);
    r->directEvanTranslate = ValNew(e);
    r->function = ValNew(e);
    r->indirectEval = ValNew(e);
    r->loader = ValNew(e);
    
    RealmInitIntrinsics(e, r);    
}


// Complete the initialization of a realm. Initialization is a two
// step process to allow a Realm to be created before any current
// context is established. So this makes it possible to initialize
// prototype objects (which will need the current context)
void RealmComplete(Js* e, Realm* r) {
    if(r->complete)
        return;

    r->complete = TRUE;
    InitArrayPrototype(e, r->arrayPrototype);
    InitArrayIteratorPrototype(e, r->arrayIteratorPrototype);    

    InitGlobalObject(e, r->globalThis, r);
}

Realm* _RealmNew(Js* e, int line) {
    Realm* r = (Realm*) _halloc(e->memory[RM].data, line);
    memset(r, 0, sizeof(Realm));
    r->referenceCount = 0;
    r->complete = FALSE;
    r->objectPrototype = ValNewObject(e);
    RealmInit(e, r);
    return r;
}

Realm* RealmRetain(Js* e, Realm* r) {
    r->referenceCount++;
    return r;
}

void RealmRelease(Js* e, Realm* r) {
    if(!r) return;
    assert(r->referenceCount > 0);
    r->referenceCount--;
    if(r->referenceCount == 0)
        RealmDelete(e, r);
}

void RealmDelete(Js* e, Realm* r) {
    if(!r)
        return;
    
    assert(r->referenceCount == 0);
    ValDel(e, r->globalEnv);
    ValDel(e, r->globalThis);
    ValDel(e, r->directEvalFallback);
    ValDel(e, r->directEvanTranslate);
    ValDel(e, r->function);
    ValDel(e, r->indirectEval);
    ValDel(e, r->loader);
    RealmDeleteIntrinsics(e, r);
    hfree(e->memory[RM].data, r);
}





/////// Completion
Completion* CompNew(Js* e, int type, Val* v, Val* label) {
    Completion* c = (Completion*) halloc(e->memory[CM].data);
    c->empty = TRUE;
    if(!v)
        c->value = ValNew(e);
    else {
        c->value = ValClone(e, v);
        c->empty = FALSE;
    }
    c->type = type;
    if(label)
        c->target = ValClone(e, label);
    else
        c->target = NULL;
    return c;
}

void CompDel(Js* e, Completion* c) {
    ValDel(e, c->value);
    if(c->target)
        ValDel(e, c->target);
    hfree(e->memory[CM].data, c);
}

Val* CompGetValue(Js* e, Completion* c) {
    return ValClone(e, c->value);
}

bool_t CompIsAbrupt(Js* e, Completion* c) {
    if(c->type == COMP_NORMAL)
        return FALSE;
    return TRUE;
}

/////// List
List* ListNew(Js* e) {
    List* l = (List*) halloc(e->memory[LS].data);
    l->count = 0;
    l->head = NULL;
    l->tail = NULL;
    return l;
}

int ListGetCount(Js* e, List* l) {
    return l->count;
}

// important note - the value is NOT copied since typically
// the caller has obtained a copy of the value to Put on a List
// using eval() or some other mechanism
void ListAddValue(Js* e, List* l, Val* v) {
    Item* i = (Item*) halloc(e->memory[IT].data);
    i->value = v;
    l->count++;
    i->next = NULL;
    
    if(!l->head) {
        l->head = l->tail = i;
    }
    else {
        l->tail->next = i;
        l->tail = i;
    }
}

Val* ListGetValue(Js* e, List* l, int index) {
    if(index >= l->count)
        return NULL;
    
    Item* i = l->head;
    for(int x=0; i != NULL;  x++) {
        if(x == index)
            return ValClone(e, i->value);
        i = i->next;
    }
    return NULL;
}

void ListDel(Js* e, List* l) {
    Item* i = l->head;
    
    while(i) {
        Item* n = i->next;
        ValDel(e, i->value);
        hfree(e->memory[IT].data, i);
        i = n;
    }
    hfree(e->memory[LS].data, l);
}

void ListDelItem(Js* e, List* l, Val* v) {
    Item* prev = NULL;
    for(Item* i = l->head; i != NULL; i = i->next) {
        Val* sv = SameValue(e, i->value, v);
        if(ValIsTrueDel(e, sv)) {
        
            if(!prev) {
                l->head = i->next;
            }
            else {
                prev->next = i->next;
            }
            if(l->tail == i)
                l->tail = prev;
            ValDel(e, i->value);
            hfree(e->memory[IT].data, i);
            return;
        }
        prev = i;
    }
}

void ListRemoveLast(Js* e, List* l) {
    for(Item* i = l->head; i; i = i->next) {
        if(i->next == l->tail) {
            ValDel(e, l->tail->value);
            hfree(e->memory[IT].data, l->tail);
            l->tail = i;
            i->next = NULL;
            return;
        }
    }
}

bool_t ListHasValue(Js* e, List* l, Val* v) {
    for(Item* i = l->head; i != NULL; i = i->next) {
        Val* sv = SameValue(e, i->value, v);
        if(ValIsTrueDel(e, sv))
            return TRUE;
    }
    return FALSE;
}

int ListValueIndex(Js* e, List* l, Val* v) {
    int index = 0;
    for(Item* i = l->head; i != NULL; i = i->next) {
        Val* sv = SameValue(e, i->value, v);
        if(ValIsTrueDel(e, sv))
            return index;
        index++;
    }
    return -1;
}

List* ListClone(Js* e, List* s) {
    List *d = ListNew(e);
    for(int i=0; i < s->count; i++) {
        Val* v = ListGetValue(e, s, i);
        ListAddValue(e, d, v);
    }
    return d;
}

List* ListConcat(Js* e, List* d, List* s) {
    for(int i=0; i < s->count; i++) {
        Val* v = ListGetValue(e, s, i);
        ListAddValue(e, d, v);
    }
    return d;
}


////// PtrList
PtrList* _PtrListNew(Js* e, int line) {
    PtrList* l = (PtrList*) _halloc(e->memory[PL].data,line);
    l->count = 0;
    l->head = NULL;
    l->tail = NULL;
    return l;
}

int PtrListCount(Js* e, PtrList* l) {
    if(!l)
        return 0;
    return l->count;
}

PtrList* PtrListAdd(Js* e, PtrList* l, void* v) {
    PtrItem* i = (PtrItem*) halloc(e->memory[PI].data);
    i->value = v;
    l->count++;
    i->next = NULL;
    
    if(!l->head) {
        l->head = l->tail = i;
    }
    else {
        l->tail->next = i;
        l->tail = i;
    }
    return l;
}

void* PtrListGet(Js* e, PtrList* l, int index) {
    if(index >= l->count)
        return NULL;
    
    PtrItem* i = l->head;
    for(int x=0; i != NULL;  x++) {
        if(x == index)
            return i->value;
        i = i->next;
    }
    return NULL;
}

void PtrListDel(Js* e, PtrList* l) {
    if(!l)
        return;
    
    PtrItem* i = l->head;
    
    while(i) {
        PtrItem* n = i->next;
        hfree(e->memory[PI].data, i);
        i = n;
    }
    hfree(e->memory[PL].data, l);
}

void PtrListDelItem(Js* e, PtrList* l, void* v) {
    PtrItem* prev = NULL;
    for(PtrItem* i = l->head; i != NULL; i = i->next) {
        if(v == i->value) {        
            if(!prev) {
                l->head = i->next;
            }
            else {
                prev->next = i->next;
            }
            if(l->tail == i)
                l->tail = prev;
            ValDel(e, i->value);
            hfree(e->memory[PI].data, i);
            return;
        }
        prev = i;
    }
}

void PtrListPrepend(Js* e, PtrList* l, void *v) {
    PtrItem* i = (PtrItem*) halloc(e->memory[PI].data);
    i->value = v;
    l->count++;
    i->next = l->head;
    l->head = i;
}


bool_t PtrListHas(Js* e, PtrList* l, void* v) {
    for(PtrItem* i = l->head; i != NULL; i = i->next) {
        if(v == i->value)
            return TRUE;
    }
    return FALSE;
}

PtrList* PtrListCat(Js* e, PtrList* l, PtrList* r, bool_t delR) {
    if(!r)
        return l;

    if(r->count ==0) {
        if(delR)
            PtrListDel(e, r);
        return l;
    }
    // Special performance handling for delR, no need to copy values
    // do a tail insertion
    if(delR) {
        if(l->tail) 
            l->tail->next = r->head;
        else 
            l->head = r->head;
        l->tail = r->tail;
        l->count += r->count;
        hfree(e->memory[PL].data, r);
        return l;
    }
    for(PtrItem* pi = r->head; pi; pi = pi->next) {
        PtrListAdd(e, l, pi->value);
    }
    if(delR)
        PtrListDel(e, r);
    return l;
}

///// Ref
Ref* RefNew(Js* e, Val* b, Val* n, bool_t s, Val* tv) {
    Ref* r = (Ref*) halloc(e->memory[RF].data);
    if(b)
        r->base = ValClone(e, b);
    else
        r->base = ValNew(e);
    r->name = ValClone(e, n);
    r->strict = s;
    
    r->thisValue = NULL;
    if(tv)
        r->thisValue = ValClone(e, tv);
    return r;
}

void RefDelete(Js* e, Ref* r) {
    if(r->thisValue)
        ValDel(e, r->thisValue);
    ValDel(e, r->name);
    ValDel(e, r->base);
    hfree(e->memory[RF].data, r);
}

bool_t RegGetEqNum(Js* e, Val* r, number n) {
    Val* v = GetValue(e, r);
    bool_t ret = FALSE;
    
    if(v->type == TYPE_NUM && v->num == n)
        ret = TRUE;
    
    ValDel(e, v);
    return ret;
}

bool_t RegGetAbrupt(Js* e, Val* r) {
    Val* v = GetValue(e, r);
    bool_t ret = FALSE;
    if(v->type == TYPE_COMP && CompIsAbrupt(e, v->completion))
        ret = TRUE;
    ValDel(e, v);
    return ret;
}


Val* RefGetBase(Js* e, Val* v) {
    if(v->type != TYPE_REF) return NULL;
    Ref* r = (Ref*) v->Ref;
    return ValClone(e, r->base);
}

Val* RefGetReferencedName(Js* e, Val* v) {
    if(v->type != TYPE_REF) return NULL;
    Ref* r = (Ref*) v->Ref;
    return r->name;
}

bool_t RefIsStrict(Js* e, Val* v) {
    if(v->type != TYPE_REF) return FALSE;
    Ref* r = (Ref*) v->Ref;
    return r->strict;
}

bool_t RefHasPrimitiveBase(Js* e, Val* v) {
    if(v->type != TYPE_REF) return FALSE;
    Ref* r = (Ref*) v->Ref;

    Val* rv = (Val*) r->base;
    int t = rv->type;
    if(t == TYPE_BOOL || t == TYPE_STR || t == TYPE_SYMA || t == TYPE_NUM)
        return TRUE;
    return FALSE;
}

bool_t RefIsPropRef(Js* e, Val* v) {
    if(v->type != TYPE_REF) return FALSE;
    Ref* r = (Ref*) v->Ref;

    if(RefHasPrimitiveBase(e, v))
        return TRUE;
    Val* x = (Val*) r->base;
    int t = x->type;
    if(t == TYPE_OBJ)
        return TRUE;
    return FALSE;
}

bool_t RefIsUnresolvable(Js* e, Val* v) {
    if(v->type != TYPE_REF) return TRUE;
    Ref* r = (Ref*) v->Ref;

    Val* x = (Val*) r->base;
    if(x->type == TYPE_UNDEF)
        return TRUE;
    return FALSE;
}

bool_t RefIsSuper(Js* e, Val* v) {
    if(v->type != TYPE_REF) return FALSE;
    Ref* r = (Ref*) v->Ref;

    if(r->thisValue)
        return TRUE;
    return FALSE;
}

Val* GetValue(Js* e, Val* v) {
    RET_IF_ABRUPT(v);
    if(v->type != TYPE_REF)
        return ValClone(e,v);
    Val* base = RefGetBase(e, v);
    
    if(RefIsUnresolvable(e, v)) {
        ValDel(e, base);
        return ThrowRefError(e, 0, RefGetReferencedName(e, v), " not found");
    }
    
    if(RefIsPropRef(e, v)) {
        if(RefHasPrimitiveBase(e, v)) {
            assert(base != NULL);
            assert(base->type != TYPE_UNDEF);
            // This code used to delete base before passing it
            // to ToObject conversion which is obviously wrong
            // Instead we should keep the value, pass it then delete it
            Val* temp = base;
            base = ToObject(e, base);
            ValDel(e, temp);
        }
        Val* rthis = RefGetThis(e, v);
        Val* rname = RefGetReferencedName(e, v);
        Val* ret = DoGet(e, base, rname, rthis);
        ValDel(e, rthis);
        ValDel(e, base);
        return ret;
    }
    else {
        Env* ev = (Env*) base->env;
        Val* ret = ev->vtable->getBindingValue(e, ev, RefGetReferencedName(e, v), RefIsStrict(e, v));
        ValDel(e, base);
        return ret;
    }

}

// Identical to PutValue but uses initializeMutableBinding instead
// of setMutableBinding to handle eval() and strict mode var declaration
// initializatio S10.4.2.1_A1
Val* InitValue(Js* e, Val* v, Val* w) {
    RET_IF_ABRUPT(v);
    RET_IF_ABRUPT(w);
    if(v->type != TYPE_REF)
        return ThrowRefError(e, "not a reference", 0,0);
    Val* base = RefGetBase(e, v);
    if(RefIsUnresolvable(e, v)) {
        if(RefIsStrict(e, v)) {
            ValDel(e, base);
            return ThrowRefError(e, 0, RefGetReferencedName(e, v), " not found");
        }
        ValDel(e, base);
        Val* global = GetGlobalObject(e);
        Val* ret = Put(e, global, RefGetReferencedName(e, v), w, FALSE);
        ValDel(e, global);
        return ret;
    }
    if(RefIsPropRef(e, v)) {
        if(RefHasPrimitiveBase(e, v)) {
            assert(base != NULL);
            assert(base->type != TYPE_UNDEF);
            base = ToObject(e, base);
        }
        Val* rthis = RefGetThis(e, v);
        Val* succeeded = DoSet(e, base, RefGetReferencedName(e, v), w, rthis);
        ValDel(e, base);
        ValDel(e, rthis);
        RET_IF_ABRUPT(succeeded);
        if(succeeded->b == FALSE && RefIsStrict(e, v))
            return ThrowRefError(e, "strict failed to set ", RefGetReferencedName(e, v),0);
        ValDel(e, succeeded);
        return ValNew(e);
    }
    Env* ev = (Env*) base->env;
    Val* ret = ev->vtable->initializeBinding(e, ev, RefGetReferencedName(e, v), w);
    ValDel(e, base);
    return ret;
}



Val* PutValue(Js* e, Val* v, Val* w) {
    RET_IF_ABRUPT(v);
    RET_IF_ABRUPT(w);
    if(v->type != TYPE_REF)
        return ThrowRefError(e, "not a reference", 0,0);
    Val* base = RefGetBase(e, v);
    if(RefIsUnresolvable(e, v)) {
        if(RefIsStrict(e, v)) {
            ValDel(e, base);
            return ThrowRefError(e, 0, RefGetReferencedName(e, v), " not found");
        }
        ValDel(e, base);
        Val* global = GetGlobalObject(e);
        Val* ret = Put(e, global, RefGetReferencedName(e, v), w, FALSE);
        ValDel(e, global);
        return ret;
    }
    if(RefIsPropRef(e, v)) {
        if(RefHasPrimitiveBase(e, v)) {
            assert(base != NULL);
            assert(base->type != TYPE_UNDEF);
            base = ToObject(e, base);
        }
        Val* rthis = RefGetThis(e, v);
        Val* succeeded = DoSet(e, base, RefGetReferencedName(e, v), w, rthis);
        ValDel(e, base);
        ValDel(e, rthis);
        RET_IF_ABRUPT(succeeded);
        if(succeeded->b == FALSE && RefIsStrict(e, v))
            return ThrowRefError(e, "strict failed to set ", RefGetReferencedName(e, v),0);
        ValDel(e, succeeded);
        return ValNew(e);
    }
    Env* ev = (Env*) base->env;
    Val* ret = ev->vtable->setMutableBinding(e, ev, RefGetReferencedName(e, v), w, RefIsStrict(e, v));
    ValDel(e, base);
    return ret;
}

Val* RefGetThis(Js* e, Val* v) {
    RET_IF_ABRUPT(v);
    if(v->type != TYPE_REF)
        return ValClone(e,v);
    if(RefIsUnresolvable(e, v))
        return ThrowRefError(e, "this unresolvable", 0,0);
    if(RefIsSuper(e, v)) {
        Ref* r = (Ref*) v->Ref;
        return ValClone(e, r->thisValue);
    }
    return RefGetBase(e, v);
}


//////// throw
Val* ThrowAnyError(Js* e, Val* cons, char* prefix, Val* msg, char* suffix) {
    Val* ov = ValNewObject(e);
    Val* proto = DoGet(e, cons, e->prototype, NULL);
    ObjectSetProto(e, ov, proto);
    if(prefix || msg || suffix) {
        int len = 0;
        if(prefix)
            len += strlen(prefix);
        if(msg && msg->type == TYPE_STR) {
            len += msg->str->length;
        }
        if(suffix)
            len += strlen(suffix);
        char* buff = _hallocsize(e->memory[ST].data, (int) len+1, __LINE__);
        int offset = 0;
        if(prefix) {
            strcpy(buff, prefix);
            offset += strlen(prefix);
        }
        if(msg && msg->type == TYPE_STR) {
            for(int i=0; i < msg->str->length; i++) 
                buff[offset++] = msg->str->chars[i];
        }
        buff[offset] = 0;
        if(suffix) {
            strcpy(buff+offset, suffix);
        }
        Val* m = ValNewStrA(e, buff);
        hfree(e->memory[ST].data, buff);
        PutA(e, ov, "message", m, TRUE);
    }
    ValDel(e, proto);
    Val* ret = ValNewCompA(e, COMP_THROW, ov, NULL);
    ValDel(e, ov);
    return ret;
}

Val* ThrowRefError(Js* e, char* prefix, Val* m, char* suffix) {
    return ThrowAnyError(e, CurrentRealm(e)->referenceErrorObject, prefix, m, suffix);
}

Val* ThrowURIError(Js* e, char* prefix, Val* m, char* suffix) {
    return ThrowAnyError(e, CurrentRealm(e)->uriErrorObject, prefix, m, suffix);
}


Val* ThrowTypeError(Js* e, char* prefix, Val* m, char* suffix) {
    return ThrowAnyError(e, CurrentRealm(e)->typeErrorObject, prefix, m, suffix);
}

Val* ThrowRangeError(Js* e, char* prefix, Val* m, char* suffix) {
    return ThrowAnyError(e, CurrentRealm(e)->rangeErrorObject, prefix, m, suffix);
}

Val* ThrowSyntaxError(Js* e, char* prefix, Val* m, char* suffix) {
    return ThrowAnyError(e, CurrentRealm(e)->syntaxErrorObject, prefix, m, suffix);
}

Val* ThrowError(Js* e, char* prefix, Val* m, char* suffix) {
    return ThrowAnyError(e, CurrentRealm(e)->errorObject, prefix, m, suffix);
}

///// 7.1 type conversion
Val* ToPrimitive(Js* e, Val* v, Val* preferred_type) {
    Val* ret = NULL, *hint = NULL, *exotic_to_prim = NULL;
    Val* args = NULL, *result = NULL;
    List* l = NULL;

    switch(v->type) {
        case TYPE_UNDEF:
        case TYPE_NULL:
        case TYPE_NUM:
        case TYPE_STR:
        case TYPE_SYMA:
        case TYPE_BOOL:
            RET(ValClone(e, v));
        case TYPE_COMP:
            if(ValIsAbrupt(e, v))
                RET(ValClone(e, v));
            RET(ToPrimitive(e, v->completion->value, preferred_type));
        break;
        case TYPE_DESC:
        case TYPE_ENV:
        case TYPE_LEX:
        case TYPE_REF:
            RET(ThrowTypeError(e, "Cannot convert to primitive",0,0));
    }
    
    assert(v->type == TYPE_OBJ);
    if(!preferred_type)
        hint = ValNewStrA(e, "default");
    else if(preferred_type->type == TYPE_STR) {
        if(ValEqStrA(e, preferred_type, "number"))
            hint = ValNewStrA(e, "number");
        else
            hint = ValNewStrA(e, "string");
    }
    else if(preferred_type->type == TYPE_NUM)
        hint = ValNewStrA(e, "number");
    exotic_to_prim = Get(e, v, e->toPrimitive);
    RET_IF_AB(exotic_to_prim);
    if(exotic_to_prim->type != TYPE_UNDEF) {
        if(!IsCallableBool(e, exotic_to_prim)) {
            RET(ThrowTypeError(e, "type not undefined", 0,0));
        }
        l = ListNew(e);
        ListAddValue(e, l, ValClone(e, hint));
        args = ValNewList(e, l);
        result = DoCall(e, exotic_to_prim, v, args);
        RET_IF_AB(result);
        if(result->type != TYPE_OBJ)
            RET_VAL(result);
        RET(ThrowTypeError(e, "type not object",0,0));
    }
    if(StrEqChars(e, hint->str, "default")) {
        ValDel(e, hint);
        hint = ValNewStrA(e, "number");
    }
    RET(OrdinaryToPrimitive(e, v, hint));

exit:
    IFD(hint);
    IFD(exotic_to_prim);
    IFD(args);
    IFD(result);    
    return ret;
}

Val* OrdinaryToPrimitive(Js* e, Val* o, Val* hint) {
    assert(o->type == TYPE_OBJ);
    assert(hint->type == TYPE_STR);
    char** method_names;
    char* methods_str[] = { "toString", "valueOf" };
    char* methods_num[] = { "valueOf", "toString" };
    if(StrEqChars(e, hint->str, "string"))
        method_names = methods_str;
    else if(StrEqChars(e, hint->str, "number"))
        method_names = methods_num;
    else
        assert(FALSE);
    for(int i=0; i < 2; i++) {
        char* name = method_names[i];
        Val* method = GetA(e, o, name);
        if(IsCallableBool(e, method)) {
            Val* result = DoCall(e, method, o, NULL);
            IFZ(method);
            RET_IF_ABRUPT(result);
            if(result->type != TYPE_OBJ) {
                return result;
            }
            ValDel(e, result);
        }
        IFZ(method);
    }
    return ThrowTypeError(e, "unexpected OrdinaryToPrimitive",0,0);
}
bool_t isnegzero(number n) {
    return (n == 0 && isneg(n));
}

bool_t isposzero(number n) {
    return (n == 0 && !isneg(n));
}

Val* ToBoolean(Js* e, Val* v) {
    switch(v->type) {
        case TYPE_COMP:
            if(ValIsAbrupt(e, v))
                return ValClone(e, v);
            return ToBoolean(e, v->completion->value);
        break;
        case TYPE_UNDEF:
        case TYPE_NULL:
            return ValNewBool(e, FALSE);
        case TYPE_BOOL:
            return ValClone(e, v);
        case TYPE_NUM:
            if(isposzero(v->num) || isnegzero(v->num) || isnan(v->num))
                return ValNewBool(e, FALSE);
            return ValNewBool(e, TRUE);
        case TYPE_STR:
            if(v->str->length != 0)
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        case TYPE_OBJ:
        case TYPE_SYMA:
            return ValNewBool(e, TRUE);
        case TYPE_DESC:
        case TYPE_ENV:
        case TYPE_LEX:
        case TYPE_REF:
            break;
    }
    return ThrowTypeError(e, "unexpected ToBoolean",0,0);
}


Val* ToNumber(Js* e, Val* v) {
    switch(v->type) {
        case TYPE_COMP:
            if(ValIsAbrupt(e, v))
                return ValClone(e, v);
            return ToNumber(e, v->completion->value);
        break;
        case TYPE_UNDEF:
            return ValNewNum(e, NAN);
        case TYPE_NULL:
            return ValNewNum(e, 0);
        case TYPE_BOOL:
            if(v->b == TRUE)
                return ValNewNum(e, 1);
            return ValNewNum(e, 0);
        case TYPE_NUM:
            return ValClone(e, v);
        case TYPE_STR:
        {
            Tokenizer* tk = TkNew(e);
            // @todo: 7.1.3.1 ensure all parsing grammar is supported
            TkTokenize(e, tk, v->str->chars, v->str->length, 0, 0);
            Val* ret;
            int index = 0;
            number sign = 1.0;

            if(TkGetTokKeyword(e, tk, 0) == id_minus) {
                index = 1;
                sign = -1.0;
            }
            if(TkGetTokType(e, tk, index) != TOK_NUMLIT) {
                ret = ValNewNum(e, NAN);
            }
            else
                ret = ValNewNum(e, sign*TkGetTokNumVal(e, tk, index));
            TkDel(e, tk);
            return ret;
        }
        case TYPE_OBJ:
        {
            Val* hint = ValNewStrA(e, "number");
            Val* prim_value = ToPrimitive(e, v, hint);
            ValDel(e, hint);
            Val* ret = ToNumber(e, prim_value);
            ValDel(e, prim_value);
            return ret;
        }
        case TYPE_SYMA:
            return ValNewNum(e, NAN);
        case TYPE_DESC:
        case TYPE_ENV:
        case TYPE_LEX:
        case TYPE_REF:
            break;
    }
    return ThrowTypeError(e, "unexpected ToNumber",0,0);

}

number sign(number n) {
    if(n >= 0)
        return 1;
    else
        return -1;
}

Val* ToInteger(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isnan(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    if(isposzero(n->num) || isnegzero(n->num) || isinf(n->num))
        return n;
    number result = sign(n->num) * floor(fabs(n->num));
    ValDel(e, n);
    return ValNewNum(e, result);
}

Val* ToInt32(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isposzero(n->num) || isnegzero(n->num) || isnan(n->num) || isinf(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    int32 i = (int32) (sign(n->num) * floor(fabs(n->num)));
    ValDel(e, n);
    return ValNewNum(e, (number) i);
}


Val* ToUint32(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isposzero(n->num) || isnegzero(n->num) || isnan(n->num) || isinf(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    uint32 i = (uint32) (sign(n->num) * floor(fabs(n->num)));
    ValDel(e, n);
    return ValNewNum(e, (number) i);
}

Val* ToInt16(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isposzero(n->num) || isnegzero(n->num) || isnan(n->num) || isinf(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    int16 i = (int16) (sign(n->num) * floor(fabs(n->num)));
    ValDel(e, n);
    return ValNewNum(e, (number) i);
}

Val* ToUint16(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isposzero(n->num) || isnegzero(n->num) || isnan(n->num) || isinf(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    uint16 i = (uint16) (sign(n->num) * floor(fabs(n->num)));
    ValDel(e, n);
    return ValNewNum(e, (number) i);
}

Val* ToInt8(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isposzero(n->num) || isnegzero(n->num) || isnan(n->num) || isinf(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    int8 i = (int8) (sign(n->num) * floor(fabs(n->num)));
    ValDel(e, n);
    return ValNewNum(e, (number) i);
}

Val* ToUint8(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isposzero(n->num) || isnegzero(n->num) || isnan(n->num) || isinf(n->num)) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    uint8 i = (uint8) (sign(n->num) * floor(fabs(n->num)));
    ValDel(e, n);
    return ValNewNum(e, (number) i);
}

Val* ToUint8Clamp(Js* e, Val* v) {
    Val* n = ToNumber(e, v);
    RET_IF_ABRUPT(n);
    if(isnan(n->num) || n->num <= 0) {
        ValDel(e, n);
        return ValNewNum(e, 0);
    }
    if(n->num > 255) {
        ValDel(e, n);
        return ValNewNum(e, 255);
    }
    number f = floor(n->num);
    if(f + 0.5 <= n->num) {
        ValDel(e, n);
        return ValNewNum(e, f+1);
    }
    ValDel(e, n);
    return ValNewNum(e, f);
}

Val* StrFromDynStr(Js* e, DynStr* ds) {
    Val* ret = ValNewStr(e, ds->str);
    DynStrDel(e, ds);
    return ret;    
}

int digits(unsigned long s) {
    if(s == 0)
        return 0;
    int count = 1;
    while(s/10 > 0) {
        s = s/10;
        count++;
    }
    return count;
}

const number epsilon = 1.0e-8;
unsigned long fractionAsInt(number m, int *pf) {
    number frac = m - (unsigned long) m;
    if(frac == 0)
        return 0;
    int n = 0;
    
    assert(frac > 0);
    while(1) {
        n++;
        if(n > 10) { n = 10; break; }
        frac = frac * 10;
        unsigned long fi = (unsigned long) frac;
        number ff = frac - (number) fi;

        // round 0.399999999999 to 0.4
        if( (1 - ff) < epsilon) {
            frac = frac + 1;
            break;
        }
        if(ff < epsilon)
            break;
    }
    *pf = n;
    return frac;
}

bool_t NumToString_compute_nks(number m, int* pn, int* pk, unsigned long *ps) {
    unsigned long i = (unsigned long) m;
    int d;
    unsigned long f = fractionAsInt(m, &d);
    number s = (number) i * pow(10, (number) d) + f;

    for(int n = -20; n <= 22; n++ ) {
        for(int k =1; k < 22; k++) {
            if(pow(10, k-1) > s)
                continue;
            if(s >= pow(10, k))
                continue;
            
            number r = s * pow(10, n-k);
            if( fabs(r - m) < epsilon ) {
                *pn = n;
                *pk = k;
                *ps = s;
                return TRUE;
            }
        }
    }
    return FALSE;
}

bool_t isInt(number n);

// 7.1.12.1 proper number to string conversion
Val* _NumToString(Js* e, number m) {
    if(isnan(m))
        return ValNewStrA(e, "NaN");

    if(isnegzero(m))
        return ValNewStrA(e, "-0");

    if(m == 0)
        return ValNewStrA(e, "0");

    if(isinf(m)) {
        if(m < 0)
            return ValNewStrA(e, "-Infinity");
        else
            return ValNewStrA(e, "Infinity");
    }

    DynStr* ds = DynStrNew(e, 40);
    if(m < 0) {
        DynStrAdd(e, ds, '-');
        m = -m;
    }

    if(isInt(m)) {
        char buff[40];
        sprintf(buff, "%ld", (long) m);
        DynStrAddStrA(e, ds, buff);
        return StrFromDynStr(e, ds);
    }

    int n, k;
    unsigned long s;
    char buff[40];
    if(!NumToString_compute_nks(m, &n, &k, &s)) {
        char buff[40];
        sprintf(buff, "%g", m);
        DynStrAddStrA(e, ds, buff);
        return StrFromDynStr(e, ds);        
    }
    
    sprintf(buff, "%ld", s);

    if(k <= n && n <= 21) {
        DynStrAddStrA(e, ds, buff);
        for(int i=0; i < (n-k); i++)
            DynStrAdd(e, ds, '0');
        return StrFromDynStr(e, ds);
    }
    if(0 < n && n <= 21) {
        for(int i=0; i < n; i++)
            DynStrAdd(e, ds, buff[i]);
        DynStrAdd(e, ds, '.');
        for(int i=0; i < (k-n); i++) {
            DynStrAdd(e, ds, buff[n+i]);
        }
        return StrFromDynStr(e, ds);
    }
    if(-6 < n && n <= 0) {
        DynStrAdd(e, ds, '0');
        DynStrAdd(e, ds, '.');
        for(int i=0; i < (-n); i++) 
            DynStrAdd(e, ds, '0');
        for(int i=0; i < k; i++)
            DynStrAdd(e, ds, buff[i]);
        return StrFromDynStr(e, ds);
    }
    if(k == 1) {
        DynStrAdd(e, ds, buff[0]);
        DynStrAdd(e, ds, 'e');
        if((n-1) > 0)
            DynStrAdd(e, ds, '+');
        else
            DynStrAdd(e, ds, '-');
        int an = abs(n-1);
        char nb[40];
        sprintf(nb, "%d", an);
        DynStrAddStrA(e, ds, nb);
        return StrFromDynStr(e, ds);
    }
    DynStrAdd(e, ds, buff[0]);
    DynStrAdd(e, ds, '.');
    for(int i=0; i < (k-1); i++) 
        DynStrAdd(e, ds, buff[i+1]);
    DynStrAdd(e, ds, 'e');
    int an = abs(n-1);
    char nb[40];
    sprintf(nb, "%d", an);
    DynStrAddStrA(e, ds, nb);
    return StrFromDynStr(e, ds);    
}

Val* NumToString(Js* e, number n) {
     return _NumToString(e, n);
    if(isnan(n))
        return ValNewStrA(e, "NaN");

    if(n == 0)
        return ValNewStrA(e, "0");

    if(isinf(n)) {
        if(n < 0)
            return ValNewStrA(e, "-Infinity");
        else
            return ValNewStrA(e, "Infinity");
    }

    char buff[40];
    char *pbuff = buff;
    if(n < 0) {
        buff[0] = '-';
        n = -n;
        pbuff = buff+1;
    }

    double intPart = (double) (long) n;
    double fracPart = n - intPart;
    char fracBuff[40];
    sprintf(fracBuff, "%g", fracPart);
    char intBuff[40];
    sprintf(intBuff, "%ld", (long) intPart);
    int fracLen = (int) strlen(fracBuff);
    int intLen = (int) strlen(intBuff);
    int totalLen = intLen + fracLen;

// jprintf(e,0,"*** %s.%s ***\n", intBuff, fracBuff);

    if(fracPart == 0 && intLen <= 21) {
        sprintf(pbuff, "%s", intBuff);
    }
    else if(totalLen <= 21 && intPart != 0) {
        sprintf(pbuff, "%s.%s", intBuff, fracBuff+2);
    }
    else {
        sprintf(pbuff, "%g", n);
    }
    return ValNewStrA(e, buff);    
}

Val* ToString(Js* e, Val* v) {
    switch(v->type) {
        case TYPE_REF: {
            Val* vv = GetValue(e, v);
            Val* r = ToString(e, vv);
            ValDel(e, vv);
            return r;
        }
        case TYPE_COMP:
            if(ValIsAbrupt(e, v))
                return ValClone(e, v);
            return ToString(e, v->completion->value);
        break;
        case TYPE_UNDEF:
            return ValNewStrA(e, "undefined");
        case TYPE_NULL:
            return ValNewStrA(e, "null");
        case TYPE_BOOL:
            if(v->b == TRUE)
                return ValNewStrA(e, "true");
            return ValNewStrA(e, "false");
        case TYPE_NUM:
            return NumToString(e, v->num);
        case TYPE_STR:
            return ValClone(e, v);
        case TYPE_OBJ:
        {
            Val* hint = ValNewStrA(e, "number");
            Val* prim_value = ToPrimitive(e, v, hint);
            ValDel(e, hint);
            Val* ret = ToString(e, prim_value);
            ValDel(e, prim_value);
            return ret;
        }
        case TYPE_SYMA:
            return ThrowTypeError(e, "unexpected ToString",0,0);
        case TYPE_DESC:
        case TYPE_ENV:
        case TYPE_LEX:
            break;
    }
    return ThrowTypeError(e, "unexpected ToString",0,0);
}

Val* ValNewBuiltin(Js* e, Val* name, Val* v, Val* proto) {
    Val* O = ValNewObject(e);
    Val* r = Put(e, O, name, v, FALSE);
    ValDel(e, r);
    ObjectSetProto(e, O, proto);
    return O;
}

Val* ValNewBuiltinA(Js* e, char* name, Val* v, Val* proto) {
    Val* un = ValNewStrA(e, name);
    Val* ret = ValNewBuiltin(e, un, v, proto);
    ValDel(e, un);
    return ret;
}

Val* NewBoolObject(Js* e, Val* v) {
    Val* o = ObjectCreate(e, e->currentContext->realm->booleanPrototype, NULL);
    ObjectSetSlot(e, o->obj, _BooleanData_, v, TRUE, FALSE);
    return o;
}

Val* NewNumberObject(Js* e, Val* v) {
    Val* o = ObjectCreate(e, e->currentContext->realm->numberPrototype, NULL);
    ObjectSetSlot(e, o->obj, _NumberData_, v, TRUE, FALSE);
    return o;
}

Val* SymbolCreate(Js* e, Val* s) {
    Val* obj = ObjectCreate(e, CurrentRealm(e)->symbolPrototype, NULL);
    ObjectSetSlot(e, obj->obj, _SymbolData_, s, TRUE, FALSE);
    return obj;
}

Val* ToObject(Js* e, Val* v) {
    Realm* io = CurrentRealm(e);
    switch(v->type) {
        case TYPE_COMP:
            if(ValIsAbrupt(e, v))
                return ValClone(e, v);
            return ToObject(e, v->completion->value);
        break;
        case TYPE_DESC:
        case TYPE_ENV:
        case TYPE_LEX:
        case TYPE_REF:
        case TYPE_UNDEF:
        case TYPE_NULL:
            return ThrowTypeError(e, "cnnnot convert to object",0,0);

        case TYPE_BOOL:
            return NewBoolObject(e, v);
        case TYPE_NUM:
            return NewNumberObject(e, v);
        case TYPE_STR:
            return StringCreate(e, io->stringPrototype, v);
        case TYPE_SYMA: 
            return SymbolCreate(e, v);
        case TYPE_OBJ:
            return ValClone(e, v);
    }
    return ThrowTypeError(e, "cannot convert to object",0,0);
}


Val* ToPropKey(Js* e, Val* v) {
    RET_IF_ABRUPT(v);
    if(v->type == TYPE_SYMA)
        return ValClone(e, v);
    return ToString(e, v);
}

Val* ToLength(Js* e, Val* v) {
    Val* len = ToInteger(e, v);
    RET_IF_ABRUPT_CV1(v, len);
    if(len <= 0) {
        ValDel(e, len);
        return ValNewNum(e, 0);
    }
    number ret = fmin(len->num, pow(2,53)-1);
    ValDel(e, len);
    return ValNewNum(e, ret);
}


////// 7.2 Testing and Comparison Operations
Val* RequireObjectCoercible(Js* e, Val* a) {
    switch(a->type) {
        case TYPE_COMP:
            if(ValIsAbrupt(e, a))
                return ValClone(e, a);
            return RequireObjectCoercible(e, a->completion->value);
        case TYPE_UNDEF:
            return ThrowTypeError(e, "cannot convert undefined to object",0,0);
        case TYPE_NULL:
            return ThrowTypeError(e, "cnnnot convert null to object", 0,0);
        case TYPE_BOOL:
        case TYPE_NUM:
        case TYPE_OBJ:
        case TYPE_STR:
        case TYPE_SYMA:
            return ValClone(e, a);
        default:
            return ThrowTypeError(e, "cannot convert to object",0,0);
    }
}

Val* IsCallable(Js* e, Val* a) {
    switch(a->type) {
        case TYPE_COMP:
            if(ValIsAbrupt(e, a))
                return ValClone(e, a);
            return IsCallable(e, a->completion->value);
        case TYPE_UNDEF:
        case TYPE_NULL:
        case TYPE_BOOL:
        case TYPE_NUM:
        case TYPE_STR:
        case TYPE_SYMA:
            return ValNewBool(e, FALSE);
        case TYPE_OBJ:
            if(ObjectGetMethod(e, a->obj, _Call_))
                return ValNewBool(e, TRUE);
            else
                return ValNewBool(e, FALSE);
        default:
            return ThrowTypeError(e, "attempting to call non-object", 0,0);
    }
}

bool_t IsCallableBool(Js* e, Val* v) {
    Val* b = IsCallable(e, v);
    bool_t ret = FALSE;
    if(b->type == TYPE_BOOL)
        ret = b->b;
    ValDel(e, b);
    return ret;
}

Val* SameValue(Js* e, Val* x, Val* y) {
    if(!x && !y)
        return ValNewBool(e, TRUE);
    if( (!x && y) || (!y && x))
        return ValNewBool(e, FALSE);
    
    RET_IF_ABRUPT(x);
    RET_IF_ABRUPT(y);
    if(x->type != y->type)
        return ValNewBool(e, FALSE);
    
    switch(x->type) {
        case TYPE_UNDEF:
            return ValNewBool(e, TRUE);
        case TYPE_NULL:
            return ValNewBool(e, TRUE);
        case TYPE_NUM: {
            int sx = signbit(x->num);
            int sy = signbit(y->num);
            if(isnan(x->num) && isnan(y->num))
                return ValNewBool(e, TRUE);
            if(x->num == 0 && y->num == 0) {
                if(sx == sy)
                    return ValNewBool(e, TRUE);
                return ValNewBool(e, FALSE);
            }
            if(x->num == y->num)
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        }
        case TYPE_STR:
            if(StrEqStr(e, x->str, y->str))
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        case TYPE_BOOL:
            if(x->b == TRUE && y->b == TRUE)
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        case TYPE_SYMA:  // @todo - investigate symbol equality
            if(x->descA == y->descA)
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        case TYPE_OBJ:
            if(x->obj == y->obj)
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        default:
            return ThrowTypeError(e, "unexpected SameValue",0,0);
    }
}

Val* SameValueZero(Js* e, Val* x, Val* y) {
    RET_IF_ABRUPT(x);
    RET_IF_ABRUPT(y);
    if(x->type != y->type)
        return ValNewBool(e, FALSE);
    
    switch(x->type) {
        case TYPE_NUM: {
            if(isnan(x->num) && isnan(y->num))
                return ValNewBool(e, TRUE);
            if(x->num == y->num)
                return ValNewBool(e, TRUE);
            return ValNewBool(e, FALSE);
        }
        default:
            return SameValue(e, x, y);
    }
}

Val* IsConstructor(Js* e, Val* a) {
    RET_IF_ABRUPT(a);
    if(a->type != TYPE_OBJ)
        return ValNewBool(e, FALSE);
    if(ObjectGetMethod(e, a->obj, _Construct_))
        return ValNewBool(e, TRUE);
    return ValNewBool(e, FALSE);
}

Val* IsPropKey(Js* e, Val* a) {
    RET_IF_ABRUPT(a);
    if(a->type == TYPE_STR || a->type == TYPE_SYMA)
        return ValNewBool(e, TRUE);
    return ValNewBool(e, FALSE);
}

Val* IsExtensible(Js* e, Val* a) {
    assert(a->type == TYPE_OBJ);
    return DoIsExtensible(e, a);
}


Val* AbstractRelational(Js* e, Val* x, Val* y, bool_t left_first) {
    Val* ret = NULL;
    Val* hint_num = NULL;
    Val* px = NULL;
    Val* py = NULL;
    Val* nx = NULL;
    Val* ny = NULL;

    RET_IF_AB(x);
    RET_IF_AB(y);
    hint_num = ValNewStrA(e, "number");
    if(left_first == TRUE) {
        px = ToPrimitive(e, x, hint_num);
        RET_IF_AB(px);
        py = ToPrimitive(e, y, hint_num);
        RET_IF_AB(py);
    }
    else {
        px = ToPrimitive(e, y, hint_num);
        RET_IF_AB(px);
        py = ToPrimitive(e, x, hint_num);
        RET_IF_AB(py);
    }
    if(px->type == TYPE_STR && py->type == TYPE_STR) {
        if(StrPrefix(e, py->str, px->str))
            RET(ValNewBool(e, FALSE));
        if(StrPrefix(e, px->str, py->str))
            RET(ValNewBool(e, TRUE));
        for(int k=0; k < px->str->length; k++) {
            if(k >= py->str->length)
                RET(ValNewBool(e, FALSE));
            if(px->str->chars[k] != py->str->chars[k]) {
                uchar m = px->str->chars[k];
                uchar n = py->str->chars[k];
                if(m < n)
                    RET(ValNewBool(e, TRUE));
                RET(ValNewBool(e, FALSE));
            }
        }
        assert(FALSE);      // should never Get here
    }
    nx = ToNumber(e, px);
    ny = ToNumber(e, py);
    if(isnan(nx->num))
        RET(ValNew(e));
    if(isnan(ny->num))
        RET(ValNew(e));
    if(nx->num == 0 && signbit(nx->num) >= 0 && ny->num == 0 && signbit(ny->num) < 0 )
        RET(ValNewBool(e, FALSE));
    if(nx->num == 0 && signbit(nx->num) < 0 && ny->num == 0 && signbit(ny->num) >= 0 )
        RET(ValNewBool(e, FALSE));
    if(nx->num == ny->num)
        RET(ValNewBool(e, FALSE));
    if(isinf(nx->num) || isinf(ny->num))
        RET(ValNewBool(e, FALSE));
    if(nx->num < ny->num)
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));
    
exit:
    IFD(px);
    IFD(py);
    IFD(hint_num);
    IFD(nx);
    IFD(ny);
    return ret;
}


Val* AbstractEquality(Js* e, Val* x, Val* y) {
    if(x->type == y->type)
        return StrictEquality(e, x, y);
    if(x->type == TYPE_NULL && y->type == TYPE_UNDEF)
        return ValNewBool(e, TRUE);
    if(x->type == TYPE_UNDEF && y->type == TYPE_NULL)
        return ValNewBool(e, TRUE);
    if(x->type == TYPE_STR && y->type == TYPE_NUM) {
        Val *nx = ToNumber(e, x);
        Val* ret = AbstractEquality(e, nx, y);
        ValDel(e, nx);
        return ret;
    }
    if(x->type == TYPE_NUM && y->type == TYPE_STR) {
        Val *ny = ToNumber(e, y);
        Val* ret = AbstractEquality(e, x, ny);
        ValDel(e, ny);
        return ret;
    }
    if(x->type == TYPE_BOOL) {
        Val* nx = ToNumber(e, x);
        Val* ret = AbstractEquality(e, nx,y);
        ValDel(e, nx);
        return ret;
    }
    if(y->type == TYPE_BOOL) {
        Val* ny = ToNumber(e, y);
        Val* ret = AbstractEquality(e, x,ny);
        ValDel(e, ny);
        return ret;
    }
    if( (x->type == TYPE_NUM || x->type == TYPE_STR) && y->type == TYPE_OBJ) {
        Val* py = ToPrimitive(e, y, NULL);
        Val* ret = AbstractEquality(e, x, py);
        ValDel(e, py);
        return ret;
    }
    if( (y->type == TYPE_NUM || y->type == TYPE_STR) && x->type == TYPE_OBJ) {
        Val* px = ToPrimitive(e, x, NULL);
        Val* ret = AbstractEquality(e, px, y);
        ValDel(e, y);
        return ret;
    }
    return ValNewBool(e, FALSE);
}

Val* StrictEquality(Js* e, Val* x, Val* y) {
    if(x->type != y->type)
        return ValNewBool(e, FALSE);
    if(x->type == TYPE_UNDEF)
        return ValNewBool(e, TRUE);
    if(x->type == TYPE_NULL)
        return ValNewBool(e, TRUE);
    if(x->type == TYPE_NUM) {
        if(isnan(x->num))
            return ValNewBool(e, FALSE);
        if(isnan(y->num))
            return ValNewBool(e, FALSE);
        if(x->num == y->num)
            return ValNewBool(e, TRUE);
        return ValNewBool(e, FALSE);
    }
    if(x->type == TYPE_STR) {
        if(StrEqStr(e, x->str, y->str))
            return ValNewBool(e, TRUE);
        return ValNewBool(e, FALSE);
    }
    if(x->type == TYPE_BOOL) {
        if(x->b == TRUE && y->b == TRUE)
            return ValNewBool(e, TRUE);
        if(x->b == FALSE && y->b == FALSE)
            return ValNewBool(e, TRUE);
        return ValNewBool(e, FALSE);
    }
    if(x->type == TYPE_SYMA && x->descA == y->descA)
        return ValNewBool(e, TRUE);
    if(x->type == TYPE_OBJ && x->obj == y->obj)
        return ValNewBool(e, TRUE);
    return ValNewBool(e, FALSE);
}

///// 7 abstract operations

Val* Put(Js* e, Val* o, Val* p, Val* v, bool_t strict) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* success = DoSet(e, o, p, v, o);
    RET_IF_ABRUPT(success);
    if(!ValIsTrue(e, success) && strict) {
        ValDel(e, success);
        return ThrowTypeError(e, "set failed", 0,0);
    }
    return success;
}

Val* CreateDataProp(Js* e, Val* o, Val* p, Val* v) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* newDesc = ValNewDesc(e);
    PropSetConfigurable(e, newDesc->desc, TRUE);
    PropSetWritable(e, newDesc->desc, TRUE);
    PropSetEnumerable(e, newDesc->desc, TRUE);
    PropSetValue(e, newDesc->desc, v);
    Val* res = DoDefineOwnProperty(e, o, p, newDesc);
    ValDel(e, newDesc);
    return res;
}

Val* CreateDataPropOrThrow(Js* e, Val* o, Val* p, Val* v) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* newDesc = ValNewDesc(e);
    PropSetConfigurable(e, newDesc->desc, TRUE);
    PropSetWritable(e, newDesc->desc, TRUE);
    PropSetEnumerable(e, newDesc->desc, TRUE);
    PropSetValue(e, newDesc->desc, v);
    Val* success = DoDefineOwnProperty(e, o, p, newDesc);
    ValDel(e, newDesc);
    if(!ValIsTrue(e, success)) {
        ValDel(e, success);
        return ThrowTypeError(e, "create property ", p, " failed");
    }
    return success;
    
}


Val* DefinePropOrThrow(Js* e, Val* o, Val* p, Val* desc) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* success = DoDefineOwnProperty(e, o, p, desc );
    RET_IF_ABRUPT(success);
    if(!ValIsTrue(e, success)) {
        ValDel(e, success);
        return ThrowTypeError(e, "define property ", p, " failed");
    }
    return success;
}


Val* DeletePropOrThrow(Js* e, Val* o, Val* p) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* success = DoDelete(e, o, p );
    RET_IF_ABRUPT(success);
    if(!ValIsTrue(e, success)) {
        ValDel(e, success);
        return ThrowTypeError(e, "delete property ", p, " failed");
    }
    return success;
}

Val* GetMethod(Js* e, Val* o, Val* p) {
    // assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* func = DoGet(e, o, p, NULL);
    RET_IF_ABRUPT(func);
    if(ValIsUndef(func) || ValIsNull(func)) {
        ValDel(e, func);
        return ValNew(e);
    }
    if(!ValIsTrueDel(e, IsCallable(e, func))) {
        ValDel(e, func);
        return ThrowTypeError(e, 0, p, " not callable");
    }
    return func;
}

Val* HasProp(Js* e, Val* o, Val* p) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    return DoHasProperty(e, o, p);
}

Val* HasOwnProp(Js* e, Val* o, Val* p) {
    assert(o->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* desc = DoGetOwnProperty(e, o, p);
    RET_IF_ABRUPT(desc);
    if(desc->type == TYPE_UNDEF) {
        ValDel(e, desc);
        return ValNewBool(e, FALSE);
    }
    ValDel(e, desc);
    return ValNewBool(e, TRUE);
}

Val* Invoke(Js* e,Val* o, Val* p, Val* args) {
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    bool_t own_args = FALSE;
    Val* obj = NULL;
    Val* ret = NULL;
    Val* func = NULL;
    if(!args) {
        List* l = ListNew(e);
        args = ValNewList(e, l);
        own_args = TRUE;
    }
    obj = ToObject(e, o);
    RET_IF_AB(obj);
    func = DoGet(e, obj, p, NULL);
    if(!ValIsTrueDel(e, IsCallable(e, func))) {
        ret = ThrowTypeError(e, 0, p, " not callable");
        goto exit;
    }
    RET_IF_AB(func);
    ret = DoCall(e, func, obj, args);
    
exit:
    if(own_args)
        ValDel(e, args);
    IFD(obj);
    IFD(func);
    return ret;
}

Val* SetIntegrityLevel(Js* e, Val* o, Val* level) {
    assert(o->type == TYPE_OBJ);
    assert(StrEqChars(e, level->str, "sealed") || StrEqChars(e, level->str, "frozen"));
    Val* keys = DoOwnPropertyKeys(e, o);
    
    RET_IF_ABRUPT(keys);
    Val* pending_exception = ValNew(e);
    
    if(StrEqChars(e, level->str, "sealed")) {
        Val* desc = ValNewDesc(e);
        PropSetConfigurable(e, desc->desc, FALSE);
        
        while(TRUE) {
            Val* result = IteratorNext(e, keys, NULL);
            Val* done = IteratorComplete(e, result);
            if(!ValIsTrueDel(e, done)) {
                Val* k = IteratorValue(e, result);
                Val* status = DefinePropOrThrow(e, o, k, desc);
                if(ValIsAbrupt(e, status))
                    if(pending_exception->type == TYPE_UNDEF)
                        ValSet(e, pending_exception, status);
                ValDel(e, status);
                ValDel(e, result);
                ValDel(e, k);
            }
            else {
                ValDel(e, result);
                break;
            }
        }
        ValDel(e, desc);
    }
    else {      // level is frozen
        while(TRUE) {
            Val* result = IteratorNext(e, keys, NULL);
            Val* done = IteratorComplete(e, result);
            if(ValIsTrueDel(e, done)) {
                ValDel(e, result);
                break;
            }
            Val* k = IteratorValue(e, result);
            Val* desc = ValNewDesc(e);
            Val* status = DoGetOwnProperty(e, o, k);
            if(ValIsAbrupt(e, status)) {
                if(pending_exception->type == TYPE_UNDEF) {
                    ValSet(e, pending_exception, status);
                    ValDel(e, status);
                }
            }
            else {
                Val* current_desc = status;
                if(current_desc->type != TYPE_UNDEF) {
                    if(IsAccessorDesc(e, current_desc->desc)) {
                        PropSetConfigurable(e, desc->desc, FALSE);
                    }
                    else {
                        PropSetConfigurable(e, desc->desc, FALSE);
                        PropSetWritable(e, desc->desc, FALSE);
                        ValDel(e, status);
                        status = DefinePropOrThrow(e, o, k, desc);
                        if(ValIsAbrupt(e, status))
                            if(pending_exception->type == TYPE_UNDEF)
                                ValSet(e,pending_exception, status);
                    }
                }
                ValDel(e, status);
                ValDel(e, result);
                ValDel(e, k);
            }
            ValDel(e, desc);
        }
    }
    if(pending_exception->type != TYPE_UNDEF)
        return pending_exception;
    ValDel(e, pending_exception);
    ValDel(e, keys);
    return DoPreventExtensions(e, o);
}


Val* TestIntegrityLevel(Js* e, Val* o, Val* level) {
    assert(o->type == TYPE_OBJ);
    assert(StrEqChars(e, level->str, "sealed") || StrEqChars(e, level->str, "frozen"));
    Val* status = IsExtensible(e, o);
    RET_IF_ABRUPT(status);
    if(ValIsTrue(e, status)) {
        ValDel(e, status);
        return ValNewBool(e, FALSE);
    }
    ValDel(e, status);
    Val* keys = DoOwnPropertyKeys(e, o);
    RET_IF_ABRUPT(keys);
    Val* pending_exception = ValNew(e);
    bool_t configurable = FALSE;
    bool_t writable = FALSE;

    while(TRUE) {
        Val* result = IteratorNext(e, keys, NULL);
        Val* done = IteratorComplete(e, result);
        if(ValIsTrueDel(e, done)) {
            ValDel(e, result);
            break;
        }
        Val* k = IteratorValue(e, result);
        status = DoGetOwnProperty(e, o, k);
        if(ValIsAbrupt(e, status)) {
            if(pending_exception->type == TYPE_UNDEF)
                ValSet(e, pending_exception, status);
            configurable = TRUE;
            ValDel(e, status);
        }
        else {
            Val* current_desc = status;
            if(current_desc->type != TYPE_UNDEF) {
                configurable |= PropIsConfigurable(e, current_desc->desc);
                if(PropIsData(e, current_desc->desc)) {
                    writable |= PropIsWritable(e, current_desc->desc);
                }
            }
        }
        ValDel(e, status);
        ValDel(e, result);
        ValDel(e, k);
    }
    
    ValDel(e, keys);
    if(pending_exception->type != TYPE_UNDEF)
        return pending_exception;
    ValDel(e, pending_exception);
    if(StrEqChars(e, level->str, "frozen") && writable)
        return ValNewBool(e, FALSE);
    if(configurable)
        return ValNewBool(e, FALSE);
    return ValNewBool(e, TRUE);
}

Val* CreateArrayFromList(Js* e, Val* elements) {
    Val* n = ValNewNum(e, 0);
    Val* array = ArrayCreate(e, n, NULL);
    for(Item* i = elements->list->head; i ; i = i->next) {
        Val* v = i->value;
        Val* k = ToString(e, n);
        Val* status = CreateDataProp(e, array, k, v);
        assert(ValIsTrue(e, status));
        ValDel(e, status);
        ValDel(e, k);
        n->num++;
    }
    ValDel(e, n);
    return array;
}

Val* CreateListFromArrayLike(Js* e, Val* obj) {
    if(obj->type != TYPE_OBJ)
        return ThrowTypeError(e, "creating list from non-object",0,0);
    Val* len = GetA(e, obj, "length");
    Val* n = ToLength(e, len);
    Val* ret = NULL;
    List* List = NULL;
    Val* index_name = NULL;
    Val* next = NULL;
    bool_t del_list = TRUE;
    Val* index = ValNewNum(e, 0);
    RET_IF_AB(n);
    List = ListNew(e);

    while(index->num < n->num) {
        Val* index_name = ToString(e, index);
        Val* next = Get(e, obj, index_name);
        RET_IF_AB(next);
        ListAddValue(e, List, next);
        index->num++;
        ValDel(e, index_name);
        next = NULL;        // List will hold the copy
        index_name = NULL;
        next = NULL;
    }
    ret = ValNewList(e, List);
    del_list = FALSE;
exit:
    IFD(len);
    IFD(n);
    IFD(next);
    IFD(index);
    IFD(index_name);
    if(del_list)
        ListDel(e, List);
    return ret;
}

Val* InstanceOfOperator(Js* e, Val* o, Val* c) {
    if(!ValIsObject(o))
        return ThrowTypeError(e, "instanceof not an object", 0,0);
    Val* instOfHandler = GetMethod(e, c, e->hasInstance);
    if(ValIsAbrupt(e, instOfHandler))
        return instOfHandler;
    if(!ValIsUndef(instOfHandler)) {
        List* l = ListNew(e);
        ListAddValue(e, l, o);
        Val* args = ValNewList(e, l);
        Val* result = DoCall(e, instOfHandler, c, args);
        ValDel(e, args);
        Val* b = ToBoolean(e, result);
        ValDel(e, result);
        ValDel(e, instOfHandler);
        return b;
    }
    if(!ValIsTrueDel(e, IsCallable(e, c))) {
        ValDel(e, instOfHandler);
        return ThrowTypeError(e, "instanceof not callable", 0,0);
    }
    ValDel(e, instOfHandler);
    return OrdinaryHasInstance(e, c, o);
}

Val* OrdinaryHasInstance(Js* e, Val* c, Val* o) {
    Val* bound_target_func = NULL;
    Val* has_bc = NULL;
    Val* ret = NULL;
    Val* bc = NULL;
    Val* p = NULL;
    Val* oc = ValClone(e, o);
    Val* r = NULL;
    
    if(!ValIsTrueDel(e, IsCallable(e, c)))
        return ValNewBool(e, FALSE);
    bound_target_func = ValNewStrA(e, _BoundTargetFunction_);
    has_bc = HasProp(e, c, bound_target_func);
    if(ValIsTrue(e, has_bc))
        RET(InstanceOfOperator(e, o, bc));

    if(o->type != TYPE_OBJ)
        RET(ValNewBool(e, FALSE));
    
    p = Get(e, c, e->strPrototype);
    RET_IF_AB(p);
    
    if(p->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    
    while(TRUE) {
        Val* x = oc;
        if(x->type == TYPE_NULL)
            RET(ValNewBool(e, FALSE));
        
        oc = DoGetPrototypeOf(e, x);     
        ValDel(e, x);
        RET_IF_AB(o);
        if(o->type == TYPE_NULL)
            RET(ValNewBool(e, FALSE));
        r = SameValue(e, p, oc);
        if(ValIsTrue(e,r))
            RET(ValNewBool(e, TRUE));
        IFZ(r);
    }
    
exit:
    IFD(oc);
    IFD(bound_target_func);
    IFD(has_bc);
    IFD(bc);
    IFD(p);
    IFD(r);
    return ret;
}

Val* GetPrototypeFromConstructor(Js* e, Val* cons, Val* def_proto) {
    if(!ValIsTrueDel(e, IsConstructor(e, cons)))
        return ThrowTypeError(e, "not a constructor", 0,0);
    Val* proto = NULL;
    Val* ret = NULL;
    proto = DoGet(e, cons, e->prototype, cons);
    RET_IF_AB(proto);
    if(proto->type != TYPE_OBJ) {
        Realm* realm;
        Val* vr = ObjectGetSlot(e, cons->obj, _Realm_);
        if(vr && vr->type == TYPE_PTR) {
            realm = vr->ptr;
        }
        else {
            Context* ctx = e->currentContext;
            realm = ctx->realm;
        }
        // @note - spec deviation for performance. if def_proto is an object
        // we bypass the string lookup and return the object
        if(def_proto->type == TYPE_OBJ)
            ret = ValClone(e, def_proto);
        else
            ret = RealmGetIntrinsic(e, realm, def_proto);
        goto exit;
    }
    ret = proto;
    proto = NULL;   // so we don't delete it
    
exit:
    IFD(proto);
    return ret;
}





Val* Construct(Js* e, Val* f, Val* args, Val* newTarget) {
    if(!newTarget)
        newTarget = f;

//    assert(IsConstructor(e, f));
//    assert(IsConstructor(e, newTarget));
    return DoConstruct(e, f, args, newTarget);
}


Realm* GetFunctionRealm(Js* e, Val* obj) {
    assert(obj->type == TYPE_OBJ);
    assert(ValIsTrueDel(e, IsCallable(e, obj)));
    if(ObjectGetSlotRef(e, obj->obj, _Realm_)) {
        return ObjectGetSlot(e, obj->obj, _Realm_)->realm;
    }
    if(ObjectGetSlotRef(e, obj->obj, _BoundTargetFunction_)) {
        Val* target = ObjectGetSlot(e, obj->obj, _BoundTargetFunction_);
        return GetFunctionRealm(e, target);
    }
    if(ObjectGetSlotRef(e, obj->obj, _ProxyTarget_)) {
        Val* target = ObjectGetSlot(e, obj->obj, _ProxyTarget_);
        if(target)
            return GetFunctionRealm(e, target);
    }
    return CurrentRealm(e);
}

Val* GetOption(Js* e, Val* Options, Val* p) {
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    if(Options->type == TYPE_UNDEF)
        return ValNew(e);
    if(Options->type != TYPE_OBJ)
        return ThrowTypeError(e, "not an object",0,0);
    return DoGet(e, Options, p, NULL);
}


Val* GetA(Js* e, Val* o, char* n) {
    if(!o || o->type != TYPE_OBJ)
        return ThrowRefError(e, n, 0, " not found");
    
    Val* un = ValNewStrA(e, n);
    Val* ret = DoGet(e, o, un, o);
    ValDel(e, un);
    return ret;
}

Val* ObjectGetA(Js* e, Val* o, char* n) {
    Val* un = ValNewStrA(e, n);
    Val* ret = DoGet(e, o, un, o);
    ValDel(e, un);
    return ret;
}

Val* Get(Js* e, Val* o, Val* p) {
    assert(o->type == TYPE_OBJ);
    Val* k = IsPropKey(e, p);
    assert(k->type == TYPE_BOOL && k->b);
    ValDel(e, k);
    return DoGet(e, o, p, o);
}


bool_t HasA(Js* e, Val* o, char* n) {
    if(!o || o->type != TYPE_OBJ)
        return FALSE;
    
    Val* un = ValNewStrA(e, n);
    Val* ret = DoHasProperty(e, o, un);
    ValDel(e, un);
    if(ValIsTrueDel(e, ret))
        return TRUE;
    else
        return FALSE;
}
void DelA(Js* e, Val* o, char* n) {
    if(!o || o->type != TYPE_OBJ)
        return;
    
    Val* un = ValNewStrA(e, n);
    Val* succ = DoDelete(e, o, un);
    ValDel(e, un);
    ValDel(e, succ);
    return;
}

void PutA(Js* e, Val* o, char* n, Val* v, bool_t del_v) {
    if(!o || o->type != TYPE_OBJ)
        return;
    
    Val* un = ValNewStrA(e, n);
    Val* ret = DoSet(e, o, un, v, o);
    ValDel(e, ret);
    ValDel(e, un);
    if(del_v)
        ValDel(e, v);
    return;
}

void ObjectPutA(Js* e, Val* o, char* n, Val* v) {
    Val* un = ValNewStrA(e, n);
    Val* ret = DoSet(e, o, un, v, o);
    ValDel(e, ret);
    ValDel(e, un);
}

//////// 7.4 Operations on iterator objects
Val* GetIterator(Js* e, Val* obj, Val* method) {
    Val* ret = NULL, *meth = NULL, *iterator = NULL;

    RET_IF_AB(obj);
    if(!method) {
        meth = CheckIterable(e, obj);
        RET_IF_AB(meth);
    }
    else
        meth = ValClone(e, method);
    if(!ValIsTrueDel(e, IsCallable(e, meth)))
        RET(ThrowTypeError(e, "not callable",0,0));

    iterator = DoCall(e, meth, obj, NULL);
    RET_IF_AB(iterator);
    if(iterator->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    RET_VAL(iterator);
exit:
    IFD(meth);
    IFD(iterator);
    return ret;    

    // Val* iterator = Invoke(e, obj, e->iterator, NULL);
    // RET_IF_ABRUPT(iterator);
    // if(iterator->type != TYPE_OBJ)
    //     return ThrowTypeError(e);
    // return iterator;
}

Val* CheckIterable(Js* e, Val* obj) {
    if(obj->type != TYPE_OBJ)
        return ValNew(e);
    return Get(e, obj, e->iterator);
}

Val* IteratorNext(Js* e, Val* iterator, Val* value) {
    Val* result = NULL;
    Val* ret = NULL;
    if(!value) {
        result = Invoke(e, iterator, e->strNext, NULL);
    }
    else {
        List *l = ListNew(e);
        ListAddValue(e, l, value);
        Val* args = ValNewList(e, l);
        result = Invoke(e, iterator, e->strNext, args);
        ValDel(e, args);
    }
    RET_IF_AB(result);
    if(result->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    ret = result;
    result = NULL;
exit:
    IFD(result);
    return ret;
}

Val* IteratorComplete(Js* e, Val* iter_result) {
    assert(iter_result->type == TYPE_OBJ);
    Val* p = ValNewStrA(e, "done");
    Val* done = Get(e, iter_result, p);
    ValDel(e, p);
    Val* ret = ToBoolean(e, done);
    ValDel(e, done);
    return ret;
}

Val* IteratorValue(Js* e, Val* iter_result) {
    assert(iter_result->type == TYPE_OBJ);
    Val* p = ValNewStrA(e, "value");
    Val* r = Get(e, iter_result, p);
    ValDel(e, p);
    return r;
}

Val* IteratorStep(Js* e, Val* iterator) {
    Val* result = NULL;
    Val* done = NULL;
    Val* ret = NULL;
    
    result = IteratorNext(e, iterator, NULL);
    RET_IF_AB(result);
    done = IteratorComplete(e, result);
    RET_IF_AB(done);
    if(ValIsTrue(e, done))
        RET(ValNewBool(e, FALSE));
    ret = result;
    result = NULL;
    
exit:
    IFD(result);
    IFD(done);
    return ret;
}

Val* CreateResultObject(Js* e, Val* value, Val* done) {
    assert(done->type == TYPE_BOOL);
    Val* val_prop = ValNewStrA(e, "value");
    Val* done_prop = ValNewStrA(e, "done");
    Val* obj = ObjectCreate(e, e->currentContext->realm->objectPrototype, NULL);
    Val* r = CreateDataProp(e, obj, val_prop, value);
    ValDel(e, r);
    r = CreateDataProp(e, obj, done_prop, done);
    ValDel(e, r);
    ValDel(e, val_prop);
    ValDel(e, done_prop);
    return obj;
}

////////// ListIterator
// @todo - optimization use ListIteratorNextPtr instead of ListIteratorNextIndex
//         and avoid indexed lookup into the List
Val* CreateListIterator(Js* e, Val* ilist) {
    Val* iterator = ObjectCreate(e, NULL, NULL);
    ObjectSetSlot(e, iterator->obj, _IteratedList_, ilist, FALSE, FALSE);
    ObjectSetSlot(e, iterator->obj, _IteratorNextIndex_, ValNewNum(e,0), FALSE, TRUE);
    Val* r = ListIteratorNext(e, iterator);
    // PutA(e, iterator, "next", r, FALSE);
    ValDel(e, DoSet(e, iterator, e->strNext, r, iterator));
    ValDel(e, r);
    return iterator;
}


Val* ListIteratorNextCall(Js* e, Val* origin, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL;
    Val* arg1 = NULL;
    Val* arg2 = NULL;
    List* iteratedList = ObjectGetSlot(e, othis->obj, _IteratedList_)->list;
    Val* iteratorNextIndex = ObjectGetSlot(e, othis->obj, _IteratorNextIndex_);
    
    if(!iteratedList)
        RET(ThrowTypeError(e, "null list", 0,0));
    number len_value = iteratedList->count;
    if(iteratorNextIndex->num >= len_value) {
        arg1 = ValNew(e);
        arg2 = ValNewBool(e, TRUE);
    }
    else {
        iteratorNextIndex->num++;
        arg1 = ListGetValue(e, iteratedList, iteratorNextIndex->num-1); // since we advanced see 7.4.1.7.8
        arg2 = ValNewBool(e, FALSE);
    }
    ret = CreateResultObject(e, arg1, arg2);
    
exit:
    IFD(arg1);
    IFD(arg2);
    return ret;
}

Val* ListIteratorNext(Js* e, Val* othis) {
    Val* func = NativeFuncNew(e, NULL, ListIteratorNextCall);
    return func;
}

Val* CreateEmptyIterator(Js* e) {
    List* al = ListNew(e);
    Val* empty = ValNewList(e, al);
    Val* ret = CreateListIterator(e, empty);
    ValDel(e, empty);
    return ret;
}

//////// 7.5 Operations on promise objects
Val* AllocatePromise(Js* e, Val* proto) {
    return ObjectCreate(e, proto, NULL);
}

Val* InitializePromise(Js* e, Val* promise, Val* executor) {
    assert(NOT_IMPL);
    return ValNew(e);
}

Val* PromiseNew(Js* e, Val* executor) {
    Val* proto_name = ValNewStrA(e, "%Promise%");
    Val* promise = AllocatePromise(e, proto_name);
    ValDel(e, proto_name);
    return InitializePromise(e, promise, executor);
}

Val* CreatePromiseCapability(Js* e, Val* promise, Val* proto) {
    assert(NOT_IMPL);
    return ValNew(e);
}

Val* PromiseBuiltInCapability(Js* e) {
    Val* proto_name = ValNewStrA(e, "%Promise%");
    Val* promise = AllocatePromise(e, proto_name);
    ValDel(e, proto_name);
    return CreatePromiseCapability(e, promise, proto_name);
}

Val* PromiseOf(Js* e, Val* value) {
    assert(NOT_IMPL);
    return ValNew(e);
}

Val* PromiseAll(Js* e, Val* promise_list) {
    assert(NOT_IMPL);
    return ValNew(e);
}

Val* PromiseCatch(Js* e, Val* promise, Val* rejected_action) {
    assert(NOT_IMPL);
    return ValNew(e);
}

Val* PromiseThen(Js* e, Val* promise, Val* resolved_action, Val* rejected_action) {
    assert(NOT_IMPL);
    return ValNew(e);
}


///////// 8.1 Lexical Environments
EnvMethods* DeclEnvMethodsNew(Js* e) {
    EnvMethods* em = halloc(e->memory[DM].data);
    em->hasBinding = DeclEnvHasBinding;
    em->createMutableBinding = DeclEnvCreateMutableBinding;
    em->createImmutableBinding = DeclEnvCreateImmutableBinding;
    em->initializeBinding = DeclEnvInitializeBinding;
    em->setMutableBinding = DeclEnvSetMutableBinding;
    em->getBindingValue = DeclEnvGetBindingValue;
    em->deleteBinding = DeclEnvDeleteBinding;
    em->hasThisBinding = DeclEnvHasThisBinding;
    em->hasSuperBinding = DeclEnvHasSuperBinding;
    em->withBaseObject = DeclEnvWithBaseObject;
    em->destruct = DeclEnvDestruct;
    em->getThisBinding = NULL;
    em->getSuperBase = NULL;
    em->bindThisValue = NULL;
    em->hasVarDecl = NULL;
    em->hasLexDecl = NULL;
    em->canDeclGlobalVar = NULL;
    em->canDeclGlobalFunc = NULL;
    em->createGlobalVarBinding = NULL;
    em->createGlobalFuncBinding = NULL;
    return em;
}

void DeclEnvMethodsDel(Js* e, EnvMethods* em) {
    hfree(e->memory[DM].data, em);
}

Env* DeclEnvNew(Js* e) {
    DeclEnv* de = (DeclEnv*) _hallocsize(e->memory[EN].data, sizeof(DeclEnv), __LINE__);
    de->super.vtable = e->declEnvMethods;
    de->bindings = NULL;
    return (Env*) de;
}

Binding* decl_get_binding(Js* e, DeclEnv* de, Val* n) {
    for(Binding* b = de->bindings; b != NULL; b = b->next) {
        if(ValIsTrueDel(e, SameValue(e, b->name, n)))
            return b;
    }
    return NULL;
}

Val* DeclEnvHasBinding(Js* e, Env* er, Val* n) {
    if(decl_get_binding(e, (DeclEnv*) er, n))
        return ValNewBool(e, TRUE);
    return ValNewBool(e, FALSE);
}

Val* DeclEnvCreateMutableBinding(Js* e, Env* er, Val* n, bool_t d) {
    DeclEnv* de = (DeclEnv*) er;

#ifdef DEBUG
    assert(!decl_get_binding(e, de, n));
#endif

    Binding* b = halloc(e->memory[BN].data);
    b->flags = BINDING_MUTABLE;
    if(d)
        b->flags |= BINDING_CAN_DELETE;
    b->next = de->bindings;
    b->name = ValClone(e, n);
    b->value = NULL;
    de->bindings = b;
    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

Val* DeclEnvCreateImmutableBinding(Js* e, Env* er, Val* n) {
    DeclEnv* de = (DeclEnv*) er;

#ifdef DEBUG
    assert(!decl_get_binding(e, de, n));
#endif

    Binding* b = halloc(e->memory[BN].data);
    b->flags = 0;
    b->name = ValClone(e, n);
    b->next = de->bindings;
    b->value = NULL;
    de->bindings = b;
    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

Val* DeclEnvInitializeBinding(Js* e, Env* er, Val* n, Val* v) {
    DeclEnv* de = (DeclEnv*) er;
    Binding* b = decl_get_binding(e, de, n);
    assert(b);
    ValDel(e, b->value);
//    assert(b->value == NULL);
    b->value = ValClone(e, v);
    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

Val* DeclEnvSetMutableBinding(Js* e, Env* er, Val* n, Val* v, bool_t s) {
    DeclEnv* de = (DeclEnv*) er;
    Binding* b = decl_get_binding(e, de, n);
    assert(b);
    // @todo: The check below is bogus. Of course mutable bindings
    //        can start off with NULL values
   if(b->value == NULL)
       return ThrowRefError(e, "failed to set ", n, 0);
    if((b->flags & BINDING_MUTABLE) != 0) {
        ValDel(e, b->value);
        b->value = ValClone(e, v);
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
    }
    return ThrowTypeError(e, "failed to set ", n, 0);
}

Val* DeclEnvGetBindingValue(Js* e, Env* er, Val* n, bool_t s) {
    DeclEnv* de = (DeclEnv*) er;
    Binding* b = decl_get_binding(e, de, n);
    assert(b);
    if(b->value == NULL) {
    // #402 Changed DeclarativeEnvironment.GetBindingValue() to always return an error if the binding
    // is uninitialized regardless of strict or not
    //        if(s == FALSE)
    //            return ValNew(e);
    //        else
        return ThrowRefError(e, 0, n, " not found");
    }
    return ValClone(e, b->value);
}

Val* DeclEnvDeleteBinding(Js* e, Env* er, Val* n) {
    DeclEnv* de = (DeclEnv*) er;
    Binding* b = decl_get_binding(e, de, n);

    if(!b)
        return ValNewBool(e, TRUE);
    
    if((b->flags & BINDING_CAN_DELETE) == 0)
        return ValNewBool(e, FALSE);
    
    if(de->bindings == b) {
        de->bindings = b->next;
    }
    else {
        Binding* prev = de->bindings;
        for(Binding* o = de->bindings; o != NULL; o = o->next) {
            if(o == b) {
                prev->next = b->next;
                break;
            }
        }
    }
    if(b->value != NULL)
        ValDel(e, b->value);
    ValDel(e, b->name);
    hfree(e->memory[BN].data, b);
    return ValNewBool(e, TRUE);
}

Val* DeclEnvHasThisBinding(Js* e, Env* er) {
    return ValNewBool(e, FALSE);
}

Val* DeclEnvHasSuperBinding(Js* e, Env* er) {
    return ValNewBool(e, FALSE);
}

Val* DeclEnvWithBaseObject(Js* e, Env* er) {
    return ValNew(e);
}

bool_t DeclEnvDestruct(Js* e, Env* er) {
    DeclEnv* de = (DeclEnv*) er;
    
    for(Binding* b = de->bindings; b != NULL; ) {
        Binding* next = b->next;
        if( b->value != NULL)
            ValDel(e, b->value);
        ValDel(e, b->name);
        hfree(e->memory[BN].data, b);
        b = next;
    }
    return FALSE;
}

void EnvDel(Js* e, Env* er) {
    bool_t res = er->vtable->destruct(e, er);
    if(!res)
        hfree(e->memory[EN].data, er);
}


EnvMethods* ObjEnvMethodsNew(Js* e) {
    EnvMethods* em = halloc(e->memory[OM].data);
    em->hasBinding = ObjEnvHasBinding;
    em->createMutableBinding = ObjEnvCreateMutableBinding;
    em->createImmutableBinding = ObjEnvCreateImmutableBinding;
    em->initializeBinding = ObjEnvInitializeBinding;
    em->setMutableBinding = ObjEnvSetMutableBinding;
    em->getBindingValue = ObjEnvGetBindingValue;
    em->deleteBinding = ObjEnvDeleteBinding;
    em->hasThisBinding = ObjEnvHasThisBinding;
    em->hasSuperBinding = ObjEnvHasSuperBinding;
    em->withBaseObject = ObjEnvWithBaseObject;
    em->destruct = ObjEnvDestruct;
    em->getThisBinding = NULL;
    em->getSuperBase = NULL;
    em->bindThisValue = NULL;
    em->hasVarDecl = NULL;
    em->hasLexDecl = NULL;
    em->canDeclGlobalVar = NULL;
    em->canDeclGlobalFunc = NULL;
    em->createGlobalVarBinding = NULL;
    em->createGlobalFuncBinding = NULL;
    
    return em;

}
void ObjEnvMethodsDel(Js* e, EnvMethods* em) {
    hfree(e->memory[OM].data, em);
}

bool_t obj_env_is_unscopable(Js* e, Env* er, Val* v) {
    ObjEnv* oe = (ObjEnv*) er;
    
    if(!oe->unscopables)
        return FALSE;
    
    for(Item* i=oe->unscopables->head; i != NULL; i = i->next) {
        if(ValIsTrueDel(e, SameValue(e, i->value, v))) {
            return TRUE;
        }
    }
    return FALSE;
}

Val* ObjEnvHasBinding(Js* e, Env* er, Val* n) {
    ObjEnv* oe = (ObjEnv*) er;
    
    if(obj_env_is_unscopable(e, er, n))
        return ValNewBool(e, FALSE);
    
    return HasProp(e, oe->bindingObj, n);
}

Val* ObjEnvCreateMutableBinding(Js* e, Env* er, Val* n, bool_t d) {
    ObjEnv* oe = (ObjEnv*) er;
    Val* desc = ValNewDesc(e);
    PropSetConfigurable(e, desc->desc, d);
    PropSetWritable(e, desc->desc, TRUE);
    PropSetEnumerable(e, desc->desc, TRUE);
    Val* ret = DefinePropOrThrow(e, oe->bindingObj, n, desc);
    ValDel(e, desc);
    return ret;
}

Val* ObjEnvCreateImmutableBinding(Js* e, Env* er, Val* n) {
    assert(FALSE);
    return NULL;
}

Val* ObjEnvInitializeBinding(Js* e, Env* er, Val* n, Val* v) {
    return ObjEnvSetMutableBinding(e, er, n, v, FALSE);
}

Val* ObjEnvSetMutableBinding(Js* e, Env* er, Val* n, Val* v, bool_t s) {
    ObjEnv* oe = (ObjEnv*) er;
    return Put(e, oe->bindingObj, n, v, s);
}

Val* ObjEnvGetBindingValue(Js* e, Env* er, Val* n, bool_t s) {
    ObjEnv* oe = (ObjEnv*) er;
    Val* value = HasProp(e, oe->bindingObj, n);
    RET_IF_ABRUPT(value);
    if(value->b == FALSE) {
        ValDel(e, value);
        if(s == FALSE)
            return ValNew(e);
        else
            return ThrowRefError(e, 0, n, " not found");
    }
    
    ValDel(e, value);
    return Get(e, oe->bindingObj, n);
}

Val* ObjEnvDeleteBinding(Js* e, Env* er, Val* n) {
    ObjEnv* oe = (ObjEnv*) er;
    Val* o = oe->bindingObj;
    return DoDelete(e, o, n);
}

Val* ObjEnvHasThisBinding(Js* e, Env* er) {
    return ValNewBool(e, FALSE);
}

Val* ObjEnvHasSuperBinding(Js* e, Env* er) {
    return ValNewBool(e, FALSE);
}

Val* ObjEnvWithBaseObject(Js* e, Env* er) {
    ObjEnv* oe = (ObjEnv*) er;
    if(oe->withEnv)
        return ValClone(e, oe->bindingObj);
    return ValNew(e);
}

bool_t ObjEnvDestruct(Js* e, Env* er) {
    ObjEnv* oe = (ObjEnv*) er;
    ValDel(e, oe->bindingObj);
    if(oe->unscopables)
        ListDel(e, oe->unscopables);
    return FALSE;
}


Env* ObjEnvNew(Js* e, Val* o, bool_t w) {
    ObjEnv* oe = (ObjEnv*) _hallocsize(e->memory[EN].data, sizeof(ObjEnv), __LINE__);
    oe->super.vtable = e->objEnvMethods;
    if(!o)
        oe->bindingObj = ValNewObject(e);
    else
        oe->bindingObj = ValClone(e, o);
    oe->withEnv = w;
    oe->unscopables = NULL;
    return (Env*) oe;
}


EnvMethods* FuncEnvMethodsNew(Js* e) {
    EnvMethods* em = halloc(e->memory[FM].data);
    em->hasBinding = DeclEnvHasBinding;
    em->createMutableBinding = DeclEnvCreateMutableBinding;
    em->createImmutableBinding = DeclEnvCreateImmutableBinding;
    em->initializeBinding = DeclEnvInitializeBinding;
    em->setMutableBinding = DeclEnvSetMutableBinding;
    em->getBindingValue = DeclEnvGetBindingValue;
    em->deleteBinding = DeclEnvDeleteBinding;
    em->hasThisBinding = FuncEnvHasThisBinding;
    em->hasSuperBinding = FuncEnvHasSuperBinding;
    em->withBaseObject = DeclEnvWithBaseObject;
    em->destruct = FuncEnvDestruct;
    em->getThisBinding = FuncEnvGetThisBinding;
    em->getSuperBase = FuncEnvGetSuperBase;
    em->bindThisValue = FuncEnvBindThisValue;
    em->hasVarDecl = NULL;
    em->hasLexDecl = NULL;
    em->canDeclGlobalVar = NULL;
    em->canDeclGlobalFunc = NULL;
    em->createGlobalVarBinding = NULL;
    em->createGlobalFuncBinding = NULL;
    
    return em;

}

void FuncEnvMethodsDel(Js* e, EnvMethods* em) {
    hfree(e->memory[FM].data, em);
}

bool_t ValEqNum(Js* e, Val* v, number n) {
    if(v->type != TYPE_NUM)
        return FALSE;
    return (v->num == n);
}

Val* FuncEnvBindThisValue(Js* e, Env* er, Val* v) {
    FuncEnv* fe = (FuncEnv*) er;
    assert(!ValEqNum(e, fe->thisBindingStatus, BINDING_STATUS_LEXICAL));
    if(ValEqNum(e, fe->thisBindingStatus, BINDING_STATUS_INITIALIZED))
        return ThrowRefError(e, "already initialized",0,0);
    ValDel(e, fe->thisValue);
    fe->thisValue = ValClone(e, v);
    ValDel(e, fe->thisBindingStatus);
    fe->thisBindingStatus = ValNewNum(e, BINDING_STATUS_INITIALIZED);
    return ValClone(e, v);
}

Val* FuncEnvHasThisBinding(Js* e, Env* er) {
    FuncEnv* fe = (FuncEnv*) er;
    if(ValEqNum(e, fe->thisBindingStatus, BINDING_STATUS_LEXICAL))
        return ValNewBool(e, FALSE);
    return ValNewBool(e, TRUE);
}

Val* FuncEnvHasSuperBinding(Js* e, Env* er) {
    FuncEnv* fe = (FuncEnv*) er;
    if(fe->homeObj)
        return ValNewBool(e, TRUE);
    return ValNewBool(e, FALSE);
}

bool_t FuncEnvDestruct(Js* e, Env* er) {
    FuncEnv* fe = (FuncEnv*) er;
    if(fe->thisValue)
        ValDel(e, fe->thisValue);
    if(fe->newTarget)
        ValDel(e, fe->newTarget);
    if(fe->homeObj)
        ValDel(e, fe->homeObj);
    ValDel(e, fe->thisBindingStatus);
    DeclEnvDestruct(e, er);
    hfree(e->memory[FE].data, fe);
    return TRUE;
}

Val* FuncEnvGetThisBinding(Js* e, Env* er) {
    FuncEnv* fe = (FuncEnv*) er;
    assert(!ValEqNum(e, fe->thisBindingStatus, BINDING_STATUS_LEXICAL));
    if(ValEqNum(e, fe->thisBindingStatus, BINDING_STATUS_UNINITIALIZED))
        return ThrowRefError(e, "this uninitialized", 0,0);
    return ValClone(e, fe->thisValue);
}

Val* FuncEnvGetSuperBase(Js* e, Env* er) {
    FuncEnv* fe = (FuncEnv*) er;
    if(fe->homeObj) {
        assert(fe->homeObj->type == TYPE_OBJ);
        return DoGetPrototypeOf(e, fe->homeObj);
    }
    return ValNew(e);
}


Env* FuncEnvNew(Js* e) {
    // FuncEnv* fe = (FuncEnv*) _hallocsize(e->memory[EN].data, sizeof(FuncEnv), __LINE__);
    FuncEnv* fe = (FuncEnv*) halloc(e->memory[FE].data);
    fe->super.bindings = NULL;
    fe->super.super.vtable = e->funcEnvMethods;
    fe->thisValue = NULL;
    fe->homeObj = NULL;
    fe->newTarget = NULL;
    // fe->topLex = NULL;              // @todo: revisit in spec
    return (Env*) fe;
}

EnvMethods* GlobalEnvMethodsNew(Js* e) {
    EnvMethods* em = halloc(e->memory[FM].data);
    em->hasBinding = GlobalEnvHasBinding;
    em->createMutableBinding = GlobalEnvCreateMutableBinding;
    em->createImmutableBinding = GlobalEnvCreateImmutableBinding;
    em->initializeBinding = GlobalEnvInitializeBinding;
    em->setMutableBinding = GlobalEnvSetMutableBinding;
    em->getBindingValue = GlobalEnvGetBindingValue;
    em->deleteBinding = GlobalEnvDeleteBinding;
    em->hasThisBinding = GlobalEnvHasThisBinding;
    em->hasSuperBinding = GlobalEnvHasSuperBinding;
    em->withBaseObject = GlobalEnvWithBaseObject;
    em->destruct = GlobalEnvDestruct;
    em->getThisBinding = GlobalEnvGetThisBinding;
    em->getSuperBase = GlobalEnvGetSuperBase;
    em->hasVarDecl = GlobalEnvHasVarDecl;
    em->hasLexDecl = GlobalEnvHasLexDecl;
    em->canDeclGlobalVar = GlobalEnvCanDeclGlobalVar;
    em->canDeclGlobalFunc = GlobalEnvCanDeclGlobalFunc;
    em->createGlobalVarBinding = GlobalEnvCreateGlobalVarBinding;
    em->createGlobalFuncBinding = GlobalEnvCreateGlobalFuncBinding;
    
    return em;

}

void GlobalEnvMethodsDel(Js* e, EnvMethods* em) {
    hfree(e->memory[FM].data, em);
}


Env* _GlobalEnvNew(Js* e, Env* de, Env* oe, int line) {
    GlobalEnv* ge = _hallocsize(e->memory[EN].data, sizeof(GlobalEnv), line);
    
    if(!de)
        de = DeclEnvNew(e);
    if(!oe)
        oe = ObjEnvNew(e, NULL, FALSE);
    
    ge->dclRec = (DeclEnv*) de;
    ge->objRec = (ObjEnv*) oe;
    ge->varNames = ListNew(e);
    Env* en = (Env*) ge;
    en->vtable = e->globalEnvMethods;
    return (Env*) ge;
}


Val* GlobalEnvHasBinding(Js* e, Env* er, Val* n) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    Val* r = de->vtable->hasBinding(e, de, n);
    if(ValIsTrue(e, r)) {
        return r;
    }
    ValDel(e, r);
    Env* oe = (Env*) ge->objRec;
    return oe->vtable->hasBinding(e, oe, n);
}

Val* GlobalEnvCreateMutableBinding(Js* e, Env* er, Val* n, bool_t d) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    return de->vtable->createMutableBinding(e, de, n,d);
}

Val* GlobalEnvCreateImmutableBinding(Js* e, Env* er, Val* n) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    return de->vtable->createImmutableBinding(e, de, n);
}

Val* GlobalEnvInitializeBinding(Js* e, Env* er, Val* n, Val* v) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    if(ValIsTrueDel(e, de->vtable->hasBinding(e,de,n)))
        return de->vtable->initializeBinding(e, de, n, v);
    Env* oe = (Env*) ge->objRec;
    return oe->vtable->initializeBinding(e, oe, n, v);
}

Val* GlobalEnvSetMutableBinding(Js* e, Env* er, Val* n, Val* v, bool_t s) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    if(ValIsTrueDel(e, de->vtable->hasBinding(e,de,n)))
        return de->vtable->setMutableBinding(e, de, n, v, s);
    Env* oe = (Env*) ge->objRec;
    return oe->vtable->setMutableBinding(e, oe, n, v, s);
}

Val* GlobalEnvGetBindingValue(Js* e, Env* er, Val* n, bool_t s) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    if(ValIsTrueDel(e, de->vtable->hasBinding(e,de,n)))
        return de->vtable->getBindingValue(e, de, n, s);
    Env* oe = (Env*) ge->objRec;
    return oe->vtable->getBindingValue(e, oe, n, s);
}

Val* GlobalEnvDeleteBinding(Js* e, Env* er, Val* n) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    if(ValIsTrueDel(e, de->vtable->hasBinding(e,de,n)))
        return de->vtable->deleteBinding(e, de, n);
    Env* oe = (Env*) ge->objRec;
    if(ValIsTrueDel(e, oe->vtable->hasBinding(e, oe, n))) {
        Val* status = oe->vtable->deleteBinding(e, oe, n);
        RET_IF_ABRUPT(status);
        if(ValIsTrue(e, status)) {
            ListDelItem(e, ge->varNames, n);
            return status;
        }
    }
    return ValNewBool(e, TRUE);
}

Val* GlobalEnvHasThisBinding(Js* e, Env* er) {
    return ValNewBool(e, TRUE);
}

Val* GlobalEnvHasSuperBinding(Js* e, Env* er) {
    return ValNewBool(e, FALSE);
}

Val* GlobalEnvWithBaseObject(Js* e, Env* er) {
    return ValNew(e);
}

bool_t GlobalEnvDestruct(Js* e, Env* er) {
    GlobalEnv* ge = (GlobalEnv*) er;
    EnvDel(e, (Env*) ge->dclRec);
    EnvDel(e, (Env*) ge->objRec);
    ListDel(e, ge->varNames);
    return FALSE;
}

Val* GlobalEnvGetThisBinding(Js* e, Env* er) {
    GlobalEnv* ge = (GlobalEnv*) er;
    ObjEnv* oe = ge->objRec;
    return ValClone(e, oe->bindingObj);
}

Val* GlobalEnvGetSuperBase(Js* e, Env* er) {
    return NULL;
}


Val* GlobalEnvHasVarDecl(Js* e, Env* er, Val* n){
    GlobalEnv* ge = (GlobalEnv*) er;
    return ValNewBool(e, ListHasValue(e, ge->varNames, n));
}

Val* GlobalEnvHasLexDecl(Js* e, Env* er, Val* n){
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* de = (Env*) ge->dclRec;
    return de->vtable->hasBinding(e, de, n);
}

Val* GlobalEnvCanDeclGlobalVar(Js* e, Env* er, Val* n) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* oe = (Env*) ge->objRec;
    if(ValIsTrueDel(e, oe->vtable->hasBinding(e, oe, n)))
        return ValNewBool(e, TRUE);
    Val* bindings = ge->objRec->bindingObj;
    return IsExtensible(e, bindings);
}

Val* GlobalEnvCanDeclGlobalFunc(Js* e, Env* er, Val* n) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* oe = (Env*) ge->objRec;
    Val* global_obj = ge->objRec->bindingObj;
    Val* extensible = IsExtensible(e, global_obj);
    RET_IF_ABRUPT(extensible);
    if(!ValIsTrueDel(e, oe->vtable->hasBinding(e, oe, n)))
        return extensible;
    Val* existing_prop = DoGetOwnProperty(e, global_obj, n);
    if(existing_prop->type == TYPE_UNDEF) {
        ValDel(e, existing_prop);
        return extensible;
    }
    ValDel(e, extensible);
    Property* d = existing_prop->desc;
    if(PropIsConfigurable(e, d)) {
        ValDel(e, existing_prop);
        return ValNewBool(e, TRUE);
    }
    if(PropIsData(e, d) && PropIsWritable(e, d) && PropIsEnumerable(e, d)) {
        ValDel(e, existing_prop);
        return ValNewBool(e, TRUE);
    }
    ValDel(e, existing_prop);
    return ValNewBool(e, FALSE);
}

Val* GlobalEnvCreateGlobalVarBinding(Js* e, Env* er, Val* n, bool_t d) {
    GlobalEnv* ge = (GlobalEnv*) er;
    Env* oe = (Env*) ge->objRec;
    if(!ValIsTrueDel(e, oe->vtable->hasBinding(e, oe, n))) {
        Val* status = oe->vtable->createMutableBinding(e, oe, n, d);
        RET_IF_ABRUPT(status);
        ValDel(e, status);
    }
    if(ListHasValue(e, ge->varNames, n))
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
    ListAddValue(e, ge->varNames, ValClone(e,n));
    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

Val* GlobalEnvCreateGlobalFuncBinding(Js* e, Env* er, Val* n, Val* v, bool_t d) {
    Val* existing_prop = NULL;
    Val* status = NULL;
    Val* dp = NULL;
    Val* ret = NULL;
    
    GlobalEnv* ge = (GlobalEnv*) er;
    Val* global_obj = ge->objRec->bindingObj;
    existing_prop = DoGetOwnProperty(e, global_obj, n);
    Property* ep = existing_prop->desc;
    dp = ValNewDesc(e);
    Property* desc = dp->desc;
    PropInit(e, desc);
    PropSetValue(e, desc, v);
    if(existing_prop->type == TYPE_UNDEF || PropIsConfigurable(e, ep)) {
        PropSetWritable(e, desc, TRUE);
        PropSetEnumerable(e, desc, TRUE);
        PropSetConfigurable(e, desc, d);
    }
    status = DefinePropOrThrow(e, global_obj, n, dp);
    RET_IF_AB(status);
    if(ListHasValue(e, ge->varNames, n))
        RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
    ListAddValue(e, ge->varNames, ValClone(e,n));
    ret = ValNewCompU(e, COMP_NORMAL, NULL, NULL);

exit:
    IFD(existing_prop);
    IFD(status);
    IFD(dp);
    return ret;
}


LexEnv* _LexEnvNew(Js* e, int line) {
    LexEnv* lex = (LexEnv*) _halloc(e->memory[LE].data, line);
    lex->envRec = NULL;
    lex->outer = NULL;
    lex->referenceCount = 1;
    return lex;
}

void LexEnvRetain(Js* e, LexEnv* le) {
    le->referenceCount++;
}

void LexEnvRelease(Js* e, LexEnv* le) {
    le->referenceCount--;
    if(le->referenceCount == 0)
        LexEnvDel(e, le);
}

void LexEnvDel(Js* e, LexEnv* le) {
    if(le->envRec)
        EnvDel(e, le->envRec);
    if(le->outer)
        ValDel(e, le->outer);
    hfree(e->memory[LE].data, le);
}

Val* GetIdentifierRef(Js* e, Val* le, Val* name, bool_t strict) {
    if(le == NULL) {
        return ValNewRefU(e, NULL, name, strict, NULL);
    }
    LexEnv* lex = le->lex;
    Env* er = lex->envRec;
    Val* exists = er->vtable->hasBinding(e, er, name);
    RET_IF_ABRUPT(exists);
    if(ValIsTrueDel(e, exists)) {
        Val* ve = ValNewEnv(e, er);
        Val* ret = ValNewRefU(e, ve, name, strict, NULL);
        ValDel(e, ve);
        return ret;
    }
    return GetIdentifierRef(e, lex->outer, name, strict);
}

Val* NewDeclEnv(Js* e, Val* E) {
    LexEnv* lex = LexEnvNew(e);
    lex->envRec = DeclEnvNew(e);
    lex->outer = ValClone(e, E);
    return ValNewLex(e, lex);
}

Val* NewObjEnv(Js* e, Val* o, Val* E) {
    LexEnv* lex = LexEnvNew(e);
    lex->envRec = ObjEnvNew(e, o, FALSE);   // @todo - is with false?
    lex->outer = ValClone(e, E);
    return ValNewLex(e, lex);
}
enum  { THIS_MODE_LEXICAL, THIS_MODE_STRICT, THIS_MODE_GLOBAL };

Val* NewFunctionEnvironment(Js* e, Val* f, Val* newTarget) {
    // assert(IsFunction(e, f)); @todo:
    assert(!newTarget || newTarget->type == TYPE_OBJ || newTarget->type == TYPE_UNDEF);

    LexEnv* env = LexEnvNew(e);
    FuncEnv* envRec = (FuncEnv*) FuncEnvNew(e);
    int thisMode = (int) (ObjectGetSlot(e, f->obj, _ThisMode_)->num);
    if(thisMode == THIS_MODE_LEXICAL)
        envRec->thisBindingStatus = ValNewNum(e, BINDING_STATUS_LEXICAL);
    else
        envRec->thisBindingStatus = ValNewNum(e, BINDING_STATUS_UNINITIALIZED);
    Val* home = ObjectGetSlot(e, f->obj, _HomeObject_);
    envRec->homeObj = home;     // no need to delete it 
    envRec->newTarget = ValClone(e, newTarget);
    env->envRec = (Env*) envRec;
    env->outer = ValClone(e, ObjectGetSlot(e, f->obj, _Environment_));
    return ValNewLex(e, env);
}


////////// 8.3 Execution Contexts
Context* ContextNew(Js* e, Realm* r, Val* gen, bool_t deferEnv) {

    Context* ctx = (Context*) halloc(e->memory[CX].data);
    ctx->prev = e->currentContext;
    Val* outer = NULL;
    if(e->currentContext) {
        outer = e->currentContext->lex;
        if(!r) {
            r = CurrentRealm(e);
        }
    }
    else {
        if(!r) {
            r = RealmNew(e);
        }
    }
    RealmRetain(e, r);


    ctx->realm = r;
    e->currentContext = ctx;
    ctx->generator = ValClone(e, gen);
    ctx->ref_count = 1;
    ctx->own_vars = FALSE;
    ctx->function = NULL;

    // Now that we have a current context ensure Realm is completely initialized
    RealmComplete(e, r);            

    if(deferEnv)
        return ctx;
    
    LexEnv* le = LexEnvNew(e);
    if(!outer) {
        Env* ge = GlobalEnvNew(e, NULL, NULL);
        le->envRec = ge;
    }
    else {
        Env* de = DeclEnvNew(e);      // @todo: is this true?
        le->envRec = de;
        le->outer = ValClone(e, outer);
    }
    ctx->lex = ValNewLex(e, le);
    ctx->vars = ValClone(e, ctx->lex);
    return ctx;
}

bool_t ContextIsSuspended(Js* e, Context* ctx) {
    if(e->currentContext == ctx)
        return FALSE;
    return TRUE;
}

void ContextRetain(Js* e, Context* ctx) {
    ctx->ref_count++;
}

void ContextDelete(Js* e, Context* ctx) {
    if(!ctx)
        return;
    
    RealmRelease(e, ctx->realm);
    if(!ContextIsSuspended(e, ctx)) {
        e->currentContext = ctx->prev;
    }

    ctx->ref_count--;
    if(ctx->ref_count == 0) {
        ValDel(e, ctx->lex);
        ValDel(e, ctx->vars);
        ValDel(e, ctx->generator);
        ValDel(e, ctx->function);
        hfree(e->memory[CX].data, ctx);
    }
}

Val* ResolveBinding(Js* e, Val* name, bool_t strict) {
    Context* ctx = e->currentContext;
    return GetIdentifierRef(e, ctx->lex, name, strict);
}

Val* GetThisEnv(Js* e) {
    Context* ctx = e->currentContext;
    Val* lex = ctx->lex;
    while(1) {
        LexEnv* le = lex->lex;
        Env* ev = le->envRec;
        Val* exists = ev->vtable->hasThisBinding(e, ev);
        if(ValIsTrueDel(e, exists)) {
            return ValNewEnv(e, ev);
        }
        lex = lex->lex->outer;
    }
    assert(FALSE);     // global Env will always be root and always have a this_env
    return NULL;
}

Val* GetNewTarget(Js* e) {
    Val* envRec = GetThisEnv(e);
    FuncEnv* fe = (FuncEnv*) envRec->lex->envRec;
    assert(fe->newTarget);
    return ValClone(e, fe->newTarget);
}

Val* ResolveThisBinding(Js* e) {
    Val* evv = GetThisEnv(e);
    Env* ev = evv->env;
    Val* ret = ev->vtable->getThisBinding(e, ev);
    ValDel(e, evv);
    return ret;
}

Val* GetGlobalObject(Js* e) {
    Context* ctx = e->currentContext;
    Realm* r = ctx->realm;
    return ValClone(e, r->globalThis);
}

//////////// 8.4 Tasks and Task Queues
TaskQueue* TaskQueueNew(Js* e, char* name) {
    TaskQueue* q = (TaskQueue*) halloc(e->memory[TQ].data);
    q->name = name;
    q->tasks = NULL;
    return q;
}

void TaskQueueDel(Js* e, TaskQueue* q) {
    for(Task* t = q->tasks; t != NULL; ) {
        Task* n = t->next;
        RealmRelease(e, t->realm);
        hfree(e->memory[TS].data, t);
        t = n;
    }
    hfree(e->memory[TQ].data, q);
}

Val* EnqueueTask(Js* e, Val* queue, TaskFuncPtr tf, List* args) {
    assert(queue->type == TYPE_STR);
    TaskQueue* q = NULL;
    if(StrEqChars(e, queue->str, "LoadingTasks")) {
        q = e->loadingTasks;
    }
    else if(StrEqChars(e, queue->str, "PromiseTasks")) {
        q = e->promiseTasks;
    }
    else {
        assert(0);
    }
    
    assert(q);
    Context* caller_context = e->currentContext;
    Realm* caller_realm = caller_context->realm;
    Task* pt = halloc(e->memory[TS].data);
    pt->taskName = tf;
    pt->args = ListClone(e, args);
    pt->realm = RealmRetain(e, caller_realm);
    pt->next = NULL;
    if(!q->tasks)
        q->tasks = pt;
    else {
        Task* t;
        for(t = q->tasks; t->next != NULL; t = t->next);
        t->next = pt;
    }
    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

TaskQueue* TaskQueueNonEmpty(Js* e) {
    if(e->promiseTasks->tasks)
        return e->promiseTasks;
    if(e->loadingTasks->tasks)
        return e->loadingTasks;
    return NULL;
}

void NextTask(Js* e, Val* result) {
    if(ValIsAbrupt(e, result)) {
        // @todo - 8.4.2.1 need exception mechanism
        assert(0);
    }
    // @todo 8.4.2.2 what does it mean to suspend the current context?
    if(e->currentContext)
        ContextDelete(e, e->currentContext);
    assert(e->currentContext == NULL);
    TaskQueue* next_queue = TaskQueueNonEmpty(e);
    if(next_queue == NULL) {
        return; // @todo: 8.4.2.4 implementation defined?
    }
    Task* nextTask = next_queue->tasks;
    next_queue->tasks = nextTask->next;
    Context* newContext = ContextNew(e, nextTask->realm, NULL, FALSE);
    nextTask->taskName(e, nextTask->args);
    ListDel(e, nextTask->args);
    ContextDelete(e, newContext);    // @todo: is this true?
    RealmRelease(e, nextTask->realm);
    hfree(e->memory[TS].data, nextTask);
}


////// 9.1 ordinary object methods (skeletal implementation)
Val* OrdinaryGetPrototypeOf(Js* e, Val* oarg) {
    Object* o = oarg->obj;
    if(!o->prototype)
        return ValNew(e);
    return ValClone(e, o->prototype);
}

Val* OrdinarySetPrototypeOf(Js* e, Val* o, Val* v) {
    assert(v->type == TYPE_OBJ || v->type == TYPE_NULL);
    assert(o->type == TYPE_OBJ);
    Val* ret = NULL;
    Val* p = NULL;
    Val* nextp = NULL;
    Val* current = NULL;
    
    bool_t extensible = ObjectHasFlag(e, o->obj, OBJ_EXTENSIBLE);
    current = o->obj->prototype;
    if(ValIsTrueDel(e, SameValue(e, current, v)))
        RET(ValNewBool(e, TRUE));
    if(!extensible)
        RET(ValNewBool(e, FALSE));
    
    if(v->type != TYPE_NULL) {
        p = ValClone(e, v);
        while(p != NULL && p->type != TYPE_NULL) {
            if(ValIsTrueDel(e, SameValue(e, p, o)))
                RET(ValNewBool(e, FALSE));
            
            Val* nextp = DoGetPrototypeOf(e, p);
            RET_IF_AB(nextp);
            ValDel(e, p);
            p = nextp;
            nextp = NULL;
        }
    }
    ValDel(e, p);
    p = NULL;
    ValAssign(e, &o->obj->prototype, v);
    ret = ValNewBool(e, TRUE);
exit:
    IFD(p);
    IFD(nextp);
    return ret;
}

Val* OrdinaryIsExtensible(Js* e, Val* o) {
    Object* oarg = o->obj;
    bool_t ext = ObjectHasFlag(e, oarg, OBJ_EXTENSIBLE);
    return ValNewBool(e, ext);
}

Val* OrdinaryPreventExtensions(Js* e, Val* o) {
    Object* oarg = o->obj;
    ObjectClearFlag(e, oarg, OBJ_EXTENSIBLE);
    return ValNewBool(e, TRUE);
}

bool_t SameKey(Js* e, Val* v1, Val* v2) {
    if(v1->type != v2->type)
        return FALSE;
    if(v1->type == TYPE_SYMA && v1->descA == v2->descA)
        return TRUE;
    return (StrEqStr(e, v1->str, v2->str));
}

Val* OrdinaryGetOwnProperty(Js* e, Val* o, Val* key) {
    Object* oarg = o->obj;
    for(Property* p = oarg->properties; p; p = p->next) {
        if(SameKey(e, p->name, key)) {
            Val* vp = ValNew(e);
            vp->type = TYPE_DESC;
            vp->desc = PropClone(e, p);
            return vp;
        }
    }
    
    return ValNew(e);
}

Val* OrdinaryHasProperty(Js* e, Val* o, Val* p) {
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* has_own = DoGetOwnProperty(e, o, p);
    RET_IF_ABRUPT(has_own);
    if(has_own->type == TYPE_UNDEF) {
        ValDel(e, has_own);
        Val* parent = DoGetPrototypeOf(e, o);
        RET_IF_ABRUPT(parent);
        if(parent && parent->type != TYPE_NULL) {
            Val* ret = DoHasProperty(e, parent, p);
            ValDel(e, parent);
            return ret;
        }
        else {
            ValDel(e, parent);
            return ValNewBool(e, FALSE);
        }
    }
    
    ValDel(e, has_own);
    return ValNewBool(e, TRUE);
}

Val* OrdinaryGet(Js* e, Val* o, Val* p, Val* receiver) {
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* desc = DoGetOwnProperty(e, o, p);
    RET_IF_ABRUPT(desc);
    if(desc->type == TYPE_UNDEF) {
        ValDel(e, desc);
        Val* parent = DoGetPrototypeOf(e, o);
        RET_IF_ABRUPT(parent);
        if(!parent || parent->type == TYPE_NULL) {
            ValDel(e, parent);
            return ValNew(e);
        }
        Val* ret = DoGet(e, parent, p, receiver);
        ValDel(e, parent);
        return ret;
    }
    if(PropIsData(e, desc->desc)) {
        Val* ret =  PropGetValue(e, desc->desc);
        ValDel(e, desc);
        return ret;
    }
    Val* getter = ValClone(e, desc->desc->get);
    ValDel(e, desc);
    if(!getter) {
        return ValNew(e);
    }
    Val* ret = DoCall(e, getter, receiver, NULL);
    ValDel(e, getter);
    return ret;
}

Val* OrdinarySet(Js* e, Val* o, Val* p, Val* v, Val* receiver) {
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* parent = NULL;
    Val* own_desc = NULL;
    Val* existing_desc = NULL;
    Val* value_desc = NULL;
    Val* ret = NULL;
    Val* setter = NULL;
    Val* setter_result = NULL;
    Val* args = NULL;
    
    own_desc = DoGetOwnProperty(e, o, p);
    RET_IF_AB(own_desc);
    if(own_desc->type == TYPE_UNDEF) {
        parent = DoGetPrototypeOf(e, o);
        RET_IF_AB(parent);
        if(!ValIsNull(parent)) {
            RET(DoSet(e, parent, p, v, receiver));
        }
        else {
            ValDel(e, own_desc);
            own_desc = ValNewDesc(e);
            own_desc->desc->value = ValNew(e);
            PropSetWritable(e, own_desc->desc, TRUE);
            PropSetEnumerable(e, own_desc->desc, TRUE);
            PropSetConfigurable(e, own_desc->desc, TRUE);
        }
    }
    if(PropIsData(e, own_desc->desc)) {
        if(!PropIsWritable(e, own_desc->desc) || !ValIsObject(receiver)) {
            RET(ValNewBool(e, FALSE));
        }
        existing_desc = DoGetOwnProperty(e, receiver, p);
        RET_IF_AB(existing_desc);
        if(existing_desc->type != TYPE_UNDEF) {
            value_desc = ValNewDesc(e);
            value_desc->desc->value = ValClone(e, v);
            RET(DoDefineOwnProperty(e, receiver,p, value_desc));
        }
        else {
            RET(CreateDataProp(e, receiver, p, v));
        }
    }
    else if(IsAccessorDesc(e, own_desc->desc)) {
        setter = ValClone(e, own_desc->desc->set);
        if(ValIsUndef(setter))
            RET(ValNewBool(e, FALSE));
        
        List* arg_list = ListNew(e);
        ListAddValue(e, arg_list, ValClone(e, v));
        args = ValNewList(e, arg_list);
        setter_result = DoCall(e, setter, receiver, args);
        ValDel(e, args);
        RET_IF_AB(setter_result);
        RET(ValNewBool(e, TRUE));
    }
    
    ret = ValNewBool(e,  TRUE);
exit:

    IFD(setter);
    IFD(setter_result);
    IFD(value_desc);
    IFD(parent);
    IFD(own_desc);
    IFD(existing_desc);
    return ret;
}

Val* OrdinaryDelete(Js* e, Val* o, Val* p) {
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* desc = DoGetOwnProperty(e, o, p);
    if(ValIsUndef(desc)) {
        ValDel(e, desc);
        return ValNewBool(e, TRUE);
    }
    if(PropIsConfigurable(e, desc->desc)) {
        Property* last = NULL;
        for(Property* pr = o->obj->properties; pr != NULL; pr = pr->next) {
            if(StrEqStr(e, pr->name->str, p->str)) {
                if(last)
                    last->next = pr->next;
                else {
                    o->obj->properties = pr->next;
                    o->obj->tail = pr;
                }
                if(o->obj->tail == pr) 
                    o->obj->tail = last;
                PropDel(e, pr);
                ValDel(e, desc);
                return ValNewBool(e, TRUE);
            }
            last = pr;
        }
    }
    ValDel(e, desc);
    return ValNewBool(e, FALSE);
}

void ObjInsertProp(Js* e, Object* o, Property* p) {
    if(e->options.tailInsert) {
        if(!o->tail) {
            assert(!o->properties);
            o->properties = p;
            o->tail = p;
        }
        else {
            assert(o->properties);
            o->tail->next = p;
            o->tail = p;
        }
    }
    else {
        p->next = o->properties;
        o->properties = p;
    }
}

Val* ValidateApplyPropDesc(Js* e, Val* o, Val* p, bool_t extensible, Val* desc, Val* current) {
    if(o->type != TYPE_UNDEF)
        assert(ValIsTrueDel(e, IsPropKey(e, p)));
    
    Property* dp = desc->desc;
    if(dp && dp->value && dp->value->type != TYPE_NUM)
        ObjectClearFlag(e, o->obj, OBJ_ALLNUM);

    if(current->type == TYPE_UNDEF) {
        if(!extensible)
            return ValNewBool(e, FALSE);
        if(PropIsGeneric(e, desc->desc) || PropIsData(e, desc->desc)) {
            if(o->type != TYPE_UNDEF) {
                Property* np = PropNew(e);
                PropSetName(e, np, p, TRUE);
                np->flags = dp->flags;
                PropSetValue(e, np, dp->value);
                ObjInsertProp(e, o->obj, np);
                return ValNewBool(e, TRUE);
            }
        }
        else {
                Property* np = PropNew(e);
                PropSetName(e, np, p, TRUE);
                if(PropHasConfigurable(e, dp))
                    PropSetConfigurable(e, np, PropIsConfigurable(e, dp));
                if(PropHasEnumerable(e, dp))
                    PropSetEnumerable(e, np, PropIsEnumerable(e, dp));
                ValAssign(e, &np->set, dp->set);
                ValAssign(e, &np->get, dp->get);
                ObjInsertProp(e, o->obj, np);
                return ValNewBool(e, TRUE);
        }
        return ValNewBool(e, TRUE);
    }
    
    Property* cp = current->desc;
    // We now make cp the current property on the object replacing
    // what was already there... While expensive, this ensures that
    // GetOwnProperty() will always return a copy of the descriptor
    // and not a true reference. This makes it compatible with the
    // ES6 language specifications
    for(Property* prop = o->obj->properties; prop; prop = prop->next) {
        if(SameKey(e, prop->name, p)) {
            cp = prop;
            break;
        }
    }
    
    if(!dp->value && dp->flags == 0 && dp->get == NULL && dp->set == NULL)
        return ValNewBool(e, TRUE);
    if(PropEq(e, dp, cp))
        return ValNewBool(e, TRUE);
    
    if(!PropIsConfigurable(e, cp)) {
        if(PropIsConfigurable(e, dp))
            return ValNewBool(e, FALSE);
        if(PropHasEnumerable(e, dp) && PropIsEnumerable(e, dp) != PropIsEnumerable(e, cp))
            return ValNewBool(e, FALSE);
    }
    
    if(PropIsGeneric(e, dp)) {
    
    }
    else if(PropIsData(e, cp) != PropIsData(e, dp)) {
        if(PropIsConfigurable(e, cp))
            return ValNewBool(e, FALSE);
        if(PropIsData(e, cp)) {
            if(o->type != TYPE_UNDEF) {
                // convert data to accessor
                ValDel(e, cp->value);
                cp->value = NULL;
                cp->flags = ~(PROP_NOT_WRITEABLE | PROP_WRITEABLE);
                ValAssign(e, &cp->set, dp->set);
                ValAssign(e, &cp->get, dp->get);
            }
        }
        else {
            if(o->type != TYPE_UNDEF) {
                // convert accessor to data
                cp->value = ValNew(e);
                if(PropHasWritable(e, dp))
                    PropSetWritable(e, cp, PropIsWritable(e, dp));
                ValAssign(e, &cp->set, NULL);
                ValAssign(e, &cp->get, NULL);
            }
        }
    }
    else if(PropIsData(e, cp) && PropIsData(e, dp)) {
        if(PropIsConfigurable(e, cp) == FALSE) {
            if(PropIsWritable(e, cp) == FALSE && PropIsWritable(e, dp) == TRUE)
                return ValNewBool(e, FALSE);
            if(PropIsWritable(e, cp) == FALSE) {
                if(dp->value) {
                    if(FALSE == ValIsTrueDel(e, SameValue(e, cp->value, dp->value)))
                        return ValNewBool(e, FALSE);
                }
            }
        }
    }
    else if(IsAccessorDesc(e, cp) && IsAccessorDesc(e, dp)) {
        if(PropIsConfigurable(e, cp) == FALSE) {
            if(dp->set && !ValIsTrueDel(e, SameValue(e, dp->set, cp->set)))
                return ValNewBool(e, FALSE);
            if(dp->get && !ValIsTrueDel(e, SameValue(e, dp->get, cp->get)))
                return ValNewBool(e, FALSE);
        }
    }
    
    if(o->type != TYPE_UNDEF) {
        if(dp->value)
            PropSetValue(e, cp, dp->value);
        if(PropHasConfigurable(e, dp))
            PropSetConfigurable(e, cp, PropIsConfigurable(e, dp));
        if(PropHasWritable(e, dp))
            PropSetWritable(e, cp, PropIsWritable(e, dp));
        if(PropHasEnumerable(e, dp))
            PropSetEnumerable(e, cp, PropIsEnumerable(e, dp));
        if(dp->set)
            ValAssign(e, &cp->set, dp->set);
        if(dp->get)
            ValAssign(e, &cp->get, dp->get);
        if(dp->origin)
            ValAssign(e, &cp->origin, dp->origin);
    }
    
    return ValNewBool(e, TRUE);
}

Val* IsCompatiblePropDesc(Js* e, bool_t extensible, Val* desc, Val* current) {
    Val* o = ValNew(e);
    Val* p = ValNew(e);
    Val* ret = ValidateApplyPropDesc(e, o, p, extensible, desc, current);
    ValDel(e, p);
    ValDel(e, o);
    return ret;
}

Val* OrdinaryDefineOwnProperty(Js* e, Val* o, Val* p, Val* desc) {
    Val* current = DoGetOwnProperty(e, o, p);
    bool_t extensible = ObjectHasFlag(e, o->obj, OBJ_EXTENSIBLE);
    Val* ret = ValidateApplyPropDesc(e, o, p, extensible, desc, current);
    ValDel(e, current);
    return ret;
}

Val* OrdinaryEnumerate(Js* e, Val* o) {
    Val* iterator = NULL;
    Val* ret = NULL;
    Val* proto = NULL;
    
    proto = DoGetPrototypeOf(e, o);
    RET_IF_AB(proto);
    if(ValIsNull(proto)) {
        iterator = CreateEmptyIterator(e);
    }
    else {
        iterator = DoEnumerate(e, proto);
        RET_IF_AB(iterator);
    }
    List* prop_list = ObjectGetSlot(e, iterator->obj, _IteratedList_)->list;
    
    for(Property* pr = o->obj->properties; pr != NULL; pr = pr->next) {
        if(pr->name->type == TYPE_STR) {
            if(ListHasValue(e, prop_list, pr->name)) {
                ListDelItem(e, prop_list, pr->name);
            }
            if(PropIsEnumerable(e, pr)) {
                ListAddValue(e, prop_list, ValClone(e, pr->name));
            }
        }
    }
    
    ret = iterator;
    iterator = NULL;
    
exit:
    IFD(proto);
    IFD(iterator);
    return ret;
}

Val* OrdinaryOwnPropertyKeys(Js* e, Val* oarg) {
    Val* li = CreateEmptyIterator(e);
    List* l = ObjectGetSlot(e, li->obj, _IteratedList_)->list;
    
    for(Property* p = oarg->obj->properties; p ; p = p->next) {
        ListAddValue(e, l, ValClone(e, p->name));
    }
    return li;
}


Val* _ObjectCreate(Js* e, Val* proto, Val* data_list, int line) {
    List* l = NULL;
    Val* obj = NULL;
    Val* ret = NULL;
    Val* def = ValNew(e);
    bool_t del_list = FALSE;
    if(!data_list) {
        l = ListNew(e);
        data_list = ValNewList(e, l);
        del_list = TRUE;
    }
    obj = _ValNewObject(e, line);

    if(ValIsNull(proto))
        proto = e->currentContext->realm->objectPrototype;

    Val* r = DoSetPrototypeOf(e, obj, proto);
    ValDel(e, r);
    ObjectSetFlag(e, obj->obj, OBJ_EXTENSIBLE);
    
    for(int i = 0; i < data_list->list->count; i++) {
        Val* p = ListGetValue(e, data_list->list, i);
        Val* r = Put(e, obj, p, def, TRUE);
        ValDel(e, r);
        ValDel(e, p);
    }
    
    ret = obj;
    obj = NULL;
    
    if(del_list)
        ValDel(e, data_list);
    IFD(obj);
    IFD(def);
    return ret;
}

Val* OrdinaryCreateFromConstructor(Js* e, Val* cons, Val* def_proto, Val* data_list) {
    Val* proto = NULL;
    Val* ret = NULL;
    
    proto = GetPrototypeFromConstructor(e, cons, def_proto);
    RET_IF_AB(proto);
    ret = ObjectCreate(e, proto, data_list);
    
exit:
    IFD(proto);
    return ret;
}


Val* OrdinaryCall(Js* e, Val* oarg, Val* othis, Val* args) {
    return NULL;
}

Val* OrdinaryConstruct(Js* e, Val* oarg, Val* args) {
    return NULL;
}


////// 9.2 function object methods
void FunctionDestruct(Js* e, Object* func);

// @note - used to override actual property, now just the copy descriptor
Val* FunctionGetOwnProperty(Js* e, Val* f, Val* p) {
    Val* v = OrdinaryGetOwnProperty(e, f, p);
    RET_IF_ABRUPT(v);
    if(IsDataDesc(e, v)) {
        if(ValEqStrA(e, p, "caller")) {
            if(ObjectIs(e, v->desc->value, CurrentRealm(e)->functionConstructor)) {
                if(ObjectGetSlot(e, v->desc->value->obj, _Strict_)->b) {
                    Val* nv = ValNewNull(e);
                    PropSetValue(e, v->desc, nv);
                    ValDel(e, nv);
                }
            }
        }
    }
    return v;
}

Val* FunctionAllocate(Js* e, Val* proto, bool_t strict, char* kind) {
    assert(proto->type == TYPE_OBJ);
    if(kind)
        assert(strcmp(kind, "normal")==0 || strcmp(kind, "generator")==0 || strcmp(kind, "non-constructor") ==0);
    else
        kind = "normal";
    bool_t needConstruct;
    if(strcmp(kind, "non-constructor") == 0) {
        kind = "normal";
        needConstruct = FALSE;
    }
    else
        needConstruct = TRUE;

    Val* f = ObjectCreate(e, proto, NULL);
    ObjectSetMethod(e, f->obj, _Call_, FunctionCall, FALSE);
    if(!strict)
        ObjectSetMethod(e, f->obj, _GetOwnProperty_, FunctionGetOwnProperty, FALSE);

    if(needConstruct) {
        ObjectSetMethod(e, f->obj, _Construct_, FunctionConstruct, FALSE);
        if(strcmp(kind, "generator") == 0)
            ObjectSetSlot(e, f->obj, _ConstructorKind_, ValNewStrA(e, "derived"), FALSE, TRUE);
        else
            ObjectSetSlot(e, f->obj, _ConstructorKind_, ValNewStrA(e, "base"), FALSE, TRUE);
    }
    ObjectSetMethod(e, f->obj, _Destruct_, FunctionDestruct, FALSE);
    Val vk;
    ValInit(&vk);
    vk.type = TYPE_SYMA;
    vk.descA = kind;
    
    ObjectSetSlot(e, f->obj, _FunctionKind_, &vk, FALSE, FALSE);
    ObjectSetSlot(e, f->obj, _Realm_, ValNewPtr(e, e->currentContext->realm), FALSE, TRUE);
    ObjectSetSlot(e, f->obj, _Strict_, ValNewBool(e, strict), FALSE, TRUE);
    return f;
}


Val* AddRestrictedFuncProps(Js* e, Val* f) {
    Val* thrower = ValClone(e, CurrentRealm(e)->throwTypeErrorFunction);
    Val* desc = ValNewDesc(e);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, FALSE);
    desc->desc->set = ValClone(e, thrower);
    desc->desc->get = ValClone(e, thrower);
    ValDel(e, thrower);
    Val* caller = ValNewStrA(e, "caller");    // @todo symbol
    Val* status = DefinePropOrThrow(e, f, caller, desc);
    ValDel(e, caller);
    RET_IF_ABRUPT_CV2(status, desc, thrower);
    ValDel(e, status);
    Val* arguments = ValNewStrA(e, "arguments"); // @todo symbol
    status = DefinePropOrThrow(e, f, arguments, desc);
    ValDel(e, arguments);
    RET_IF_ABRUPT_CV2(status, thrower, desc);
    ValDel(e, desc);
    return status;
}

bool_t ValIsFunc(Js* e, Val* v) {
    if(!ValIsObject(v))
        return FALSE;
    Realm* i = CurrentRealm(e);
    if(ObjectIs(e, v, i->functionConstructor))
        return TRUE;
    if(ObjectIs(e, v, i->generatorObject))
        return TRUE;
    if(ObjectIs(e, v, i->functionPrototype))
        return TRUE;
    return FALSE;
}

Val* MakeCons(Js* e, Val* f, bool_t* writeable_proto, Val* proto) {
    assert(ValIsFunc(e, f));
    bool_t install = FALSE;
    Val* ret = NULL;
    Val* status = NULL;
    Val* desc_f = NULL;
    Val* desc_p = NULL;
    Val* cons_name = ValNewStrA(e, "constructor"); // @todo symbol
    
    Val* prototype = NULL; // ValClone(e, proto);
    bool_t writable = TRUE;
    
    if(proto) {
        prototype = ValClone(e, proto);
    }
    else {
        install = TRUE;
        prototype = ObjectCreate(e, NULL, NULL);
    }

    if(writeable_proto) {
        writable = *writeable_proto;
    }
    
    ObjectSetMethod(e, f->obj, _Construct_, FunctionConstruct, FALSE);
    if(install) {
        Val* consFunc = ValClone(e, f); // ValNewPtr(e, f);
        desc_p = DescNew(e, consFunc, writable, FALSE, writable, FALSE);
        ValDel(e, consFunc);
        status = DefinePropOrThrow(e, prototype, cons_name, desc_p);
        RET_IF_AB(status);
        ValDel(e, status);
    }
    desc_f = DescNew(e, prototype, FALSE, FALSE, writable, FALSE);
    
    // @todo: This will now introduce a circular reference between F and prototype
    // since F.prototype=O and O.constructor=F
    status = DefinePropOrThrow(e, f, e->prototype, desc_f);
    
    RET_IF_AB(status);
    ValDel(e, status);
    status = NULL;
    ret = ValNewCompA(e, COMP_NORMAL, NULL, NULL);
    
exit:
    IFD(cons_name);
    IFD(desc_f);
    IFD(desc_p);
    IFD(prototype);
    IFD(status);
    return ret;
}

Val* MakeMethod(Js* e, Val* f, Val* methodName, Val* homeObj) {
    assert(ObjectIs(e, f, CurrentRealm(e)->functionConstructor));
    assert(ValIsUndef(methodName) || ValIsTrueDel(e, IsPropKey(e, methodName)));
    assert(ValIsObject(homeObj) || ValIsUndef(homeObj));
    ObjectSetSlot(e, f->obj, _NeedsSuper_, ValNewBool(e, TRUE), TRUE, TRUE);
    ObjectSetSlot(e, f->obj, _HomeObject_, homeObj, TRUE, FALSE);
    ObjectSetSlot(e, f->obj, _MethodName_, methodName, TRUE, FALSE);
    return ValNewCompA(e, COMP_NORMAL, NULL, NULL);
}

Val* SetFunctionName(Js* e, Val* f, Val* name, Val* prefix) {
    Val* ret = NULL, *n1 = NULL, *n2 = NULL, *desc = NULL, *n = ValClone(e, name);
    Val* n3 = NULL;

    assert(ObjectHasFlag(e, f->obj, OBJ_EXTENSIBLE));
    Val* prop = DoGetOwnProperty(e, f, e->strName);
    assert(name->type  == TYPE_SYMA || name->type == TYPE_STR);
    if(!ValIsUndef(prefix))
        assert(prefix->type == TYPE_STR);
    if(name->type == TYPE_SYMA) {
        if(name->descA == NULL)
            n = ValNewStrA(e, "");
        else {
            n1 = ValNewStrA(e, "[");
            n2 = ValAddStr(e, n1, name, TRUE);
            n3 = ValAddStrA(e, n2, "]", TRUE);
            ValDel(e, n);
            n = n3;
            n3 = NULL;
            IFZ(n1);
            IFZ(n2);
        }
    }
    if(!ValIsUndef(prefix)) {
        n1 = ValAddStrA(e, prefix, " ", FALSE);
        n2 = ValAddStr(e, n1, n, FALSE);
        ValDel(e, n);
        n = n2;
        n2 = NULL;
    }

    desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, n);
    PropSetWritable(e, desc->desc, FALSE);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, TRUE);
    RET(DefinePropOrThrow(e, f, e->strName, desc));

exit:
    IFD(prop);
    IFD(n);
    IFD(desc);
    IFD(n1);
    IFD(n2);
    return ret;
}

Val* GetSuperBinding(Js* e, Val* obj) {
    if(!ValIsObject(obj))
        return ValNew(e);
    if(!ObjectIs(e, obj, CurrentRealm(e)->functionConstructor))
        return ValNew(e);
    if(ObjectGetSlot(e, obj->obj, _Strict_)->b)
        return ValNew(e);
    return ValClone(e, ObjectGetSlot(e, obj->obj, _HomeObject_));
}

Val* clone_method(Js* e, Val* func, Val* new_home, Val* new_name) {
    assert(ObjectIs(e, func, CurrentRealm(e)->functionConstructor));
    assert(new_home && new_home->type == TYPE_OBJ);
    assert(!new_name || new_name->type == TYPE_UNDEF || new_name->type == TYPE_SYMA || new_name->type == TYPE_STR);
    Val* new_func = ObjectCreate(e, func->obj->prototype, NULL);
    Object* fs = func->obj;
    Object* fd = new_func->obj;
    
    ObjectSetSlot(e, fd, _Code_, ObjectGetSlot(e, fs, _Code_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _Parser_, ObjectGetSlot(e, fs, _Parser_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _Environment_, ObjectGetSlot(e, fs, _Environment_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _FormalParams_, ObjectGetSlot(e, fs, _FormalParams_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _FunctionKind_, ObjectGetSlot(e, fs, _FunctionKind_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _Realm_, ObjectGetSlot(e, fs, _Realm_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _Strict_, ObjectGetSlot(e, fs, _Strict_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _ThisMode_, ObjectGetSlot(e, fs, _ThisMode_), TRUE, FALSE);
    ObjectSetSlot(e, fd, _NeedsSuper_, ObjectGetSlot(e, fs, _NeedsSuper_), TRUE, FALSE);

    if(ObjectGetSlot(e, fs, _NeedsSuper_)->b) {
        ObjectSetSlot(e, fd, _HomeObject_, new_home, TRUE, FALSE);
        if(!ValIsUndef(new_name)) {
            ObjectSetSlot(e, fd, _MethodName_, new_name, TRUE, FALSE);
        }
        else {
            ObjectSetSlot(e, fd, _MethodName_, ObjectGetSlot(e, fs, _MethodName_), TRUE, FALSE);
        }
    }
    return new_func;
}

enum { FUNC_NORMAL, FUNC_ARROW, FUNC_METHOD };

Val* FunctionInitialize(Js* e, Val* f, int kind, Node* param_list, Node* body, Val* scope) {
    Parser* p = (Parser*) ObjectGetSlotPtr(e, f, _Parser_);
    ParserRetain(p);
    int len = ExpectedArgCount(p, param_list);
    Object* fo = f->obj;
    bool_t strict = ObjectGetSlot(e, fo, _Strict_)->b;
    Val* desc = ValNewDesc(e);
    desc->desc->value = ValNewNum(e, (number) len);
    PropSetWritable(e, desc->desc, FALSE);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, TRUE);
    Val* slen = ValNewStrA(e, "length");      // @todo - symbol
    Val* status = DefinePropOrThrow(e, f, slen, desc);
    ValDel(e, desc);
    ValDel(e, slen);
    RET_IF_ABRUPT(status);
    if(strict) {
        ValDel(e, status);
        status = AddRestrictedFuncProps(e, f);
        RET_IF_ABRUPT(status);
    }
    Val* scopePtr = ValClone(e, scope); //  (scope) ? ValNewPtr(e, scope->env) : NULL;
    ObjectSetSlot(e, fo, _Environment_, scopePtr, TRUE, FALSE);
    ValDel(e, scopePtr);
    ObjectSetSlot(e, fo, _FormalParams_, ValNewPtr(e, param_list), TRUE, TRUE);
    ObjectSetSlot(e, fo, _Code_, ValNewPtr(e, body), TRUE, TRUE);
    
    if(kind == FUNC_ARROW) {
        ObjectSetSlot(e, fo, _ThisMode_, ValNewNum(e, THIS_MODE_LEXICAL), TRUE, TRUE);
    }
    else if(strict) {
        ObjectSetSlot(e, fo, _ThisMode_, ValNewNum(e, THIS_MODE_STRICT), TRUE, TRUE);
    }
    else {
        ObjectSetSlot(e, fo, _ThisMode_, ValNewNum(e, THIS_MODE_GLOBAL), TRUE, TRUE);
    }
    ValDel(e, status);
    return ValClone(e,f);
}

Val* FunctionCreate(Js* e, int kind, Node* params, Node* body, Val* scope, bool_t strict, Val* proto,
                    Parser* p, Node* code) {
    if(!proto)
        proto = CurrentRealm(e)->functionPrototype;
    char* allocKind = "normal";
    if(kind != FUNC_NORMAL)
        allocKind = "non-constructor";

    Val* f = FunctionAllocate(e, proto, strict, allocKind);
    if(p && code) {
        Val* vp = ValNewPtr(p->e, p);
        Val* vc = ValNewPtr(p->e, code);
        ObjectSetSlot(e, f->obj, _Parser_, vp, FALSE, FALSE);
        ObjectSetSlot(e, f->obj, _Code_, vc, FALSE, FALSE);
        ValDel(e, vp);
        ValDel(e, vc);
    }
    Val* ret = FunctionInitialize(e, f, kind, params, body, scope);
    ValDel(e, f);
    return ret;
}

Val* GenFunctionCreate(Js* e, int kind, Node* params, Node* body, Val* scope, bool_t strict, Val* proto) {
    if(!proto)
        proto = CurrentRealm(e)->generatorPrototype;
    Val* f = FunctionAllocate(e, proto, strict, "generator");
    Val* ret = FunctionInitialize(e, f, kind, params, body, scope);
    ValDel(e, f);
    return ret;
}




Val* StringValue(Parser* p, Node* n);
Val* GetBoundName(Parser* p, Node* param);
Node* FunctionDeclaration(Parser* p, int start, uint32 flags);
PtrList* LexicallyScopedDeclarations(Parser* p, Node* n);
Val* IteratorBindingInitialization(Parser* p, Node* node, Val* iterator, Val* env, uint32 flags);
Val* InstantiateFunctionObject(Parser* p, Node* code, Val* scope, uint32 flags);


bool_t NameListHasDuplicates(Parser* p, PtrList* names) {
    Js* e = p->e;

    for(PtrItem* ni = names->head; ni ; ni = ni->next) {        
        Val* middle = StringValue(p, ni->value);

        // Compare left of values
        for(PtrItem* li = names->head; li != ni; li = li->next) {
            Val* left = StringValue(p, li->value);
            if(StringCompare(e, left->str, middle->str) == 0) {
                ValDel(e, left);
                ValDel(e, middle);
                return TRUE;
            }
            ValDel(e, left);
        }

        // Compare right of values
        for(PtrItem* ri = ni->next; ri; ri = ri->next) {
            Val* right = StringValue(p, ri->value);
            if(StringCompare(e, right->str, middle->str) == 0) {
                ValDel(e, right);
                ValDel(e, middle);
                return TRUE;
            }
            ValDel(e, right);
        }
        ValDel(e, middle);
    }

    return FALSE;
}

bool_t IsSimpleParameterList(Parser* p, Node* n);
bool_t ContainsExpression(Parser* p, Node* n);
Node* DoStatement(Parser* p, int start, uint32 flags);
Node* WhileStatement(Parser* p, int start, uint32 flags);
Node* ForVEE(Parser* p, int start, uint32 flags);
Node* ForLEE(Parser* p, int start, uint32 flags);
Node* WithStatement(Parser* p, int start, uint32 flags);
Node* CaseBlock(Parser* p, int start, uint32 flags);
Node* SwitchStatement(Parser* p, int start, uint32 flags);
Node* CaseClause(Parser* p, int start, uint32 flags);
Node* DefaultClause(Parser* p, int start, uint32 flags);
Node* LabelledStatement(Parser* p, int start, uint32 flags);
Node* LabelledItem(Parser* p, int start, uint32 flags);
Node* FunctionStatementList(Parser* p, int start, uint32 flags);
PtrList* TopLevelVarDeclaredNames(Parser* p, Node* n);
Node* TryStatement(Parser* p, int start, uint32 flags);
Node* VariableStatement(Parser* p, int start, uint32 flags);
Node* VariableDeclaration(Parser* p, int start, uint32 flags);
Node* IfStatement(Parser* p, int start, uint32 flags);
Node* BlockStatement(Parser* p, int start, uint32 flags);
Node* LeftHandSideExpression(Parser* p, int start, uint32 flags);
Node* ObjectLiteral(Parser* p, int start, uint32 flags);
Node* ArrayLiteral(Parser* p, int start, uint32 flags);
Node* ForBinding(Parser* p, int start, uint32 flags);
Val* BindingInitialization(Parser* p, Node* identifier, Val* value, Val* env, uint32 flags);
Node* ForDeclaration(Parser* p, int start, uint32 flags);
Node* GeneratorDeclaration(Parser* p, int start, uint32 flags);

bool_t PtrListHasStr(Parser* p, PtrList* list, Val* str, PtrItem* ignore) {
    Js* e = p->e;
    if(!list) return FALSE;
    for(PtrItem* pi = list->head; pi; pi = pi->next) {
        if(pi == ignore)
            continue;
        Val* vn = StringValue(p, pi->value);
        if(StrEqStr(e, vn->str, str->str)) {
            ValDel(e, vn);
            return TRUE;
        }
        ValDel(e, vn);
    }
    return FALSE;
}

PtrList* PtrListClone(Js* e, PtrList* source) {
    PtrList* ret = PtrListNew(e);
    for(PtrItem* pi = source->head; pi ; pi = pi->next)
        PtrListAdd(e, ret, pi->value);
    return ret;
}

// 9.2.13 
PtrList* LexicallyDeclaredNames(Parser* p, Node* n);
Val* FunctionDeclarationInstantiation(Parser* p, Val* func, Val* argumentsList) {
    Js* e = p->e;
    Val* env = e->currentContext->lex;
    Val* ret = NULL;
    Env* envRec = env->lex->envRec;
    Context* calleeContext = e->currentContext;
    Node* code = ObjectGetSlotPtr(e, func, _Code_);
    bool_t strict = ObjectGetSlot(e, func->obj, _Strict_)->b;
    Node* formals = ObjectGetSlotPtr(e, func, _FormalParams_);
    PtrList* parameterNames = BoundNames(p, formals);
    bool_t hasDuplicates = NameListHasDuplicates(p, parameterNames);
    bool_t simpleParameterList = IsSimpleParameterList(p, formals);
    bool_t hasParameterExpressions = ContainsExpression(p, formals);
    PtrList* varNames = VarDeclaredNames(p, code);
    PtrList* varDeclarations = VarScopedDeclarations(p, code);
    PtrList* lexicalNames = LexicallyDeclaredNames(p, code);
    List* functionNames = ListNew(e);
    PtrList* functionsToInitialize = PtrListNew(e);
    Val* fn = NULL, *status = NULL;
    Val* ao = NULL, *formalStatus = NULL;
    uint32 flags = (strict) ? PSTRICT : 0;
    PtrList* instantiatedVarNames = NULL;
    Val* und = ValNew(e);
    Val* varEnv = NULL, *initialValue = NULL;
    Env* varEnvRec = NULL;
    Val* lexEnv = NULL;
    PtrList* lexDeclarations = NULL;
    Val* fo = NULL;

    int count = PtrListCount(e, varDeclarations);
    for(int i = count-1; i >= 0; i--) {
        Node* d = PtrListGet(e, varDeclarations, i);
        if(!NodeHasFlag(p, d, VariableDeclaration) && !NodeHasFlag(p, d, ForBinding)) {
            assert(NodeHasFlag(p, d, FunctionDeclaration) || NodeHasFlag(p, d, GeneratorDeclaration));
            fn = GetBoundName(p, d);
            if(!ListHasValue(e, functionNames, fn)) {
                ListAddValue(e, functionNames, fn);
                PtrListPrepend(e, functionsToInitialize, d);
            }
            else
                IFZ(fn);
        }
    }
    bool_t argumentsObjectNeeded = TRUE;
    int thisMode = (int) (ObjectGetSlot(e, func->obj, _ThisMode_)->num);
    if(thisMode == THIS_MODE_LEXICAL)
        argumentsObjectNeeded = FALSE;
    else if(PtrListHasStr(p, parameterNames, e->strArguments, 0))
        argumentsObjectNeeded = FALSE;
    else if(hasParameterExpressions == FALSE) {
        if(ListHasValue(e, functionNames, e->strArguments) ||
           PtrListHasStr(p, lexicalNames, e->strArguments, 0))
            argumentsObjectNeeded = FALSE;
    }

    for(PtrItem* pi = parameterNames->head; pi ; pi = pi->next) {
        Val* paramName = StringValue(p, pi->value);
        bool_t alreadyDeclared = ValIsTrueDel(e, envRec->vtable->hasBinding(e, envRec, paramName));
        if(alreadyDeclared == FALSE) {
            status = envRec->vtable->createMutableBinding(e, envRec, paramName, FALSE);

            if(hasDuplicates) {
                ValDel(e, status);
                status = envRec->vtable->initializeBinding(e, envRec, paramName, ValNew(e));
            }
            assert(!ValIsAbrupt(e, status));
            IFZ(status);
        }
        ValDel(e, paramName);
    }

    if(argumentsObjectNeeded == TRUE) {
        ao = InstantiateArgumentsObject(e, argumentsList);
        if(strict == TRUE || simpleParameterList == FALSE) {
            CompleteStrictArgumentsObject(e, ao, func, formals, env);   // @todo: review specs
        }
        else {
            CompleteMappedArgumentsObject(e, ao, func, formals, env);
        }
        RET_IF_AB(ao);
        if(strict == TRUE) 
            status = envRec->vtable->createImmutableBinding(e, envRec, e->strArguments);
        else
            status = envRec->vtable->createMutableBinding(e, envRec, e->strArguments, FALSE);
        IFZ(status);
        status = envRec->vtable->initializeBinding(e, envRec, e->strArguments, ao);
        IFZ(status);
        // @todo: How to Append "arguments" to parameterNames? 
    }
    Val* ali = CreateListIterator(e, argumentsList);
    if(hasDuplicates == TRUE) {
        formalStatus = IteratorBindingInitialization(p, formals, ali, und, flags);
    }
    else {
        formalStatus = IteratorBindingInitialization(p, formals, ali, env, flags);
    }
    ValDel(e, ali);
    RET_IF_AB(formalStatus);
    IFZ(formalStatus);

    if(hasParameterExpressions == FALSE) {
        instantiatedVarNames = PtrListClone(e, parameterNames);
        for(PtrItem* pi = varNames->head; pi ; pi = pi->next) {
            Val* n = StringValue(p, pi->value);
            if(!PtrListHasStr(p, instantiatedVarNames, n,0)) {
                PtrListAdd(e, instantiatedVarNames, pi->value);
                status = envRec->vtable->createMutableBinding(e, envRec, n, FALSE);
                IFZ(status);
                status = envRec->vtable->initializeBinding(e, envRec, n, und);
                IFZ(status);
            }
            IFZ(n);
        }
        varEnv = ValClone(e, env);
        varEnvRec = varEnv->lex->envRec;
    }
    else {
        varEnv = NewDeclEnv(e, env);
        varEnvRec = varEnv->lex->envRec;
        ValDel(e, calleeContext->vars);
        calleeContext->vars = ValClone(e, varEnv);
        instantiatedVarNames = PtrListNew(e);
        for(PtrItem* pi = varNames->head; pi ; pi = pi->next) {
            Val* n = StringValue(p, pi->value);
            if(!PtrListHasStr(p, instantiatedVarNames, n,0)) {
                PtrListAdd(e, instantiatedVarNames, n);
                status = varEnvRec->vtable->createMutableBinding(e, varEnvRec, n, FALSE);
                IFZ(status);
                if(!PtrListHasStr(p, parameterNames, n,0) || ListHasValue(e, functionNames, n))
                    initialValue = ValNew(e);
                else {
                    initialValue = envRec->vtable->getBindingValue(e, envRec, n, FALSE);
                    RET_IF_AB(initialValue);
                    ValDel(e, varEnvRec->vtable->initializeBinding(e, varEnvRec, n, initialValue));
                }
            }
            IFZ(n);
        }        
    }
    if(strict == FALSE) 
        lexEnv = NewDeclEnv(e, varEnv);        
    else 
        lexEnv = ValClone(e, varEnv);
    Env* lexEnvRec = lexEnv->lex->envRec;
    // ((FuncEnv*) envRec)->topLex = lexEnvRec;
    ValDel(e, calleeContext->lex);
    calleeContext->lex = ValClone(e, lexEnv);
    lexDeclarations = LexicallyScopedDeclarations(p, code);
    for(PtrItem* pi = lexDeclarations->head; pi; pi = pi->next) {
        Node* d = (Node*) pi->value;
        PtrList* bn = BoundNames(p, d);
        for(PtrItem* bni=bn->head; bni; bni = bni->next) {
            Val* dn = StringValue(p, bni->value);
            if(IsConstantDeclaration(p, d))
                status = lexEnvRec->vtable->createImmutableBinding(e, lexEnvRec, dn);
            else
                status = lexEnvRec->vtable->createMutableBinding(e, lexEnvRec, dn, FALSE);
            IFZ(status);
            IFZ(dn);
        }
        PtrListDel(e, bn);
    }

    for(PtrItem *pi = functionsToInitialize->head; pi; pi = pi->next) {
        Node* f = pi->value;
        fn = GetBoundName(p, f);
        fo = InstantiateFunctionObject(p, f, lexEnv, flags);
        status = varEnvRec->vtable->initializeBinding(e, varEnvRec, fn, fo);
        IFZ(status);
    }
    RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
exit:   
    IFD(fo);
    if(lexDeclarations) PtrListDel(e, lexDeclarations);
    IFD(lexEnv);
    IFD(initialValue);
    IFD(varEnv);
    IFD(und);
    if(instantiatedVarNames) PtrListDel(e, instantiatedVarNames);
    IFD(formalStatus);
    IFD(ao);
    IFD(status);
    IFD(fn);
    if(functionsToInitialize) PtrListDel(e, functionsToInitialize);
    if(functionNames) ListDel(e, functionNames);
    if(varNames) PtrListDel(e, varNames);
    if(varDeclarations) PtrListDel(e, varDeclarations);
    if(lexicalNames) PtrListDel(e, lexicalNames);
    if(parameterNames) PtrListDel(e, parameterNames);
    return ret;
}

Val* FunctionDeclarationInit(Parser* p, Val* f, Val* args, Val* envarg) {
    Js* e = p->e;
    Env* env = envarg->lex->envRec;
    Val* formal_status = NULL;
    Object* func = f->obj;
    Node* code = ObjectGetSlotPtr(e, f, _Code_);
    bool_t strict = ObjectGetSlot(e, func, _Strict_)->b;
    Node* formals = ObjectGetSlot(e, func, _FormalParams_)->ptr;
    PtrList* param_names = BoundNames(p, formals);
    PtrList* var_decl = VarScopedDeclarations(p, code);
    PtrList* funcs_init = PtrListNew(e);
    bool_t args_obj_needed;
    Val* undef = ValNew(e);
    Val* argstr = ValNewStrA(e, "arguments");
    int thisMode = (int) (ObjectGetSlot(e, func, _ThisMode_)->num);
    uint32 flags = 0;
    if(strict) 
        flags |= PSTRICT;
    if(thisMode == THIS_MODE_LEXICAL)
        args_obj_needed = FALSE;
    else
        args_obj_needed = TRUE;

    int count = PtrListCount(e, var_decl);
    for(int i = count-1; i >= 0; i--) {
        Node* d = PtrListGet(e, var_decl, i);
        Val* vfn = GetBoundName(p, d);
        if(StrEqStr(e, vfn->str, argstr->str))
            args_obj_needed = FALSE;
        Val* already_declared = env->vtable->hasBinding(e, env, vfn);
        if(!ValIsTrueDel(e, already_declared)) {
            Val* status = env->vtable->createMutableBinding(e, env, vfn, FALSE);
            ValDel(e, vfn);
            assert(!ValIsAbrupt(e, status));
            ValDel(e, status);
            PtrListAdd(e, funcs_init, d);
        }
        ValDel(e, vfn);
    }
    
    int paramCount = PtrListCount(e, param_names);
    for(int i=0; i < paramCount; i++) {
        Node* param_name = PtrListGet(e, param_names, i);
        Val* vpn = StringValue(p, param_name);
        Val* already_declared = env->vtable->hasBinding(e, env, vpn);
        if(!ValIsTrueDel(e, already_declared)) {
            if(StrEqStr(e, vpn->str, argstr->str)) {
                args_obj_needed = FALSE;
            }
        }
        Val* status = env->vtable->createMutableBinding(e, env, vpn, FALSE);
        assert(!ValIsAbrupt(e, status));
        ValDel(e, status);
        status = env->vtable->initializeBinding(e, env, vpn, undef);
        ValDel(e, status);
        ValDel(e, vpn);
    }
    
    if(args_obj_needed) {
        Val* status = env->vtable->createImmutableBinding(e, env, argstr);
        assert(!ValIsAbrupt(e,status));
        ValDel(e, status);
    }
    else {
        Val* status = env->vtable->createMutableBinding(e, env, argstr, FALSE);
        assert(!ValIsAbrupt(e, status));
        ValDel(e, status);
    }
    
    PtrList* varNames = VarDeclaredNames(p, code);
    count = PtrListCount(e, varNames);
    for(int i=0; i < count; i++) {
        Node* var_name = PtrListGet(e, varNames, i);
        Val* vn = StringValue(p, var_name);
        Val* already_declared = env->vtable->hasBinding(e, env, vn);
        if(!ValIsTrueDel(e, already_declared)) {
            Val* status = env->vtable->createMutableBinding(e, env, vn, FALSE);
            assert(!ValIsAbrupt(e, status));
            ValDel(e, status);
        }
        ValDel(e, vn);
    }
    PtrListDel(e, varNames);

    PtrList* lex_decl = LexicallyScopedDeclarations(p, code);
    for(PtrItem* i = lex_decl->head; i != NULL; i = i->next) {
        Node* d = (Node*) i->value;
        Val* vd = GetBoundName(p, d);
        if(IsConstantDeclaration(p, d)) {
            Val* status = env->vtable->createImmutableBinding(e, env, vd);
            ValDel(e, status);
        }
        else {
            Val* status = env->vtable->createMutableBinding(e, env, vd, FALSE);
            assert(!ValIsAbrupt(e, status));
            ValDel(e, status);
        }
        if(IsGeneratorDeclaration(p, d)) {
            PtrListAdd(e, funcs_init, d);
        }
        ValDel(e, vd);
    }
    PtrListDel(e, lex_decl);
    for(PtrItem* i = funcs_init->head; i; i = i->next) {
        Node* f = i->value;
        PtrList* fnl = BoundNames(p, f);
        Node* fn = PtrListGet(e, fnl, 0);
        Val* vfn = StringValue(p, fn);
        Val* fo = InstantiateFunctionObject(p, f, envarg, flags);
        Val* status = env->vtable->setMutableBinding(e, env, vfn, fo, FALSE);
        assert(!ValIsAbrupt(e, status));
        ValDel(e, status);
        ValDel(e, vfn);
    }
    
    Val* ali = CreateListIterator(e, args);
    formal_status = IteratorBindingInitialization(p, formals, ali, envarg, flags);
    ValDel(e, ali);
    Val* ret = NULL;
    RET_IF_AB(formal_status);
    
    if(args_obj_needed) {
        Val* ao = InstantiateArgumentsObject(e, args);
        if(strict) {
            CompleteStrictArgumentsObject(e, ao, f, formals, envarg);
        }
        else {
            CompleteMappedArgumentsObject(e, ao, f, formals, envarg);
        }
        Val* status = env->vtable->initializeBinding(e, env, argstr, ao);
        ValDel(e, status);
        ValDel(e, ao);
    }
    
    ret = ValNewCompA(e, COMP_NORMAL, NULL, NULL);
    
exit:
    ValDel(e, formal_status);
    PtrListDel(e, param_names);
    PtrListDel(e, var_decl);
    ValDel(e, argstr);
    PtrListDel(e, funcs_init);
    ValDel(e, undef);
    return ret;
}

Val* EvaluateBody(Js* e, Val* functionObject);



Val* PrepareForOrdinaryCall(Js* e, Val* f, Val* newTarget) {
    Val* ret = 0, *localEnv = 0;
    assert(!newTarget || newTarget->type == TYPE_UNDEF || newTarget->type == TYPE_OBJ);
    Realm* calleeRealm = ObjectGetSlot(e, f->obj, _Realm_)->ptr;
    Context* calleeContext = ContextNew(e, calleeRealm, NULL, TRUE);
    calleeContext->function = ValClone(e, f);
    localEnv = NewFunctionEnvironment(e, f, newTarget);
    RET_IF_AB(localEnv);
    calleeContext->lex = ValClone(e, localEnv);
    calleeContext->vars = ValClone(e, localEnv);
    RET(ValNewPtr(e, calleeContext));

exit:
    if(ValIsAbrupt(e, ret))
        ContextDelete(e, calleeContext);
    IFD(localEnv);    
    return ret;    
}

Val* OrdinaryCallBindThis(Js* e, Val* f, Val* calleeContext, Val* thisArg) {
    Val* ret = 0;
    int thisMode = ObjectGetSlot(e, f->obj, _ThisMode_)->num;

    if(thisMode == THIS_MODE_LEXICAL) 
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
    Realm* calleeRealm = ObjectGetSlotPtr(e, f, _Realm_);
    Val* localEnv = ((Context*) calleeContext->ptr)->lex;
    Val* thisValue = 0;
    if(thisMode == THIS_MODE_STRICT)
        thisValue = ValClone(e, thisArg);
    else {
        if(ValIsNull(thisArg) || ValIsUndef(thisArg)) {
            thisValue = ValClone(e, calleeRealm->globalThis);
        }
        else {
            thisValue = ToObject(e, thisArg);
            assert(!ValIsAbrupt(e, thisValue));
        }
    }

    Env* envRec = localEnv->lex->envRec;
    RET(envRec->vtable->bindThisValue(e, envRec, thisValue));

exit:
    IFD(thisValue);
    return ret;    
}

Val* OrdinaryCallEvaluateBody(Js* e, Val* f, Val* args) {
    Parser* p = (Parser*) ObjectGetSlotPtr(e, f, _Parser_);
    Val* ret = 0, *status = 0;
    status  = FunctionDeclarationInstantiation(p, f, args);
    RET_IF_AB(status);
    RET(EvaluateBody(e, f));
exit:
    IFD(status);
    return ret;    
}

bool_t IsFunction(Js* e, Val* func) {
return ObjectGetSlotRef(e, func->obj, _Parser_) != 0;
}
Val* FunctionCall(Js* e, Val* f, Val* thisArg, Val* args) {
    Val* ret = 0, *calleeContext = 0, *status = 0, *result = 0;

    assert(IsFunction(e, f));
    if(ValEqStrA(e, ObjectGetSlot(e, f->obj, _FunctionKind_), "classConstructor"))
        RET(ThrowTypeError(e, "no classConstructor", 0,0));
    calleeContext = PrepareForOrdinaryCall(e, f, NULL);
    RET_IF_AB(calleeContext);
    status = OrdinaryCallBindThis(e, f, calleeContext, thisArg);
    RET_IF_AB(status);
    result = OrdinaryCallEvaluateBody(e, f, args);
//    ContextDelete(e, calleeContext->ptr);
//    calleeContext->ptr = 0;
    RET_VAL(result);
exit:
    // If there is a debugger attached and the targetContext is this
    // inner context, we must point it to the parent to allow step in, over 
    // to properly stop at the parent context
    if(e->debugger && e->debugger->targetContext == calleeContext->ptr)
        e->debugger->targetContext = ((Context*)(calleeContext->ptr))->prev;

    if(calleeContext && calleeContext->ptr)
        ContextDelete(e, calleeContext->ptr);
    IFD(result);
    IFD(calleeContext);
    IFD(status);
    return ret;        
}


bool_t FunctionIsStrict(Js* e, Val* func) {
    if(!ValIsObject(func))
        return FALSE;
    
    if(!ObjectIs(e, func, CurrentRealm(e)->functionConstructor))
        return FALSE;
    
    Val* strict = ObjectGetSlot(e, func->obj, _Strict_);
    return ValIsTrue(e, strict);
}

Val* FunctionConstruct(Js* e, Val* f, Val* args, Val* newTarget) {
    Val* ret = 0, *thisArgument = 0, *calleeContext = 0, *result = 0, *status = 0;
    assert(IsFunction(e, f));
    assert(newTarget->type == TYPE_OBJ);
    Val* kind = ObjectGetSlot(e, f->obj, _ConstructorKind_);
    bool_t isBase = ValEqStrA(e, kind, "base");
    if(isBase) {
        // The code above used to use objectPrototype for functions which
        // I believe is wrong and should be functionPrototype... It was
        // causing expressions like f = new function()...; f.constructor to
        // evaluate to ptr
        thisArgument = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->functionPrototype, NULL);

        RET_IF_AB(thisArgument);
    }
    calleeContext = PrepareForOrdinaryCall(e, f, newTarget);
    RET_IF_AB(calleeContext);
    if(isBase) {
        status = OrdinaryCallBindThis(e, f, calleeContext, thisArgument);
        RET_IF_AB(status);
    }
    Val* constructorEnv = ((Context*) calleeContext->ptr)->lex;
    Env* envRec = constructorEnv->lex->envRec;
    result = OrdinaryCallEvaluateBody(e, f, args);
    // We can't check for COMP_RETURN here because EvalBody() will
    // eat up the COMP_RETURN and convert it to COMP_NORMAL
    if(result->type == TYPE_COMP) {
        if(result->completion->value->type == TYPE_OBJ) {
            RET(ValNewCompU(e, COMP_NORMAL, result->completion->value, NULL));
        }
        if(isBase) {
            RET(ValNewCompU(e, COMP_NORMAL, thisArgument, NULL));
        }
        if(!ValIsUndef(result->completion->value)) {
            RET(ThrowTypeError(e, "Constructor invalid return", 0, 0));
        }
    }
    else {
        RET_IF_AB(result);
    }
    RET(envRec->vtable->getThisBinding(e, envRec));

exit:
    if(calleeContext && calleeContext->ptr)
        ContextDelete(e, (Context*) calleeContext->ptr);
    IFD(calleeContext);
    IFD(result);
    IFD(thisArgument);
    IFD(status);
    return ret;
}

Val* ThrowTypeErrorCall(Js* e, Val* o, Val* othis, Val* arg, Val* newTarget) {
    return ThrowTypeError(e,0,0,0);
}

////// 9.3 Builtin Function Objects
Val* BuiltinFunctionCall(Js* e, Val* f, Val* othis, Val* args) {
    Val* rv = ObjectGetSlot(e, f->obj, _Realm_);
    Realm* realm = (Realm*) rv->ptr;
    Context* calleeContext = ContextNew(e, realm, NULL, FALSE);
    calleeContext->function = ValClone(e, f);
    StepsPtr steps = ObjectGetMethod(e, f->obj, _Steps_);
    Val* result = steps(e, f, othis, args, NULL);
    ContextDelete(e, calleeContext);
    return result;
}

Val* BuiltinFunctionConstruct(Js* e, Val* f, Val* args, Val* newTarget) {
    Val* rv = ObjectGetSlot(e, f->obj, _Realm_);
    Realm* realm = (Realm*) rv->ptr;
    Context* calleeContext = ContextNew(e, realm, NULL, FALSE);
    calleeContext->function = ValClone(e, f);
    StepsPtr steps = ObjectGetMethod(e, f->obj, _Steps_);
    Val* result = steps(e, f, NULL, args, newTarget);
    ContextDelete(e, calleeContext);
    return result;
}
// Val* BuiltinFunctionCall(Js* e, Val* o, Val* othis, Val* args) {
//     Val* rv = ObjectGetSlot(e, o->obj, _Realm_);
//     Realm* realm = (Realm*) rv->ptr;
//     Context* calleeContext = ContextNew(e, realm, NULL, FALSE);
//     StepsPtr steps = ObjectGetMethod(e, o->obj, _Steps_);
//     Val* result = steps(e, o, othis, args, NULL);
//     ContextDelete(e, calleeContext);
//     return result;
// }

Val* CreateBuiltinFunction(Js* e, Realm* realm, StepsPtr steps) {
    assert(realm);
    Val* func = ObjectCreate(e, realm->functionPrototype, NULL);
    ObjectSetMethod(e, func->obj, _Call_, BuiltinFunctionCall, FALSE);
    ObjectSetMethod(e, func->obj, _Construct_, BuiltinFunctionConstruct, FALSE);
    ObjectSetMethod(e, func->obj, _GetOwnProperty_, FunctionGetOwnProperty, FALSE);
    ObjectSetMethod(e, func->obj, _Steps_, steps, FALSE);
    ObjectSetSlot(e, func->obj, _Realm_, ValNewPtr(e, realm), FALSE, TRUE);
    Val* ret = AddRestrictedFuncProps(e, func);
    ValDel(e, ret);
    return func;
}

/////// 9.4.1 BoundFunction Objects
Val* BoundFunctionCall(Js* e, Val* o, Val* othis, Val* argsList) {
    Val* boundArgs = ObjectGetSlot(e, o->obj, _BoundArguments_);
    Val* boundThis = ObjectGetSlot(e, o->obj, _BoundThis_);
    Val* target = ObjectGetSlot(e, o->obj, _BoundTargetFunction_);
    List* list = ListClone(e, boundArgs->list);
    ListConcat(e, list, argsList->list);
    Val* args = ValNewList(e, list);
    Val* result = DoCall(e, target, boundThis, args);
    ValDel(e, args);
    return result;
}

Val* BoundFunctionConstruct(Js* e, Val* f, Val* extraArgs, Val* newTarget) {
    Val* target = ObjectGetSlot(e, f->obj, _BoundTargetFunction_);
    assert(ObjectGetMethod(e, target->obj, _Construct_));
    Val* boundArgs = ObjectGetSlot(e, f->obj, _BoundArguments_);
    List* list = ListClone(e, boundArgs->list);
    ListConcat(e, list, extraArgs->list);
    Val* args = ValNewList(e, list);
    if(ValIsTrueDel(e, SameValue(e, f, newTarget)))
        newTarget = target;
    Val* result = DoConstruct(e, target, args, newTarget);
    ValDel(e, args);
    return result;
}

Val* BoundFunctionCreate(Js* e, Val* targetFunc, Val* boundThis, Val* boundArgs) {
    Val* proto = CurrentRealm(e)->functionPrototype;
    Val* obj = ObjectCreate(e, proto, NULL);
    ObjectSetMethod(e, obj->obj, _Call_, BoundFunctionCall, FALSE);
    if(ObjectGetMethod(e, targetFunc->obj, _Construct_)) {
        ObjectSetMethod(e, obj->obj, _Construct_, BoundFunctionConstruct, FALSE);
    }
    ObjectSetFlag(e, obj->obj, OBJ_EXTENSIBLE);
    ObjectSetSlot(e, obj->obj, _BoundTargetFunction_, targetFunc, FALSE, FALSE);
    ObjectSetSlot(e, obj->obj, _BoundThis_, boundThis, FALSE, FALSE);
    ObjectSetSlot(e, obj->obj, _BoundArguments_, boundArgs, FALSE, FALSE);
    return obj;
}


////// 9.4.2 Array Exotic Objects
bool_t IsArrayIndex(Js* e, Val* p) {
    Val* pu32 = ToUint32(e, p);
    Val* pus = ToString(e, pu32);
    uint32 max = 0xffffffff;
    if(!ValIsTrueDel(e, SameValue(e, pus, p))) {
        ValDel(e, pu32);
        ValDel(e, pus);
        return FALSE;
    }
    uint32 u32 = (uint32) pu32->num;
    if(u32 == max) {
        ValDel(e, pu32);
        ValDel(e, pus);
        return FALSE;
    }
    ValDel(e, pu32);
    ValDel(e, pus);
    return TRUE;
}

Val* ArrayDefineOwnProperty(Js* e, Val* o, Val* p, Val* desc) {
    Val* ret = NULL;
    Val* oldLenDesc = NULL;
    Val* oldLen = NULL;
    Val* index = NULL;
    Val* succeeded = NULL;
    
    assert(ValIsTrueDel(e,IsPropKey(e, p)));
    if(ValEqStrA(e, p, "length")) {
        return ArraySetLength(e, o, desc);
    }
    if(IsArrayIndex(e, p)) {
        oldLenDesc = DoGetOwnProperty(e, o, e->strLength);
        assert(oldLenDesc->type == TYPE_DESC);
        assert(PropIsData(e, oldLenDesc->desc));
        oldLen = PropGetValue(e, oldLenDesc->desc);
        index = ToUint32(e, p);
        assert(!ValIsAbrupt(e, index));
        if(index->num >= oldLen->num && !PropIsWritable(e, oldLenDesc->desc)) {
            RET(ValNewBool(e, FALSE));
        }
        succeeded = OrdinaryDefineOwnProperty(e, o, p, desc);
        RET_IF_AB(succeeded);
        if(!ValIsTrue(e, succeeded))
            RET(ValNewBool(e, FALSE));
        
        ValDel(e, succeeded);
        succeeded = NULL;
        if(index->num >= oldLen->num) {
            index->num++;
            PropSetValue(e, oldLenDesc->desc, index);
            succeeded = OrdinaryDefineOwnProperty(e, o, e->strLength, oldLenDesc);
            RET_IF_AB(succeeded);
            ValDel(e, succeeded);
            succeeded = NULL;
            RET(ValNewBool(e, TRUE));
        }
    }
    ret = OrdinaryDefineOwnProperty(e, o, p, desc);
exit:
    IFD(oldLenDesc);
    IFD(oldLen);
    IFD(index);
    IFD(succeeded);
    return ret;
}

bool_t IsArray(Js* e, Val* a) {
    assert(a->type == TYPE_OBJ);
    return (ObjectGetMethod(e, a->obj, _DefineOwnProperty_ )== ArrayDefineOwnProperty);
}

bool_t IsString(Js* e, Val* s) {
    assert(s->type == TYPE_OBJ);
    return (ObjectGetSlotPtr(e, s, _StringData_) != NULL);
}


Val* _ArrayCreate(Js* e, Val*  length, Val* proto, int line) {
    bool_t delLen = FALSE;
    
    if(!proto || ValIsUndef(proto))
        proto = CurrentRealm(e)->arrayPrototype;
    Val* a = _ObjectCreate(e, proto, NULL, line);
    ObjectSetMethod(e, a->obj, _DefineOwnProperty_, ArrayDefineOwnProperty, FALSE);
    ObjectSetFlag(e, a->obj, OBJ_EXTENSIBLE);
    if(!ValIsUndef(length)) {
        ObjectSetSlot(e, a->obj, _ArrayInitState_, ValNewBool(e, TRUE), FALSE, TRUE);
    }
    else {
        ObjectSetSlot(e, a->obj, _ArrayInitState_, ValNewBool(e, FALSE), FALSE, TRUE);
        length = ValNewNum(e, 0);
        delLen = TRUE;
    }
    
    if(length->num > 0xffffffff) {
        ValDel(e, a);
        if(delLen) ValDel(e, length);
        return ThrowAnyError(e, CurrentRealm(e)->rangeErrorObject, "length out of range ", length, 0);
    }
    
    Val* newLen = DescNew(e, length, FALSE, FALSE, TRUE, FALSE);
    Val* ret = OrdinaryDefineOwnProperty(e, a, e->strLength, newLen);
    ValDel(e, ret);
    if(delLen) ValDel(e, length);
    ValDel(e, newLen);
    ObjectSetFlag(e, a->obj, OBJ_ARRAY);
    return a;
}
Val* _ArrayCreateN(Js* e, int n, int line) {
    Val* nv = ValNewNum(e, n);
    Val* ret = _ArrayCreate(e, nv, NULL, line);
    ValDel(e, nv);
    return ret;
}

int ArrayGetIntLen(Js* e, Val* arr) {
    Val* len = GetA(e, arr, "length");
    int l = (int) len->num;
    ValDel(e, len);
    return l;    
}

void ArraySetN(Js* e, Val* arr, int idx, Val* v, bool_t del) {
    char sindex[255];
    sprintf(sindex, "%d", idx);
    PutA(e, arr, sindex, v, del);
}

Val* ArraySetLength(Js* e, Val* a, Val* desc) {
    if(ValIsUndef(desc->desc->value)) {
        return OrdinaryDefineOwnProperty(e, a, e->strLength, desc);
    }
    ObjectClearFlag(e, a->obj, OBJ_CONT);
    Val* newLenDesc = ValClone(e, desc);
    Val* ret = NULL;
    Val* newLen = ToUint32(e, desc->desc->value);
    Val* numVal = ToNumber(e, desc->desc->value);
    Val* eq = SameValue(e, newLen, numVal);
    Val* oldLenDesc = NULL;
    Val* oldLen = NULL;
    Val* succeeded = NULL;
    Val* deleteSucceeded = NULL;

    if(!ValIsTrue(e, eq)) {
        RET(ThrowAnyError(e, CurrentRealm(e)->rangeErrorObject, "invalid length",0,0));
    }
    PropSetValue(e, newLenDesc->desc, newLen);
    oldLenDesc = DoGetOwnProperty(e, a, e->strLength);
    oldLen = PropGetValue(e, oldLenDesc->desc);
    if(newLen->num >= oldLen->num) {
        RET(OrdinaryDefineOwnProperty(e, a, e->strLength, newLenDesc));
    }
    if(!PropIsWritable(e, oldLenDesc->desc)) {
        RET(ValNewBool(e, FALSE));
    }
    bool_t newWritable = FALSE;
    if(!PropHasWritable(e, newLenDesc->desc) || PropIsWritable(e, newLenDesc->desc)) {
        newWritable = TRUE;
    }
    else {
        newWritable = FALSE;
        PropSetWritable(e, newLenDesc->desc, TRUE);
    }
    
    succeeded = OrdinaryDefineOwnProperty(e, a, e->strLength, newLenDesc);
    RET_IF_AB(succeeded);
    if(!ValIsTrue(e, succeeded)) {
        RET(ValNewBool(e, FALSE));
    }
    while(newLen->num < oldLen->num) {
        oldLen->num -= 1;
        Val* oldLenStr = ToString(e, oldLen);
        deleteSucceeded = DoDelete(e, a, oldLenStr);
        ValDel(e, oldLenStr);
        RET_IF_AB(deleteSucceeded);
        if(!ValIsTrueDel(e, deleteSucceeded)) {
            deleteSucceeded = NULL;
            oldLen->num += 1;
            PropSetValue(e, newLenDesc->desc, oldLen);
            if(newWritable == FALSE)
                PropSetWritable(e, newLenDesc->desc, FALSE);
            ValDel(e, succeeded);
            succeeded = OrdinaryDefineOwnProperty(e, a, e->strLength, newLenDesc);
            RET_IF_AB(succeeded);
            RET(ValNewBool(e, FALSE));
        }
        deleteSucceeded = NULL;
    }
    if(newWritable == FALSE) {
        Val* pd = ValNewDesc(e);
        PropSetWritable(e, pd->desc, FALSE);
        Val* result = OrdinaryDefineOwnProperty(e, a, e->strLength, pd);
        ValDel(e, pd);
        ValDel(e, result);
    }
    RET(ValNewBool(e, TRUE));
exit:
    IFD(deleteSucceeded);
    IFD(succeeded);
    IFD(oldLen);
    IFD(oldLenDesc);
    IFD(numVal);
    IFD(eq);
    IFD(newLen);
    IFD(newLenDesc);
    return ret;
}


Val* CreateArrayIterator(Js* e, Val* array, Val* kind) {
    Val* o = NULL;
    o = ToObject(e, array);
    if(ValIsAbrupt(e, o))
        return o;
    Val* iterator = ObjectCreate(e, CurrentRealm(e)->arrayIteratorPrototype, NULL);
    ObjectSetSlot(e, iterator->obj, _IteratedObject_, o, FALSE, TRUE);
    ObjectSetSlot(e, iterator->obj, _ArrayIteratorNextIndex_, ValNewNum(e,0), FALSE, TRUE);
    ObjectSetSlot(e, iterator->obj, _ArrayIteratorKind_, kind, FALSE, FALSE);
    return iterator;
}

// return true if a >= b
bool_t ValGte(Js* e, Val* a, Val* b) {
    Val* ret = AbstractRelational(e, b, a, TRUE);
    if(ValIsTrueDel(e, ret))
        return TRUE;
    ret = StrictEquality(e, a, b);
    if(ValIsTrueDel(e, ret))
        return TRUE;
    return FALSE;
}

Val* ArrayIteratorPrototypeIteratorCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ValClone(e, othis);
}

Val* ArrayIteratorPrototypeNextCall(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* a = NULL, *index = NULL, *itemKind = NULL, *lenValue = NULL;
    Val* len = NULL, *ret = NULL, *elementKey = NULL, *result = NULL;
    Val* elementValue = NULL, *vt = ValNewBool(e, TRUE), *vf = ValNewBool(e, FALSE);
    Val* und = ValNew(e);

    Val* ot = othis;
    if(!ValIsObject(othis))
        RET(ThrowTypeError(e, "not an object", 0,0));

    if(!ObjectGetSlotRef(e, ot->obj, _IteratedObject_) || !ObjectGetSlotRef(e, ot->obj, _ArrayIteratorKind_) ||
        !ObjectGetSlotRef(e, ot->obj, _ArrayIteratorNextIndex_))
        RET(ThrowTypeError(e, "not an ArrayIterator", 0,0));

    a = ObjectGetSlot(e, ot->obj, _IteratedObject_);
    if(ValIsUndef(a)) 
        RET(CreateResultObject(e, ValNew(e), vt));

    index = ValClone(e, ObjectGetSlot(e, ot->obj, _ArrayIteratorNextIndex_));
    itemKind = ObjectGetSlot(e, ot->obj, _ArrayIteratorKind_);
    lenValue = Get(e, a, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(ValGte(e, index, len)) {
        ObjectSetSlot(e, ot->obj, _IteratedObject_, ValNew(e), TRUE, TRUE);
        RET(CreateResultObject(e, und, vt));
    }
    ObjectSetSlot(e, ot->obj, _ArrayIteratorNextIndex_, ValNewNum(e, index->num+1), TRUE, TRUE);
    if(ValEqStrA(e, itemKind, "key")) {
        result = ValClone(e, index);
        RET(CreateResultObject(e, result, vf));
    }
    else {
        elementKey = ToString(e, index);
        elementValue = Get(e, a, elementKey);
        RET_IF_AB(elementValue);
    }
    if(ValEqStrA(e, itemKind, "value")) {
        result = ValClone(e, elementValue);
    }
    else {
        assert(ValEqStrA(e, itemKind, "key+value"));
        Val* v2 = ValNewNum(e, 2);
        result = ArrayCreate(e, v2, NULL);
        ValDel(e, CreateDataProp(e, result, e->strZero, index));
        ValDel(e, CreateDataProp(e, result, e->strOne, elementValue));
        ValDel(e, v2);
    }
    RET(CreateResultObject(e, result, vf));

exit:
    IFD(lenValue);
    IFD(len);
    IFD(elementKey);
    IFD(elementValue);
    IFD(result);
    IFD(index);
    IFD(vt);
    IFD(vf);
    IFD(und);
    return ret;
}


void InitArrayIteratorPrototype(Js* e, Val* aip) {
    Val* next = NativeFuncNew(e, NULL, ArrayIteratorPrototypeNextCall);
    Val * ret = Put(e, aip, e->strNext, next, FALSE);
    ValDel(e, next);
    ValDel(e, ret);    
    Val* it = NativeFuncNew(e, NULL, ArrayIteratorPrototypeIteratorCall);
    ret = Put(e, aip, e->iterator, it, FALSE);
    ValDel(e, it);
    ValDel(e, ret);
}

Val* ArrayPrototypeValuesCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ot = ToObject(e, othis);
    if(ValIsAbrupt(e, ot))
        return ot;

    Val* kind = ValNewStrA(e, "value");
    Val* ret = CreateArrayIterator(e, ot, kind);
    ValDel(e, kind);
    ValDel(e, ot);
    return ret;
}


void InitArrayPrototype(Js* e, Val* ap) {
    Val* values = NativeFuncNew(e, NULL, ArrayPrototypeValuesCall);
    Val* name = ValNewStrA(e, "values");
    Val * ret = Put(e, ap, name, values, FALSE);
    ValDel(e, name);
    ValDel(e, ret); 
    ret = Put(e, ap, e->iterator, values, FALSE);
    ValDel(e, values);
    ValDel(e, ret);
}

////// 9.4.3 String Exotic Objects
Val* StringCreate(Js* e, Val* proto, Val *str) {
    Val* a = ObjectCreate(e, proto, NULL);
    ObjectSetMethod(e, a->obj, _GetOwnProperty_, StringGetOwnProperty, FALSE);
    ObjectSetMethod(e, a->obj, _DefineOwnProperty_, StringDefineOwnProperty, FALSE);
    ObjectSetMethod(e, a->obj, _OwnPropertyKeys_, StringOwnPropertyKeys, FALSE);
    ObjectSetMethod(e, a->obj, _Enumerate_, StringEnumerate, FALSE);
    ObjectSetFlag(e, a->obj, OBJ_EXTENSIBLE);
    number len = 0;
    
    if(str) {
        ObjectSetSlot(e, a->obj, _StringData_, str, FALSE, FALSE);
        len = StrLen(e,str->str);
    }
    
    Val* lenVal = ValNewNum(e, len);
    Val* r = Put(e, a, e->strLength, lenVal, TRUE);
    ValDel(e, r);
    ValDel(e, lenVal);
    return a;
}

Val* StringGetOwnProperty(Js* e, Val* o, Val* p) {
    Val* desc = NULL;
    Val* ret = NULL;
    Val* index = NULL;
    Val* absIntIndex = NULL;
    
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    desc = OrdinaryGetOwnProperty(e, o, p);
    RET_IF_AB(desc);
    if(!ValIsUndef(desc)) {
        ret = desc;
        desc = NULL;
        goto exit;
    }
    
    if(p->type != TYPE_STR)
        RET(ValNew(e));
    
    index = ToInteger(e, p);
    assert(!ValIsAbrupt(e, index));
    index->num = fabs(index->num);
    absIntIndex = ToString(e, index);
    if(!ValIsTrueDel(e, SameValue(e, absIntIndex, p)))
        RET(ValNew(e));
    
    Val* str = ObjectGetSlot(e, o->obj, _StringData_);
    if(ValIsUndef(str))
        str = e->strEmpty;
    int len = StrLen(e, str->str);
    if(len <= index->num)
        RET(ValNew(e));
    uchar c = str->str->chars[(int)index->num];
    Val newStr;
    ValInit(&newStr);
    newStr.type = TYPE_STR;
    newStr.str = StrNewLength(e, 1);
    newStr.str->chars[0] = c;
    ret = DescNew(e, &newStr, FALSE, TRUE, FALSE, FALSE);
    ValClear(e, &newStr);
    
exit:
    IFD(absIntIndex);
    IFD(index);
    IFD(desc);
    return ret;
}

Val* StringDefineOwnProperty(Js* e, Val* o, Val* p, Val* desc) {
    Val* current = DoGetOwnProperty(e, o, p);
    bool_t extensible = ObjectHasFlag(e, o->obj, OBJ_EXTENSIBLE);
    Val* ret = ValidateApplyPropDesc(e, o, p, extensible, desc, current);
    ValDel(e, current);
    return ret;
}

Val* StringEnumerate(Js* e, Val* o) {
    return NULL;
}

Val* StringOwnPropertyKeys(Js* e, Val* o) {
    return NULL;
}


////// 9.4.4 Arguments Exotic Objects
Val* InstantiateArgumentsObject(Js* e,Val* args) {
    int len = (args) ? ListGetCount(e, args->list) : 0;
    Val* obj = ObjectCreate(e, CurrentRealm(e)->objectPrototype, NULL);
    Val* desc = DescNew(e, ValNewNum(e, len), TRUE, FALSE, TRUE, TRUE);
    Val* ret = DoDefineOwnProperty(e, obj, e->strLength, desc);
    ValDel(e, desc);
    ValDel(e, ret);
    Val indx;
    ValInitNum(&indx, len-1);
    while(indx.num >= 0) {
        Val* v = ListGetValue(e, args->list, indx.num);
        Val* p = ToString(e, &indx);
        desc = DescNew(e, v, TRUE, TRUE, TRUE, TRUE);
        ret = DoDefineOwnProperty(e, obj, p, desc);
        ValDel(e, desc);
        ValDel(e, ret);
        ValDel(e, p);
        indx.num--;
    }
    
    return obj;
}

void CompleteStrictArgumentsObject(Js* e,Val* obj, Val* func, Node* formals, Val* env) {
    Val* ret = AddRestrictedFuncProps(e, obj);
    ValDel(e, ret);
}

Val* GetBoundName(Parser* p, Node* param) {
    PtrList* names = BoundNames(p, param);
    Node* n = PtrListGet(p->e, names, 0);
    Val* ret = StringValue(p, n);
    PtrListDel(p->e, names);
    return ret;
}

 Node* ParseGetParameter(Parser* p, Node* args, int index) {
    int i = 0;
    for(Node* a = args; a ; a = a->right) {
        Node* arg = a->left;
        if(i == index)
            return arg;
    }
    return NULL;
 }
void CompleteMappedArgumentsObject(Js* e,Val* obj, Val* func, Node* formals, Val* env) {
    Parser* p = (Parser*) ObjectGetSlotPtr(e, func, _Parser_);
    Val* len = Get(e, obj, e->strLength);
    List* mappedNames = ListNew(e);
    int numberOfNonRestFormals = NumberOfParameters(e, formals);
    Val* map = ObjectCreate(e, CurrentRealm(e)->objectPrototype, NULL);
    Val indx;
    ValInitNum(&indx, len->num-1);
    while(indx.num >= 0) {
        if(indx.num < numberOfNonRestFormals) {
            Node* param = ParseGetParameter(p, formals, indx.num);
            if(IsBindingIdentifier(p, param)) {
                Val* name = GetBoundName(p, param); 
                if(!ListHasValue(e, mappedNames, name)) {
                    ListAddValue(e, mappedNames, name);
                    Val* g = MakeArgGetter(e, name, env);
                    Val* p = MakeArgSetter(e, name, env);
                    Val* strIndx = ToString(e, &indx);
                    Val* desc = ValNewDesc(e);
                    desc->desc->set = p;     // No need to copy and delete p
                    desc->desc->get = g;     // No need to copy and delete g
                    Val* ret = DoDefineOwnProperty(e, map, strIndx, desc);
                    ValDel(e, desc);
                    ValDel(e, strIndx);
                    ValDel(e, ret);
                }
                ValDel(e, name);
            }
        }
        indx.num--;
    }
    if(ListGetCount(e, mappedNames) > 0) {
        ObjectSetSlot(e, obj->obj, _ParameterMap_, map, FALSE, TRUE);
        ObjectSetMethod(e, obj->obj, _Get_, ArgumentsGet, FALSE);
        ObjectSetMethod(e, obj->obj, _GetOwnProperty_, ArgumentsGetOwnProperty, FALSE);
        ObjectSetMethod(e, obj->obj, _Delete_, ArgumentsDelete, FALSE);
        ObjectSetMethod(e, obj->obj, _DefineOwnProperty_, ArgumentsDefineOwnProperty, FALSE);
    }
    
    Val* calleeDesc = DescNew(e, func, TRUE, FALSE, TRUE, FALSE);
    Val* ret = DoDefineOwnProperty(e, obj, e->strCallee, calleeDesc);
    ValDel(e, calleeDesc);
    ValDel(e, ret);
    ValDel(e, len);
    ValDel(e, map);
    ListDel(e, mappedNames);
}


Val* ArgGetterCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* env = ObjectGetSlot(e, o->obj, _Environment_);
    Val* name = ObjectGetSlot(e, o->obj, _Name_);
    return env->env->vtable->getBindingValue(e, env->env, name, TRUE);
}

// @note spec deviation, we use a native function here instead of a script parsed function
Val* MakeArgGetter(Js* e, Val* name, Val* env) {
    Val* func = CreateBuiltinFunction(e, CurrentRealm(e), ArgGetterCall);
    ObjectSetSlot(e, func->obj, _Name_, name, FALSE, FALSE);
    ObjectSetSlot(e, func->obj, _Environment_, env, FALSE, FALSE);
    ObjectSetSlot(e, func->obj, _Strict_, ValNewBool(e, TRUE), FALSE, TRUE);
    return func;
}


Val* ArgSetterCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* env = ObjectGetSlot(e, o->obj, _Environment_);
    Val* name = ObjectGetSlot(e, o->obj, _Name_);
    assert(args->type == TYPE_LIST);
    assert(ListGetCount(e, args->list) > 0);
    Val* a0 = ListGetValue(e, args->list, 0);
    Val* ret = env->env->vtable->initializeBinding(e, env->env, name, a0);
    ValDel(e, a0);
    return ret;
    
}

// @note spec deviation using native function instead of script code for setter
Val* MakeArgSetter(Js* e, Val* name, Val* env) {
    Val* func = CreateBuiltinFunction(e, CurrentRealm(e), ArgSetterCall);
    ObjectSetSlot(e, func->obj, _Name_, name, FALSE, FALSE);
    ObjectSetSlot(e, func->obj, _Environment_, env, FALSE, FALSE);
    ObjectSetSlot(e, func->obj, _Strict_, ValNewBool(e, TRUE), FALSE, TRUE);
    return func;
}


Val* ArgumentsGet(Js* e, Val* o, Val* p, Val* receiver) {
    Val* args = o;
    Val* map = ObjectGetSlot(e, o->obj, _ParameterMap_);
    Val* isMapped = DoGetOwnProperty(e, map, p);
    if(ValIsUndef(isMapped)) {
        ValDel(e, isMapped);
        Val* v = OrdinaryGet(e, args, p, args);
        if(ValIsTrueDel(e, SameValue(e, p, e->strCaller))) {
            if(FunctionIsStrict(e, v)) {
                ValDel(e, v);
                return ThrowTypeError(e, "caller not allowed in strict", 0,0);
            }
        }
        return v;
    }
    ValDel(e, isMapped);
    return Get(e, map, p);
}

Val* ArgumentsGetOwnProperty(Js* e, Val* o, Val* p) {
    Val* desc = OrdinaryGetOwnProperty(e, o, p);
    if(ValIsUndef(desc)) {
        return desc;
    }
    
    Val* map = ObjectGetSlot(e, o->obj, _ParameterMap_);
    Val* isMapped = DoGetOwnProperty(e, map, p);
    if(!ValIsUndef(isMapped)) {
        Val* v = Get(e, map, p);
        // @note used to override actual descriptor, now just a copy
        PropSetValue(e, desc->desc, v);
        ValDel(e, v);
    }
    
    ValDel(e, isMapped);
    return desc;
}

Val* ArgumentsDefineOwnProperty(Js* e, Val* arguments, Val* p, Val* desc) {
    Val* map = ObjectGetSlot(e, arguments->obj, _ParameterMap_);
    Val* isMapped = DoGetOwnProperty(e, map, p);
    Val* allowed = OrdinaryDefineOwnProperty(e, arguments, p, desc);
    RET_IF_ABRUPT_CV1(allowed, isMapped);
    if(!ValIsTrueDel(e, allowed)) {
        ValDel(e, isMapped);
        return ValNewBool(e, FALSE);
    }

    if(!ValIsUndef(isMapped)) {
        if(IsAccessorDesc(e, desc->desc)) {
            ValDel(e, DoDelete(e, map, p));
        }
        else {
            if(desc->desc->value) {
                Val* putStatus = Put(e, map, p, desc->desc->value, FALSE);
                assert(ValIsTrueDel(e, putStatus));
            }
            if(PropHasWritable(e, desc->desc) && !PropIsWritable(e, desc->desc)) {
                ValDel(e, DoDelete(e, map, p));
            }
        }
    }
    
    ValDel(e, isMapped);
    return ValNewBool(e, TRUE);
}

Val* ArgumentsDelete(Js* e, Val* arguments, Val* p) {
    Val* map = ObjectGetSlot(e, arguments->obj, _ParameterMap_);
    Val* isMapped = DoGetOwnProperty(e, map, p);
    Val* result = OrdinaryDelete(e, arguments, p);
    if(ValIsTrue(e, result) && !ValIsUndef(isMapped)) {
        ValDel(e, DoDelete(e, map, p));
    }
    ValDel(e, isMapped);
    return result;
}


////// 9.4.5 Integer Indexed Exotic Objects

bool_t IntegerIndexedIsWriteable(Js* e, Object* ii) {
    Val* ro = ObjectGetSlot(e, ii, _IntegerIndexedReadOnly);
    if(!ro)
        return TRUE;
    if(ro->b)
        return FALSE;
    return TRUE;
}

void IntegerIndexedSetWritable(Js* e, Object* ii, bool_t w) {
    if(w)
        ObjectSetSlot(e, ii, _IntegerIndexedReadOnly, ValNewBool(e, FALSE), TRUE, TRUE);
    else
        ObjectSetSlot(e, ii, _IntegerIndexedReadOnly, ValNewBool(e, TRUE), TRUE, TRUE);
}

Val* IntegerIndexedGetOwnProperty(Js* e, Val* o, Val* p) {
    Val *vintIndex = NULL, *svintIndex = NULL, *ret = NULL, *value = NULL;
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    assert(ValIsObject(o));
    assert(ObjectGetSlot(e, o->obj, _ViewArrayBuffer_));
    
    if(p->type == TYPE_STR) {
        vintIndex = ToInteger(e, p);
        assert(!ValIsAbrupt(e, vintIndex));
        int intIndex = (int) vintIndex->num;
        svintIndex = ToString(e, vintIndex);
        if(ValIsTrueDel(e, SameValue(e, svintIndex, p))) {
            Val* value = IntegerIndexedElementGet(e, o, intIndex);
            RET_IF_ABRUPT(value);
            if(ValIsUndef(value))
                RET(value);
            
            bool_t writable = IntegerIndexedIsWriteable(e, o->obj);
            RET(DescNew(e, value, TRUE, TRUE, writable, FALSE));
        }
    }
    ret = OrdinaryGetOwnProperty(e, o, p);
exit:
    IFD(vintIndex);
    IFD(svintIndex);
    IFD(value);
    return ret;
}


Val* IntegerIndexedDefineOwnProperty(Js* e, Val* o, Val* p, Val* desc) {
    Val *vintIndex = NULL, *svintIndex = NULL, *ret = NULL, *oldValue = NULL;
    Val* status = NULL;
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    assert(ValIsObject(o));
    assert(ObjectGetSlot(e, o->obj, _ViewArrayBuffer_));
    
    if(p->type == TYPE_STR) {
        vintIndex = ToInteger(e, p);
        int intIndex = (int) vintIndex->num;
        assert(!ValIsAbrupt(e, vintIndex));
        svintIndex = ToString(e, vintIndex);
        if(ValIsTrueDel(e, SameValue(e, svintIndex, p))) {
            if(intIndex < 0)
                RET(ValNewBool(e, FALSE));
            Val* length = ObjectGetSlot(e, o->obj, _ArrayLength_);
            if(ValIsUndef(length))
                RET(ThrowTypeError(e, "length undefined",0,0));
            if(intIndex >= (int) length->num)
                RET(ValNewBool(e, FALSE));
            if(PropHasConfigurable(e, desc->desc) && PropIsConfigurable(e, desc->desc))
                RET(ValNewBool(e, FALSE));
            if(PropHasEnumerable(e, desc->desc) && !PropIsEnumerable(e, desc->desc))
                RET(ValNewBool(e, FALSE));
            bool_t writable = IntegerIndexedIsWriteable(e, o->obj);
            bool_t makeReadOnly = FALSE;
            if(PropHasWritable(e, desc->desc)) {
                if(PropIsWritable(e, desc->desc) && ! writable)
                    RET(ValNewBool(e, FALSE));
                if(!PropIsWritable(e, desc->desc) && writable)
                    makeReadOnly = TRUE;
            }
            if(desc->desc->value) {
                Val* value = desc->desc->value;
                if(!writable) {
                    oldValue = IntegerIndexedElementGet(e, o, intIndex);
                    RET_IF_AB(oldValue);
                    if(ValIsUndef(oldValue))
                        RET(ValNewBool(e, FALSE));
                    if(!ValIsTrueDel(e, SameValue(e, oldValue, value)))
                        RET(ValNewBool(e, FALSE));
                }
                else {
                    status = IntegerIndexedElementSet(e, o, intIndex, value);
                    RET_IF_AB(status);
                }
            }
            if(makeReadOnly)
                IntegerIndexedSetWritable(e, o->obj, FALSE);
            RET(ValNewBool(e, TRUE));
        }
    }
    ret = OrdinaryDefineOwnProperty(e, o, p, desc);
exit:
    IFD(status);
    IFD(oldValue);
    IFD(vintIndex);
    IFD(svintIndex);
    return ret;
}

Val* IntegerIndexedGet(Js* e, Val* o, Val* p, Val* receiver) {
    Val* ret = NULL, *intIndex = NULL, *sintIndex = NULL;
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    if(p->type == TYPE_STR && ValIsTrueDel(e, SameValue(e, o, receiver))) {
        intIndex = ToInteger(e, p);
        assert(!ValIsAbrupt(e, intIndex));
        sintIndex = ToString(e, intIndex);
        if(ValIsTrueDel(e, SameValue(e, sintIndex, p)))
            RET(IntegerIndexedElementGet(e, o, (int) intIndex->num));
    }
    ret = OrdinaryGet(e, o, p, receiver);
exit:
    IFD(intIndex);
    IFD(sintIndex);
    return ret;
}

Val* IntegerIndexedSet(Js* e, Val* o, Val* p, Val* v, Val* receiver) {
    Val* ret = NULL, *intIndex = NULL, *sintIndex = NULL, *result = NULL, *tb = NULL;
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    if(p->type == TYPE_STR && ValIsTrueDel(e, SameValue(e, o, receiver))) {
        intIndex = ToInteger(e, p);
        assert(!ValIsAbrupt(e, intIndex));
        sintIndex = ToString(e, intIndex);
        if(ValIsTrueDel(e, SameValue(e, sintIndex, p))) {
            result = IntegerIndexedElementSet(e, o, (int) intIndex->num, v);
            ret = ToBoolean(e, result);
            goto exit;
        }
    }
    ret = OrdinarySet(e, o, p, v, receiver);
exit:
    IFD(tb);
    IFD(result);
    IFD(intIndex);
    IFD(sintIndex);
    return ret;

}

Val* IntegerIndexedEnumerate(Js* e, Val* o) {
    // @todo: spec needed
    return NULL;
}

Val* IntegerIndexedOwnPropertyKeys(Js* e, Val* o) {
    Val* ret = 0, *keys = 0, *len = 0;

    assert(ObjectGetSlotRef(e, o->obj, _ViewArrayBuffer_) != 0);
    assert(ObjectGetSlotRef(e, o->obj, _ArrayLength_) != 0);
    assert(ObjectGetSlotRef(e, o->obj, _ByteOffset_) != 0);

    keys = ValNewListEmpty(e);
    len = ObjectGetSlot(e, o->obj, _ArrayLength_);
    for(int i=0; i < len->num; i++) {
        Val ni;
        ValInitNum(&ni, i);
        Val* ts = ToString(e, &ni);
        ListAddValue(e, keys->list, ts);    // owned by the list now        
    }
    for(Property* p=o->obj->properties; p; p = p->next) {
        if(p->name && p->name->type == TYPE_STR) {
            ListAddValue(e, keys->list, ValClone(e, p->name));            
        }
    }
    for(Property* p=o->obj->properties; p; p = p->next) {
        if(p->name && p->name->type == TYPE_SYMA) {
            ListAddValue(e, keys->list, ValClone(e, p->name));            
        }
    }
    RET_VAL(keys);
exit:    
    IFD(keys);
    return ret;
}

Val* IntegerIndexedObjectCreate(Js* e, Val* proto) {
    Val* a = ObjectCreate(e, proto, NULL);
    ObjectSetMethod(e, a->obj, _GetOwnProperty_, IntegerIndexedGetOwnProperty, FALSE);
    ObjectSetMethod(e, a->obj, _DefineOwnProperty_, IntegerIndexedDefineOwnProperty, FALSE);
    ObjectSetMethod(e, a->obj, _Get_, IntegerIndexedGet, FALSE);
    ObjectSetMethod(e, a->obj, _Set_, IntegerIndexedSet, FALSE);
    ObjectSetMethod(e, a->obj, _Enumerate_, IntegerIndexedEnumerate, FALSE);
    ObjectSetMethod(e, a->obj, _OwnPropertyKeys_, IntegerIndexedOwnPropertyKeys, FALSE);
    ObjectSetFlag(e, a->obj, OBJ_EXTENSIBLE);
    return a;
}

Val* IntegerIndexedElementGet(Js* e, Val* o, int index) {
    Val* buffer = ObjectGetSlot(e, o->obj, _ViewArrayBuffer_);
    Val* length = ObjectGetSlot(e, o->obj, _ArrayLength_);
    Val* offset = ObjectGetSlot(e, o->obj, _ByteOffset_);
    Val* arrayTypeName = ObjectGetSlot(e, o->obj, _TypedArrayName_);
    
    assert(buffer && length && offset && arrayTypeName);
    
    if(ValIsUndef(buffer))
        return ThrowTypeError(e, "not a ViewArray",0,0);
    
    if(index < 0 || index >= (int) length->num)
        return ValNew(e);
    
    int elementSize = ElementSizeFromConstructor(e, arrayTypeName);
    int indexedPosition = (index * elementSize) + (int) offset->num;
    int elementType = ElementTypeFromConstructor(e, arrayTypeName);
    return GetValueFromBuffer(e, buffer, indexedPosition, elementType, NULL);
}

Val* IntegerIndexedElementSet(Js* e, Val* o, int index, Val* value) {
    Val* buffer = ObjectGetSlot(e, o->obj, _ViewArrayBuffer_);
    Val* length = ObjectGetSlot(e, o->obj, _ArrayLength_);
    Val* offset = ObjectGetSlot(e, o->obj, _ByteOffset_);
    Val* arrayTypeName = ObjectGetSlot(e, o->obj, _TypedArrayName_);
    
    assert(buffer && length && offset && arrayTypeName);
    if(ValIsUndef(buffer))
        return ThrowTypeError(e, "not IntegerIndexed",0,0);
    
    Val* numValue = NULL, *ret = NULL, *status = NULL;
    
    numValue = ToNumber(e, value);
    RET_IF_AB(numValue);
    
    if(index < 0 || index >= (int) length->num)
        RET(ValNewBool(e, FALSE));
    int elementSize = ElementSizeFromConstructor(e, arrayTypeName);
    int indexedPosition = (index * elementSize) + (int) offset->num;
    int elementType = ElementTypeFromConstructor(e, arrayTypeName);
    
    status = SetValueInBuffer(e, buffer, indexedPosition, elementType, numValue, NULL);
    RET_IF_AB(status);
    ret = ValNewBool(e, TRUE);

exit:
    IFD(status);
    IFD(numValue);
    return ret;
}



// @todo: Move these to buffer objects when implemented

TypedArrayConsData TypedArrayConstructors[]  = {
    //  constructorName         elementType                 elementSize
    {   "Int8Array",            ELEMENT_TYPE_INT8,          1 },
    {   "Uint8Array",           ELEMENT_TYPE_UINT8,         1 },
    {   "Uint8ClampedArray",    ELEMENT_TYPE_UINT8_CLAMPED, 1 },
    {   "Int16Array",           ELEMENT_TYPE_INT16,         2 },
    {   "Uint16Array",          ELEMENT_TYPE_UINT16,        2 },
    {   "Int32Array",           ELEMENT_TYPE_INT32,         4 },
    {   "Uint32Array",          ELEMENT_TYPE_UINT32,        4 },
    {   "Float32Array",         ELEMENT_TYPE_FLOAT32,       4 },
    {   "Float64Array",         ELEMENT_TYPE_FLOAT64,       8 }
};

TypedArrayConsData* TypedArrayConstructorFind(Js* e, Val* name) {
    size_t sizeOne = sizeof(TypedArrayConsData);
    size_t sizeAll = sizeof(TypedArrayConstructors);
    int count = (int) (sizeAll / sizeOne);
    for(int i = 0; i <  count; i++) {
        if(ValEqStrA(e, name, TypedArrayConstructors[i].constructorName))
            return &TypedArrayConstructors[i];
    }
    return NULL;
}

int ElementSizeFromConstructor(Js* e, Val* arrayTypeName) {
    TypedArrayConsData* c = TypedArrayConstructorFind(e, arrayTypeName);
    assert(c);
    return c->elementSize;
}

int ElementTypeFromConstructor(Js* e, Val* arrayTypeName) {
    TypedArrayConsData* c = TypedArrayConstructorFind(e, arrayTypeName);
    assert(c);
    return c->elementType;
}

int ElementSizeFromType(Js* e, int elementType) {
    size_t sizeOne = sizeof(TypedArrayConsData);
    size_t sizeAll = sizeof(TypedArrayConsData);
    int count = (int) (sizeAll / sizeOne);
    for(int i = 0; i <  count; i++) {
        if(TypedArrayConstructors[i].elementType == elementType)
            return TypedArrayConstructors[i].elementSize;
    }
    assert(0);
    return 0;
}


/////// 9.5 Proxy Objects
Val* ProxyCreate(Js* e, Val* target, Val* handler) {
    if(!ValIsObject(target))
        return ThrowTypeError(e, "target not an object", 0,0);
    if(!ValIsObject(handler))
        return ThrowTypeError(e, "handler not an object",0,0);
    Val* p = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, p->obj, _GetPrototypeOf_, ProxyGetPrototypeOf, FALSE);
    ObjectSetMethod(e, p->obj, _SetPrototypeOf_, ProxySetPrototypeOf, FALSE);
    ObjectSetMethod(e, p->obj, _IsExtensible_, ProxyIsExtensible, FALSE);
    ObjectSetMethod(e, p->obj, _PreventExtensions_, ProxyPreventExtensions, FALSE);
    ObjectSetMethod(e, p->obj, _GetOwnProperty_, ProxyGetOwnProperty, FALSE);
    ObjectSetMethod(e, p->obj, _HasProperty_, ProxyHasProperty, FALSE);
    ObjectSetMethod(e, p->obj, _Get_, ProxyGet, FALSE);
    ObjectSetMethod(e, p->obj, _Set_, ProxySet, FALSE);
    ObjectSetMethod(e, p->obj, _Delete_, ProxyDelete, FALSE);
    ObjectSetMethod(e, p->obj, _DefineOwnProperty_, ProxyDefineOwnProperty, FALSE);
    ObjectSetMethod(e, p->obj, _Enumerate_, ProxyEnumerate, FALSE);
    ObjectSetMethod(e, p->obj, _OwnPropertyKeys_, ProxyOwnPropertyKeys, FALSE);
    if(ValIsTrueDel(e, IsCallable(e, target))) {
        ObjectSetMethod(e, p->obj, _Call_, ProxyCall, FALSE);
        if(ObjectGetMethod(e, target->obj, _Construct_))
            ObjectSetMethod(e, p->obj, _Construct_, ProxyConstruct, FALSE);
    }
    
    ObjectSetSlot(e, p->obj, _ProxyTarget_, target, FALSE, FALSE);
    ObjectSetSlot(e, p->obj, _ProxyHandler_, handler, FALSE, FALSE);
    return p;
}

Val* ListNewWithArg(Js* e, Val* a) {
    List* l = ListNew(e);
    ListAddValue(e, l, ValClone(e, a));
    return ValNewList(e, l);
}

Val* ProxyGetPrototypeOf(Js* e, Val* o) {
    Val* handler = NULL, *target = NULL, *trap = NULL, *extensibleTarget = NULL;
    Val* targetProto = NULL, *ret = NULL, *args = NULL, *handlerProto = NULL;
    
    handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler not an object", 0,0 ));
    target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strGetPrototypeOf);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoGetPrototypeOf(e, target));
    
    args = ListNewWithArg(e, target);
    handlerProto = DoCall(e, trap, handler, args);
    RET_IF_AB(handlerProto);
    if(!ValIsObject(handlerProto) && !ValIsNull(handlerProto))
        RET(ThrowTypeError(e, "invalid handler prototype", 0,0));
    extensibleTarget = DoIsExtensible(e, target);
    RET_IF_AB(extensibleTarget);
    if(ValIsTrue(e, extensibleTarget))
        RET_VAL(handlerProto);
    targetProto = DoGetPrototypeOf(e, targetProto);
    RET_IF_AB(targetProto);
    if(!ValIsTrueDel(e, SameValue(e, handlerProto, targetProto)))
        RET(ThrowTypeError(e, "unexpected prototype mismatch", 0,0));
    
    RET_VAL(handlerProto);
    
exit:
    IFD(handlerProto);
    IFD(args);
    IFD(trap);
    IFD(extensibleTarget);
    IFD(targetProto);
    return ret;
}

Val* ProxySetPrototypeOf(Js* e, Val* o, Val* v) {
    Val* trap = NULL, *trapResult = NULL, *booleanTrapResult = NULL;
    Val* extensibleTarget = NULL, *targetProto = NULL, *ret = NULL;
    Val* args = NULL;
    
    assert(ValIsObject(v) || ValIsNull(v));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "invalid handler",0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strSetPrototypeOf);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoSetPrototypeOf(e, target, v));

    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, v));
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    RET_IF_AB(booleanTrapResult);
    extensibleTarget = IsExtensible(e, target);
    RET_IF_AB(extensibleTarget);
    if(ValIsTrue(e, extensibleTarget))
        RET_VAL(booleanTrapResult);
    targetProto = DoGetPrototypeOf(e, target);
    RET_IF_AB(targetProto);
    if(ValIsTrue(e, booleanTrapResult) && !ValIsTrueDel(e, SameValue(e, v, targetProto)))
        RET(ThrowTypeError(e, "proxy prorotype set failed", 0,0));
    RET_VAL(booleanTrapResult);
    
exit:
    IFD(args);
    IFD(trap);
    IFD(trapResult);
    IFD(booleanTrapResult);
    IFD(extensibleTarget);
    IFD(targetProto);
    return ret;
}

Val* ProxyIsExtensible(Js* e, Val* o) {
    Val *trap = NULL, *trapResult = NULL, *booleanTrapResult = NULL,
         *targetResult = NULL, *ret = NULL, *args = NULL;
    
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "invalid handler", 0, 0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strIsExtensible);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoIsExtensible(e, target));
    args = ListNewWithArg(e, target);
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    RET_IF_AB(booleanTrapResult);
    targetResult = DoIsExtensible(e, target);
    RET_IF_AB(targetResult);
    if(!ValIsTrueDel(e, SameValue(e, booleanTrapResult, targetResult)))
        RET(ThrowTypeError(e, "invalid result", 0, 0));
    RET(booleanTrapResult);
exit:
    IFD(args);
    IFD(trap);
    IFD(trapResult);
    IFD(booleanTrapResult);
    IFD(targetResult);
    return ret;
}


// @note spec seems to imply that preventExtensions should cauase future
// calls to the target object's [[IsExtensible]] to somehow return FALSE
Val* ProxyPreventExtensions(Js* e, Val* o) {
    Val *trap = NULL, *trapResult = NULL, *booleanTrapResult = NULL,
         *targetIsExtensible = NULL, *ret = NULL, *args = NULL;
    
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null", 0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strPreventExtensions);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoPreventExtensions(e, target));
    args = ListNewWithArg(e, target);
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    RET_IF_AB(booleanTrapResult);
    targetIsExtensible = DoIsExtensible(e, target);
    RET_IF_AB(targetIsExtensible);
    if(ValIsTrue(e, booleanTrapResult) && ValIsTrue(e, targetIsExtensible))
        RET(ThrowTypeError(e, "target extensible", 0, 0));
    RET_VAL(booleanTrapResult);
exit:
    IFD(args);
    IFD(trap);
    IFD(trapResult);
    IFD(booleanTrapResult);
    IFD(targetIsExtensible);
    return ret;
}

Val* ProxyGetOwnProperty(Js* e, Val* o, Val* p) {
    Val* trap = NULL, *trapResultObj = NULL, *targetDesc = NULL;
    Val* extensibleTarget = NULL, *booleanExtensibleTarget = NULL;
    Val* resultDesc = NULL, *valid = NULL, *ret = NULL, *args = NULL;
    
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null", 0, 0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strGetOwnPropertyDescriptor);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoGetOwnProperty(e, target, p));
    
    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, p));
    trapResultObj = DoCall(e, trap, handler, args);
    RET_IF_AB(trapResultObj);
    if(!ValIsUndef(trapResultObj) && !ValIsObject(trapResultObj))
        RET(ThrowTypeError(e, "trap result not an object", 0, 0));
    targetDesc = DoGetOwnProperty(e, target, p);
    RET_IF_AB(targetDesc);
    if(ValIsUndef(trapResultObj)) {
        if(ValIsUndef(targetDesc))
            RET(ValNew(e));
        if(!PropIsConfigurable(e, targetDesc->desc))
            RET(ThrowTypeError(e, "property not configurable", 0,0));
        extensibleTarget = IsExtensible(e, target);
        RET_IF_AB(extensibleTarget);
        booleanExtensibleTarget = ToBoolean(e, extensibleTarget);
        if(!ValIsTrue(e, booleanExtensibleTarget))
            RET(ThrowTypeError(e, "target not configurable", 0, 0));
        RET(ValNew(e));
    }
    extensibleTarget = IsExtensible(e, target);
    RET_IF_AB(extensibleTarget);
    resultDesc = ToPropertyDesc(e, trapResultObj);
    RET_IF_AB(resultDesc);
    CompletePropertyDesc(e, resultDesc, targetDesc);    // Doesn't copy data
    valid = IsCompatiblePropDesc(e, extensibleTarget->b, resultDesc, targetDesc);
    if(!ValIsTrue(e, valid))
        RET(ThrowTypeError(e, "incompatible properties", 0, 0));
    if(!PropIsConfigurable(e, resultDesc->desc)) {
        if(ValIsUndef(targetDesc) || PropIsConfigurable(e, targetDesc->desc))
            RET(ThrowTypeError(e, "undefined target or configurable property", 0, 0));
    }
    RET_VAL(resultDesc);
    
exit:
    IFD(valid);
    IFD(args);
    IFD(trap);
    IFD(trapResultObj);
    IFD(targetDesc);
    IFD(extensibleTarget);
    IFD(booleanExtensibleTarget);
    IFD(resultDesc);
    return ret;
}

Val* ProxyDefineOwnProperty(Js* e, Val* o, Val* p, Val* desc) {
    Val* trap = NULL, *descObj = NULL, *booleanTrapResult = NULL;
    Val* args = NULL, *targetDesc = NULL, *extensibleTarget = NULL;
    Val* settingConfigFalse = NULL, *ret = NULL, *trapResult = NULL;

    assert(ValIsTrueDel(e, IsPropKey(e,p)));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null", 0, 0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strDefineProperty);
    RET_IF_AB(trap);
    if(ValIsUndef(trap)) 
        RET(DoDefineOwnProperty(e, target, p, desc));
    descObj = FromPropertyDesc(e, desc);
    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e,p));
    ListAddValue(e, args->list, ValClone(e, descObj));
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    targetDesc = DoGetOwnProperty(e, target, p);
    RET_IF_AB(targetDesc);
    extensibleTarget = IsExtensible(e, target);
    RET_IF_AB(extensibleTarget);
    if(PropHasConfigurable(e, desc->desc) && !PropIsConfigurable(e, desc->desc)) 
        settingConfigFalse = ValNewBool(e, TRUE);
    else
        settingConfigFalse = ValNewBool(e, FALSE);
    if(ValIsUndef(targetDesc)) {
        if(!ValIsTrue(e, extensibleTarget))
            RET(ThrowTypeError(e, "non_extensible target",0,0));
        if(ValIsTrue(e, settingConfigFalse))
            RET(ThrowTypeError(e, "failed to set config", 0, 0));
    }
    else {
        if(!ValIsTrueDel(e, IsCompatiblePropDesc(e, extensibleTarget->b, desc, targetDesc)))
            RET(ThrowTypeError(e, "incompatible properties",0,0));
        if(ValIsTrue(e, settingConfigFalse) && PropIsConfigurable(e, targetDesc->desc))
            RET(ThrowTypeError(e, "failt to set config", 0, 0));
    }
    RET(ValNewBool(e, TRUE));

exit:
    IFD(trap);
    IFD(descObj);
    IFD(booleanTrapResult);
    IFD(args);
    IFD(targetDesc);
    IFD(extensibleTarget);
    IFD(settingConfigFalse);    
    IFD(trapResult);
    return ret;
}

Val* ProxyHasProperty(Js* e, Val* o, Val* p) {
    Val* trap = NULL, *trapResult = NULL, *booleanTrapResult = NULL;
    Val* ret = NULL, *targetDesc = NULL, *extensibleTarget = NULL;
    Val* args = NULL;

    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null", 0, 0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strHas);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoHasProperty(e, target, p));

    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e,p));    
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    RET_IF_AB(booleanTrapResult);
    if(!ValIsTrue(e, booleanTrapResult)) {
        targetDesc = DoGetOwnProperty(e, target, p);
        RET_IF_AB(targetDesc);
        if(!ValIsUndef(targetDesc)) {
            if(!PropIsConfigurable(e, targetDesc->desc))
                RET(ThrowTypeError(e, 0, p, " not configurable"));
            extensibleTarget = IsExtensible(e, target);
            RET_IF_AB(extensibleTarget);
            if(!ValIsTrue(e, extensibleTarget))
                RET(ThrowTypeError(e, "target not extensible ", p, 0));
        }
    }
    RET_VAL(booleanTrapResult);
exit:
    IFD(trap);
    IFD(trapResult);
    IFD(booleanTrapResult);
    IFD(targetDesc);
    IFD(extensibleTarget);
    IFD(args);
    return ret;
}

Val* ProxyGet(Js* e, Val* o, Val* p, Val* receiver) {
    Val* trap = NULL, *trapResult = NULL, *targetDesc = NULL;
    Val* ret = NULL, *args = NULL;

    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null ", p, 0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strGet);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoGet(e, target, p, receiver));
    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, p));
    ListAddValue(e, args->list, ValClone(e, receiver));
    trapResult = DoCall(e, trap, handler, args);
    RET_IF_AB(trapResult);
    targetDesc = DoGetOwnProperty(e, target, p);
    RET_IF_AB(targetDesc);
    if(!ValIsUndef(targetDesc)) {
        if(IsDataDesc(e, targetDesc) && !PropIsConfigurable(e, targetDesc->desc) &&
            !PropIsWritable(e, targetDesc->desc)) {
            if(!ValIsTrueDel(e, SameValue(e, trapResult, targetDesc->desc->value)))
                RET(ThrowTypeError(e, "unexpected trap result", 0, 0));
        }
        if(IsAccessorDesc(e, targetDesc->desc) && !PropIsConfigurable(e, targetDesc->desc) &&
            ValIsUndef(targetDesc->desc->get)) {
            if(!ValIsUndef(trapResult))
                RET(ThrowTypeError(e, "invalid trap result", 0, 0));
        }
    }
    RET_VAL(trapResult);

exit:
    IFD(args);
    IFD(trap);
    IFD(trapResult);
    IFD(targetDesc);
    return ret;
}

Val* ProxySet(Js* e, Val* o, Val* p, Val* v, Val* receiver) {
    Val* trap = NULL, *trapResult = NULL, *booleanTrapResult = NULL;
    Val* targetDesc = NULL, *ret = NULL, *args = NULL;

    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsUndef(handler))
        RET(ThrowTypeError(e, "handler null", 0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strSet);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoSet(e, target, p, v, receiver));

    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, p));
    ListAddValue(e, args->list, ValClone(e, v));
    ListAddValue(e, args->list, ValClone(e, receiver));
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    RET_IF_AB(booleanTrapResult);
    targetDesc = DoGetOwnProperty(e, target, p);
    RET_IF_AB(targetDesc);
    if(!ValIsUndef(targetDesc)) {
        if(IsDataDesc(e, targetDesc) && !PropIsConfigurable(e, targetDesc->desc)
            && !PropIsWritable(e, targetDesc->desc)) {
            if(!ValIsTrueDel(e, SameValue(e, v, targetDesc->desc->value)))
                RET(ThrowTypeError(e, "failed to set", 0,0));
        }
        if(IsAccessorDesc(e, targetDesc->desc) && !PropIsConfigurable(e, targetDesc->desc)) {
            if(ValIsUndef(targetDesc->desc->set))
                RET(ThrowTypeError(e, 0, p, " not configurable"));
        }
    }
    RET(ValNewBool(e, TRUE));
exit:
    IFD(args);
    IFD(trap);
    IFD(trapResult);
    IFD(booleanTrapResult);
    IFD(targetDesc);

    return ret;
}

Val* ProxyDelete(Js* e, Val* o, Val* p) {
    Val* ret = NULL, *trap = NULL, *booleanTrapResult = NULL, *trapResult = NULL;
    Val* targetDesc = NULL, *args = NULL;
    assert(ValIsTrueDel(e, IsPropKey(e, p)));
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null", 0, 0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strDeleteProperty);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoDelete(e, target, p));
    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, p));
    trapResult = DoCall(e, trap, handler, args);
    booleanTrapResult = ToBoolean(e, trapResult);
    RET_IF_AB(booleanTrapResult);
    if(!ValIsTrue(e, booleanTrapResult))
        RET(ValNewBool(e, FALSE));
    targetDesc = DoGetOwnProperty(e, target, p);
    RET_IF_AB(targetDesc);
    if(ValIsUndef(targetDesc))
        RET(ValNewBool(e, TRUE));
    if(!PropIsConfigurable(e, targetDesc->desc))
        RET(ThrowTypeError(e, 0, p, " not configurable"));
    RET(ValNewBool(e, TRUE));

exit:
    IFD(args);
    IFD(trap);
    IFD(trapResult);
    IFD(booleanTrapResult);
    IFD(targetDesc);
    return ret;
}


Val* ProxyEnumerate(Js* e, Val* o) {
    Val* ret = NULL, *trap = NULL, *trapResult = NULL, *args = NULL;
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsNull(handler))
        RET(ThrowTypeError(e, "handler null", 0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strEnumerate);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoEnumerate(e, target));
    args = ListNewWithArg(e, target);
    trapResult = DoCall(e, trap, handler, args);
    RET_IF_AB(trapResult);
    if(!ValIsObject(trapResult))
        RET(ThrowTypeError(e, "result not an object",0,0));
    RET_VAL(trapResult);

exit:
    IFD(trap);
    IFD(trapResult);
    IFD(args);    
    return ret;
}

Val* ProxyOwnPropertyKeys(Js* e, Val* o) {
    Val* ret = NULL, *args = NULL, *trap = NULL, *trapResult = NULL;
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsUndef(handler))
        RET(ThrowTypeError(e, "handler undefined",0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strOwnKeys);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoOwnPropertyKeys(e, target));
    args = ListNewWithArg(e, target);
    trapResult = DoCall(e, trap, handler, args);
    RET_IF_AB(trapResult);
    if(!ValIsObject(trapResult))
        RET(ThrowTypeError(e, "result not object",0,0));
    RET_VAL(trapResult);

exit:
    IFD(trap);
    IFD(trapResult);
    IFD(args);    
    return ret;
}

Val* ProxyCall(Js* e, Val* o, Val* othis, Val* argumentsList) {
    Val* ret = NULL, *trap = NULL, *args = NULL, *argArray = NULL;
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsUndef(handler))
        RET(ThrowTypeError(e, "handler undefined",0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strApply);
    RET_IF_AB(trap);
    if(ValIsUndef(trap))
        RET(DoCall(e, target, othis, argumentsList));
    argArray = CreateArrayFromList(e, argumentsList);
    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, othis));
    ListAddValue(e, args->list, ValClone(e, argArray));
    RET(DoCall(e, trap, handler, args));
exit:
    IFD(trap);
    IFD(args);
    IFD(argArray);    
    return ret;
}

Val* ProxyConstruct(Js* e, Val* o, Val* argumentList, Val* newTarget) {
    Val* ret = NULL, *argArray = NULL, *newObj = NULL, *trap = NULL, *args = NULL;
    Val* handler = ObjectGetSlot(e, o->obj, _ProxyHandler_);
    if(ValIsUndef(handler))
        RET(ThrowTypeError(e, "handler undefined",0,0));
    Val* target = ObjectGetSlot(e, o->obj, _ProxyTarget_);
    trap = GetMethod(e, handler, e->strConstruct);
    RET_IF_AB(trap);
    if(ValIsUndef(trap)) {
        if(ObjectGetMethod(e, target->obj, _Construct_))
            RET(ThrowTypeError(e, "not a constructor",0,0));
        RET(DoConstruct(e, target, args, newTarget));
    }
    argArray = CreateArrayFromList(e, argumentList);
    args = ListNewWithArg(e, target);
    ListAddValue(e, args->list, ValClone(e, argArray));
    ListAddValue(e, args->list, ValClone(e, newTarget));
    newObj = DoCall(e, trap, handler, args);
    RET_IF_AB(newObj);
    if(!ValIsObject(newObj))
        RET(ThrowTypeError(e, "not an object",0,0));
    RET_VAL(newObj);
exit:
    IFD(args);
    IFD(trap);
    IFD(newObj);
    IFD(argArray);
    return ret;
}



/////// Parser
typedef Node* (*ParseFunc)(Parser* p, int start, uint32 flags);
typedef bool_t (*OpsFunc)(int k);

Parser* ParserNew(Js* e) {
    Parser* p = (Parser*) halloc(e->memory[PA].data);
    p->tk = TkNew(e);
    p->next = 0;
    p->root = NULL;
    p->error[0] = 0;
    p->stop = 0;
    p->e = e;
    p->retain = FALSE;
    p->source = NULL;
    p->fileName[0] = 0;
    p->functions = NULL;
    p->currentFunc = NULL;
    p->blocks = NULL;
    p->currentBlock = NULL;
    p->refCount = 1;
    p->fileIndex = -1;
    p->calls = 0;
    return p;
}

void ParserRetain(Parser* p) {
    if(p)
        p->refCount++;
}

void ParserDel(Parser* p) {
    if(!p) return;
    p->refCount--;
    if(p->refCount <= 0)
        ParserFree(p);
}

void ParserFree(Parser* p) {
    if(p->calls)
        ValDel(p->e, p->calls);

    if(p->functions) {
        for(FuncDef* fd = p->functions; fd; ) {
            FuncDef* next = fd->next;
            FuncDefDel(p, fd);
            fd = next;
        }
        p->functions = NULL;
    }

    if(p->blocks) {
        for(BlockDef* bd = p->blocks; bd; ) {
            BlockDef* next = bd->next;
            BlockDefDel(p, bd);
            bd = next;
        }
        p->blocks = NULL;
    }
    if(p->retain)
        StrDel(p->e, p->source);
    NodeDel(p, p->root);
    TkDel(p->e, p->tk);
    hfree(p->e->memory[PA].data, p);

}

FuncDef* FuncDefNew(Parser* p) {
    FuncDef* fd = halloc(p->e->memory[FD].data);
    fd->name = NULL;
    fd->line = 0;
    fd->block = 0;
    fd->parent = p->currentFunc;
    fd->next = p->functions;
    p->functions = fd;
    p->currentFunc = fd;
    return fd;
}

FuncDef* FuncDefFind(Parser* p, int line) {
    for(FuncDef* fd = p->functions; fd; fd = fd->next) {
        if(fd->line == line)
            return fd;
    }
    return NULL;
}

void FuncDefDel(Parser* p, FuncDef* fd) {
    ValDel(p->e, fd->name);
    hfree(p->e->memory[FD].data, fd);
}

BlockDef* BlockDefNew(Parser* p) {
    BlockDef* bd = halloc(p->e->memory[BD].data);
    bd->start = 0;
    bd->end = 0;
    bd->parent = p->currentBlock;
    bd->next = p->blocks;
    p->blocks = bd;
    p->currentBlock = bd;
    return bd;
}

void BlockDefDel(Parser* p, BlockDef* bd) {
    hfree(p->e->memory[BD].data, bd);
}

int DebugFileIndex(DebugContext* dc, Val* file);

void ParserSetFileName(Parser* p, char* file) {
    strncpy(p->fileName, file, MAX_FILE_NAME-1);
#ifdef JSE_DEBUG    
    Js* e = p->e;
    if(e->debugger) {
        Val* ufile = ValNewStrA(e, file);

        DebugContext* dc = e->debugger->context;
        p->fileIndex = DebugFileIndex(dc, ufile);
        ValDel(e, ufile);
    }
#endif    
}


Node* NodeNew(Parser* p) {
    Node* n = halloc(p->e->memory[ND].data);
    n->flags = 0;
    n->left = NULL;
    n->right = NULL;
    n->token = TOK_NOT_FOUND;
    n->extra = NULL;
    n->flags = NULL;
    n->p = p;
    return n;
}

void NodeSetFlag(Parser* p, Node* n, void* flag) {
    NodeFlag* nf = (NodeFlag*) halloc(p->e->memory[NF].data);
    nf->flag = flag;
    nf->next = n->flags;
    n->flags = nf;
}

void NodeClearFlag(Parser* p, Node* n, void* flag) {
    NodeFlag* nf = NodeHasFlag(p, n, flag);
    if(nf) 
        nf->flag = NULL;
    // @todo: should we remove the flag?
}

NodeFlag* NodeHasFlag(Parser* p, Node* n, void* flag) {
    if(!n) return NULL;
    if(!n->flags)
        return NULL;
    for(NodeFlag* nf = n->flags; nf; nf = nf->next) {
        if(nf->flag == flag)
            return nf;
    }
    return NULL;
}

void NodeDel(Parser* p, Node* n) {
    if(!n)
        return;
    if(n->extra)
        ValDel(p->e, n->extra);
    if(n->flags) {
        NodeFlag* f = n->flags;
        while(TRUE) {
            NodeFlag* next = f->next;
            hfree(p->e->memory[NF].data, f);
            if(!next)
                break;
            f = next;
        }
    }
    Node* l = n->left;
    Node* r = n->right;
    hfree(p->e->memory[ND].data, n);
    NodeDel(p, l);          // @todo: Recursive will run out of stack!
    NodeDel(p, r);
}

int NextKeyword(Parser* p, bool_t skipNew) {
    // Slip LINETERM 
    while(skipNew && TkGetTokType(p->e, p->tk, p->next) == TOK_LINETERM)
        p->next++;
    return TkGetTokKeyword(p->e, p->tk, p->next);
}

int NextType(Parser* p, bool_t skipNew) {
    // Slip LINETERM 
    while(skipNew && TkGetTokType(p->e, p->tk, p->next) == TOK_LINETERM)
        p->next++;
    return TkGetTokType(p->e, p->tk, p->next);
}

int NodeKeyword(Parser* p, Node* n) {
    return TkGetTokKeyword(p->e, p->tk, n->token);
}

int NodeType(Parser* p, Node* n) {
    return TkGetTokType(p->e, p->tk, n->token);
}

void NodePrint(Parser* p, Node* n, int level) {
    Js* e = p->e;
    int indent = 4;
    bool_t addLines = TRUE;

    if(!n)
        return;
    
    if(n->right) {
        NodePrint(p, n->right, level+indent);
        if(addLines) {
            for(int i=0; i < level+indent; i++)
                jprintf(e,0," ");
            jprintf(e,0,"/\n");
        }
    }

    for(int i=0; i < level; i++)
        jprintf(e, 0," ");

    jprintf(e, 0, " ");
    if(n->token != TOK_NOT_FOUND)
        TkPrintToken(e, p->tk, n->token, FALSE);
    else 
        jprintf(e,0,"<null>");
    jprintf(e,0," \n");

    if(n->left) {
        if(addLines) {
            for(int i=0; i < indent+level; i++)
                jprintf(e,0," ");
            jprintf(e,0,"\\\n");
        }
        NodePrint(p, n->left, level+indent);
    }
}


void OpmlBegin(Js* e, int level, char* text) {
    for(int i=0; i < level/2; i++) jprintf(e, 0," ");
    jprintf(e,0, "<outline text=\"%s\">\r\n", text);
}

void OpmlEnd(Js* e, int level) {
    for(int i=0; i < level; i++) jprintf(e, 0," ");
    jprintf(e,0, "</outline>\r\n");        
}

void OpmlTerminator(Js* e, int level) {
    for(int i=0; i < level; i++) jprintf(e, 0," ");
    jprintf(e, 0, "<outline text=\"|||\"/>\r\n");    
}

void NodePrintOpml(Parser* p, Node* n, int level, const char* title) {
    Js* e = p->e;
    int indent = 4;
    bool_t showLR = e->options.opmlUseLR;

    if(!n) return;

    if(level == 0) {
        jprintf(e, 0, "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n");
        jprintf(e, 0, "<opml version=\"1.0\">\r\n");
        jprintf(e, 0, "<head>\r\n");
        jprintf(e, 0, "<title>%s</title>\r\n", title);
        jprintf(e, 0, "</head>\r\n");
        jprintf(e, 0, "<body>\r\n");
    }

    for(int i=0; i < level; i++)
        jprintf(e, 0," ");

    jprintf(e, 0, "<outline text=\"");
    if(n->token != TOK_NOT_FOUND)
        TkPrintToken(e, p->tk, n->token, FALSE);
    else {
        if(level == 0)
            jprintf(e, 0, title);
        else
            jprintf(e,0," ");
    }
    jprintf(e,0,"\"> \r\n");

    bool_t willShowLeft = (n->left || (n->right && !n->left));

    if(showLR && willShowLeft) OpmlBegin(e, level+indent/2, "L");
        NodePrintOpml(p, n->left, level+indent, NULL);
        if(n->right && !n->left) OpmlTerminator(e, level+indent);
    if(showLR && willShowLeft) OpmlEnd(e, level+indent/2);

    bool_t willShowRight = (n->right || (n->left && !n->right));

    if(showLR && willShowRight) OpmlBegin(e, level+indent/2, "R");
        NodePrintOpml(p, n->right, level+indent, NULL);
        if(n->left && !n->right) OpmlTerminator(e, level+indent);
    if(showLR && willShowRight) OpmlEnd(e, level+indent/2);

    OpmlEnd(e, level);

    if(level == 0) {
        jprintf(e, 0, "</body>\r\n");
        jprintf(e, 0, "</opml>\r\n");
    }
}

Val* ParseA(Parser* p, char* source, uint32 flags) {
    Str* us = StrNewChars(p->e, source);
    Val* v = Parse(p, us, TRUE, flags);        // will be deleted by parser
    return v;
}

Val* Parse(Parser* p, Str* source, bool_t retain, uint32 flags) {
    p->source = source;
    p->retain = retain;
    p->error[0] = 0;
    TkTokenize(p->e, p->tk, source->chars,source->length,0,0);

    if(TkHasError(p->e, p->tk)) {
        char err[MAX_PARSE_ERROR];
        sprintf(err, "%s:%d:%d %s", (p->fileName[0]) ? p->fileName:"", p->tk->errorLine+1, p->tk->errorCol, p->tk->error);
        Val* strErr = ValNewStrA(p->e, err);
        Val* ret = ValNewCompA(p->e, COMP_THROW, strErr, NULL);
        ValDel(p->e, strErr);
        return ret;
    }

    if(p->e->debugLevel == DEBUG_LEVEL_TOKENIZE)
        return ValNew(p->e);

    p->root = Script(p,flags);
    if(p->error[0] || !p->root) {
        if(!p->error[0]) {
            // @todo we should never see this when the parser is complete
            strcpy(p->error, "Failed to parse");    
        }

        Val* strErr = ValNewStrA(p->e, p->error);
        Val* ret = ValNewCompA(p->e, COMP_THROW, strErr, NULL);
        ValDel(p->e, strErr);
        return ret;
    }

    if(p->e->debugLevel == DEBUG_LEVEL_PARSE) {
        NodePrint(p, p->root, 0);
    }
    return ValNew(p->e);
}

Val* RunA(Js* e, char* text, uint32 flags) {
    Str* us = StrNewChars(e, text);
    Val* ret = Run(e, us, flags);
    StrDel(e, us);
    return ret;
}

Val* EvalStatementList(Parser* p, Node* n, uint32 flags);

Val* Run(Js* e, Str* text, uint32 flags) {
    Parser* p = ParserNew(e);
    Val* v = Parse(p, text, FALSE,flags);
    if(ValIsAbrupt(e, v)) {
        ParserDel((p));
        return v;
    }
    ValDel(e, v);
    v = EvalStatementList(p, p->root, flags);
    ParserDel(p);

    return v;
}

Val* GetVal(Parser* p, Node* n, uint32 flags) {
    Val* v = Eval(p, n, flags);
    Val* r = GetValue(p->e, v);
    ValDel(p->e, v);
    return r;
}

number EvalNum(Parser* p, Node* n, uint32 flags) {
    Val* v = GetVal(p, n, flags);
    Val* nv = ToNumber(p->e, v);
    number ret = nv->num;
    ValDel(p->e, v);
    ValDel(p->e, nv);
    return ret;
}

bool_t EvalBool(Parser* p, Node* n, uint32 flags) {
    Val* v = GetVal(p, n, flags);
    Val* bv = ToBoolean(p->e, v);
    bool_t ret = bv->b;
    ValDel(p->e, v);
    ValDel(p->e, bv);
    return ret;   
}

Val* TkGetTokStrVal(Js* e, Tokenizer* tk, int token) {
    if(token == TOK_NOT_FOUND)
        return ThrowError(e, "token not found",0,0);
    int type = TkGetTokType(e, tk, token);
    if(type == TOK_IDENTIFIER || type == TOK_KEYWORD) {
        return  ValNewStrId(e, tk, token);
    }
    return ValNewStr(e, TkGetTokStr(e, tk, token));
}

Val* StringValue(Parser* p, Node* n) {
    int token = n->token;
    return TkGetTokStrVal(p->e, p->tk, token);
}

Val* InitializeBoundName(Js* e, Val* name, Val* value, Val* environment, bool_t strict) {
    assert(name->type == TYPE_STR);
    if(!ValIsUndef(environment)) {
        LexEnv* env = environment->lex;
        Val* ret = env->envRec->vtable->initializeBinding(e, env->envRec, name, value);
        ValDel(e, ret);
        return ValNewCompA(e, COMP_NORMAL,NULL, NULL);
    }
    else {
        Val* lhs = ResolveBinding(e, name, strict);
        // S10.4.2.1_A1 - we can't just use PutValue here since
        // it will resort to using setMutableBinding which would
        // throw in the case of strict code
        Val* ret =  InitValue(e, lhs, value);
        ValDel(e, lhs);
        return ret;
    }
}

Val* EvalBindingIdentifier(Parser* p, Node* n,  Val* value, Val* env, bool_t strict) {
    Val* name = StringValue(p, n);
    return InitializeBoundName(p->e, name, value, env, strict);
}

Val* EvalExpression(Parser* p, Node* n, uint32 flags);

Val* EvalSpread(Parser* p, Val* array, Node* n, Val* index, uint32 flags) {
    Js* e = p->e;
    Val* spreadRef = NULL, *spreadObj = NULL, *iterator = NULL, *next = NULL, *nextValue = NULL;
    Val* ret = NULL, *defineStatus = NULL, *name = NULL;

    spreadRef = Eval(p, n, flags);
    spreadObj = GetValue(e, spreadRef);
    ValDel(e, spreadRef);
    RET_IF_AB(spreadObj);
    if(!ValIsObject(spreadObj)) 
        RET(ThrowTypeError(e, "not an object",0,0));

    iterator = GetIterator(e, spreadObj, NULL);
    RET_IF_AB(iterator);
    while(1) {
        IFD(next);
        IFD(nextValue);
        IFD(name);
        next = IteratorStep(e, iterator);
        RET_IF_AB(next);
        if(next->type == TYPE_BOOL && next->b == FALSE) 
            RET_VAL(next);
        nextValue = IteratorValue(e, iterator);
        RET_IF_AB(nextValue);
        name = ToString(e, index);
        defineStatus = CreateDataPropOrThrow(e, array, name, nextValue);
        RET_IF_AB(defineStatus);
        index->num++;
    }
exit:
    IFD(spreadRef);
    IFD(spreadObj);
    IFD(iterator);
    IFD(next);
    IFD(nextValue);  
    IFD(defineStatus);  
    IFD(name);
    return ret;
}

void WatcherLine(Parser* p, Node* n, Val* value);
void W(Parser* p, Node* n, Val* v) {
    if(!p->e->options.watcher)
        return;
    WatcherLine(p, n, v);
}

Val* EvalElement(Parser* p, Val* array, Node* n, Val* index, uint32 flags) {
    Js* e = p->e;
    int tok = n->left->token;
    if(TkGetTokKeyword(e, p->tk, tok) == id_dotdotdot) {
        return EvalSpread(p, array, n->left->left, index, flags);
    }
    else {
        Val* initResult = EvalExpression(p, n->left, 0);
        Val* initValue = GetValue(e, initResult);
        ValDel(e, initResult);
        if(!ValIsObject(initValue))
            W(p, n, initValue);
        if(ValIsAbrupt(e, initValue)) 
            return initValue;
        Val* desc = DescNew(e, initValue, TRUE, TRUE, TRUE, TRUE);
        Val* name = ToString(e, index);
        Val* created = DoDefineOwnProperty(e, array, name, desc );
        ValDel(e, desc);
        ValDel(e, name);
        if(!ValIsTrue(e, created)) {
            ValDel(e, created);
            return ThrowTypeError(e, 0, name, " failed to create");        
        }
        return created;
    }
}

Val* EvalArrayReference(Parser* p, Node* n, uint32 flags);
Val* EvalComprehensionFor(Parser* p, Node* n, Val* accumulator, Node* tail, uint32 flags);

Val* EvalArray(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;

    // This has to hanle array literals but also LHS array member expressions
    if(n->left && TkGetTokKeyword(e, p->tk, n->left->token) != id_for) {
        return EvalArrayReference(p, n, flags);
    }

    Val index;
    ValInitNum(&index,0);
    Val* array = ArrayCreate(e, 0, NULL);
    
    if(n->left) {
        int k = TkGetTokKeyword(e, p->tk, n->left->token);
        if(k == id_for) {
            Val* ret =  EvalComprehensionFor(p, n->left, array, n->right, flags);
            ValDel(e, ret);
            return array;
        }
    }
    for(Node* element = n->right; element != NULL; element = element->right) {
        if(element->left) {
            Val* created = EvalElement(p, array, element, &index, flags);
            if(ValIsAbrupt(e, created)) {
                ValDel(e, array);
                return created;
            }
            ValDel(e, created);
        }
        // 12.2.4 If an element is elided at the end of an array, that element
        // does not contribute to the length of the Array.
        if(element->left || element->right)
            index.num++;
    }

    Val* r = Put(e, array, e->strLength, &index, FALSE);
    ValDel(e, r);
    return array;
}

bool_t HasName(Parser* p, Node* n) {
    if(n->left->left)
        return TRUE;
    return FALSE;
}
Node* FunctionExpression(Parser* p, int start, uint32 flags);
bool_t IsFunctionDefinition(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, FunctionDeclaration))
        return TRUE;
    if(NodeHasFlag(p, n, FunctionExpression))
        return TRUE;
    return FALSE;
}

bool_t IsAnonymousFunctionDefinition(Parser* p, Node* n) {
    if(!IsFunctionDefinition(p, n))
        return FALSE;
    return !HasName(p, n);
}

Val* PropertyDefinitionEvaluation(Parser* p, Node* n, uint32 flags, Val* object, bool_t enumerable);

Val* EvalPropDef(Parser* p, Node* n, Val* object, uint32 flags) {
    Val* propName = NULL, *propValue = NULL, *exprValue = NULL,  *ret = NULL;
    Val* desc = NULL;
    Js* e = p->e;

    if(!n)
        return ValNew(e);

    // PropertyDefinition : IdentifierReference
    int t = NodeType(p, n);
    if(t == TOK_IDENTIFIER) {
        propName = StringValue(p, n);
        exprValue = Eval(p, n, flags);
        RET_IF_AB(exprValue);
        propValue = GetValue(e, exprValue);
        RET_IF_AB(propValue);
    }
    else if(NodeKeyword(p, n) == id_colon) {
        int type = NodeType(p, n->left);
        if(type == TOK_STRLIT || type == TOK_IDENTIFIER
            || type == TOK_KEYWORD
            ) {
            propName = StringValue(p, n->left);
        }
        else if(type == TOK_NUMLIT) {
            Val* temp = Eval(p, n->left, flags);
            propName = ToString(e, temp);
            ValDel(e, temp);
        }
        else  {// Must be [ computed property
            exprValue = Eval(p, n->left, flags);
            propName = GetValue(e, exprValue);
            RET_IF_AB(propName);
            Val* key = ToPropKey(e, propName);
            ValDel(e, propName);
            propName = key;
            ValDel(e, exprValue);
        }
        exprValue = Eval(p, n->right, flags);
        propValue = GetValue(e, exprValue);
        RET_IF_AB(propValue);
        if(IsFunctionDefinition(p, n->right)) {
            Object* obj = propValue->obj;
            Val* referencesSuper = ObjectGetSlot(e, obj, _NeedsSuper_);
            Val* thisMode = ObjectGetSlot(e, obj, _ThisMode_);
            if(!ValEqStrA(e, thisMode, "lexical") && ValIsTrue(e, referencesSuper)) {
                if(ValIsUndef(ObjectGetSlot(e, obj, _HomeObject_))) {
                    // @todo: Assert: AssignmentExpression is not a class definition whose constructor references super.
                    ObjectSetSlot(e, obj, _HomeObject_, object, TRUE, FALSE);
                    ObjectSetSlot(e, obj, _MethodName_, propName, TRUE, FALSE);
                }
            }
            if(IsAnonymousFunctionDefinition(p, n->right)) {
                ValDel(e, SetFunctionName(e, propValue, propName, NULL));
            }
        }
    }
    else {
        int k = NodeKeyword(p, n);
        if(k == id_lpar || k == id_get || k == id_set) {
            // @todo: enumerable always true?
            RET(PropertyDefinitionEvaluation(p, n, flags, object, TRUE)); 
        }
        RET(ThrowTypeError(e, "invalid property definition ", propName, 0));
    }

    desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, propValue);
    W(p, n, propValue);
    PropSetEnumerable(e, desc->desc, TRUE);
    PropSetConfigurable(e, desc->desc, TRUE);
    PropSetWritable(e, desc->desc, TRUE);
    RET(DefinePropOrThrow(e, object, propName, desc));    
exit:
    IFD(desc);
    IFD(propName);
    IFD(exprValue);
    IFD(propValue);    
    return ret;
}

Val* EvalObject(Parser* p, Node* n, uint32 flags) {
    Val* object = ObjectCreate(p->e, NULL, NULL);
    for(Node* e=n->right; e != NULL; e = e->right) {
        Val* status = EvalPropDef(p, e->left, object, flags);
        if(ValIsAbrupt(p->e, status)) {
            ValDel(p->e, object);
            return status;
        }
        ValDel(p->e, status);
    }
    return object;
}


Val* EvalArrayReference(Parser* p, Node* n, uint32 flags) {
    Val* baseRef = NULL, *baseVal = NULL, *ret =  NULL;
    Val* propNameRef = NULL, *propNameVal = NULL, *propNameStr = NULL;
    Val* bv = NULL;

    Js* e = p->e;
    baseRef = Eval(p, n->left, flags);
    baseVal = GetValue(e, baseRef);
    RET_IF_AB(baseVal);
    propNameRef = Eval(p, n->right, flags);
    propNameVal = GetValue(e, propNameRef);
    RET_IF_AB(propNameVal);
    bv = RequireObjectCoercible(e, baseVal);
    RET_IF_AB(bv);
    propNameStr = ToString(e, propNameVal);
    Ref* ref = RefNew(e, bv, propNameStr, (flags & PSTRICT), NULL);
    ret = ValNewRef(e, ref);

exit:
    IFD(bv);
    IFD(baseRef);
    IFD(baseVal);
    IFD(propNameRef);
    IFD(propNameVal);
    IFD(propNameStr);
    return ret;    
}
Node* MetaProperty(Parser* p, int start, uint32 flags);
Val* EvalDot(Parser* p, Node* n, uint32 flags) {
    Val* baseRef = NULL, *baseVal = NULL, *ret =  NULL;
    Val *propNameStr = NULL;
    Val* bv = NULL;

    // Must be new.target
    if(NodeHasFlag(p, n, MetaProperty)) {
        return GetNewTarget(p->e);
    }
    Js* e = p->e;
    baseRef = Eval(p, n->left, flags);
    baseVal = GetValue(e, baseRef);
    RET_IF_AB(baseVal);
    propNameStr = StringValue(p, n->right); //  ValNewStrId(p->e, p->tk, n->right->token);
    bv = RequireObjectCoercible(e, baseVal);
    RET_IF_AB(bv);
    Ref* ref = RefNew(e, bv, propNameStr, (flags & PSTRICT), NULL);
    ret = ValNewRef(e, ref);

exit:
    IFD(bv);
    IFD(baseRef);
    IFD(baseVal);
    IFD(propNameStr);
    return ret;    
}

bool_t IsInTailPosition(Parser* p, Node* thisCall) {
    return FALSE;   // @todo: implement
}

void PrepareForTailCall(Js* e) {
    // @todo: implement
}


// CheckSpec
Val* MakeSuperReference(Js* e, Val* propertyKey, bool_t strict) {
    // @todo: test
    Val* ev = NULL, *actualThis = NULL, *baseValue = NULL, *pk = NULL, *bv = NULL;
    Val* ret = NULL;

    ev = GetThisEnv(e);
    Env* env = ev->env;
    if(! ValIsTrueDel(e, env->vtable->hasSuperBinding(e, env)))
        RET(ThrowRefError(e, 0, propertyKey, " not found"));

    actualThis = env->vtable->getThisBinding(e, env);
    baseValue = env->vtable->getSuperBase(e, env);
    bv = RequireObjectCoercible(e, baseValue);
    pk = NULL;
    if(ValIsAbrupt(e, bv))
        RET_VAL(bv);

    if(ValIsUndef(propertyKey)) {
        // pk = env->vtable->getMethodName(e, env); @todo: CheckSpec
        if(ValIsUndef(pk))
            RET(ThrowRefError(e, "undefined property",0,0));
        RET(ValNewRefU(e, bv, pk, strict, actualThis));
    }
    RET(ValNewRefU(e, bv, propertyKey, strict, actualThis));
exit:
    IFD(ev);
    IFD(actualThis);
    IFD(baseValue);
    IFD(pk);
    IFD(bv);
    return ret;
}

Val* EvalNewNoArgs(Parser* p, Node* n, uint32 flags) {
    Val* ref = NULL, *constructor = NULL, *result = NULL, *ret=NULL;
    Js* e = p->e;

    if(TkGetTokKeyword(e, p->tk, n->left->token) == id_super) 
        ref = MakeSuperReference(e, NULL, (flags & PSTRICT));
    else
        ref = Eval(p, n->left, flags);
    constructor = GetValue(e, ref);
    RET_IF_AB(constructor);
    if(!ValIsTrueDel(e, IsConstructor(e, constructor)))
        RET(ThrowTypeError(e, "not a constructor",0,0));
    Node* thisCall = n->left;
    bool_t tailCall = IsInTailPosition(p, thisCall);
    if(tailCall) 
        PrepareForTailCall(p->e);
    
    result = DoConstruct(e, constructor, NULL, NULL);
    // @todo: Handle tailCall == TRUE
    RET_VAL(result);
exit:
    IFD(ref);
    IFD(constructor);
    IFD(result);
    IFD(result);
    return ret;
}

Val* ArgumentListEvaluationNonTemplate(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    List* l = ListNew(e);
    while(n) {
        if(TkGetTokKeyword(p->e, p->tk, n->token) == id_dotdotdot) {
            Val* spreadRef = Eval(p, n->left, flags);
            Val* spreadObj = GetValue(e, spreadRef);
            ValDel(e, spreadRef);
            if(ValIsAbrupt(e, spreadObj)) {
                ListDel(e, l);
                return spreadObj;
            }
            if(!ValIsObject(spreadObj)) {
                ListDel(e, l);
                ValDel(e, spreadObj);
                return ThrowTypeError(e, "not anobject",0,0);
            }
            Val* iterator = GetIterator(e, spreadObj, NULL);
            ValDel(e, spreadObj);
            if(ValIsAbrupt(e, iterator)) {
                ListDel(e, l);
                return iterator;
            }
            while(TRUE) {
                Val* next = IteratorStep(e, iterator);
                if(ValIsAbrupt(e, next)) {
                    ListDel(e, l);
                    ValDel(e, iterator);
                    return next;
                }
                if(next->type == TYPE_BOOL && next->b == FALSE) {
                    ValDel(e, next);
                    ValDel(e, iterator);
                    break;
                }

                Val* nextArg = IteratorValue(e, next);
                if(ValIsAbrupt(e, nextArg)) {
                    ListDel(e, l);
                    ValDel(e, iterator);
                    ValDel(e, next);
                    return nextArg;
                }
                ListAddValue(e, l, nextArg);
                ValDel(e, next);
            }
            n = n->right;
            continue;           // Allow evaluation continue after spread
        }
        Val* v = Eval(p, n->left, flags);
        Val* arg = GetValue(e, v);                  // 2014-09-26 cannot pass references here
        ValDel(e, v);

        // 20141129 - an exception here is not being caught and returned
        if(ValIsAbrupt(e, arg)) {
            ListDel(e, l);
            return arg;
        }

        ListAddValue(e, l, arg);
        n = n->right;
    }
    return ValNewList(e, l);

}


Val* EvalNewArgs(Parser* p, Node* n, uint32 flags) {
    Val* ref = NULL, *constructor = NULL, *result = NULL, *ret=NULL, *argList = NULL;
    Js* e = p->e;
    if(TkGetTokKeyword(e, p->tk, n->left->token) == id_super) 
        ref = MakeSuperReference(e, NULL, (flags & PSTRICT));
    else    
        ref = Eval(p, n->left, flags);
    constructor = GetValue(e, ref);
    RET_IF_AB(constructor);
    argList = ArgumentListEvaluationNonTemplate(p, n->right, flags);
    RET_IF_AB(argList);
    if(!ValIsTrueDel(e, IsConstructor(e, constructor)))
        RET(ThrowTypeError(e, "not a constructor",0,0));
    Node* thisCall = n->left;
    bool_t tailCall = IsInTailPosition(p, thisCall);
    if(tailCall)
        PrepareForTailCall(e);
    result = DoConstruct(e, constructor, argList, NULL);
    // @todo: Handle tailCall == TRUE
    RET_VAL(result);        
exit:
    IFD(argList);
    IFD(ref);
    IFD(constructor);
    IFD(result);
    IFD(result);
    return ret;
}

Val* EvalNew(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    Val* ref = 0, *ret = 0, *constructor = 0, *arguments = 0;
    ref = Eval(p, n->left, flags);
    constructor = GetValue(e, ref);
    RET_IF_AB(constructor);
    arguments = ArgumentListEvaluationNonTemplate(p, n->right, flags);
    RET_IF_AB(arguments);
    if(!ValIsTrueDel(e, IsConstructor(e, constructor)))
        RET(ThrowTypeError(e, "not a constructor",0,0));
    RET(Construct(e, constructor, arguments, NULL));
exit:
    IFD(arguments);
    IFD(constructor);
    IFD(ref);
    return ret;    

    if(n->right)
        return EvalNewArgs(p, n, flags);
    return EvalNewNoArgs(p, n, flags);
}

Val* ArgumentListEvaluationTemplate(Parser* p, Node* n, uint32 flags);

Val* EvaluateCall(Parser* p, Val* ref, Node* args, bool_t tail, uint32 flags, bool_t template) {
    Val* func = NULL, *argList = NULL, *ret = NULL, *result = NULL, *thisValue = NULL;
    Val* base = NULL;
    Js* e = p->e;

    func = GetValue(e, ref);
    RET_IF_AB(func);
    if(template)
        argList = ArgumentListEvaluationTemplate(p, args, flags);
    else
        argList = ArgumentListEvaluationNonTemplate(p, args, flags);
    RET_IF_AB(argList);
    if(!ValIsTrueDel(e, IsCallable(e, func)))
        RET(ThrowTypeError(e, "not callable", 0, 0));
    if(ref->type == TYPE_REF) {
        if(RefIsPropRef(e, ref)) 
            thisValue = RefGetThis(e, ref);
        else {
            base = RefGetBase(e, ref);
            assert(base->type == TYPE_ENV);
            thisValue = base->env->vtable->withBaseObject(e, base->env);
        }
    }
    else {
        thisValue = ValNew(e);
    }
    if(tail) {
        PrepareForTailCall(e);
    }
    result = DoCall(e, func, thisValue, argList);
    // @todo: tail position handling
    RET_VAL(result);

exit:
    IFD(base);
    IFD(func);
    IFD(argList);
    IFD(result);
    IFD(thisValue);
    return ret;
}

Val* EvalTemplateLiteralCall(Parser* p, Node* n, uint32 flags) {
    Val* tagRef = Eval(p, n->left, flags);
    Val* ret = EvaluateCall(p, tagRef, n->right, IsInTailPosition(p, n), flags, TRUE);
    ValDel(p->e, tagRef);
    return ret;
}

Val* EvalIncDec(Parser* p, Node* n, uint32 flags, number delta, bool_t retOld) {
    Val* oldValue = NULL, *lhs = NULL, *lhsVal = NULL, *newValue = NULL, *ret = NULL;
    Val* status = NULL;
    Js* e = p->e;

    if(retOld)
        lhs = Eval(p, n->left, flags);
    else
        lhs = Eval(p, n->right, flags);
    lhsVal = GetValue(e, lhs);
    oldValue = ToNumber(e, lhsVal);
    RET_IF_AB(oldValue);
    newValue = ValNewNum(e, oldValue->num + delta);
    status = PutValue(e, lhs, newValue);
    RET_IF_AB(status);
    if(retOld)
        RET_VAL(oldValue);

    RET_VAL(newValue);

exit:
    IFD(status);
    IFD(lhsVal);
    IFD(oldValue);
    IFD(newValue);
    IFD(lhs);    
    return ret;
}

Val* EvalPlusPlus(Parser* p, Node* n, uint32 flags) {
    if(n->left)
        return EvalIncDec(p, n, flags, 1, TRUE);
    return EvalIncDec(p, n, flags, 1, FALSE);
}

Val* EvalMinusMinus(Parser* p, Node* n, uint32 flags) {
    if(n->left)
        return EvalIncDec(p, n, flags, -1, TRUE);
    return EvalIncDec(p, n, flags, -1, FALSE);
}

Val* EvalDelete(Parser* p, Node* n, uint32 flags) {
    Val* ref = NULL, *refObj = NULL, *deleteStatus = NULL, *bindings = NULL, *refName = NULL;
    Val* ret = NULL, *base = NULL;
    Js* e = p->e;
    ref = Eval(p, n->right, flags);
    RET_IF_AB(ref);
    if(ref->type != TYPE_REF)
        RET(ValNewBool(e, TRUE));
    if(RefIsUnresolvable(e, ref)) {
        assert(RefIsStrict(e, ref));
        RET(ValNewBool(e, TRUE));
    }
    refName = RefGetReferencedName(e, ref);

    if(RefIsPropRef(e, ref)) {
        if(RefIsSuper(e, ref))
            RET(ThrowRefError(e, 0, refName, " not found"));
        base = RefGetBase(e, ref);
        refObj = ToObject(e, base);
        deleteStatus = DoDelete(e, refObj, refName);
        RET_IF_AB(deleteStatus);
        RET_VAL(deleteStatus);
    }
    bindings = RefGetBase(e, ref);
    Env* env = bindings->env;
    RET(env->vtable->deleteBinding(e, env, refName));
exit:
    IFD(base);
    IFD(ref);
    IFD(refObj);
    IFD(deleteStatus);
    IFD(bindings);    
    return ret;
}

Val* EvalVoid(Parser* p, Node* n, uint32 flags) {
    Val* expr = Eval(p, n->right, flags);
    Val* status = GetValue(p->e, expr);
    if(ValIsAbrupt(p->e, status)) {
        ValDel(p->e, expr);
        return status;
    }
    ValDel(p->e, expr);
    ValDel(p->e, status);
    return ValNew(p->e);
}

Val *EvalTypeOf(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    Val* v = Eval(p, n->right, flags);
    if(v->type == TYPE_REF) {
        if(RefIsUnresolvable(e, v)) {
            ValDel(e, v);
            return ValNewStrA(e, "undefined");
        }
        Val* v2 = GetValue(e, v);
        ValDel(e, v);
        v = v2;
    }
    if(ValIsAbrupt(e, v)) 
        return v;
    
    int t = v->type;
    char * s = NULL;
    switch(t) {
        case TYPE_UNDEF:
            s =  "undefined";
            break;
        case TYPE_NULL:
            s =  "null";
            break;
        case TYPE_BOOL:
            s = "boolean";
            break;
        case TYPE_NUM:
            s = "number";
            break;
        case TYPE_STR:
            s = "string";
            break;
        case TYPE_SYMA:
            s = "symbol";
            break;
        case TYPE_OBJ:
            if(!ObjectGetMethod(e, v->obj, _Call_))
                s = "object";
            else
                s = "function";
            break;
    }
    ValDel(e, v);
    return ValNewStrA(e, s);
}

Val* EvalPrePlus(Parser* p, Node* n, uint32 flags) {
    Val* expr = Eval(p, n->right, flags);
    Val* v = GetValue(p->e, expr);
    Val* ret = ToNumber(p->e, v);
    ValDel(p->e, v);
    ValDel(p->e, expr);
    return ret;
}

Val* EvalPreMinus(Parser* p, Node* n, uint32 flags) {
    Val* expr = NULL, *v = NULL, *oldValue = NULL, *ret= NULL;
    Js* e = p->e;
    expr = Eval(p, n->right, flags);
    v = GetValue(e, expr);
    oldValue = ToNumber(e, v);
    RET_IF_AB(oldValue);
    if(isnan(oldValue->num))
        RET_VAL(oldValue);
    oldValue->num = - oldValue->num;
    RET_VAL(oldValue);
exit:
    IFD(expr);
    IFD(v);
    IFD(oldValue);
    return ret;
}

Val* EvalTilde(Parser* p, Node* n, uint32 flags) {
    Val* expr = Eval(p, n->right, flags);
    Val* v = GetValue(p->e, expr);
    Val* oldValue = ToInt32(p->e, v);
    ValDel(p->e, expr);
    ValDel(p->e, v);
    if(ValIsAbrupt(p->e, oldValue)) 
        return oldValue;
    int32 iv = (int32) oldValue->num;
    iv = ~iv;
    oldValue->num = iv;
    return oldValue;
}

Val* EvalNot(Parser* p, Node* n, uint32 flags) {
     Val* expr = Eval(p, n->right, flags);
    Val* v = GetValue(p->e, expr);
    Val* oldValue = ToBoolean(p->e, v);
    ValDel(p->e, expr);
    ValDel(p->e, v);
    if(ValIsAbrupt(p->e, oldValue)) 
        return oldValue;
    oldValue->b = !oldValue->b;
    return oldValue;   
}

typedef number (*NumOp)(Js* e, number n1, number n2);


number MultOp(Js* e, number n1, number n2) {
    if(isnan(n1) || isnan(n2))
        return NAN;

    number mult = 1;
    if( (n1 > 0 && n2 < 0) ||  (n1 < 0 && n2 > 0))
        mult = -1;

    if( (isinf(n1) && n2 ==0 ) || (isinf(n2) && n1 == 0))
        return NAN;

    if( isinf(n1) && isinf(n2)) 
        return mult * INFINITY;

    if( isinf(n1) || isinf(n2)) 
        return mult * INFINITY;

    return n1 * n2;
}

bool_t isneg(number n) {
    return signbit(n);
}

bool_t ispos(number n) {
    return !signbit(n);
}

number DivOp(Js* e, number n1, number n2) {
    if(isnan(n1) || isnan(n2)) 
        return NAN;
    number mult = 1;
    if( (ispos(n1) && isneg( n2)) ||  (isneg(n1) && ispos(n2)))
        mult = -1;
    if(isinf(n1) && isinf(n2))
        return NAN;
    if(isinf(n1) && n2 == 0)
        return mult * INFINITY;
    if(isinf(n1))
        return mult * INFINITY;
    if(isinf(n2))
        return mult*0;
    if(n1 == 0 &&  n2 == 0)
        return NAN;
    if(n1 == 0)
        return mult*0;
    if(n2 == 0)
        return mult*INFINITY;
    return n1 / n2;
}

number ModOp(Js* e, number dividend, number divisor) {
    if(isnan(dividend) || isnan(divisor))
        return NAN;
    if(isinf(dividend) || divisor == 0)
        return NAN;
    if(!isinf(dividend) && isinf(divisor))
        return dividend;
    if(dividend == 0 && !isinf(divisor) && divisor != 0 )
        return dividend;

    number n = fmod(dividend, divisor);
//    if(isneg(dividend) && (n == +0))
//        n = -0;
//    if(ispos(dividend) && (n == -0))
//        n = +0;

    return n;
}

Val* EvalMultExpr(Parser* p, Node* n, uint32 flags, NumOp op) {
    Val* left = NULL, *leftValue = NULL, *right = NULL, *rightValue = NULL;
    Val* lnum = NULL, *rnum = NULL, *ret = NULL;
    Js* e = p->e;

    left = Eval(p, n->left, flags);
    leftValue = GetValue(e, left);
    RET_IF_AB(leftValue);
    right = Eval(p, n->right, flags);
    rightValue = GetValue(e, right);
    RET_IF_AB(rightValue);
    lnum = ToNumber(e, leftValue);
    RET_IF_AB(lnum);
    rnum = ToNumber(e, rightValue);
    RET_IF_AB(rnum);
    RET(ValNewNum(e, op(e, lnum->num, rnum->num)));

exit:
    IFD(left);
    IFD(leftValue);
    IFD(right);
    IFD(rightValue);
    IFD(lnum);
    IFD(rnum);
    return ret;
}


Val* EvalCall(Parser* p, Node* n, uint32 flags) {
    Val* ref;
    if(TkGetTokKeyword(p->e, p->tk, n->left->token) == id_super) 
        ref = MakeSuperReference(p->e, NULL, (flags & PSTRICT));
    else
        ref = Eval(p, n->left, flags);

    if(TokIsId(p->e, p->tk, n->left, "eval")) {
        // @todo: Check if direct eval?
        Val* ret = EvaluateCall(p, ref, n->right, FALSE, flags, FALSE);
        ValDel(p->e, ref);
        return ret;
    }
    Val* ret = EvaluateCall(p, ref, n->right, IsInTailPosition(p, n), flags, FALSE);
    ValDel(p->e, ref);
    return ret;
}

number AddOp(number n1, number n2) {
    if(isnan(n1) || isnan(n2))
        return NAN;

    bool_t s1 = (n1 > 0);
    bool_t s2 = (n2 > 0);

    if(isinf(n1) && isinf(n2))  {
        if(s1 != s2)
            return NAN;
        if(s1)
            return INFINITY;
        return -INFINITY;
    }

    if(isinf(n1))
        return n1;
    if(isinf(n2))
        return n2;
    if(isnegzero(n1) && isnegzero(n2)) {
        return n1;
    }
    if(n1 == 0 && n2 == 0)
        return 0;
    return n1 + n2;
}

Val* EvalAdd(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *rref = NULL, *rval = NULL;
    Val* ret = NULL, *lprim = NULL, *rprim = NULL, *lnum =0, *rnum = 0;
    Js* e = p->e;

    lref = Eval(p, n->left, flags);
    lval = GetValue(e, lref);
    RET_IF_AB(lval);
    rref = Eval(p, n->right, flags);
    rval = GetValue(e, rref);
    RET_IF_AB(rval);
    lprim = ToPrimitive(e, lval, NULL);
    RET_IF_AB(lprim);
    rprim = ToPrimitive(e, rval, NULL);
    RET_IF_AB(rprim);

    if(lprim->type == TYPE_STR || rprim->type == TYPE_STR) {
        Val* sleft = ToString(e, lprim);
        Val* sright = ToString(e, rprim);
        Str* s = StrAddUCharUChar(e, sleft->str, sright->str);
        ret = ValNewStr(e, s);
        StrDel(e, s);
        ValDel(e, sleft);
        ValDel(e, sright);
    }
    else
    {
        lnum = ToNumber(e, lprim);
        RET_IF_AB(lnum);
        rnum = ToNumber(e, rprim);
        RET_IF_AB(rnum);
        ret = ValNewNum(e, AddOp(lnum->num, rnum->num));
    }

exit:
    IFD(lnum);
    IFD(rnum);
    IFD(lref);
    IFD(lval);
    IFD(rref);
    IFD(rval);
    IFD(lprim);
    IFD(rprim);
    return ret;
}


Val* EvalLeftShift(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *rref = NULL, *rval = NULL;
    Val* lnum = NULL, *rnum = NULL, *ret = NULL;
    Js* e = p->e;
    lref = Eval(p, n->left, flags);
    lval = GetValue(e, lref);
    RET_IF_AB(lval);
    rref = Eval(p, n->right, flags);
    rval = GetValue(e, rref);
    RET_IF_AB(rval);
    lnum = ToInt32(e, lval);
    RET_IF_AB(lnum);
    rnum = ToUint32(e, rval);
    RET_IF_AB(rnum);
    int32 ln = (int32) lnum->num;
    uint32 rn = (uint32) rnum->num;
    uint32 shiftCount = rn & 0x1f;
    ln = ln << shiftCount;
    RET(ValNewNum(e, ln));

exit:
    IFD(lref);
    IFD(lval);
    IFD(rref);
    IFD(rval);
    IFD(lnum);
    IFD(rnum);

    return ret;
}

Val* EvalSignedRightShift(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *rref = NULL, *rval = NULL;
    Val* lnum = NULL, *rnum = NULL, *ret = NULL;
    Js* e = p->e;
    lref = Eval(p, n->left, flags);
    lval = GetValue(e, lref);
    RET_IF_AB(lval);
    rref = Eval(p, n->right, flags);
    rval = GetValue(e, rref);
    RET_IF_AB(rval);
    lnum = ToInt32(e, lval);
    RET_IF_AB(lnum);
    rnum = ToUint32(e, rval);
    RET_IF_AB(rnum);
    int32 ln = (int32) lnum->num;
    uint32 rn = (uint32) rnum->num;
    uint32 shiftCount = rn & 0x1f;
    ln = ln >> shiftCount;
    RET(ValNewNum(e, ln));

exit:
    IFD(lref);
    IFD(lval);
    IFD(rref);
    IFD(rval);
    IFD(lnum);
    IFD(rnum);

    return ret;
}

Val* EvalUnsignedRightShift(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *rref = NULL, *rval = NULL;
    Val* lnum = NULL, *rnum = NULL, *ret = NULL;
    Js* e = p->e;
    lref = Eval(p, n->left, flags);
    lval = GetValue(e, lref);
    RET_IF_AB(lval);
    rref = Eval(p, n->right, flags);
    rval = GetValue(e, rref);
    RET_IF_AB(rval);
    lnum = ToUint32(e, lval);
    RET_IF_AB(lnum);
    rnum = ToUint32(e, rval);
    RET_IF_AB(rnum);
    uint32 ln = (uint32) lnum->num;
    uint32 rn = (uint32) rnum->num;
    uint32 shiftCount = rn & 0x1f;
    ln = ln >> shiftCount;
    RET(ValNewNum(e, ln));

exit:
    IFD(lref);
    IFD(lval);
    IFD(rref);
    IFD(rval);
    IFD(lnum);
    IFD(rnum);

    return ret;
}

Val* EvalSub(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *lnum = NULL;
    Val* rref = NULL, *rval = NULL, *rnum = NULL;
    Val* ret = NULL;
    Js* e = p->e;
    lref = Eval(p, n->left, flags);
    lval = GetValue(e, lref);
    RET_IF_AB(lval);
    rref = Eval(p, n->right, flags);
    rval = GetValue(e, rref);
    RET_IF_AB(rval);
    lnum = ToNumber(e, lval);
    RET_IF_AB(lnum);
    rnum = ToNumber(e, rval);
    RET_IF_AB(rnum);
    number nv = AddOp(lnum->num, -rnum->num);
    RET(ValNewNum(e, nv));

exit:
    IFD(lref);
    IFD(lval);
    IFD(lnum);
    IFD(rref);
    IFD(rval);
    IFD(rnum);
    return ret;    
}

Val* EvalLtGt(Parser* p, Node* n, uint32 flags, bool_t leftFirst) {
    Val* lval = NULL, *rval = NULL, *r = NULL, *ret = NULL;
    Js* e = p->e;
    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    rval = GetVal(p, n->right, flags);
    RET_IF_AB(rval);
    r = AbstractRelational(e, lval, rval, leftFirst);
    RET_IF_AB(r);
    if(ValIsUndef(r))
        RET(ValNewBool(e, FALSE));
    
    RET_VAL(r);
exit:
    IFD(lval);
    IFD(rval);
    IFD(r);
    return ret;    
}


Val* EvalLteGte(Parser* p, Node* n, uint32 flags, bool_t leftFirst) {
    Val* lval = NULL, *rval = NULL, *r = NULL, *ret = NULL;
    Js* e = p->e;
    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    rval = GetVal(p, n->right, flags);
    RET_IF_AB(rval);
    r = AbstractRelational(e, lval, rval, leftFirst);
    RET_IF_AB(r);
    if(ValIsTrue(e, r) || ValIsUndef(r))
        RET(ValNewBool(e, FALSE));

    RET(ValNewBool(e, TRUE));
exit:
    IFD(lval);
    IFD(rval);
    IFD(r);
    return ret;    
}

Val* EvalEquality(Parser* p, Node* n, uint32 flags, bool_t strictEq, bool_t ne) {
    Val* lval = NULL, *rval = NULL, *ret = NULL, *r = NULL;
    Js* e = p->e;

    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    rval = GetVal(p, n->right, flags);
    RET_IF_AB(rval);
    if(strictEq)
        r = StrictEquality(e, rval, lval);
    else
        r = AbstractEquality(e, rval, lval);
    if(ne) {
        if(ValIsTrue(e, r))
            RET(ValNewBool(e, FALSE));
        RET(ValNewBool(e, TRUE));
    }
    RET_VAL(r);

exit:
    IFD(lval);
    IFD(rval);
    IFD(r);
    return ret;    
}

Val* EvalInstanceOf(Parser* p, Node* n, uint32 flags) {
    Val* lval = NULL, *rval = NULL, *ret = NULL;
    Js* e = p->e;

    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    rval = GetVal(p, n->right, flags);
    RET_IF_AB(rval);
    RET(InstanceOfOperator(e, lval, rval));
exit:
    IFD(lval);
    IFD(rval);
    return ret;    
}

Val* EvalIn(Parser* p, Node* n, uint32 flags) {
    Val* lval = NULL, *rval = NULL, *pk = NULL, *ret = NULL;
    Js* e = p->e;    
    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    rval = GetVal(p, n->right, flags);
    RET_IF_AB(rval);
    pk = ToPropKey(e, lval);
    RET(HasProp(e, rval, pk));
exit:
    IFD(lval);
    IFD(rval);
    IFD(pk);
    return ret;        
}

#define BITWISE_AND     0
#define BITWISE_OR      1
#define BITWISE_XOR     2
Val* EvalBitwise(Parser* p, Node* n, uint32 flags, int mode) {
    Val* lval = NULL, *rval = NULL, *lnum = NULL, *rnum = NULL, *ret = NULL;
    Js* e = p->e;

    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    rval = GetVal(p, n->right, flags);
    RET_IF_AB(rval);
    lnum = ToInt32(e, lval);
    RET_IF_AB(lnum);
    rnum = ToInt32(e, rval);
    RET_IF_AB(rnum);

    int32 l = (int32) lnum->num;
    int32 r = (int32) rnum->num;
    int32 x = 0;
    switch(mode) {
        case BITWISE_AND:
            x = l & r;
            break;
        case BITWISE_OR:
            x = l | r;
            break;
        case BITWISE_XOR:
            x = l ^ r;
            break;
    }
    RET(ValNewNum(e, x));

exit:
    IFD(lval);
    IFD(rval);
    IFD(lnum);
    IFD(rnum);
    return ret;    
}

Val* EvalLogicalAnd(Parser* p, Node* n, uint32 flags) {
    Val* lval = NULL, *ret = NULL, *lbool = NULL;
    Js* e = p->e;

    lval = GetVal(p, n->left, flags);
    RET_IF_AB(lval);
    lbool = ToBoolean(e, lval);
    RET_IF_AB(lbool);
    if(lbool->b == FALSE)
        RET_VAL(lval);
    RET(GetVal(p, n->right, flags));

exit:
    IFD(lval);
    IFD(lbool);    
    return ret;
}

Val* EvalLogicalOr(Parser* p, Node* n, uint32 flags) {
    Val* lval = NULL, *ret = NULL, *lbool = NULL;
    Js* e = p->e;

    lval = GetVal(p, n->left, flags);
    lbool = ToBoolean(e, lval);
    RET_IF_AB(lbool);
    if(lbool->b == TRUE)
        RET_VAL(lval);
    RET(GetVal(p, n->right, flags));

 exit:
    IFD(lval);
    IFD(lbool);    
    return ret;
}

Val* EvalConditional(Parser* p, Node* n, uint32 flags) {
    Val* lv = NULL, *lval = NULL, *ret = NULL;
    Js* e = p->e;

    lv = GetVal(p, n->left, flags);
    lval = ToBoolean(e, lv);
    RET_IF_AB(lv);
    if(lval->b == TRUE) 
        RET(GetVal(p, n->right->left, flags));
    RET(GetVal(p, n->right->right, flags));

exit:
    IFD(lv);
    IFD(lval);
    return ret;    
}

bool_t IsIdentifierRef(Parser* p, Node* n) {
    return FALSE;   // @todo: implement
}

Val* DestructuringAssignmentEvaluation(Parser* p, Node* pattern, Val* obj, uint32 flags);

Val* KeyedDestructuringAssignmentEvaluation(Parser* p, Node* pattern, Val* obj, uint32 flags) {
    Val* P = NULL, *ret = NULL, *v = NULL, *defaultValue = NULL, *lref = NULL, *status = NULL;
    Val* name = NULL;

    Js* e = p->e;
    Node* n = pattern;
    while(n) {
        int k = NodeKeyword(p, n->left);
        if(k != id_colon) {   // AssignmentProperty: IdentifierRef [Initializer]
            Node* idRef = n->left, *init = NULL;
            if(k == id_eq) {
                idRef = n->left->left;
                init = n->left->right;
            }
            P = StringValue(p, idRef);
            v = Get(e, obj, P);
            RET_IF_AB(v);
            if(init && ValIsUndef(v)) {
                defaultValue = Eval(p, init, flags);
                ValDel(e, v);
                v = GetValue(e, defaultValue);
                RET_IF_AB(v);
            }
            lref = ResolveBinding(e, P, FALSE);
            status = PutValue(e, lref, v);
            RET_IF_AB(status);
            IFZ(status);
            IFZ(lref);
            IFZ(P);
            IFZ(v);
            IFZ(defaultValue);
            n = n->right;
            continue;
        }

        // AssignmentProperty: ProeprtyName : AssignmentElement
        Node* init = NULL, *target = n->left->right;
        if(NodeKeyword(p, n->left->right) == id_eq){
            init = n->left->right->right;
            target = n->left->right->left;
        }
        name = StringValue(p, n->left->left);
        RET_IF_AB(name);
        v = Get(e, obj, name);
        RET_IF_AB(v);
        if(ValIsUndef(v) && init) {
            defaultValue = Eval(p, init, flags);
            ValDel(e, v);
            v = GetValue(e, defaultValue);
            RET_IF_AB(v);
        }
        k = NodeKeyword(p, target);
        if(k == id_lbrace || k == id_lbracket) {
            if(!ValIsObject(v))
                RET(ThrowTypeError(e, "not an object", 0,0));
            status = DestructuringAssignmentEvaluation(p, target, v, flags);
        }
        else {
            lref = Eval(p, target, flags);
            status = PutValue(e, lref, v);
            RET_IF_AB(status);
        }
        IFZ(status);
        IFZ(v);
        IFZ(defaultValue);
        IFZ(name);
        IFZ(P);
        n = n->right;
    }
    RET(ValNew(e));
exit:
    IFD(P);
    IFD(v);
    IFD(defaultValue);
    IFD(lref);
    IFD(status);
    IFD(name);
    return ret;    
}

Val* IteratorDestructuringAssignmentEvaluation(Parser* p, Node* pattern, Val* iterator, uint32 flags) {
    Val* lref = NULL, *next = NULL, *v = NULL, *ret = NULL, *status = NULL, *A = NULL;
    Val* nextValue = NULL, *defineStatus = NULL, *uintN = NULL, *strN = NULL;
    Node* target = NULL, *initializer = NULL;

    Js* e = p->e;
    Node* n = pattern;
    while(n) {
        if(!n->left) {
            Val* next = IteratorStep(e, iterator);
            RET_IF_AB(next);
            IFZ(next);
            n = n->right;
            continue;
        }

        if(NodeKeyword(p, n->left) == id_dotdotdot) {    // spread
            lref = Eval(p, n->left->left, flags);
            RET_IF_AB(lref);
            A = ArrayCreate(e, 0, NULL);
            Val num;
            ValInitNum(&num, 0);
            while(TRUE) {
                next = IteratorStep(e, iterator);
                RET_IF_AB(next);
                if(next->type == TYPE_BOOL && next->b == FALSE) 
                    RET(PutValue(e, lref, A));
                nextValue = IteratorValue(e, next);
                RET_IF_AB(nextValue);
                uintN = ToUint32(e, &num);
                strN = ToString(e, uintN);
                defineStatus = CreateDataPropOrThrow(e, A, strN, nextValue);
                RET_IF_AB(defineStatus);
                IFZ(next);
                IFZ(uintN);
                IFZ(strN);
                IFZ(nextValue);
                IFZ(defineStatus);
                num.num++;
            }
            RET(ValNew(e));
        }

        if(NodeKeyword(p, n->left) == id_eq) {
            target = n->left->left;
            initializer = n->left->right;
        }
        else 
            target = n->left;
        int k = NodeKeyword(p, target);
        Val* lref = NULL;
        if(k != id_lbracket && k != id_lbrace) {
            lref = Eval(p, target, flags);
            RET_IF_AB(lref);
        }
        Val* next = IteratorNext(e, iterator, NULL);
        RET_IF_AB(next);
        if(next->type == TYPE_BOOL && next->b == FALSE)
            v = ValNew(e);
        else {
            v = IteratorValue(e, next);
            RET_IF_AB(v);
        }
        if(initializer && ValIsUndef(v)) {
            IFZ(v);
            v = GetVal(p, initializer, flags);
            RET_IF_AB(v);
        }
        if(k == id_lbrace || k == id_lbracket) {
            if(!ValIsObject(v))
                RET(ThrowTypeError(e, "not an object",0,0));
            status = DestructuringAssignmentEvaluation(p, target, v, flags);
            goto cont;
        }
        status = PutValue(e, lref, v);
cont:
        RET_IF_AB(status);
        IFZ(status);
        IFZ(v);
        IFZ(lref);
        IFZ(next);
        n = n->right;
        continue;
    }
    RET(ValNew(e));
exit:
    IFD(A);
    IFD(nextValue);
    IFD(uintN);
    IFD(strN);
    IFD(defineStatus);
    IFD(status);
    IFD(next);
    IFD(v);
    IFD(lref);    
    return ret;
}

Val* DestructuringAssignmentEvaluation(Parser* p, Node* pattern, Val* obj, uint32 flags) {
    Js* e = p->e;
    // ObjectAssignmentPattern : { }
    if(NodeKeyword(p, pattern) == id_lbrace && pattern->right == NULL)
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);

    // ArrayAssignmentPattern : [ ]
    if(NodeKeyword(p, pattern) == id_lbracket && pattern->right == NULL) {
        Val* iterator = GetIterator(e, obj, NULL);
        if(ValIsAbrupt(e, iterator))
            return iterator;
        ValDel(e, iterator);
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);        
    }

    if(NodeKeyword(p, pattern) == id_lbracket) {
        Val* iterator = GetIterator(e, obj, NULL);
        if(ValIsAbrupt(e, iterator))
            return iterator;
        Val* ret = IteratorDestructuringAssignmentEvaluation(p, pattern->right, iterator, flags);
        ValDel(e, iterator);
        return ret;
    }

    if(NodeKeyword(p, pattern) == id_lbrace) {
        return KeyedDestructuringAssignmentEvaluation(p, pattern->right, obj, flags);

    }

    return NULL;
}

bool_t IsAssignmentPattern(Parser* p, Node* n) {
    if(!n)
        return FALSE;
    int k = NodeKeyword(p, n);
    if(k != id_lbracket && k != id_lbrace)
        return FALSE;
    if(k == id_lbracket && n->left)
        return FALSE;

    return TRUE;    
}

Node* AssignmentPattern(Parser* p, int start, uint32 flags);
Val* EvalAssignment(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *rref = NULL, *rval = NULL, *ret = NULL;
    Val* hasNameProperty = NULL, *status = NULL;
    Js* e = p->e;

    // int k = NodeKeyword(p, n->left);
    
    // #444 I think this should be !NodeHasFlag(AssignmentPattern)
    // if(k != id_lbracket && k != id_lbrace) {    // not an object or array
   if(!IsAssignmentPattern(p, n->left)) {
        lref = Eval(p, n->left, flags);
        RET_IF_AB(lref);
        rref = Eval(p, n->right, flags);
        rval = GetValue(e, rref);
        if(IsAnonymousFunctionDefinition(p, n->right) && IsIdentifierRef(p, n->left)) {
            Val* name = ValNewStrA(e, "name"); // todo: const
            hasNameProperty = HasOwnProp(e, rval, name);
            ValDel(e, name);
            RET_IF_AB(hasNameProperty);
            if(!ValIsTrue(e, hasNameProperty)) {
                Val* v = SetFunctionName(e, rval, RefGetReferencedName(e, lref), NULL);
                ValDel(e, v);
                status = PutValue(e, lref, rval);
                RET_IF_AB(status);
                RET_VAL(rval);
            }
        }
        status = PutValue(e, lref, rval);
        RET_IF_AB(status);
        RET_VAL(rval);
    }

    Node* AssignmentPattern = n->left;
    rref = Eval(p, n->right, flags);
    rval = GetValue(e, rref);
    RET_IF_AB(rval);
    if(!ValIsObject(rval))
        RET(ThrowTypeError(e, "not an object", 0,0));
    status = DestructuringAssignmentEvaluation(p, AssignmentPattern, rval, flags);
    RET_IF_AB(status);
    RET_VAL(rval);
exit:
    IFD(lref);
    IFD(lval);
    IFD(rref);
    IFD(rval);    
    IFD(hasNameProperty);
    IFD(status);
    return ret;
}

Val* EvalAssignmentOp(Parser* p, Node* n, uint32 flags, int op) {
    Val* lref = Eval(p, n->left, flags);
    Val *v = 0;
    switch(op) {
        case id_multeq:
            v = EvalMultExpr(p, n, flags, MultOp);
            break;
        case id_diveq:
            v = EvalMultExpr(p, n, flags, DivOp);
            break;
        case id_modeq:
            v = EvalMultExpr(p, n, flags, ModOp);
            break;        
        case id_pluseq:
            v = EvalAdd(p, n, flags);
            break;
        case id_minuseq:
            v = EvalSub(p, n, flags);
            break;            
        case id_lshifteq:
            v = EvalLeftShift(p, n, flags);
            break;
        case id_rshifteq:
            v = EvalSignedRightShift(p, n, flags);
            break;
        case id_rshiftaeq:
            v = EvalUnsignedRightShift(p, n, flags);
            break;
        case id_andeq:
            v = EvalBitwise(p, n, flags, BITWISE_AND);
            break;
        case id_oreq:
            v = EvalBitwise(p, n, flags, BITWISE_OR);
            break;
        case id_careteq:        
            v = EvalBitwise(p, n, flags, BITWISE_XOR);
            break;        
    }
    if(ValIsAbrupt(p->e, v)) {
        ValDel(p->e, lref);
        return v;
    }
    Val* status = PutValue(p->e, lref, v);
    ValDel(p->e, lref);
    if(ValIsAbrupt(p->e, status)) {
        ValDel(p->e, v);
        return status;
    }
    ValDel(p->e, status);
    return v;
}

Val* EvalExpression(Parser* p, Node* n, uint32 flags);

Val* EvalComma(Parser* p, Node* n, uint32 flags) {
    Val* lref = NULL, *lval = NULL, *ret = NULL;
    Js* e = p->e;

    while(NodeKeyword(p, n) == id_comma) {
        lref = EvalExpression(p, n->left, flags);
        lval = GetValue(e, lref);
        RET_IF_AB(lval);
        IFZ(lref);
        IFZ(lval);
        n = n->right;
    }
    lref = EvalExpression(p, n, flags);
    lval = GetValue(e, lref);
    RET_IF_AB(lval);
    RET_VAL(lval);

exit:
    IFD(lref);
    IFD(lval);
    return ret;    
}


bool_t LabelSetHasString(Parser* p, PtrList* l, Val* v) {
    if(!l)
        return FALSE;
    for(PtrItem* pi=l->head; pi; pi = pi->next) {
        Node* n = pi->value;
        Val* s = StringValue(p, n);
        if(ValIsTrueDel(p->e, SameValue(p->e, s, v))) {
            ValDel(p->e, s);
            return TRUE;
        }
        ValDel(p->e, s);
    }
    return FALSE;
}

void LabelSetPrint(Parser* p, PtrList* l, Val* v) {
    if(!l) {
        jprintf(p->e, 0, "<empty>\n");
        return;
    }
    for(PtrItem* pi=l->head; pi; pi = pi->next) {
        Node* n = pi->value;
        if(pi != l->head)
            jprintf(p->e, 0, ", ");
        Val* s = StringValue(p, n);
        StrPrint(p->e, s->str);
        ValDel(p->e, s);
    }
    jprintf(p->e, 0, "\n");
}


bool_t LoopContinues(Parser* p, Val* completion, PtrList* labelSet) {
    if(completion->type != TYPE_COMP) return TRUE;
    if(completion->completion->type == COMP_NORMAL) return TRUE;
    if(completion->completion->type != COMP_CONTINUE) return FALSE;
    if(!completion->completion->target) return TRUE;
    if(LabelSetHasString(p, labelSet, completion->completion->target))
        return TRUE;
    return FALSE;
}



Val* StatementValue(Parser* p, Val* comp) {
    if(comp->type != TYPE_COMP)
        return comp;
    return comp->completion->value;
}

Val* EvalDo(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Js* e = p->e;
    Val* v = ValNew(e), *ret =0, *exprRef =0, *exprv=0, *exprValue=0, *stmt =0;

    LOOP_START(e);
    while(TRUE) {
        LOOP_CHECK(e);
        stmt = Eval(p, n->left, flags);
        if(!LoopContinues(p, stmt, labelSet))
            RET_VAL(stmt);

        
        if(StatementValue(p, stmt)) {
            IFZ(v);
            v = ValClone(e, StatementValue(p, stmt));
        }
        exprRef = Eval(p, n->right, flags);
        exprv = GetValue(e, exprRef);
        exprValue = ToBoolean(e, exprv);

        IFZ(exprv);
        IFZ(exprRef);
        IFZ(stmt);
        if(exprValue->type == TYPE_BOOL && !exprValue->b) {
            RET(ValNewCompU(e, COMP_NORMAL, v, NULL));
        }
        if(!ValIsTrue(e, exprValue)) {
            assert(ValIsAbrupt(e, exprValue));
            if(!LoopContinues(p, exprValue, labelSet))
                RET_VAL(exprValue);
        }
        IFZ(exprValue);
    }   
    RET_VAL(v);
exit:
    IFD(exprRef);
    IFD(exprv);
    IFD(exprValue);
    IFD(stmt);
    IFD(v);
    return ret;
}


Val* EvalWhile(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Js* e = p->e;
    Val* v = ValNew(e), *ret = 0, *exprRef =0, *exprv = 0, *exprValue =0, *stmt=0;
    LOOP_START(e);
    while(TRUE) {
        LOOP_CHECK(e);
        exprRef = Eval(p, n->left, flags);
        exprv = GetValue(e, exprRef);
        exprValue = ToBoolean(e, exprv);
        IFZ(exprRef);
        IFZ(exprv);
        if(exprValue->type == TYPE_BOOL && !exprValue->b) 
            RET(ValNewCompU(e, COMP_NORMAL, v, NULL));
        
        if(!ValIsTrue(e, exprValue)) {
            assert(ValIsAbrupt(e, exprValue));
            if(!LoopContinues(p, exprValue, labelSet)) {
                RET_VAL(exprValue);
            }
        }
        IFZ(exprValue);
        stmt = Eval(p, n->right, flags);
        if(StatementValue(p, stmt)) {
            ValDel(e, v);
            v = ValClone(e, StatementValue(p, stmt));
        }
        IFZ(stmt);
    }
    RET_VAL(v);
exit:
    IFD(exprRef);
    IFD(exprv);
    IFD(exprValue);
    IFD(stmt);
    IFD(v);
    return ret;    
}

bool_t HasIterationBindings(PtrList* perIterationBinding) {
    if(perIterationBinding && perIterationBinding->count)
        return TRUE;
    return FALSE;    
}

Val* CreatePerIterationEnvironment(Parser* p, PtrList* perIterationBinding) {
    Val* ret = NULL, *lastIterationEnv = NULL, *outer = NULL, *thisIterationEnv = NULL;
    Val* status = NULL, *lastValue = NULL, *bn = NULL;
    Js* e = p->e;
    PtrList* list = perIterationBinding;

    if(HasIterationBindings(perIterationBinding) ) {
        lastIterationEnv = e->currentContext->lex;
        outer = lastIterationEnv->lex->outer;
        assert(outer != NULL);
        thisIterationEnv = NewDeclEnv(e, outer);
        for(PtrItem* li=list->head; li; li = li->next) {
            Node* bnn = li->value;
            bn = StringValue(p, bnn);
            Env* te = thisIterationEnv->lex->envRec;
            status = te->vtable->createMutableBinding(e, te, bn, FALSE);
            assert(!ValIsAbrupt(e, status));
            IFZ(status);
            Env* le = lastIterationEnv->lex->envRec;
            lastValue = le->vtable->getBindingValue(e, le, bn, TRUE);
            RET_IF_AB(lastValue);
            Val* x = te->vtable->initializeBinding(e, te, bn, lastValue);
            ValDel(e, x);
            IFZ(lastValue);
            IFZ(bn);
        }
        e->currentContext->lex = ValClone(e, thisIterationEnv);
    }
    RET(ValNew(e));
exit:
    IFD(bn);
    IFD(thisIterationEnv);
    IFD(status);
    IFD(lastValue);
    return ret;
}

// Print context chain
void pcc(Js* e) {
    for(LexEnv* l = e->currentContext->lex->lex; ; ) {
        printf("0x%lx >> ",  (unsigned long) l);
        if(l->outer)
            l = l->outer->lex;
        else
            break;
    }

    printf("null\n");
}

Val* ForBodyEvaluation(Parser* p, Node* testExpr, Node* incrementExpr, Node* stmt, PtrList* perIterationBinding, 
    PtrList* labelSet, uint32 flags) {
    Val* v = NULL, *ret = NULL, *testExprRef = NULL, *testExprValue = NULL, *result = NULL;
    Val* status = NULL, *incExprRef = NULL, *incExprVal = NULL;
    Js* e = p->e;

    Val* originalEnv = e->currentContext->lex;
    // Create a vector to hold all the environments that we create so that
    // we can release them when done.... Of course functions created inside
    // the statement 
    v = ValNew(e);
    status = CreatePerIterationEnvironment(p, perIterationBinding);
    RET_IF_AB(status);

    IFZ(status);
    LOOP_START(e);
    while(TRUE) {
        LOOP_CHECK(e);
        if(testExpr) {
            testExprRef = Eval(p, testExpr, flags);
            Val* tev = GetValue(e, testExprRef);
            testExprValue = ToBoolean(e, tev);
            ValDel(e, tev);
            IFZ(testExprRef);
            if(testExprValue->type == TYPE_BOOL && !testExprValue->b) {
                RET(ValNewCompU(e, COMP_NORMAL, v, NULL));
            }
            else if(!LoopContinues(p, testExprValue, labelSet))
                RET_VAL(testExprValue);
            IFZ(testExprValue);
        }
        result = Eval(p, stmt, flags);
        if(!LoopContinues(p, result, labelSet))
            RET_VAL(result);
        if(StatementValue(p, result)) {
            ValDel(e, v);
            v = ValClone(e, StatementValue(p, result));
        }
        IFZ(result);

        // #401 each iteration of ForLEEE should create a spearate iteration 
        //      environment. Should fucntions be created in this iteration
        //      they would capture the environment ... Since we are 
        //      about to replace the environment, we _free the last one
        //      We have to _free old one after the new one is created since
        //      the new environment will need the lexical declarations from
        //      the previous one in CreatePerIterationEnvironment
        if(perIterationBinding) {
            Val* cl = e->currentContext->lex;
            status = CreatePerIterationEnvironment(p, perIterationBinding);
            RET_IF_AB(status);
            IFZ(status);
            ValDel(e, cl);
        }
        
        if(incrementExpr) {
            incExprRef = Eval(p, incrementExpr, flags);
            incExprVal = GetValue(e, incExprRef);
            if(!LoopContinues(p, incExprVal, labelSet)) 
                RET_VAL(incExprVal);
            IFZ(incExprRef);
            IFZ(incExprVal);
        }
    }
exit:

    if(perIterationBinding) { 
        Val* cl = e->currentContext->lex;
        e->currentContext->lex = originalEnv;
        ValDel(e, cl);
    }
    IFD(v);
    IFD(testExprRef);
    IFD(testExprValue);
    IFD(incExprRef);
    IFD(incExprVal);
    IFD(result);
    IFD(status);
    return ret;
}

Val* EvalForEEE(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    if(n->left->left) {
        Val* exprRef = Eval(p, n->left->left, flags);
        Val* exprValue = GetValue(p->e, exprRef);
        ValDel(p->e, exprRef);
        if(!LoopContinues(p, exprValue, labelSet)) 
            return exprValue;
        ValDel(p->e, exprValue);        
    }
    return ForBodyEvaluation(p, n->left->right->left, n->left->right->right->left, n->right, NULL, labelSet, flags);
}

Val* EvalForVEE(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Val* varDcl = Eval(p, n->left->left, flags);
    if(!LoopContinues(p, varDcl, labelSet))
        return varDcl;
    ValDel(p->e, varDcl);
    return ForBodyEvaluation(p, n->left->right->left, n->left->right->right->left, n->right, NULL, labelSet, flags);
}

Val* EvalForLEE(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    PtrList* boundNames = NULL;
    Val* ret = NULL, *forDecl = NULL;
    Js* e = p->e;

    Node* lexDecl = n->left->left->left;
    Node* testExpr = n->left->left->right;
    Node* incExpr = n->left->right->left;
    Node* stmt = n->right;

    Val* oldEnv = e->currentContext->lex;
    Val* loopEnv = NewDeclEnv(e, oldEnv);
    bool_t isConst = IsConstantDeclaration(p, lexDecl);
    boundNames = BoundNames(p, lexDecl);
    Env* le = loopEnv->lex->envRec;
    for(PtrItem* bi=boundNames->head; bi; bi = bi->next) {
        Node* dnl = bi->value;
        Val* dn = StringValue(p, dnl);
        Val* res;
        if(isConst) 
            res = le->vtable->createImmutableBinding(e, le, dn);
        else
            res = le->vtable->createMutableBinding(e, le, dn, FALSE);
        ValDel(e, res);
        ValDel(e, dn);
    }
    e->currentContext->lex = loopEnv;
    forDecl = Eval(p, lexDecl, flags);
    if(LoopContinues(p, forDecl, labelSet) == FALSE) {
        e->currentContext->lex = oldEnv;
        RET_VAL(forDecl);
    }

    PtrList* perIterationLets;
    if(!isConst) 
        perIterationLets = boundNames;
    else
        perIterationLets = NULL;


    Val* bodyResult = ForBodyEvaluation(p, testExpr, incExpr, stmt, perIterationLets, labelSet, flags);
    e->currentContext->lex = oldEnv;
    ret = bodyResult;

exit:
    IFD(forDecl);
    IFD(loopEnv);
    if(boundNames) PtrListDel(e, boundNames);
    return ret;

}


#define IKIND_ENUM 0
#define IKIND_ITERATE  1

#define LKIND_ASSIGN 0
#define LKIND_VAR 1
#define LKIND_LEX 2


Val* ForInOfExpressionEvaluation(Parser* p, PtrList* TDZnames, Node* expr, int iterationKind, PtrList* labelSet, uint32 flags) {
    Js* e = p->e;
    Val* ret = NULL, *TDZ = NULL, *obj = NULL, *keys = NULL;

    Val* oldEnv = e->currentContext->lex;
    if(TDZnames && TDZnames->count) {
        // @todo: assert no duplicate names in list
        TDZ = NewDeclEnv(e, oldEnv);
        Env* tdze = TDZ->lex->envRec;
        for(PtrItem* pi=TDZnames->head; pi; pi = pi->next) {
            Val* name = StringValue(p, pi->value);
            Val* status = tdze->vtable->createMutableBinding(e, tdze, name, FALSE);
            ValDel(e, status);
            ValDel(e, name);
        }
        e->currentContext->lex = TDZ;
    }
    Val* exprRef = Eval(p, expr, flags);
    Val* exprValue = GetValue(e, exprRef);
    ValDel(e, exprRef);
    if(ValIsAbrupt(e, exprValue)) {
        if(LoopContinues(p, exprValue, labelSet) == FALSE) 
            RET_VAL(exprValue);
        RET(ValNewCompU(e, COMP_BREAK, NULL, NULL));
    }
    obj = ToObject(e, exprValue);
    if(iterationKind == IKIND_ENUM) {
        keys = DoEnumerate(e, obj);
    }
    else {
        assert(iterationKind == IKIND_ITERATE);
        keys = GetIterator(e, obj, NULL);
    }
    if(ValIsAbrupt(e, keys)) {
        if(LoopContinues(p, keys, labelSet) == FALSE) 
            RET_VAL(keys);
        assert(keys->type == TYPE_COMP && keys->completion->type == COMP_CONTINUE);
        RET(ValNewCompU(e, COMP_BREAK, NULL, NULL));
    }
    RET_VAL(keys);
exit:
    IFD(TDZ);
    IFD(obj);
    IFD(exprValue);
    IFD(keys);
    e->currentContext->lex = oldEnv;
    return ret;
}


bool_t ValIsNormal(Val* v) {
    if(v->type != TYPE_COMP)
        return TRUE;
    return (v->completion->type == COMP_NORMAL);
}


Val* ForInOfBodyEvaluation(Parser* p, Node* lhs, Node* stmt, Val* iterator, int lhsKind, PtrList* labelSet, uint32 flags) {
    Js* e = p->e;
    Val* v = NULL, *nextResult = NULL, *nextValue = NULL, *status = NULL, *iterationEnv = NULL;
    Val* innerResult = NULL, *ret = NULL, *lhsRef = NULL, *und = ValNew(e);

    Val* oldEnv = e->currentContext->lex;
    v = ValNew(e);
    while(1) {
        nextResult = IteratorStep(e, iterator);
        RET_IF_AB(nextResult);
        if(nextResult->type == TYPE_BOOL && !nextResult->b)
            RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
        nextValue = IteratorValue(e, nextResult);
        RET_IF_AB(nextValue);
        IFZ(nextResult);
        if(lhsKind == LKIND_ASSIGN) {
            assert(NodeHasFlag(p, lhs, LeftHandSideExpression));
            if(!NodeHasFlag(p, lhs, ObjectLiteral) && !NodeHasFlag(p, lhs, ArrayLiteral)) {
                lhsRef = Eval(p, lhs, flags);
                status = PutValue(e, lhsRef, nextValue);
            }
            else {
                if(nextValue->type != TYPE_OBJ)
                    RET(ThrowTypeError(e, "not an object",0,0));
                status = DestructuringAssignmentEvaluation(p, lhs, nextValue, flags);
            }
        }
        else if(lhsKind == LKIND_VAR) {
            assert(NodeHasFlag(p, lhs->right, ForBinding));
            status = BindingInitialization(p, lhs->right, nextValue, und, flags);
        }
        else {
            assert(lhsKind == LKIND_LEX);
            assert(NodeHasFlag(p, lhs, ForDeclaration));
            iterationEnv = NewDeclEnv(e, oldEnv);
            status = BindingInitialization(p, lhs, nextValue, iterationEnv, flags);
            e->currentContext->lex = iterationEnv;            
        }

        if(ValIsNormal(status)) {
            ValDel(e, status);
            status = Eval(p, stmt, flags);
            if(StatementValue(p, status)) {
                ValDel(e, v);
                v = ValClone(e, StatementValue(p, status));
            }
        }
        e->currentContext->lex = oldEnv;
        if(ValIsAbrupt(e, status) && LoopContinues(p, status, labelSet) == FALSE) {
            if(status->type == TYPE_COMP && status->completion->type == COMP_THROW) {
                if(ValIsTrueDel(e, HasProp(e, iterator, e->strThrow))) {
                    List* l = ListNew(e);
                    ListAddValue(e, l, ValClone(e, status->completion->value));
                    Val* args = ValNewList(e, l);
                    innerResult = Invoke(e, iterator, e->strThrow, args);
                    ValDel(e, args);
                    RET_IF_AB(innerResult);
                }
                else if(ValIsTrueDel(e, HasProp(e, iterator, e->strReturn))) {
                    innerResult = Invoke(e, iterator, e->strReturn, NULL);
                    RET_IF_AB(innerResult);
                }
            }
            RET_VAL(status);
        }
        IFZ(iterationEnv);
        IFZ(status);
        IFZ(nextValue);
        IFZ(lhsRef);
    }

exit:
    IFD(und);
    IFD(v);    
    IFD(lhsRef);
    IFD(nextResult);
    IFD(nextValue);
    IFD(status);
    IFD(iterationEnv);
    IFD(innerResult);
    return ret;
}

Val* EvalForLIE(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Val* keyResult = ForInOfExpressionEvaluation(p, NULL, n->left->right, IKIND_ENUM, labelSet, flags);
    if(ValIsAbrupt(p->e, keyResult))
        return keyResult;
    Val* ret = ForInOfBodyEvaluation(p, n->left->left, n->right, keyResult, LKIND_ASSIGN, labelSet, flags);
    ValDel(p->e, keyResult);
    return ret;
}

Val* EvalForVIE(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Val* keyResult = ForInOfExpressionEvaluation(p, NULL, n->left->right, IKIND_ENUM, labelSet, flags);
    if(ValIsAbrupt(p->e, keyResult))
        return keyResult;
    Val* ret = ForInOfBodyEvaluation(p, n->left->left, n->right, keyResult, LKIND_VAR, labelSet, flags);
    ValDel(p->e, keyResult);
    return ret;
}

Val* EvalForFIE(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    PtrList* boundNames = BoundNames(p, n->left->left);
    Val* keyResult = ForInOfExpressionEvaluation(p, boundNames, n->left->right, IKIND_ENUM, labelSet, flags);
    if(ValIsAbrupt(p->e, keyResult)) {
        PtrListDel(p->e, boundNames);
        return keyResult;
    }
    Val* ret = ForInOfBodyEvaluation(p, n->left->left, n->right, keyResult, LKIND_LEX, labelSet, flags);
    ValDel(p->e, keyResult);
    PtrListDel(p->e, boundNames);
    return ret;
}

Val* EvalForLOA(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Val* keyResult = ForInOfExpressionEvaluation(p, NULL, n->left->right, IKIND_ITERATE, labelSet, flags);
    if(ValIsAbrupt(p->e, keyResult))
        return keyResult;
    Val* ret = ForInOfBodyEvaluation(p, n->left->left, n->right, keyResult, LKIND_ASSIGN, labelSet, flags);
    ValDel(p->e, keyResult);
    return ret;
}

Val* EvalForVOA(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Val* keyResult = ForInOfExpressionEvaluation(p, NULL, n->left->right, IKIND_ITERATE, labelSet, flags);
    if(ValIsAbrupt(p->e, keyResult))
        return keyResult;
    Val* ret = ForInOfBodyEvaluation(p, n->left->left, n->right, keyResult, LKIND_VAR, labelSet, flags);
    ValDel(p->e, keyResult);
    return ret;
}

Val* EvalForFOA(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    PtrList* boundNames = BoundNames(p, n->left->left);
    Val* keyResult = ForInOfExpressionEvaluation(p, boundNames, n->left->right, IKIND_ITERATE, labelSet, flags);
    if(ValIsAbrupt(p->e, keyResult)) {
        PtrListDel(p->e, boundNames);
        return keyResult;
    }
    Val* ret = ForInOfBodyEvaluation(p, n->left->left, n->right, keyResult, LKIND_LEX, labelSet, flags);
    ValDel(p->e, keyResult);
    PtrListDel(p->e, boundNames);
    return ret;
}



Node* ForEEE(Parser* p, int start, uint32 flags);
Node* ForVEE(Parser* p, int start, uint32 flags);
Node* ForLEE(Parser* p, int start, uint32 flags);
Node* ForLIE(Parser* p, int start, uint32 flags);
Node* ForVIE(Parser* p, int start, uint32 flags);
Node* ForFIE(Parser* p, int start, uint32 flags);
Node* ForLOA(Parser* p, int start, uint32 flags);
Node* ForVOA(Parser* p, int start, uint32 flags);
Node* ForFOA(Parser* p, int start, uint32 flags);

Val* EvalFor(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    if(NodeHasFlag(p, n, ForEEE))
        return EvalForEEE(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForVEE))
        return EvalForVEE(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForLEE))
        return EvalForLEE(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForLIE))
        return EvalForLIE(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForVIE))
        return EvalForVIE(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForFIE))
        return EvalForFIE(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForLOA))
        return EvalForLOA(p, n, flags, labelSet);
    if(NodeHasFlag(p, n, ForVOA))
        return EvalForVOA(p, n, flags, labelSet);    
    if(NodeHasFlag(p, n, ForFOA))
        return EvalForFOA(p, n, flags, labelSet);
    return NULL;

}

Val* EvalIf(Parser* p, Node* n, uint32 flags) {
    Val* exprRef = NULL, *exprValue = NULL, *stmtValue = NULL;
    Val* bexprValue = NULL;
    Val* ret = NULL;
    Js* e = p->e;

    exprRef = Eval(p, n->left, flags);
    exprValue = GetValue(e, exprRef);
    bexprValue = ToBoolean(e, exprValue);
    RET_IF_AB(bexprValue);
    if(NodeKeyword(p, n->right) != id_else) {
        if(ValIsTrue(e, bexprValue)) 
            stmtValue = Eval(p, n->right, flags);
        else
            RET(ValNewCompU(e, COMP_NORMAL,0,NULL));
    }
    else {
        if(ValIsTrue(e, bexprValue))
            stmtValue = Eval(p, n->right->left, flags);
        else 
            stmtValue = Eval(p, n->right->right, flags);
    }
    if(stmtValue->type == TYPE_COMP && !stmtValue->completion->value)
        RET(ValNewCompU(e, COMP_NORMAL, 0, NULL));
    RET_VAL(stmtValue);

exit:
    IFD(exprRef);
    IFD(exprValue);
    IFD(stmtValue);
    IFD(bexprValue);
    return ret;    
}




void GetTryBlocks(Parser* p, Node* n, Node** b1, Node** b2, Node** b3) {
    *b1 = NULL;
    *b2 = NULL;
    *b3 = NULL;

    if(n->left)
        *b1 = n->left;
    if(n->right->left)
        *b2 = n->right->left->right;
    if(n->right->right)
        *b3 = n->right->right->left;
}

void GetIfBlocks(Parser* p, Node* n, Node** b1, Node** b2) {
    *b1 = NULL;
    *b2 = NULL;
    if(NodeKeyword(p, n->right) != id_else) {
        *b1 = n->right;
        return;
    }
    *b1 = n->right->left;
    *b2 = n->right->right;
}

Node* GetStatementBlock(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, DoStatement))
        return n->right;
    if(NodeHasFlag(p, n, WhileStatement))
        return n->right;
    if(NodeHasFlag(p, n, ForEEE))
        return n->right;
    if(NodeHasFlag(p, n, ForVEE))
        return n->right;
    if(NodeHasFlag(p, n, ForLEE))
        return n->right;
    if(NodeHasFlag(p, n, ForVIE))
        return n->right;
    if(NodeHasFlag(p, n, ForLIE))
        return n->right;
    if(NodeHasFlag(p, n, ForFIE))
        return n->right;
    if(NodeHasFlag(p, n, ForLOA))
        return n->right;
    if(NodeHasFlag(p, n, ForVOA))
        return n->right;
    if(NodeHasFlag(p, n, ForFOA))
        return n->right;
    if(NodeHasFlag(p, n, WithStatement)) 
        return n->right;
    return NULL;
}

PtrList* VarDeclaredNames(Parser* p, Node* node) {
    Node* n = node;

    if(NodeHasFlag(p, n, FunctionStatementList)) {
        return TopLevelVarDeclaredNames(p, n);
    }
    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s = n; s ; s = s->right) {
            Node* st = s->left;
            if(NodeHasFlag(p, st, VariableStatement)) {
                PtrListCat(p->e, ret, VarDeclaredNames(p, st), TRUE);
            }
        }
        return ret;
    }

    if(NodeHasFlag(p, n, BlockStatement))
        return VarDeclaredNames(p, n->right);

    if(NodeHasFlag(p, n, VariableStatement)) {
        return BoundNames(p, n->right);
    }
    if(NodeHasFlag(p, n, SwitchStatement)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* c = n->right; c; c = c->right) {
            Node* st = c->left->right;
            PtrListCat(p->e, ret, VarDeclaredNames(p, st), TRUE);
        }
        return ret;        
    }

    Node* b1, *b2, *b3;
    if(NodeHasFlag(p, n, TryStatement)) {        
        GetTryBlocks(p, n, &b1, &b2, &b3);
        PtrList* ret = PtrListNew(p->e);
        PtrListCat(p->e, ret, VarDeclaredNames(p, b1), TRUE);
        PtrListCat(p->e, ret, VarDeclaredNames(p, b2), TRUE);
        PtrListCat(p->e, ret, VarDeclaredNames(p, b3), TRUE);
        return ret;
    }

    if(NodeHasFlag(p, n, IfStatement)) {
        GetIfBlocks(p, n, &b1, &b2);
        PtrList* ret = PtrListNew(p->e);
        PtrListCat(p->e, ret, VarDeclaredNames(p, b1), TRUE);
        PtrListCat(p->e, ret, VarDeclaredNames(p, b2), TRUE);
        return ret;
    }


    Node* block = GetStatementBlock(p, n);
    if(block)
        return VarDeclaredNames(p, block);
    return PtrListNew(p->e);


}



PtrList* TopLevelVarScopedDeclarations(Parser* p, Node* n);
Node* ScriptBody(Parser* p, int start, uint32 flags);
PtrList* VarScopedDeclarations(Parser* p, Node* node) {
    Node* n = node;
    Js* e = p->e;

    if(NodeHasFlag(p, n, ScriptBody)) {
        return TopLevelVarScopedDeclarations(p, n);
    }

    if(NodeHasFlag(p, n, FunctionStatementList)) {
        return TopLevelVarScopedDeclarations(p, n);
    }


    // if(NodeHasFlag(p, n, StatementList)) {
    //     PtrList* ret = PtrListNew(p->e);
    //     for(Node* s = n; s ; s = s->right) {
    //         Node* st = s->left;
    //         if(NodeHasFlag(p, st, Statement)) {
    //             PtrListCat(p->e, ret, VarScopedDeclarations(p, st), TRUE);
    //         }
    //     }
    //     return ret;
    // }

    if(NodeHasFlag(p, n, BlockStatement))
        return VarScopedDeclarations(p, n->right);

    if(NodeHasFlag(p, n, VariableStatement)) {
        PtrList* ret = PtrListNew(e);
        for(Node* vd = n->right; vd; vd = vd->right)
            PtrListAdd(e, ret, vd);
        return ret;
    }
    
//        if(n->right->left)
//            return VarScopedDeclarations(p, n->right->left);
//        return VarScopedDeclarations(p, n->right);
//    }

    if(NodeHasFlag(p, n, SwitchStatement)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* c = n->right; c; c = c->right) {
            Node* st = c->left->right;
            PtrListCat(p->e, ret, VarScopedDeclarations(p, st), TRUE);
        }
        return ret;        
    }

    Node* b1, *b2, *b3;
    if(NodeHasFlag(p, n, TryStatement)) {        
        GetTryBlocks(p, n, &b1, &b2, &b3);
        PtrList* ret = PtrListNew(p->e);
        PtrListCat(p->e, ret, VarScopedDeclarations(p, b1), TRUE);
        PtrListCat(p->e, ret, VarScopedDeclarations(p, b2), TRUE);
        PtrListCat(p->e, ret, VarScopedDeclarations(p, b3), TRUE);
        return ret;
    }

    if(NodeHasFlag(p, n, IfStatement)) {
        GetIfBlocks(p, n, &b1, &b2);
        PtrList* ret = PtrListNew(p->e);
        PtrListCat(p->e, ret, VarScopedDeclarations(p, b1), TRUE);
        PtrListCat(p->e, ret, VarScopedDeclarations(p, b2), TRUE);
        return ret;
    }


    Node* block = GetStatementBlock(p, n);
    if(block)
        return VarScopedDeclarations(p, block);
    return NULL;    

}
PtrList* TopLevelLexicallyDeclaredNames(Parser* p, Node* n);
Node* Declaration(Parser* p, int start, uint32 flags);

PtrList* TopLevelLexicallyScopedDeclarations(Parser* p, Node* n);

PtrList* LexicallyScopedDeclarations(Parser* p, Node* n) {

    if(NodeHasFlag(p, n, ScriptBody)) {
        return TopLevelLexicallyScopedDeclarations(p, n);
    }
    if(NodeHasFlag(p, n, FunctionStatementList)) {
        return TopLevelLexicallyScopedDeclarations(p, n);
    }

    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s = n; s; s = s->right) {
            Node* st = s->left;
            if(NodeHasFlag(p, st, Declaration))
                PtrListAdd(p->e, ret, st);
            else if(NodeHasFlag(p, st, LabelledStatement))
                PtrListCat(p->e, ret, LexicallyScopedDeclarations(p, st), TRUE);
            else if(NodeHasFlag(p, st, BlockStatement))
                PtrListCat(p->e, ret, LexicallyScopedDeclarations(p, st), TRUE);            
        }
        return ret;
    }
    if(NodeHasFlag(p, n, SwitchStatement)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* c = n->right; c; c = c->right) {
            Node* st = c->left->right;
            PtrListCat(p->e, ret, LexicallyScopedDeclarations(p, st), TRUE);
        }
        return ret;
    }

    if(NodeHasFlag(p, n, LabelledStatement)) {
        if(NodeHasFlag(p, n->right, FunctionDeclaration))  {
            PtrList* ret = PtrListNew(p->e);
            PtrListAdd(p->e, ret, n->right);
            return ret;
        }
    }
    return PtrListNew(p->e);
}




PtrList* LexicallyDeclaredNames(Parser* p, Node* n) {

    if(NodeHasFlag(p, n, FunctionStatementList)) {
        return TopLevelLexicallyDeclaredNames(p, n);
    }
    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s=n; s; s = s->right) {
            Node* st = s->left;
            if(NodeHasFlag(p, st, Declaration))
                PtrListCat(p->e, ret, BoundNames(p, st), TRUE);
            else if(NodeHasFlag(p, st, LabelledStatement))
                PtrListCat(p->e, ret, LexicallyDeclaredNames(p, st), TRUE);
            else if(NodeHasFlag(p, st, BlockStatement))
                PtrListCat(p->e, ret, LexicallyDeclaredNames(p, s->right), TRUE);
        }
        return ret;
    }
    if(NodeHasFlag(p, n, SwitchStatement)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* c = n->right; c; c = c->right) {
            Node* st = c->left->right;
            PtrListCat(p->e, ret, LexicallyDeclaredNames(p, st), TRUE);
        }
        return ret;
    }

    if(NodeHasFlag(p, n, LabelledStatement)) {
        if(NodeHasFlag(p, n->right, FunctionDeclaration)) 
            return BoundNames(p, n->right);
    }
    return NULL;
}


PtrList* TopLevelLexicallyDeclaredNames(Parser* p, Node* n) {
Node* GeneratorDeclaration(Parser* p, int start, uint32 flags);

    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s = n; s; s = s->right) {
            Node* st = s->left;
            if(NodeHasFlag(p, st, Declaration) && !NodeHasFlag(p, st, FunctionDeclaration) &&
                !NodeHasFlag(p, st, GeneratorDeclaration)) {
                PtrListCat(p->e, ret, BoundNames(p, st), TRUE);
            }
        }
        return ret;
    }
    return NULL;
}


PtrList* TopLevelLexicallyScopedDeclarations(Parser* p, Node* n) {

    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s = n; s ; s = s->right) {
            Node* st = s->left;
            if(NodeHasFlag(p, st, Declaration) && !NodeHasFlag(p, st, FunctionDeclaration) &&
                !NodeHasFlag(p, st, GeneratorDeclaration)) {
                PtrListAdd(p->e, ret, st);
            }
        }
        return ret;
    }
    return NULL;
}

PtrList* TopLevelVarDeclaredNames(Parser* p, Node* n) {

    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s = n; s ; s = s->right) {
            Node* st = s->left;
            if(NodeHasFlag(p, st, Statement)) {
                if(NodeHasFlag(p, st, LabelledStatement))
                    PtrListCat(p->e, ret, TopLevelVarDeclaredNames(p, st), TRUE);
                else
                    PtrListCat(p->e, ret, VarDeclaredNames(p, st), TRUE);
            }
            else if(NodeHasFlag(p, st, Declaration)) {
                if(NodeHasFlag(p, st, FunctionDeclaration))
                    PtrListCat(p->e, ret, BoundNames(p, st), TRUE);
                else if(NodeHasFlag(p, st, GeneratorDeclaration))
                    PtrListCat(p->e, ret, BoundNames(p, st), TRUE);
            }
        }
        return ret;
    }

    if(NodeHasFlag(p, n, LabelledStatement)) {
        if(NodeHasFlag(p, n->right, FunctionDeclaration))  {
            return BoundNames(p, n->right);
        }
        return TopLevelVarDeclaredNames(p, n->right);
    }

    return NULL;
}

PtrList* TopLevelVarScopedDeclarations(Parser* p, Node* n) {

    if(NodeHasFlag(p, n, StatementList)) {
        PtrList* ret = PtrListNew(p->e);
        for(Node* s = n; s; s = s->right) {
            Node* st = s->left;
            PtrListCat(p->e, ret, TopLevelVarScopedDeclarations(p, st), TRUE);
        }
        return ret;
    }    

    if(NodeHasFlag(p, n, FunctionDeclaration)) {
        PtrList* ret = PtrListNew(p->e);
        PtrListAdd(p->e, ret, n);
        return ret;
    }

    if(NodeHasFlag(p, n, GeneratorDeclaration)) {
        PtrList* ret = PtrListNew(p->e);
        PtrListAdd(p->e, ret, n);
        return ret;
    }

    if(NodeHasFlag(p, n, LabelledStatement)) {
        return TopLevelVarScopedDeclarations(p, n->right);
    }

    if(NodeHasFlag(p, n, Statement)) {
        return VarScopedDeclarations(p, n);
    }

    
    if(NodeHasFlag(p, n, LabelledItem)) {
        if(NodeHasFlag(p, n->right, Statement)) {
            if(NodeHasFlag(p, n->right, LabelledStatement))
                return TopLevelVarScopedDeclarations(p, n->right);
            return VarScopedDeclarations(p, n->right);
        }
        else if(NodeHasFlag(p, n->right, FunctionDeclaration)) {
            PtrList* ret = PtrListNew(p->e);
            PtrListAdd(p->e, ret, n->right);
            return ret;
        }
    }
    return NULL;

}

bool_t IsStrict(Parser* p, Node* n);
bool_t ReferencesSuper(Parser* p, Node* n);
Val* InstantiateFunctionObject(Parser* p, Node* code, Val* scope, uint32 flags) {
    Js* e = p->e;
    bool_t strict = (flags & PSTRICT) || IsStrict(p, code->left->right);
    Val* name = StringValue(p, code->left->left);
    Val* F = FunctionCreate(e, FUNC_NORMAL, code->right, code->left->right, scope, strict, NULL, p, code);
    Val* home = ValNew(e);
    if(ReferencesSuper(p, code))
        ValDel(e, MakeMethod(e, F, name, home));
    ValDel(e, MakeCons(e, F, NULL, NULL));
    ValDel(e, SetFunctionName(e, F, name, NULL));
    ValDel(e, home);
    ValDel(e, name);

    return F;        // @todo implement
}

Node* Constant(Parser* p, int start, uint32 flags);
void BlockDeclarationInstantiation(Parser* p, Node* code, uint32 flags, Val* env) {
    Js* e = p->e;

    Env* er = env->lex->envRec;
    PtrList* declarations = LexicallyScopedDeclarations(p, code);
    PtrList* functionsToInitialize = PtrListNew(e);
    if(declarations) {
        for(PtrItem* di=declarations->head; di; di = di->next) {
            Node* d = di->value;
            PtrList* bn = BoundNames(p, d);
            for(PtrItem* bi=bn->head; bi; bi = bi->next) {
                Node* dnl = bi->value;
                Val* dn = StringValue(p, dnl);
                if(NodeHasFlag(p, d, Constant)) 
                    ValDel(e, er->vtable->createImmutableBinding(e, er, dn));
                else {
                    Val* status = er->vtable->createMutableBinding(e, er, dn, FALSE);
                    assert(!ValIsAbrupt(e, status));
                    ValDel(e, status);
                }
                ValDel(e, dn);
            }
            if(NodeHasFlag(p, d, FunctionDeclaration) || NodeHasFlag(p, d, GeneratorDeclaration)) 
                PtrListAdd(e, functionsToInitialize, d);
            PtrListDel(e, bn);
        }
    }

    for(PtrItem* fi=functionsToInitialize->head; fi; fi = fi->next) {
        Node* f = fi->value;
        Val* fn = GetBoundName(p, f);
        Val* fo = InstantiateFunctionObject(p, f, env, flags);
        Val* status = env->env->vtable->initializeBinding(e, env->env, fn, fo);
        ValDel(e, status);
        ValDel(e, fo);
        ValDel(e, fn);
    }

    PtrListDel(e, functionsToInitialize);
    PtrListDel(e, declarations);
}


bool_t ValIsEmpty(Js* e, Val* v) {
    if(v->type == TYPE_COMP && v->completion->empty)
        return TRUE;
    return FALSE;
}

Val* ValGet(Js* e, Val* v) {
    if(v->type == TYPE_COMP)
        return v->completion->value;
    return v;
}

Val* EvalStatementList(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;

    Val* v = NULL;
    while(n) {
#ifdef JSE_DEBUG
        p->next = n->left->token;
        if(!DebuggerTick(p)) {
           return ThrowError(e, "debugger error", 0,0); 
        }
#endif
        Val* sl = Eval(p, n->left, flags);
        W(p, n->left, sl);        

        if(ValIsAbrupt(e, sl)) {
            ValDel(e, v);
            return sl;
        }

        // If the statement is an empty statement or block then
        // it should not affect the last result value (see Block.Return)
        if(!ValIsEmpty(e, sl)) {
            ValDel(e, v);
            v = GetValue(e, sl);
            W(p, n->left, v);        
        }
        ValDel(e, sl);

        n = n->right;
        if(!n)
            break;
    }
    if(!v)
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
    return v;
}

Val* EvalBlock(Parser* p, Node* n, uint32 flags) {
    if(!n->right)
        return ValNewCompU(p->e, COMP_NORMAL, NULL, NULL);
    Js* e = p->e;

    Val* oldEnv = e->currentContext->lex;
    Val* blockEnv = NewDeclEnv(e, oldEnv);
    BlockDeclarationInstantiation(p, n->right, flags, blockEnv);
    e->currentContext->lex = blockEnv;
    Val* blockValue = Eval(p, n->right, flags);
    e->currentContext->lex = oldEnv;
    ValDel(e, blockEnv);

    if(blockValue->type == TYPE_COMP && blockValue->completion->value == NULL) {
        ValDel(e, blockValue);
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
    }
    return blockValue;
}



Node* BindingIdentifier(Parser* p, int start, uint32 flags);
Node* BindingPattern(Parser* p, int start, uint32 flags);
//
// This is used to evaluate let, const, or var statements
// The main difference between var vs. let/const is that
// var will use undefined (NULL) as the environment which will 
// cause BindingInitialization() to use ResolveBinding
//  
Val* EvalLexicalDeclaration(Parser* p, Node* n, uint32 flags, bool_t undefEnv) {
    Js* e = p->e;
    bool_t isVar = undefEnv;
    
    n = n->right;
    while(n) {
        Node* l = n->left;
        Node* r = NULL;
        Val* v = NULL;
        Val* env = (undefEnv) ? NULL : p->e->currentContext->lex;

        if(NodeKeyword(p, n->left) == id_eq) {
            l = n->left->left;
            r = n->left->right;
        }
        if(NodeHasFlag(p, l, BindingIdentifier)) {
            if(r) {
                Val* rhs = Eval(p, r, flags);
                if(ValIsAbrupt(e, rhs))
                    return rhs;
                Val* value = GetValue(e, rhs);
                ValDel(e, rhs);
                if(ValIsAbrupt(e, value)) 
                    return value;
                if(IsAnonymousFunctionDefinition(p, r)) {
                    Val* strName = ValNewStrA(e, "name");
                    Val* hasNameProperty = HasOwnProp(e, value, strName);
                    ValDel(e, strName);
                    if(ValIsAbrupt(e, hasNameProperty))
                        return hasNameProperty;
                    if(hasNameProperty->type == TYPE_BOOL && hasNameProperty->b == FALSE) {
                        Val* sv = StringValue(p, l);
                        ValDel(e, SetFunctionName(e, value, sv, NULL));
                        ValDel(e, sv);
                    }
                    ValDel(e, hasNameProperty);
                }
                v = BindingInitialization(p, l, value, env, flags);
                ValDel(e, value);
            }
            else {
                bool_t set = TRUE;
                // VariableStatement - we don't initialize the value
                // to undefined if there is no initializer and it
                // is already initialized
                if(isVar) {
                    Val* name = StringValue(p, l);
                    Val* ref = ResolveBinding(e, name, flags);
                    set = RefIsUnresolvable(e, ref);
                    ValDel(e, name);
                    ValDel(e, ref);
                }
                if(set) {
                    Val* und = ValNew(e);
                    v = BindingInitialization(p, l, und, env, flags);
                    ValDel(e, und);
                }
            }
        }
        if(NodeHasFlag(p, l, BindingPattern)) {
            if(r) {
                Val* rhs = Eval(p, r, flags);
                Val* value = GetValue(e, rhs);
                ValDel(e, rhs);
                if(ValIsAbrupt(e, value)) 
                    return value;
                if(!ValIsObject(value)) {
                    ValDel(e, value);
                    v = ThrowTypeError(e, "not an object", 0,0);
                }
                v = BindingInitialization(p, l, value, env, flags);
                ValDel(e, value);
            }
        }
        if(ValIsAbrupt(p->e, v))
            return v;
        ValDel(e, v);
        n = n->right;
    }
    return ValNewCompU(p->e, COMP_NORMAL, NULL, NULL);
}


Val* EvalContinue(Parser* p, Node* n, uint32 flags) {
    if(!n->right) {
        return ValNewCompU(p->e, COMP_CONTINUE, NULL, NULL);
    }
    Val* v = StringValue(p, n->right);
    Val* ret = ValNewCompU(p->e, COMP_CONTINUE, NULL, v);
    ValDel(p->e, v);
    return ret;
}

Val* EvalBreak(Parser* p, Node* n, uint32 flags) {
    if(!n->right) {
        return ValNewCompU(p->e, COMP_BREAK, NULL, NULL);
    }
    Val* v = StringValue(p, n->right);
    Val* ret = ValNewCompU(p->e, COMP_BREAK, NULL, v);
    ValDel(p->e, v);
    return ret;
}

Val* EvalReturn(Parser* p, Node* n, uint32 flags) {
    Val* v;
    if(!n->right) 
        v = ValNew(p->e);
    else {
        v = Eval(p, n->right, flags);

        // Return can never return a reference since that
        // might introduce an environment reference back
        // to the caller on the function evironment which
        // is long since been destroyed
        Val* r = GetValue(p->e, v);
        ValDel(p->e, v);
        v = r;
    }

    if(ValIsAbrupt(p->e, v))
        return v;
    Val* ret = ValNewCompU(p->e, COMP_RETURN, v, NULL);
    ValDel(p->e, v);
    return ret;
}

Val* EvalWith(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    Val* ret = NULL, *v = NULL, *obj = NULL, *newEnv = NULL, *C = NULL;

    Val* oldEnv = e->currentContext->lex;
    v = Eval(p, n->left, flags);
    Val* v2 = GetValue(e, v);
    obj = ToObject(e, v2);
    ValDel(e, v2);
    RET_IF_AB(obj);
    newEnv = NewObjEnv(e, obj, oldEnv);
    ObjEnv* oe = (ObjEnv*) newEnv->lex->envRec;
    oe->withEnv = TRUE;
    e->currentContext->lex = newEnv;
    C = Eval(p, n->right, flags);
    RET_VAL(C);
exit:
    e->currentContext->lex = oldEnv;
    IFD(v);
    IFD(obj);
    IFD(newEnv);
    IFD(C);
    return ret;    
}


Val* EvalCaseClause(Parser* p, Node* c, uint32 flags) {
    Node* s = c->left->right;
    if(!s)
        return ValNewCompU(p->e, COMP_NORMAL, NULL, NULL);
    return EvalStatementList(p, s, flags);
}

Val* CaseSelectorEvaluation(Parser* p, Node* c, uint32 flags) {
    Val* exprRef = Eval(p, c->left->left, flags);
    Val* v = GetValue(p->e, exprRef);
    ValDel(p->e, exprRef);
    return v;
}

Val* CaseBlockEvaluation(Parser* p, Node* n, uint32 flags, Val* input) {
    Val* v = NULL, *clauseSelector=NULL;
    Val* r = NULL, *ret= NULL;
    Js* e = p->e;
    Node *a = NULL, *b = NULL, *d = NULL;

    // a = First find the case clauses before default
    // b = Find case clauses after default
    // d = default clause
    for(Node* c=n ; c; c = c->right) {
        if(NodeKeyword(p, c->left) == id_default) {
            d = c;
            b = c->right;
            break;
        }
        else {
            if(!a) a = c;
        }
    }

    bool_t found = FALSE;
    v = ValNew(e);
    for(Node* c = a; c && c != d; c = c->right) {
        if(!found) {
            clauseSelector = CaseSelectorEvaluation(p, c, flags);
            if(ValIsAbrupt(e, clauseSelector)) {
                if(ValIsEmpty(e, clauseSelector)) {
                    RET(ValNewCompU(e, clauseSelector->completion->type, NULL, 
                        clauseSelector->completion->target));
                }
                else
                    RET_VAL(clauseSelector);
            }
            found = ValIsTrueDel(e, StrictEquality(e, input, clauseSelector));
        }
        if(found) {
            r = EvalCaseClause(p, c, flags);
            if(!ValIsEmpty(e, r)) {
                IFZ(v);
                v = ValClone(e, ValGet(e, r));
            }
            if(ValIsAbrupt(e, r)) {
                RET(ValNewCompU(e, r->completion->type, v, r->completion->target));
            }
        }
        IFZ(clauseSelector);
        IFZ(r);
    }

    bool_t foundInB = FALSE;
    for(Node* c =b; c; c = c->right) {
        if(!foundInB) {
            clauseSelector = CaseSelectorEvaluation(p, c, flags);
            if(ValIsAbrupt(e, clauseSelector)) {
                if(ValIsEmpty(e, clauseSelector))
                    RET(ValNewCompU(e, clauseSelector->completion->type, NULL, clauseSelector->completion->target));
                RET_VAL(clauseSelector);
            }
            foundInB = ValIsTrueDel(e, StrictEquality(e, input, clauseSelector));
            if(foundInB) {
                r = EvalCaseClause(p, c, flags);
                if(!ValIsEmpty(e, r)) {
                    IFZ(v);
                    v = ValClone(e, ValGet(e, r));
                }
                if(ValIsAbrupt(e, r)) {
                    RET(ValNewCompU(e, r->completion->type, v, r->completion->target));
                }                
            }
        }
        IFZ(clauseSelector);
        IFZ(r);
    }
    if(foundInB)
        RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
    if(!d) 
        RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));

    r = EvalCaseClause(p, d, flags);
    if(!ValIsEmpty(e, r)) {
        ValDel(e, v);
        v = ValClone(e, ValGet(e, r));
        if(ValIsAbrupt(e, r)) {
            RET(ValNewCompU(e, r->completion->type, v, r->completion->target));
        }
    }
    RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));

exit:
    IFD(v);
    IFD(clauseSelector);
    IFD(r);
    return ret;
}

Val* EvalSwitch(Parser* p, Node* n, uint32 flags) {
    Val* exprRef = NULL, *switchValue = NULL, *blockEnv = NULL, *r=NULL;
    Val* ret = NULL;
    Js* e = p->e;

    exprRef = Eval(p, n->left, flags);
    switchValue = GetValue(e, exprRef);
    RET_IF_AB(switchValue);
    Val* oldEnv = e->currentContext->lex;
    blockEnv = NewDeclEnv(e, oldEnv);
    BlockDeclarationInstantiation(p, n->right, flags, blockEnv);
    r = CaseBlockEvaluation(p, n->right, flags, switchValue);
    e->currentContext->lex = oldEnv;
    RET_VAL(r);
exit:    
    IFD(exprRef);
    IFD(switchValue);
    IFD(blockEnv);
    IFD(r);
    return ret;
}

Node* BreakableStatement(Parser* p, int start, uint32 flags);
Val* LabelledEvaluation(Parser* p, Node* n, uint32 flags, PtrList* labelSet) {
    Val* stmtResult = NULL, *ret = NULL, *label = NULL;
    Js* e = p->e;

    Node* stmt = n->right;
    if(NodeHasFlag(p, stmt, FunctionDeclaration))
        return Eval(p, stmt, flags);

    if(NodeHasFlag(p, stmt, BreakableStatement)) {
        int k = NodeKeyword(p, stmt);
        switch(k) {
            case id_while:
                stmtResult = EvalWhile(p, stmt, flags, labelSet);
                break;
            case id_do:
                stmtResult = EvalDo(p, stmt, flags, labelSet);
                break;
            case id_for:
                stmtResult = EvalFor(p, stmt, flags, labelSet);
                break;
            default:
                assert(0);
        }
    }
    else if(NodeHasFlag(p, stmt, LabelledStatement)) {
        PtrListAdd(p->e, labelSet, stmt->left);
        stmtResult = LabelledEvaluation(p, stmt, flags, labelSet);
    }
    else {
        stmtResult = Eval(p, stmt, flags);
    }
    if(stmtResult->type == TYPE_COMP && stmtResult->completion->type == COMP_BREAK) {
        label = StringValue(p, labelSet->tail->value); // @todo: always last one?
        if(ValIsTrueDel(e, SameValue(e, stmtResult->completion->target, label)))
            RET(ValNewCompU(e, COMP_NORMAL, stmtResult->completion->value, NULL));
    }
    RET_VAL(stmtResult);

exit:
    IFD(stmtResult);
    IFD(label);
    return ret;    
}

Val* EvalColon(Parser* p, Node* n, uint32 flags) {
    if(!NodeHasFlag(p, n, LabelledStatement))
        return ThrowRefError(p->e, "not a labelled statement",0,0);

    PtrList* labelSet = PtrListNew(p->e);
    PtrListAdd(p->e, labelSet, n->left);
    Val* ret = LabelledEvaluation(p, n, flags, labelSet);
    PtrListDel(p->e, labelSet);
    return ret;
}

Val* EvalThrow(Parser* p, Node* n, uint32 flags) {
    Val* exprRef = Eval(p, n->left, flags);
    Val* exprValue = GetValue(p->e, exprRef);
    ValDel(p->e, exprRef);
    if(ValIsAbrupt(p->e, exprValue))
        return exprValue;
    Val* ret = ValNewCompU(p->e, COMP_THROW, exprValue, NULL);
    ValDel(p->e, exprValue);
    return ret;
}

Val* CatchBlockEvaluation(Parser* p, Node* n, uint32 flags, Val* value) {
    Val* catchEnv = NULL, *status = NULL, *b = NULL, *ret = NULL;
    PtrList* boundNames = NULL;
    Js* e = p->e;
    Val* oldEnv = e->currentContext->lex;
    catchEnv = NewDeclEnv(e, oldEnv);
    Env* ce = catchEnv->lex->envRec;
    boundNames = BoundNames(p, n->left->left);
    for(PtrItem* bi=boundNames->head; bi; bi = bi->next) {
        Val* argName = StringValue(p, bi->value);
        ValDel(e, ce->vtable->createMutableBinding(e, ce, argName, FALSE));
        ValDel(e, argName);
    }
    status = BindingInitialization(p, n->left->left, value, catchEnv, flags);
    RET_IF_AB(status);
    e->currentContext->lex = catchEnv;
    b = Eval(p, n->left->right, flags);
    e->currentContext->lex = oldEnv;
    RET_VAL(b);

exit:
    if(boundNames) PtrListDel(e, boundNames);
    IFD(catchEnv);
    IFD(status);
    IFD(b);
    return ret;    
}

bool_t ValThrow(Val* v) {
    if(v->type != TYPE_COMP)
        return FALSE;
    return (v->completion->type == COMP_THROW);
}

Val* EvalTry(Parser* p, Node* n, uint32 flags) {
    Val* b = NULL, *f = NULL, *c = NULL, *ret = NULL;
    Js* e = p->e;

    if(n->right->left && !n->right->right) {    // try Block catch Block
        b = Eval(p, n->left, flags);
        if(!ValThrow(b))
            RET_VAL(b);
        RET(CatchBlockEvaluation(p, n->right, flags, b->completion->value));
    }
    else if(!n->right->left && n->right->right) { // try Block Finally Block
        b = Eval(p, n->left, flags);
        f = Eval(p, n->right->right->left, flags);
        if(ValIsNormal(f))
            RET_VAL(b);
        RET_VAL(f);
    }
    else {  // try Block catch Block finally Block
        b = Eval(p, n->left, flags);
        if(ValThrow(b)) 
            c = CatchBlockEvaluation(p, n->right, flags, b->completion->value);
        else {
            IFZ(c);
            c = b;
            b = NULL;
        }
        f = Eval(p, n->right->right->left, flags);
        if(ValIsNormal(f))
            RET_VAL(c);
        RET_VAL(f);
        
    }

exit:
    IFD(b);
    IFD(f);
    IFD(c);
    return ret;    
}



Val* EvaluateBody(Js* e, Val* functionObject) {
    assert(functionObject->type == TYPE_OBJ);

    Node* code = (Node*) ObjectGetSlotPtr(e, functionObject, _Code_);
    if(!code)
        return ValNewCompU(e, COMP_NORMAL, NULL, NULL);

    Parser* p = (Parser*) ObjectGetSlotPtr(e, functionObject, _Parser_);
    assert(p);


    uint32 flags  = 0;
    Val* strict = (Val*) ObjectGetSlot(e, functionObject->obj, _Strict_);
    if(strict && strict->b)
        flags = PSTRICT;

//    Node* body = code->left->right;

    Val* result = Eval(p, code, flags);
    if(result->type == TYPE_COMP && result->completion->type == COMP_RETURN) {
        Val* ret = ValNewCompU(e, COMP_NORMAL, result->completion->value, NULL);
        ValDel(e, result);
        return ret;
    }
    if(ValIsAbrupt(e, result))
        return result;
    ValDel(e, result);
    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

Val* EvalFunction(Parser* p, Node* n, uint32 flags) {
    if(NodeHasFlag(p, n, FunctionDeclaration))
        return ValNewCompU(p->e, COMP_NORMAL, NULL, NULL);

    Js* e = p->e;
    bool_t strict = (flags & PSTRICT) || IsStrict(p, n->left->right);
    if(NodeHasFlag(p, n, IsStrict))
        strict = TRUE;
    if(!n->left->left) {
        Val* scope = e->currentContext->lex;
        Val* closure = FunctionCreate(e, FUNC_NORMAL, n->right, n->left->right, scope, strict, NULL,
            p, n);
        if(ReferencesSuper(p, n))
            ValDel(e, MakeMethod(e, closure, NULL, NULL));
        ValDel(e, MakeCons(e, closure, NULL, NULL));
        return closure;
    }
    Val* runningContext = e->currentContext->lex;
    Val* funcEnv = NewDeclEnv(e, runningContext);
    Val* name = StringValue(p, n->left->left);
    Env* envRec = funcEnv->lex->envRec;
    ValDel(e, envRec->vtable->createImmutableBinding(e, envRec, name));
    Val* closure = FunctionCreate(e, FUNC_NORMAL, n->right, n->left->right, funcEnv, strict, NULL, p, n);
    if(ReferencesSuper(p, n))
        ValDel(e, MakeMethod(e, closure, name, NULL));
    ValDel(e, MakeCons(e, closure, NULL, NULL));
    ValDel(e, SetFunctionName(e, closure, name, NULL));
    ValDel(e, envRec->vtable->initializeBinding(e, envRec, name, closure));
    ValDel(e, name);
    ValDel(e, funcEnv);
    Val* r = ValNewCompU(e, COMP_NORMAL, closure, NULL);
    ValDel(e, closure);
    return r;
}

Val* EvalExpression(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    Val* v = NULL;

    int type = NodeType(p, n);
    if(type == TOK_STRLIT || type == TOK_NUMLIT || type == TOK_IDENTIFIER
        || type == TOK_TEMPHEAD || type == TOK_TEMPLIT)
        return Eval(p, n,flags);
    
    int key = NodeKeyword(p,  n);
    switch(key) {
        case id_semi:   // EmptyStatement
            return ValNewCompU(e, COMP_NORMAL, NULL, NULL); 
        case id_comma:
            return EvalComma(p, n, flags);
        case id_typeof:
            return EvalTypeOf(p, n, flags);
        case id_void:
            return EvalVoid(p, n, flags);
        case id_not:
            return EvalNot(p, n, flags);
        case id_delete:
            return EvalDelete(p, n, flags);
        case id_plusplus:
            return EvalPlusPlus(p, n, flags);
        case id_minusminus:
            return EvalMinusMinus(p, n, flags);
        case id_tilde:
            return EvalTilde(p, n, flags);
        case id_new:
            return EvalNew(p, n, flags);
        case id_lpar:
            return EvalCall(p, n, flags);
        case id_lbracket:
            return EvalArray(p, n, flags);
        case id_lbrace:
            return EvalObject(p, n, flags);
        case id_true:
            return ValNewBool(e, TRUE);
        case id_false:
            return ValNewBool(e, FALSE);
        case id_null:
            return ValNewNull(e);
        case id_this:
            return ResolveThisBinding(e);
        case id_plus: 
            if(n->left == NULL)
                return EvalPrePlus(p, n, flags);
            return EvalAdd(p, n, flags);
        case id_lshift:
            return EvalLeftShift(p, n, flags);
        case id_rshift:
            return EvalSignedRightShift(p, n, flags);
        case id_rshifta:
            return EvalUnsignedRightShift(p, n, flags);
        case id_minus: 
            if(n->left == NULL)
                return EvalPreMinus(p, n, flags);
            return EvalSub(p, n, flags);
        case id_mult: 
            return EvalMultExpr(p, n, flags, MultOp);
        case id_div: 
            return EvalMultExpr(p, n, flags, DivOp);
        case id_mod: 
            return EvalMultExpr(p, n, flags, ModOp);
        case id_and:
            return EvalBitwise(p, n, flags, BITWISE_AND);
        case id_or:
            return EvalBitwise(p, n, flags, BITWISE_OR);
        case id_caret:
            return EvalBitwise(p, n, flags, BITWISE_XOR);
        case id_andand:
            return EvalLogicalAnd(p, n, flags);
        case id_oror:
            return EvalLogicalOr(p, n, flags);
        case id_lt: 
            return EvalLtGt(p, n, flags, TRUE);
        case id_gt: 
            return EvalLtGt(p, n, flags, FALSE);
        case id_lte: 
            return EvalLteGte(p, n, flags, FALSE);
        case id_gte: 
            return EvalLteGte(p, n, flags, TRUE);
        case id_instanceof:
            return EvalInstanceOf(p, n, flags);
        case id_in:
            return EvalIn(p, n, flags);
        case id_eqeq: 
            return EvalEquality(p, n, flags, FALSE, FALSE);
        case id_eqeqeq: 
            return EvalEquality(p, n, flags, TRUE, FALSE);
        case id_ne:
            return EvalEquality(p, n, flags, FALSE, TRUE);
        case id_neqeq:
            return EvalEquality(p, n, flags, TRUE, TRUE);
        case id_question:
            return EvalConditional(p, n, flags);
        case id_if:
            return EvalIf(p, n, flags);
        case id_do:
            return EvalDo(p, n, flags, NULL);
        case id_while:
            return EvalWhile(p, n, flags, NULL);
        case id_for:
            return EvalFor(p, n, flags, NULL);
        case id_rbrace:
            return EvalBlock(p, n, flags);
        case id_let:
        case id_const:
            return EvalLexicalDeclaration(p, n, flags | PSTRICT, FALSE);
        case id_var:
            return EvalLexicalDeclaration(p, n, flags, TRUE);
        case id_continue:
            return EvalContinue(p, n, flags);
        case id_break:
            return EvalBreak(p, n, flags);
        case id_return:
            return EvalReturn(p, n, flags);
        case id_with:
            return EvalWith(p, n, flags);
        case id_switch:
            return EvalSwitch(p, n, flags);
        case id_colon:
            return EvalColon(p, n, flags);
        case id_throw:
            return EvalThrow(p, n, flags);
        case id_try:
            return EvalTry(p, n, flags);
        case id_function:
            return EvalFunction(p, n, flags);
        case id_debugger:
        {
            Val* str =  ValNewStrA(e, "Debugger break");
            v = ValNewCompA(e, COMP_THROW, str, NULL);
            ValDel(e, str);
        }
        break;

        case id_dot: {
            v = EvalDot(p, n, flags);
        }
        break;

        case id_multeq:
        case id_diveq:
        case id_modeq:
        case id_pluseq:
        case id_minuseq:
        case id_lshifteq:
        case id_rshifteq:
        case id_rshiftaeq:
        case id_andeq:
        case id_oreq:
        case id_careteq:
            return EvalAssignmentOp(p, n, flags, key);

        case id_eq:
            return EvalAssignment(p, n, flags);
        // {
        //     Val* l = Eval(p, n->left, flags);
        //     if(ValIsAbrupt(e, l))
        //         return l;
        //     Val* r = Eval(p, n->right, flags);
        //     if(ValIsAbrupt(e, r)) {
        //         ValDel(e, l);
        //         return r;
        //     }
        //     Val* rv = GetValue(e, r);
        //     ValDel(e, r);
        //     Val* status = PutValue(e, l, rv);
        //     if(ValIsAbrupt(e, status)) {
        //         ValDel(e, l);
        //         ValDel(e, rv);
        //         return status;
        //     }
        //     ValDel(e, l);
        //     ValDel(e, status);
        //     v = rv;
        // }
        // break;
    }
    return v;
}

Val* _ValNewStrId(Js* e, Tokenizer* tk, int tok, int line) {
    int start = TkGetTokOffset(e, tk, tok);

    Token* t = VectorGet(e, tk->tokens, tok);
    assert(t);
    if(t->string >= 0 && t->type != TOK_KEYWORD && t->type != TOK_NUMLIT) {
        return ValNewStr(e, TkGetTokStr(e, tk, tok));
    }

    int len = TkGetTokLen(e, tk, tok);    
    Str* uc = StrNewLength(e, len);
    int i;
    for(i=0; i < len; i++)
        uc->chars[i] = tk->input[start+i];
    Val* v = _ValNew(e, line);
    v->type = TYPE_STR;
    v->str = uc;
    return v;
}

////// 15.1.8 Global Declaration Instantiation
Node* ForBinding(Parser* p, int start, uint32 flags);


void DefineGlobalProperty(Js* e, Val* global, char* name, Val* value) {
    Val* desc = ValNewDesc(e);
    Val* key = ValNewStrA(e, name);
    PropSetValue(e, desc->desc, value);
    PropSetWritable(e, desc->desc, TRUE);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, TRUE);
    Val* res = DefinePropOrThrow(e, global, key, desc);
    ValDel(e, res);
    ValDel(e, value);
    ValDel(e, desc);
    ValDel(e, key);
}


Val* GetArg(Js* e, Val* args, int index) {
    if(!args || args->type != TYPE_LIST)
        return ValNew(e);

    Val* ret = ListGetValue(e, args->list, index);
    if(!ret)
        ret = ValNew(e);
    return ret;
}

Val* isFinite(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *number = NULL, *num = NULL;

    number = GetArg(e, args, 0);
    num = ToNumber(e, number);
    RET_IF_AB(num);
    if(isnan(num->num) || num->num == +INFINITY || num->num == -INFINITY)
        RET(ValNewBool(e, FALSE));
    RET(ValNewBool(e, TRUE));

exit:
    IFD(number);
    IFD(num);
    return ret;
}


// CheckSpec
Val*  EvalDeclarationInstantiation(Parser* p, Node* body, Val* varEnv, Val* lexEnv, bool_t strict) {
    Js* e = p->e;
    PtrList *lexNames = NULL, *varNames = NULL, *varDeclarations = NULL, *lexDeclarations = NULL;
    Val *ret = NULL, *fn = NULL, *fo = NULL;
    Val *fnDefinable = NULL;
    PtrList *functionsToInitialize = NULL;
    List *declaredFunctionNames = NULL, *declaredVarNames = NULL;
    PtrList* boundNames = NULL;
    Val* vn = NULL, *status = NULL;
    uint32 flags = (strict) ? PSTRICT : 0;

    lexNames = LexicallyDeclaredNames(p, body);
    varNames = VarDeclaredNames(p, body);
    varDeclarations = VarScopedDeclarations(p, body);
    Env* lexEnvRec = lexEnv->lex->envRec;
    Env* varEnvRec = varEnv->lex->envRec;

    if(strict == FALSE) {
        if(varEnvRec->vtable == e->globalEnvMethods) {
            for(PtrItem* vi = varNames->head; vi; vi = vi->next) {
                Val* name = StringValue(p, vi->value);
                Val* result = varEnvRec->vtable->hasLexDecl(e, varEnvRec, name);
                IFZ(name);
                if(ValIsTrueDel(e, result)) 
                    RET(ThrowSyntaxError(e, 0, name, " not found"));
            }
        }
        // else if(varEnvRec->vtable == e->funcEnvMethods) {
        //     FuncEnv* fe = (FuncEnv*) varEnvRec;
        //     // Env* topLexEnvRec = fe->topLex; @todo: CheckSpec
        //     for(PtrItem* vi = varNames->head; vi; vi = vi->next) {
        //         Val* name = StringValue(p, vi->value);
        //         Val* result = topLexEnvRec->vtable->hasBinding(e, topLexEnvRec, name);
        //         IFZ(name);
        //         if(ValIsTrueDel(e, result)) 
        //             RET(ThrowSyntaxError(e));
        //     }            
        // }
    }

    functionsToInitialize = PtrListNew(e);
    declaredFunctionNames = ListNew(e);


    for(int count=PtrListCount(e, varDeclarations), i=count-1; i >= 0; i--) {
        Node* d = PtrListGet(e, varDeclarations, i);     // @todo: Very slow!!!
        if(!NodeHasFlag(p, d, VariableDeclaration) && !NodeHasFlag(p, d, ForBinding)) {
            assert(NodeHasFlag(p, d, FunctionDeclaration) || NodeHasFlag(p, d, GeneratorDeclaration));
            fn = GetBoundName(p, d);
            if(!ListHasValue(e, declaredFunctionNames, fn)) {
                if(varEnvRec->vtable == e->globalEnvMethods) {
                    fnDefinable = varEnvRec->vtable->canDeclGlobalFunc(e, varEnvRec, fn);
                    if(!ValIsTrueDel(e, fnDefinable))
                        RET(ThrowTypeError(e, "failed to define ", fn, 0));
                }
                ListAddValue(e, declaredFunctionNames, fn);
                PtrListPrepend(e, functionsToInitialize, d);
            }
            else
                IFZ(fn);
        }
    }    

    declaredVarNames = ListNew(e);
    for(PtrItem* vi=varDeclarations->head; vi; vi = vi->next) {
        Node* d = vi->value;
        boundNames = BoundNames(p, d);
        if(NodeHasFlag(p, d, VariableDeclaration) || NodeHasFlag(p, d, ForBinding)) {
            for(PtrItem* bi=boundNames->head; bi; bi = bi->next) {
                vn = StringValue(p, bi->value);
                if(!ListHasValue(e, declaredFunctionNames, vn)) {
                    if(varEnvRec->vtable == e->globalEnvMethods) {
                        Val* vnDefinable = varEnvRec->vtable->canDeclGlobalVar(e, varEnvRec, vn);
                        if(!ValIsTrueDel(e, vnDefinable)) 
                            RET(ThrowTypeError(e, "failed to define ", vn, 0));
                    }
                    if(!ListHasValue(e, declaredVarNames, vn))
                        ListAddValue(e, declaredVarNames, vn);
                    else
                        IFZ(vn);
                }
            }
        }
        PtrListDel(e, boundNames);
        boundNames = NULL;
    }
    lexDeclarations = LexicallyScopedDeclarations(p, body);
    for(PtrItem* li=lexDeclarations->head; li; li=li->next) {
        Node* d = li->value;
        boundNames = BoundNames(p, d);
        for(PtrItem* bi=boundNames->head; bi; bi=bi->next) {
            Val* dn = StringValue(p, bi->value);
            if(NodeHasFlag(p, d, Constant)) 
                status = lexEnvRec->vtable->createImmutableBinding(e, lexEnvRec, dn);
            else 
                status = lexEnvRec->vtable->createMutableBinding(e, lexEnvRec, dn, FALSE);
            RET_IF_AB(status);
            IFZ(status);
            IFZ(dn);
        }
        PtrListDel(e, boundNames);
        boundNames = NULL;
    }

    for(PtrItem* fi=functionsToInitialize->head; fi; fi = fi->next) {
        Node* f = fi->value;
        fn = GetBoundName(p, f);
        fo = InstantiateFunctionObject(p, f, lexEnv, flags);
        if(varEnvRec->vtable == e->globalEnvMethods) 
            status = varEnvRec->vtable->createGlobalFuncBinding(e, varEnvRec, fn, fo, TRUE);
        else {
            status = varEnvRec->vtable->createMutableBinding(e, varEnvRec, fn, TRUE);
            ValDel(e, status);
            status = varEnvRec->vtable->initializeBinding(e, varEnvRec, fn, fo);
        }
        RET_IF_AB(status);
        IFZ(status);
        IFZ(fo);
        IFZ(fn);
    }

    for(Item* vi=declaredVarNames->head; vi; vi=vi->next) {
        Val* vn = vi->value;
        if(varEnvRec->vtable == e->globalEnvMethods) {
            status = varEnvRec->vtable->createGlobalVarBinding(e, varEnvRec, vn, TRUE);
        }
        else {
            status = varEnvRec->vtable->createMutableBinding(e, varEnvRec, vn, TRUE);
        }
        RET_IF_AB(status);
        IFZ(status);
    }
    RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));

exit:
    IFD(vn);
    IFD(fn);
    IFD(fo);
    IFD(status);
    if(lexDeclarations) PtrListDel(e, lexDeclarations);
    if(boundNames) PtrListDel(e, boundNames);
    if(declaredVarNames) ListDel(e, declaredVarNames);
    if(declaredFunctionNames) ListDel(e, declaredFunctionNames);
    if(functionsToInitialize) PtrListDel(e, functionsToInitialize);
    if(varDeclarations) PtrListDel(e, varDeclarations);
    PtrListDel(e, lexNames);     // @todo: cache against body?
    PtrListDel(e, varNames);
    return ret;
}

Val* PerformEval(Js* e, Val* x, Realm* evalRealm, bool_t strictCaller, bool_t direct, char* file) {
    Val *lexEnv = NULL, *varEnv = NULL, *v = NULL, *result = NULL, *ret = NULL;
    Parser* p = NULL;
    Context* evalCxt = NULL;

    if(direct == FALSE) assert(strictCaller == FALSE);
    if(x->type != TYPE_STR)
        return ValClone(e, x);

    p = ParserNew(e);
    if(file)
        ParserSetFileName(p, file);

    // We need to clone and retain the string in the parser so that 
    // we can access tokens in functions that are defined during eval
    // but called long afterwards
    v = Parse(p, StrClone(e, x->str), TRUE,0);
    if(ValIsAbrupt(e, v)) 
        RET(ThrowSyntaxError(e, "eval failed",0,0));    
    IFZ(v);
    if(!p->root)
        RET(ValNew(e));

    Node* script = p->root;
    Node* body = script;
    bool_t strictEval = FALSE;
    if(strictCaller) 
        strictEval = TRUE;
    else
        strictEval = IsStrict(p, body);
    Context* ctx = e->currentContext;
    if(direct) {
        lexEnv = NewDeclEnv(e, ctx->lex);
        varEnv = ValClone(e, ctx->vars);
    }    
    else {
        lexEnv = NewDeclEnv(e, evalRealm->globalEnv);
        varEnv = ValClone(e, evalRealm->globalEnv);
    }
    if(strictEval) {
        ValDel(e, varEnv);
        varEnv = ValClone(e, lexEnv);
    }

    evalCxt = ContextNew(e, evalRealm, NULL, TRUE);
    evalCxt->vars = varEnv;
    evalCxt->lex = lexEnv;

    result = EvalDeclarationInstantiation(p, body, varEnv, lexEnv, strictEval);
    if(ValIsNormal(result)) {
        ValDel(e, result);
        result = EvalStatementList(p, body, (strictEval) ? PSTRICT : 0);
    }
    if(ValIsNormal(result) && ValIsEmpty(e, result)) {
        ValDel(e, result);
        result = ValNewCompU(e, COMP_NORMAL, NULL, NULL);
    }
    RET_VAL(result);

exit:
    if(p) ParserDel(p);
    IFD(v);
    IFD(result);
    // e->currentContext = ctx; context delete will take care of this
    ContextDelete(e, evalCxt);     // Will this delete the associated environments?
    return ret;
}

Val* eval(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* x = GetArg(e, args, 0);
    Realm* evalRealm = ObjectGetSlot(e, o->obj, _Realm_)->ptr;
    bool_t strictCaller = FALSE;
    bool_t directEval = FALSE;
    Val* ret = PerformEval(e, x, evalRealm, strictCaller, directEval, NULL);
    ValDel(e, x);
    return ret;
}

// Append two strings 
Val* StrAppend(Js* e, Val* s1, Val* s2) {
    Str* s = StrNewLength(e, s1->str->length + s2->str->length);
    memcpy(s->chars, s1->str->chars, s1->str->length*sizeof(uchar));
    memcpy(s->chars + s1->str->length, s2->str->chars, s2->str->length*sizeof(uchar));
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s;
    return v;
}

// Get the active folder
Val* GetActiveFolder(Js* e) {
    char* file = e->options.file;
    
    if(!file)
        return ValNewStrA(e, "");

    // No current file
    if(!file[0])
        return ValNewStrA(e, "");

    char* lastSlash = strstr(file, "/");
    if(!lastSlash)
        return ValNewStrA(e, "");
    char* nextSlash = strstr(lastSlash+1, "/");
    while(nextSlash) {
        lastSlash = nextSlash;
        nextSlash = strstr(lastSlash+1, "/");
    }

    // Create a string from the beginning of the string up to and 
    // including the last slash
    int len = (int) (lastSlash - file + 1);
    Str* s = StrNewLength(e, len);
    for(int i=0; i < len; i++)
        s->chars[i] = file[i];
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s;
    return v;
}

bool_t StrStartsWithA(Js* e, Str* s, char* match, bool_t ignoreCase, bool_t skipPrefixSpace) {
    uchar* cp = s->chars;
    if(skipPrefixSpace) {
        while(*cp == ' ') {
            cp++;
        }
    }

    while(*match) {
        if(ignoreCase) {
            char cl = tolower(*cp);
            char ml = tolower(*match);
            if(cl != ml) return FALSE;
        }
        else {
            if(*match != *cp)
                return FALSE;
        }
        match++;
        cp++;
    }
    return TRUE;
}


// Strip path information from a file
Val* ValStripPath(Js* e, Val* file) {
    if(file->type != TYPE_STR)
        return ValClone(e, file);

    int index = -1;
    for(int i=0; i < file->str->length; i++) {
        if(file->str->chars[i] == '/')
            index = i;
    }
    if(index < 0)
        return ValClone(e, file);
    int len = file->str->length - index - 1;
    Str* s = StrNewLength(e, len);
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s;
    for(int i=0; i < len; i++) 
        s->chars[i] = file->str->chars[index + i + 1];
    return v;
}

// Resolve the path for a file depending on whether a path specification
// is provided or whether local directory or last root file directory
// are used. 
Val* ResolvePath(Js* e, Val* file) {
    Val* ret = 0, *folder = 0;

    // Not a string handled by caller
    if(file->type != TYPE_STR)
        RET(ValClone(e, file));


    // Starts with a path, use full path
    if(StrStartsWithA(e, file->str, "/", FALSE, TRUE))
        RET(ValClone(e, file));

    // Root file has a folder, we append it
    folder = GetActiveFolder(e);

    // Append the file to the folder path
    RET(StrAppend(e, folder, file));

exit:
    IFD(folder);
    ValDel(e, file);
    return ret;
}

char* FileReadA(Js* e, const char* name);
Val* Utf8Decode(Js* e, uint8* string);
Val* require(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* file = GetArg(e, args, 0), *ret = 0;
    Val* source = 0; 
    char* name = 0;
    char* buff = 0;

    file = ResolvePath(e, file);
    if(file->type != TYPE_STR) 
        RET(ThrowTypeError(e, "string expected", 0,0));

    name = StrGetChars(e, file->str);
    buff = FileReadA(e, name);
    
    if(!buff) {
        char err[255];
        sprintf(err,"unable to open file %s", name);
        RET(ThrowTypeError(e, err, 0,0));
    }
    
    source = Utf8Decode(e, (uint8*) buff);
    Realm* evalRealm = ObjectGetSlot(e, o->obj, _Realm_)->ptr;
    DefineGlobalProperty(e, evalRealm->globalThis, "global", ValClone(e, evalRealm->globalThis));
    DefineGlobalProperty(e, evalRealm->globalThis, "exports", ValClone(e, evalRealm->globalThis));
    bool_t strictCaller = FALSE;
    bool_t directEval = FALSE;
    RET(PerformEval(e, source, evalRealm, strictCaller, directEval, name));
exit:
    IFD(file);
    if(name)
        hfree(e->memory[ST].data, name);
    IFD(source);
    if(buff)
        hfree(e->memory[ST].data, buff);
    return ret;
}



Val* parseFloat(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* a0 = NULL, *string = NULL, *ret = NULL;

    a0 = GetArg(e, args, 0);
    string = ToString(e, a0);
    RET_IF_AB(string);
    RET(ToNumber(e, string));
exit:
    IFD(a0);
    IFD(string);
    return ret;    
}

bool_t isRadix(uchar c, int radix) {
    char ch = tolower((char) c);
    if(ch >= '0' && ch <= '9')
        ch = ch - '0';
    else if(ch >= 'a' && ch <= 'z')
        ch = ch - 'a';

    if(ch >= radix)
        return FALSE;
    return TRUE;
}

int intValue(Js* e, Str* s, int radix) {
    int v = 0;
    int len = s->length;
    for(int i=0; i < len; i++) {
        int c = tolower(s->chars[i]);
        if(c >= '0' && c <= '9') 
            c = c - '0';
        else
            c = c - 'a'+10;

        v = v*radix + c;
    }
    return v;
}

Val* parseInt(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* a0 = NULL, *inputString = NULL, *ret = NULL, *r = NULL, *radix;
    DynStr* s = NULL, *z = NULL;

    a0 = GetArg(e, args, 0);
    radix = GetArg(e, args, 1);
    inputString = ToString(e, a0);
    RET_IF_AB(inputString);
    int sourceLen = inputString->str->length;
    s = DynStrNew(e, sourceLen);
    for(int i=0; i < sourceLen; i++) {
        uchar c = inputString->str->chars[i];
        if(!TkIsSpace(NULL, c))
            DynStrAdd(e, s, c);
    }
    int sign = 1;
    int start = 0;
    if(s->str->length && s->str->chars[0] == 0x2D)
        sign = -1;
    if(s->str->length && (s->str->chars[0] == 0x2D || s->str->chars[0] == 0x2b))
        start = 1;
    r = ToInt32(e, radix);
    RET_IF_AB(r);
    int ri = (int) r->num;
    bool_t stripPrefix = TRUE;
    if(ri != 0) {
        if(ri < 2 || ri > 36)
            RET(ValNewNum(e, NAN));
        if(ri != 16)
            stripPrefix = FALSE;
    }
    else 
        ri = 10;
    if(stripPrefix) {
        if(s->str->length > (2+start) && s->str->chars[start] == '0' &&
            (s->str->chars[start+1] == 'x' || s->str->chars[start+1] == 'X')) {
            start = start + 2;
            ri = 16;
        }
    }
    int len = s->str->length;
    z = DynStrNew(e, len-start);
    for(int i=start; i < len; i++) {
        uchar c = s->str->chars[i];
        if(!isRadix(c, ri))
            break;
        DynStrAdd(e, z, c);
    }
    if(z->str->length == 0)
        RET(ValNewNum(e, NAN));
    int mathInt = intValue(e, z->str, ri);
    number num = sign * mathInt;
    RET(ValNewNum(e, num));
    
exit:
    IFD(radix);
    IFD(r);
    if(z) DynStrDel(e, z);
    if(s) DynStrDel(e, s);
    IFD(a0);
    IFD(inputString);
    return ret;    
}

bool_t CharInSet(uchar c, char* set) {
    while(*set)
        if(c == *set++)
            return TRUE;
    return FALSE;
}

Val* DynStrToVal(Js* e, DynStr* ds) {
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = ds->str;
    ds->str = NULL;
    DynStrDel(e, ds);
    return v;
}

void Utf8RepToOctets(Js* e, uint32 v, uint8* octets, int* L) {
    // Range: 0x0000 - 0x007F Rep: 00000000 0zzzzzzz Octets: 0zzzzzzz
    uchar c1 = (v >> 16);
    uchar c2 = (v & 0xFFFF);
    if(c1 >= 0x0000 && c1 <= 0x007F) {
        uint8 z = c1 & 0x7F;
        octets[0] = z;
        *L  = 1;
    }
    // Range: 0x0080 - 0x07FF Rep: 00000yyy yyzzzzzz Octets:110yyyyy 10zzzzzz
    else if(c1 >= 0x0080 && c1 <= 0x07FF) {
        uint8 z = c1 & 0x3F;
        uint8 y = (c1 & 0x07C0) >> 6;
        octets[0] = 0xC0 | y;
        octets[1] = 0x80 | z;
        *L = 2;
    }
    // Range: 0x0800 - 0xD7FF  Rep: xxxxyyyy yyzzzzzz Octets:1110xxxx  10yyyyyy 10zzzzzz
    else if(c1 >= 0x800 && c1 <= 0xD7FF) {
        uint8 x = (c1 & 0xF000) >> 12;
        uint8 y = (c1 & 0x0FC0) >> 6;
        uint8 z = (c1 & 0x3F);
        octets[0] = 0xE0 | x;
        octets[1] = 0x80 | y;
        octets[2] = 0x80 | z;
        *L = 3;
    }
    // Range: 0xD800 - 0xDBFF 0xDC00  0xDFFF Rep: 110110vv vvwwwwxx 110111yy yyzzzzzz Octets: 11110uuu 10uuwwww 10xxyyyy 10zzzzzz
    else if(c1 >= 0xD800 && c1 <= 0xDBFF && c2 >= 0xDC00 && c2 <= 0xDFFF) {
        uint8 v = (c1 & 0x03C0) >> 6;
        uint8 w = (c1 & 0x003C) >> 2;
        uint8 x = (c1 & 0x0003);
        uint8 y = (c2 & 0x03C0) >> 6;
        uint8 z = (c2 & 0x003F);
        uint8 u = v + 1;
        octets[0] = 0xF0 | u;
        octets[1]  = 0x80 | u | w;
        octets[2] = 0x80 | x | y;
        octets[3] = 0x80 | z;
        *L = 4;
    }
    // 0xD800 - 0xDBFF not followed by 0xDC00  0xDFFF causes URIError
    else if( (c1 >= 0xD800 && c1 <= 0xDBFF) && !(c2 >= 0xDC00 && c2 <= 0xDFFF)) {
        *L = 0;
    }
    // 0xDC00  0xDFFF causes URIError
    else if(c1 >= 0xDC00 && c1 <= 0xDFFF) {
        *L = 0;
    }
    // Range: 0xE000 - 0xFFFF Rep: xxxxyyyy yyzzzzzz Octets: 1110xxxx 10yyyyyy 10zzzzzz
    else if(c1 >= 0xE000 && c1 <= 0xFFFF) {
        uint8 x = (c1 & 0xF000) >> 12;
        uint8 y = (c1 & 0x0FC0) >> 6;
        uint8 z = c1 & 0x3F;
        octets[0] = 0xE0 | x;
        octets[1] = 0x80 | y;
        octets[2] = 0x80 | z;
        *L = 3;
    }
}

uint32 Utf8OctetsToRep(Js* e, uint8* octets, int l) {
    // 0x0000 - 0x007F 0zzzzzzz <------ 0zzzzzzz
    if(l == 1) {
        uint8 z = octets[0] & 0x80;
        return z;
    }
    // 0x0080 - 0x07FF 00000yyy yyzzzzzz <------ 110yyyyy 10zzzzzz
    if(l == 2) {
        uint32 z = octets[1] & 0x3f;
        uint32 y = (octets[0] & 0x1f);
        return y << 6 | z;
     }
     
     // 0x0800 - 0xD7FF  xxxxyyyy yyzzzzzz  <------ 1110xxxx  10yyyyyy 10zzzzzz
     // 0xE000 - 0xFFFF  xxxxyyyy yyzzzzzz 1110xxxx  10yyyyyy 10zzzzzz
     if(l == 3) {
        uint32 z = octets[2] & 0x3f;
        uint32 y = octets[1] & 0x3f;
        uint32 x = octets[0] & 0x0f;
        return (x << 12) | (y << 6) | z;
     }
     uint32 u = octets[0] & 0x7;
     uint32 v = octets[1] & 0x3f;
     uint32 w = octets[2] & 0x3f;
     uint32 x = octets[3] & 0x3f;

     uint32 r = u << 18 | v << 12 | w << 6 | x;
     return r;
     // 0xD800 - 0xDBFF + 0xDC00  0xDFFF 110110vv vvwwwwxx + 110111yy yyzzzzzz 11110uuu 10uuwwww 10xxyyyy 10zzzzzz
     /*
     uint32 u = (octets[0] & 0x7) | (octets[1] & 0x30) >> 4;
     uint32 w = octets[1] & 0xf;
     uint32 x = (octets[2] & 0x30) >> 4;
     uint32 y = octets[2] & 0xf;
     uint32 z = octets[3] & 0x3f;
     uint32 v = u - 1;
     uint32 r1 = (v >> 2) | 0xd8;
     uint32 r2 = ((v & 0x3) << 6) | (w << 2) | x;
     uint32 r3 = 0xd8 | (y >> 2);
     uint32 r4 = ((y & 0x3) << 6) | z;
     return r1 << 24 | r2 << 16 | r3 << 8 | r4;
     */
}

// 18.2.6.1.1
Val* Encode(Js* e, Str* string, char* unescapedSet) {
    int strLen = string->length;
    DynStr* R = DynStrNew(e, strLen);
    int k = 0;
    while(TRUE) {
        if(k == strLen) 
            return DynStrToVal(e, R);
        uchar c = string->chars[k];
        if(CharInSet(c, unescapedSet)) {
            DynStrAdd(e, R, c);
            k++;
            continue;
        }
        
        if( c >= 0xD800 && c <= 0xDFFF) {
            DynStrDel(e, R);
            return ThrowURIError(e, "encode error code must be between 0xd800 and 0xdfff",0,0);
        }
        uint32 v;

        if( c < 0xD800 || c > 0xDBFF)
            v = c << 16;
        else {
            k++;
            if(k == strLen) {
                DynStrDel(e, R);
                return ThrowURIError(e, "failed to encode", 0,0);
            }
            uchar kChar = string->chars[k];
            if(kChar < 0xDC00 || kChar > 0xDFFF) {
                DynStrDel(e, R);
                return ThrowURIError(e, "character must be between 0xdc00 and 0xdfff",0,0);
            }
            v = (c - 0xD800) * 0x400 + (kChar - 0xDC00) + 0x10000;
        }
        int L = 0;
        uint8 octlets[6];
        Utf8RepToOctets(e, v, octlets, &L);
        int j = 0;
        while(j < L) {
            uint8 jOctlet = octlets[j];
            char buff[10];
            sprintf(buff, "%%%02X", jOctlet);
            DynStrAdd(e, R, buff[0]);
            DynStrAdd(e, R, buff[1]);
            DynStrAdd(e, R, buff[2]);
            j++;
        }
        k++;
    }
}

Val* Decode(Js* e, Str* string, char* reservedSet) {
    int strLen = string->length;
    DynStr* R = DynStrNew(e, strLen);
    int k = 0;
    while(TRUE) {
        if(k == strLen)
            return DynStrToVal(e, R);
        uchar c = string->chars[k];
        if(c != '%') {
            DynStrAdd(e, R, c);
            k++;
            continue;
        }
        int start = k;
        if(k+2 >= strLen) {
            DynStrDel(e, R);
            return ThrowURIError(e, "decode error end reached", 0, 0);
        }
        uchar h1 = string->chars[k+1];
        uchar h2 = string->chars[k+2];
        if(!TkIsHexDigit(h1) || !TkIsHexDigit(h2)) {
            DynStrDel(e, R);
            return ThrowURIError(e, "decode not a hex digit", 0, 0);
        }
        uint8 b = TkHexVal(h1) << 4 | TkHexVal(h2);
        if( (b & 0x80) == 0)  { // MSB == 0
            c = b;
            if(!CharInSet(c, reservedSet)) {
                DynStrAdd(e, R, c);
            }
            else {
                for(int i = start; i <= k; i++) {
                    DynStrAdd(e, R, string->chars[i]);
                }
            }
            k += 3;
            continue;
        }
        int n = 6;
        for(uint8 N=5; N >=1; N--) {
            if(((b << N) & 0x80) == 0) {
                if(N < n)
                    n = N;
            }
        }
        if(n == 1 || n > 4) {
            DynStrDel(e, R);
            return ThrowURIError(e, "decode error octets not between 2 and 4", 0, 0);
        }
        uint8 octets[4];
        octets[0] = b;
        if((k + 3*(n-1)) >= strLen) {
            DynStrDel(e, R);
            return ThrowURIError(e, "decode error end reached", 0,0);
        }
        k += 2;
        int j = 1;
        while(j < n) {
            k++;
            uchar c = string->chars[k];
            if(c != '%') {
                DynStrDel(e, R);
                return ThrowURIError(e, "%% expected", 0, 0);
            }
            uint8 h1 = string->chars[k+1];
            uint8 h2 = string->chars[k+2];
            if(!TkIsHexDigit(h1) || !TkIsHexDigit(h2)) {
                DynStrDel(e, R);
                return ThrowURIError(e, "not a hex digit", 0, 0);
            }
            uint8 b = TkHexVal(h1) << 4 | TkHexVal(h2);
#ifdef CHECKTHIS
            if( (b & 0x80) == 0 || (b & 40) != 0) {
                DynStrDel(e, R);
                return ThrowURIError(e);
            }
#endif
            k += 2;
            octets[j] = b;
            j++;
        }
        uint32 v = Utf8OctetsToRep(e, octets, j);
        if(v < 0x10000) {
            uchar c = (uchar) v;
            if(!CharInSet(c, reservedSet)) {
                DynStrAdd(e, R, c);
            }
            else {
                for(int i=start; i <=k ; i++) {
                    DynStrAdd(e, R, string->chars[i]);
                }
            }
        }
        else {
            uchar L = (((v - 0x10000) & 0x3FF) + 0xDC00);
            uchar H = ((((v - 0x10000) >> 10) & 0x3FF) + 0xD800);
            DynStrAdd(e, R, H);
            DynStrAdd(e, R, L);
        }
        k++;
    }
}



//
// Input is a byte array, output is a string with 16 bit codepoints and all 
// UTF content property encoded into pairs
Val* Utf8Decode(Js* e, uint8* string) {
    int strLen = (int) strlen((char*) string);
    DynStr* R = DynStrNew(e, strLen);
    int k = 0;
    while(TRUE) {
        if(k == strLen)
            return DynStrToVal(e, R);
        uint8 b = string[k];
        if( (b & 0x80) == 0)  { // MSB == 0
            DynStrAdd(e, R, b);
            k++;
            continue;
        }
        int n = 6;
        for(uint8 N=5; N >=1; N--) {
            if(((b << N) & 0x80) == 0) {
                if(N < n)
                    n = N;
            }
        }
        if(n == 1 || n > 4) {
            DynStrDel(e, R);
            return ThrowURIError(e, "decode expecting 2 to 4 octets",0,0);
        }
        uint8 octets[4];
        octets[0] = b;
        if((k + (n-1)) >= strLen) {
            DynStrDel(e, R);
            return ThrowURIError(e, "decode end reached",0,0);
        }
        k++;
        int j = 1;
        while(j < n) {
            b = string[k];
            octets[j] = b;
            k++;
            j++;
        }
        uint32 v = Utf8OctetsToRep(e, octets, j);
        if(v < 0x10000) {
            uchar c = (uchar) v;
            DynStrAdd(e, R, c);
        }
        else {
            uint32 L = (((v - 0x10000) & 0x3FF) + 0xDC00);
            uint32 H = ((((v - 0x10000) >> 10) & 0x3FF) + 0xD800);
            DynStrAdd(e, R, H);
            DynStrAdd(e, R, L);
        }
    }
}

Val* decodeURI(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* encodedURI = GetArg(e, args, 0);
    Val* ret = NULL;
    Val* uriString = ToString(e, encodedURI);
    RET_IF_AB(uriString);
    ret = Decode(e, uriString->str, ";/?:@&=+$,#");
exit: 
    IFD(encodedURI);
    IFD(uriString);
    return ret;
}


Val* decodeURIComponent(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* encodedURIComponent = GetArg(e, args, 0);
    Val* ret = NULL;
    Val* componentString = ToString(e, encodedURIComponent);
    RET_IF_AB(componentString);
    ret = Decode(e, componentString->str, "");
exit: 
    IFD(encodedURIComponent);
    IFD(componentString);
    return ret;
}

Val* encodeURI(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* uri = GetArg(e, args, 0);
    Val* ret = NULL;
    Val* uriString = ToString(e, uri);
    RET_IF_AB(uriString);
    ret = Encode(e, uriString->str, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_.!~*'();/?:@&=+$,#%");
exit:
    IFD(uri);
    IFD(uriString);    
    return ret;
}


Val* encodeURIComponent(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {    
    Val* uriComponent = GetArg(e, args, 0);
    Val* ret = NULL;
    Val* componentString = ToString(e, uriComponent);
    RET_IF_AB(componentString);
    ret = Encode(e, componentString->str, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_.!~*'()");
exit:
    IFD(uriComponent);
    IFD(componentString);    
    return ret;
}

bool_t NewTargetIsActiveFunction(Js* e, Val* f, Val* newTarget) {
    if(!newTarget)
        return FALSE;
    if(newTarget->type == TYPE_OBJ && newTarget->obj == f->obj)
        return TRUE;
    return FALSE;
}

Val* ObjectConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret=0, *value = GetArg(e, args, 0);

    if(!ValIsUndef(newTarget) && !NewTargetIsActiveFunction(e, o, newTarget))
        RET(OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->objectPrototype, NULL));
    if(ValIsNull(value) || ValIsUndef(value))
        RET(ObjectCreate(e, CurrentRealm(e)->objectPrototype, NULL));
    RET(ToObject(e, value));

exit:
    IFD(value);
    return ret;
}



Val* ConsCall(Js* e, Val* o, Val* args) {
    Val* F = o;
    return DoCall(e, F, NULL, args);
}


Val* Object_assign(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *target = NULL, *to = NULL, *sources = NULL, *from = NULL;
    Val* keys = NULL, *pendingException = NULL;
    target = GetArg(e, args, 0);
    to = ToObject(e, target);
    RET_IF_AB(to);
    if(args->list->count == 1)
        RET_VAL(to);

    for(Item* i = args->list->head->next; i; i = i->next) {
        Val* nextSource = i->value;
        from = ToObject(e, nextSource);
        RET_IF_AB(from);
        keys = DoOwnPropertyKeys(e, from);
        RET_IF_AB(keys);

        while(TRUE) {
            Val* result = IteratorNext(e, keys, NULL);
            Val* done = IteratorComplete(e, result);
            if(!ValIsTrueDel(e, done)) {
                Val* nextKey = IteratorValue(e, result);
                ValDel(e, result);
                Val* desc = DoGetOwnProperty(e, from, nextKey);
                if(ValIsAbrupt(e, desc)) {
                    if(!pendingException)
                        pendingException = ValClone(e, desc);
                }
                else {
                    if(!ValIsUndef(desc) && PropIsEnumerable(e, desc->desc)) {
                        Val* propValue = Get(e, from, nextKey);
                        if(ValIsAbrupt(e, propValue)) {
                            if(!pendingException)
                                pendingException = ValClone(e, propValue);                            
                        }
                        else {
                            Val* status = Put(e, to, nextKey, propValue, TRUE);
                            if(ValIsAbrupt(e, status)) {
                                if(!pendingException)
                                    pendingException = ValClone(e, status);
                            }
                            ValDel(e, status);
                        }
                        ValDel(e, propValue);
                    }
                }
                ValDel(e, nextKey);
                ValDel(e, desc);
            }
            else {
                ValDel(e, result);            
                break;
            }
        }
        if(pendingException) 
            RET_VAL(pendingException);
        IFZ(from);
        IFZ(keys);
    }
    RET_VAL(to);
exit:
    IFD(target);
    IFD(sources);
    IFD(to);
    IFD(from);
    IFD(keys);
    IFD(pendingException);
    return ret;    
}

Val* ObjectDefineProperties(Js* e, Val* o, Val* properties) {
    Val* ret = NULL, *props = NULL, *keys = NULL;
    Val* propDesc = NULL, *descObj = NULL, *result = NULL, *done = NULL, *nextKey = NULL;
    List* descList = NULL, *keyList = NULL;
    Val* desc = NULL, *pendingException = NULL;

    if(!ValIsObject(o))
        RET(ThrowTypeError(e, "not an object", 0, 0));
    props = ToObject(e, properties);
    keys = DoOwnPropertyKeys(e, props);
    RET_IF_AB(keys);
    descList = ListNew(e);
    keyList = ListNew(e);

    while(TRUE) {
        result = IteratorNext(e, keys, NULL);
        done = IteratorComplete(e, result);
        if(ValIsTrueDel(e, done))
            break;
        nextKey = IteratorValue(e, result);
        IFZ(result);
        propDesc = DoGetOwnProperty(e, props, nextKey);
        RET_IF_AB(propDesc);
        if(!ValIsUndef(propDesc) && PropIsEnumerable(e, propDesc->desc)) {
            descObj = Get(e, props, nextKey);
            RET_IF_AB(descObj);
            desc = ToPropertyDesc(e, descObj);
            RET_IF_AB(desc);
            IFZ(descObj);
            ListAddValue(e, keyList, nextKey);
            ListAddValue(e, descList, desc);
            desc = NULL;
            nextKey = NULL;
        }
        IFZ(propDesc);
    }
    pendingException = NULL;
    for(Item* k = keyList->head, *d = descList->head; k; k = k->next, d = d->next) {
        Val* status = DefinePropOrThrow(e, o, k->value, d->value);
        if(ValIsAbrupt(e, status) && !pendingException)
            pendingException = status;
        else
            ValDel(e, status);
    }
    if(pendingException)
        RET_VAL(pendingException)
    else
        ret = ValClone(e, o);
exit:
    IFD(nextKey);
    IFD(result);
    IFD(descObj);
    IFD(propDesc);
    IFD(desc);
    IFD(props);
    IFD(keys);
    if(descList) ListDel(e, descList);
    if(keyList) ListDel(e, keyList);
    IFD(pendingException);
    return ret;    
}

Val* Object_create(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* obj = NULL, *properties = NULL;
    Val* ret = NULL;
    if(!ValIsObject(o))
        RET(ThrowTypeError(e, "not an object", 0, 0));
    obj = ObjectCreate(e, o, NULL);
    if(args->list->count > 1)
        properties = GetArg(e, args, 1);
    if(!ValIsUndef(properties)) 
        ret = ObjectDefineProperties(e, obj, properties);
    else
        RET_VAL(obj);
exit:
    IFD(o);
    IFD(obj);
    IFD(properties);
    return ret;    
}

Val* Object_defineProperties(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* obj = GetArg(e, args, 0);
    Val* properties = GetArg(e, args, 1);
    Val* ret = ObjectDefineProperties(e, obj, properties);
    ValDel(e, obj);
    ValDel(e, properties);
    return ret;
}

Val* Object_defineProperty(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* p = GetArg(e, args, 1);
    Val* attributes = GetArg(e, args, 2);
    Val* ret = NULL, * key = NULL, *desc = NULL, *success = NULL;
    if(!ValIsObject(o))
        RET(ThrowTypeError(e, "not an object", 0,0));
    key = ToPropKey(e, p);
    RET_IF_AB(key);
    desc = ToPropertyDesc(e, attributes);
    RET_IF_AB(desc);
    success = DefinePropOrThrow(e, o, key, desc);
    RET_IF_AB(success);
    ret = ValClone(e, o);
exit:
    IFD(desc);
    IFD(success);
    IFD(key);
    IFD(o);
    IFD(p);
    IFD(attributes);    
    return ret;
}


Val* Object_freeze(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* status = NULL, *ret = NULL;
    if(!ValIsObject(o))
        RET(ThrowTypeError(e, "not an object", 0, 0));
    status = SetIntegrityLevel(e, o, e->strFrozen);
    RET_IF_AB(status);
    if(!ValIsTrue(e, status))
        RET(ThrowTypeError(e, "failed to freeze", 0, 0));
    ret = ValClone(e, o);
exit:
    IFD(o);
    IFD(status);    
    return ret;
}

Val* Object_getOwnPropertyDescriptor(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0), *p = GetArg(e, args, 1), *desc = NULL, *ret = NULL;
    Val* obj = ToObject(e, o), *key = NULL;
    RET_IF_AB(obj);
    key = ToPropKey(e, p);
    RET_IF_AB(key);
    desc = DoGetOwnProperty(e, obj, key);
    RET_IF_AB(desc);
    ret = FromPropertyDesc(e, desc);
exit:
    IFD(o);
    IFD(p);
    IFD(obj);
    IFD(key);
    IFD(desc);
    return ret;
}

Val* GetOwnPropertyKeys(Js* e, Val* o, bool_t string) {
    Val* obj = NULL, *keys = NULL, *ret = NULL;
    List* nameList = NULL;
    Val *result = NULL;
    uint8 type = (string)? TYPE_STR : TYPE_SYMA;
    Val* nameListVar = NULL;
    obj = ToObject(e, o);
    RET_IF_AB(obj);
    keys = DoOwnPropertyKeys(e, obj);
    RET_IF_AB(keys);

    // #521 in the process of implementing IntegerIndexedOwnPropertyKeys, the new spec
    //      shows it returning a list and not an iterable object. As a result, 
    //      we can change GetOwnPropertyKeys to support objects which will return 
    //      a list directly
    if(keys->type == TYPE_LIST)
        RET(CreateArrayFromList(e, keys));

    nameList = ListNew(e);
    while(TRUE) {
        result = IteratorNext(e, keys, NULL);
        Val* done = IteratorComplete(e, result);
        if(ValIsTrueDel(e, done))
            break;
        Val* nextKey = IteratorValue(e, result);
        IFZ(result);
        if(nextKey->type == type) 
            ListAddValue(e, nameList, nextKey);
        else
            ValDel(e, nextKey);
    }

    nameListVar = ValNewList(e, nameList);
    ret = CreateArrayFromList(e, nameListVar);

exit:    
    IFD(result);
    IFD(nameListVar);
    IFD(obj);
    IFD(keys);
    return ret;
}

Val* Object_getOwnPropertyNames(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = GetOwnPropertyKeys(e, o, TRUE);
    ValDel(e, o);
    return ret;
}

Val* Object_getOwnPropertySymbols(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = GetOwnPropertyKeys(e, o, FALSE);
    ValDel(e, o);
    return ret;
}

Val* Object_getPrototypeOf(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* obj = ToObject(e, o);
    Val* ret = NULL;
    RET_IF_AB(obj);
    ret = DoGetPrototypeOf(e, obj);

exit:
    IFD(o);
    IFD(obj);
    return ret;
}

Val* Object_is(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* value1 = GetArg(e, args, 0);
    Val* value2 = GetArg(e, args, 1);
    Val* ret = SameValue(e, value1, value2);
    ValDel(e, value1);
    ValDel(e, value2);
    return ret;
}

Val* Object_isExtensible(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = NULL;
    if(!ValIsObject(o)) 
        ret = ValNewBool(e, FALSE);
    else
        ret = DoIsExtensible(e, o);
    ValDel(e, o);
    return ret;
}

Val* Object_isFrozen(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = NULL;
    if(!ValIsObject(o)) 
        ret = ValNewBool(e, TRUE);
    else
        ret = TestIntegrityLevel(e, o, e->strFrozen);
    ValDel(e, o);
    return ret;
}

Val* Object_isSealed(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = NULL;
    if(!ValIsObject(o)) 
        ret = ValNewBool(e, TRUE);
    else
        ret = TestIntegrityLevel(e, o, e->strSealed);
    ValDel(e, o);
    return ret;
}

Val* EnumerableOwnNames(Js* e, Val* o) {
    Val* ret = NULL;
    assert(o->type == TYPE_OBJ);
    Val* ownKeys = DoOwnPropertyKeys(e, o);
    Val *desc = NULL, *key = NULL, *result = NULL;
    Val *done = NULL;
    List* names = NULL;
    RET_IF_AB(ownKeys);
    names = ListNew(e);
    while(TRUE) {
        result = IteratorNext(e, ownKeys, NULL);
        done = IteratorComplete(e, result);
        if(ValIsTrueDel(e, done))
            break;
        key = IteratorValue(e, result);
        IFZ(result);
        if(key->type == TYPE_STR) {
            desc = DoGetOwnProperty(e, o, key);
            RET_IF_AB(desc);
            if(!ValIsUndef(desc)) {
                if(PropIsEnumerable(e, desc->desc))
                    ListAddValue(e, names, key);
                else
                    IFZ(key);
            }
            IFZ(desc);
        }
        else
            IFZ(key);
        IFZ(result);
    }
    ret = ValNewList(e, names);  
    names = NULL;

exit:
    if(names) ListDel(e, names);
    IFD(result);
    IFD(key);
    IFD(desc);
    IFD(ownKeys);
    return ret;    

}

Val* Object_keys(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = NULL;
    Val* obj = ToObject(e, o);
    Val* nameList = NULL;
    RET_IF_AB(obj);
    nameList = EnumerableOwnNames(e, obj);
    ret = CreateArrayFromList(e, nameList);
exit:
    IFD(nameList);
    IFD(o);    
    IFD(obj);
    return ret;
}

Val* Object_preventExtensions(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* ret = NULL, *status = NULL;
    if(!ValIsObject(o)) 
        RET_VAL(o);

    status = DoPreventExtensions(e, o);
    RET_IF_AB(status);
    if(!status)
        RET(ThrowTypeError(e, "failed to prevent extensions",0,0));
    RET_VAL(o);
exit:
    IFD(o);
    IFD(status);    
    return ret;
}


Val* Object_seal(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = GetArg(e, args, 0);
    Val* status = NULL, *ret = NULL;
    if(!ValIsObject(o))
        RET_VAL(o);
    status = SetIntegrityLevel(e, o, e->strSealed);
    RET_IF_AB(status);
    if(!ValIsTrue(e, status))
        RET(ThrowTypeError(e, "failed to seal", 0, 0));
    RET_VAL(o);
exit:
    IFD(o);
    IFD(status);    
    return ret;
}

Val* Object_setPrototypeOf(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *a0 = NULL, *o = NULL, *status = NULL, *proto = NULL;

    a0 = GetArg(e, args, 0);
    proto = GetArg(e, args, 1);
    o = RequireObjectCoercible(e, a0);
    RET_IF_AB(o);
    if(proto->type != TYPE_NULL && proto->type != TYPE_OBJ) 
        RET(ThrowTypeError(e, "prototype not null or an object",0,0));
    status = DoSetPrototypeOf(e, o, proto);
    RET_IF_AB(status);
    if(!ValIsTrue(e, status))
        RET(ThrowTypeError(e, "failed to set prototype",0,0));
    RET_VAL(o);
    
exit:
    IFD(a0);
    IFD(proto);
    IFD(o);
    IFD(status);
    return ret;    
}


NativeMethod Object_methods[] = {
    { "assign", Object_assign, 2},
    { "create", Object_create, 2},
    { "defineProperties", Object_defineProperties, 2},
    { "defineProperty", Object_defineProperty, 3},
    { "freeze", Object_freeze, 1},
    { "getOwnPropertyDescriptor", Object_getOwnPropertyDescriptor, 2},
    { "getOwnPropertyNames", Object_getOwnPropertyNames, 1},
    { "getOwnPropertySymbols", Object_getOwnPropertySymbols, 1},
    { "getPrototypeOf", Object_getPrototypeOf, 1},
    { "is", Object_is, 1},
    { "isExtensible", Object_isExtensible, 1},
    { "isFrozen", Object_isFrozen, 1},
    { "isSealed", Object_isSealed, 1},
    { "keys", Object_keys, 1},
    { "preventExtensions", Object_preventExtensions, 1},
    { "seal", Object_seal, 1},
    { "setPrototypeOf", Object_setPrototypeOf, 2}
};

Val* Object_prototype_hasOwnProperty(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* v = NULL, *o = NULL, *p = NULL, *ret = NULL;
    v = GetArg(e, args, 0);
    p = ToPropKey(e, v);
    RET_IF_AB(p);
    o = ToObject(e, othis);
    RET_IF_AB(o);
    RET(HasOwnProp(e, o, p));

exit:
    IFD(v);
    IFD(o);
    IFD(p);
    return ret;    
}

Val* Object_prototype_isPrototypeOf(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *v = GetArg(e, args, 0), *o = NULL;
    if(!ValIsObject(v)) 
        RET(ValNewBool(e, FALSE));

    o = ToObject(e, othis);
    RET_IF_AB(o);
    while(TRUE) {
        Val* temp = DoGetPrototypeOf(e, v);
        IFZ(v);
        v = temp;
        if(ValIsNull(v))
            RET(ValNewBool(e, FALSE));
        if(ValIsTrueDel(e, SameValue(e, o, v)))
            RET(ValNewBool(e, TRUE));
    }

exit:
    IFD(o);
    IFD(v);
    return ret;    
}

Val* Object_prototype_proeprtyIsEnumerable(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *v = GetArg(e, args, 0), *p = NULL, *desc = NULL, *o = NULL;

    p = ToPropKey(e, v);
    RET_IF_AB(p);
    o = ToObject(e, othis);
    RET_IF_AB(o);
    desc = DoGetOwnProperty(e, o, p);
    RET_IF_AB(desc);
    if(ValIsUndef(desc))
        RET(ValNewBool(e, FALSE));
    if(PropIsEnumerable(e, desc->desc))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));

exit:
    IFD(o);
    IFD(v);
    IFD(p);
    IFD(desc);
    return ret;    
}

Val* Object_prototype_toLocaleString(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* p = ValNewStrA(e, "toString");
    Val* ret = Invoke(e, othis, p, NULL);
    ValDel(e, p);
    return ret;
}

Val* Object_prototype_toString(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* o = NULL, *ret = NULL, *tag = NULL;
    if(ValIsUndef(othis))
        RET(ValNewStrA(e, "[object Undefined]"));
    if(ValIsNull(othis))
        RET(ValNewStrA(e, "[object Null]"));
    o = ToObject(e, othis);
    char* builtinTag;
    if(IsArray(e, o))
        builtinTag = "Array";
    else if(IsString(e, o))
        builtinTag = "String";
    else if(ObjectGetSlotRef(e, o->obj, _ParameterMap_))
        builtinTag = "Arguments";
    else if(ObjectGetMethodRef(e, o->obj, _Call_))
        builtinTag = "Function";
    else if(ObjectGetSlotRef(e, o->obj, _ErrorData_))
        builtinTag = "Error";
    else if(ObjectGetSlotRef(e, o->obj, _BooleanData_))
        builtinTag = "Boolean";
    else if(ObjectGetSlotRef(e, o->obj, _NumberData_))
        builtinTag = "Number";
    else if(ObjectGetSlotRef(e, o->obj, _DateValue_))
        builtinTag = "Date";
    else if(ObjectGetSlotRef(e, o->obj, _RegExpMatcher_))
        builtinTag = "RegExp";
    else
        builtinTag = "Object";

    tag = DoGet(e, o, e->toStringTag, NULL);
    RET_IF_AB(tag);
    if(ValIsUndef(tag)) {
        ValDel(e, tag);
        tag = ValNewStrA(e, builtinTag);
    }
    else {
        if(tag->type != TYPE_STR) {
            ValDel(e, tag);
            tag = ValNewStrA(e, "???");
            if(ValEqStrA(e, tag, "Arguments") || ValEqStrA(e, tag, "Array") ||
               ValEqStrA(e, tag, "Boolean") || ValEqStrA(e, tag, "Date") ||
               ValEqStrA(e, tag, "Error") || ValEqStrA(e, tag, "Function") ||
               ValEqStrA(e, tag, "Function") || ValEqStrA(e, tag, "Number") ||
               ValEqStrA(e, tag, "RegExp") || ValEqStrA(e, tag, "String")) {
                if(ValEqStrA(e, tag, builtinTag)) {
                    DynStr* ds = DynStrNew(e, tag->str->length+1);
                    DynStrAdd(e, ds, '~');
                    DynStrAddStr(e, ds, tag->str);
                    ValDel(e, tag);
                    tag = ValNew(e);
                    tag->type = TYPE_STR;
                    tag->str = StrClone(e, ds->str);
                    DynStrDel(e, ds);
                }
            }
        }
    }
    DynStr* ds = DynStrNew(e, tag->str->length+9);
    DynStrAddStrA(e, ds, "[object ");
    DynStrAddStr(e, ds, tag->str);
    DynStrAdd(e, ds, ']');
    ret = ValNew(e);
    ret->type = TYPE_STR;
    ret->str = StrClone(e, ds->str);
    DynStrDel(e, ds);

exit:
    IFD(tag);
    IFD(o);
    return ret;    
}

Val* Object_prototype_valueOf(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    return ToObject(e, othis);
}

NativeMethod Object_prototype_methods[] = {
    { "hasOwnProperty", Object_prototype_hasOwnProperty, 1},
    { "isPrototypeOf", Object_prototype_isPrototypeOf, 1},
    { "propertyIsEnumerable", Object_prototype_proeprtyIsEnumerable, 1},
    { "toLocaleString", Object_prototype_toLocaleString, 0},
    { "toString", Object_prototype_toString, 0},
    { "valueOf", Object_prototype_valueOf, 0}
};

Node* FormalParameters(Parser* p, int start, uint32 flags);
Node* BindingElement(Parser* p, int start, uint32 flags);
Node* FunctionBody(Parser* p, int start, uint32 flags);

bool_t NeedsSuperBinding(Parser* p, Node* node) {
    return FALSE;           // @todo: Implement
}

void TkTokenizeTop(Js* e, Tokenizer* tk, Str* str) {
    tk->colorizer = FALSE;               // must indicate colorizer first for empty input
    tk->source = StrClone(e, str);
    TkBegin(e, tk, tk->source->chars, -1, tk->source->length);
    while(TkTokenizeNext(e, tk)) {
    }
}

void TkTokenizeAdd(Js* e, Tokenizer* tk, Str* str) {
    Str* s2 = StrAddUCharUChar(e, tk->source, str);
    StrDel(e, tk->source);
    tk->source = s2;
    tk->input = tk->source->chars;
    tk->max = s2->length;
    while(TkTokenizeNext(e, tk)) {
    }
}

Node* P(ParseFunc fn, Parser* p, int start, uint32 flags, uint32 isNot);

void FunctionDestruct(Js* e, Object* func) {
    Property* prop = ObjectGetSlotRef(e, func, _Parser_);
    if(prop)
        ParserDel(prop->value->ptr);
}

Val* CreateDynamicFunction(Js* e, Val* constructor, Val* newTarget, char* kind, Val* args);


Val* FunctionConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
        Val* C = o;
        return CreateDynamicFunction(e, C, newTarget, "normal", args);
}


Val* CreateDynamicFunction(Js* e, Val* constructor, Val* newTarget, char* kind, Val* args) {
    Val* ret = NULL, *p = NULL, *firstArg = NULL, *nextArg = NULL;
    Val* nextArgString = NULL, *bodyText = NULL;
    Parser* parser = NULL;
    Node* params = NULL, *body = NULL;
    PtrList* boundNames = NULL, *lexDeclNames = NULL;
    Val* vn = NULL, *scope = NULL, *f = NULL, *status = NULL;
    bool_t delParser = TRUE;
    Val* fallbackProto = 0, *proto = 0, *prototype = 0; 
    Val* nameStr = 0;

    if(ValIsUndef(newTarget))
        newTarget = constructor;
    if(strcmp(kind, "normal") == 0) {
        fallbackProto = CurrentRealm(e)->functionPrototype;
    }
    else {
        fallbackProto = CurrentRealm(e)->generatorPrototype;
    }


    int argCount = args->list->count;
    p = ValNewStrA(e, "");
    if(argCount == 0)
        bodyText = ValNewStrA(e, "");
    else if(argCount == 1)
        bodyText = GetArg(e, args, 0);
    else {
        firstArg = GetArg(e, args, 0);
        IFZ(p);
        p = ToString(e, firstArg);
        RET_IF_AB(p);
        int k = 1;
        while(k < (argCount-1) ) {
            nextArg = GetArg(e, args, k);
            nextArgString = ToString(e, nextArg);
            RET_IF_AB(nextArgString);
            p = ValAddStrA(e, p, ",", TRUE);
            Str* s1 = StrAddUCharUChar(e, p->str, nextArgString->str);
            IFZ(p);
            p = ValNew(e);
            p->type = TYPE_STR;
            p->str = s1;
            k++;
        }
        Val* t = GetArg(e, args, k);
        bodyText = ToString(e, t);
        ValDel(e, t);
        RET_IF_AB(bodyText);
    }
    parser = ParserNew(e);
    TkTokenizeTop(e, parser->tk, p->str);
    if(TkHasError(e, parser->tk))
        RET(ThrowSyntaxError(e, "failed to tokenize ", p, 0));
    int offset = TkGetCount(e, parser->tk);
    TkTokenizeAdd(e, parser->tk, bodyText->str);  
    if(TkHasError(e, parser->tk))
        RET(ThrowSyntaxError(e, "failed to tokenize ", bodyText, 0));
    TkEnd(e, parser->tk);
    params = P(FormalParameters,parser, 0, 0, 0); // @todo: strict?
    if(parser->error[0])
        RET(ThrowSyntaxError(e, "failed to parse parameters", 0, 0));    
    body = P(FunctionBody,parser, offset, 0, 0);       // @todo: strict?
    if(parser->error[0])
        RET(ThrowSyntaxError(e, "failed to parse body",0,0));
    parser->root = NodeNew(parser);
    parser->root->left = params;
    parser->root->right = body;
    boundNames = BoundNames(parser, params);
    lexDeclNames = LexicallyDeclaredNames(parser, body);
    for(PtrItem* bi=boundNames->head; bi; bi = bi->next) {
        vn = StringValue(parser, bi->value);
        if(PtrListHasStr(parser, lexDeclNames, vn,0)) 
            RET(ThrowSyntaxError(e, "duplicate found ", vn, 0));
        IFZ(vn);
    }
    bool_t strict = FALSE;
    if(IsStrict(parser, body)) {
        strict = TRUE;
        // @todo: If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.
    }
    proto = GetPrototypeFromConstructor(e, newTarget, fallbackProto);
    RET_IF_AB(proto);
    f = FunctionAllocate(e, proto, strict, kind);
    RET_IF_AB(f);

    Realm* realmF = ObjectGetSlotPtr(e, f, _Realm_);
    scope = ValClone(e, realmF->globalEnv);
    delParser = FALSE;
    ObjectSetSlot(e, f->obj, _Parser_, ValNewPtr(e, parser), FALSE, TRUE);
    ObjectSetSlot(e, f->obj, _Code_, ValNewPtr(e, body), FALSE, TRUE);
    ObjectSetSlot(e, f->obj, _Code_, ValNewPtr(e, params), FALSE, TRUE);
    ObjectSetMethod(e, f->obj, _Destruct_, FunctionDestruct, TRUE);

    status = FunctionInitialize(e, f, FUNC_NORMAL, params, body, scope);    // @todo: Strict?
    // Since FunctionInitialize calls FunctionAllocate which retains the parser
    // we need to release this reference so we don't leak
    ParserDel(parser);
    RET_IF_AB(status);
    if(strcmp(kind, "generator") == 0) {
        prototype = ObjectCreate(e, CurrentRealm(e)->generatorPrototype, NULL);
        RET_IF_AB(prototype);
        bool_t writable = TRUE;
        ValDel(e, MakeCons(e, f, &writable, prototype));
    }
    else {
        ValDel(e, MakeCons(e, f, NULL, NULL));
    }
    nameStr = ValNewStrA(e, "anonymous");
    ValDel(e, SetFunctionName(e, f, nameStr, NULL));
    RET_VAL(f);

exit:
    if(delParser) {
        if(params) NodeDel(parser, params); 
        if(body) NodeDel(parser, body);
        if(parser) ParserDel(parser);       
    }
    IFD(nameStr);
    IFD(proto);
    IFD(status);
    IFD(scope);
    IFD(f);
    IFD(vn);
    IFD(p);
    IFD(firstArg);
    IFD(nextArg);
    IFD(nextArgString);
    IFD(bodyText);
    if(boundNames) PtrListDel(e, boundNames);
    if(lexDeclNames) PtrListDel(e, lexDeclNames);
    return ret;    
}

NativeMethod Function_methods[] = {
};

Val* Function_prototype_apply(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* func = othis;
    Val* thisArg = GetArg(e, args, 0);
    Val* argArray = GetArg(e, args, 1);
    Val* ret = NULL, *argList = NULL;

    if(!ValIsTrueDel(e, IsCallable(e, func)))
        RET(ThrowTypeError(e, "not callable", 0, 0));
    if(ValIsNull(argArray) || ValIsUndef(argArray)) {
        RET(DoCall(e, func, thisArg, NULL));
    }
    argList = CreateListFromArrayLike(e, argArray);
    RET_IF_AB(argList);
    PrepareForTailCall(e);
    RET(DoCall(e, func, thisArg, argList));

exit:
    IFD(thisArg);
    IFD(argArray);
    IFD(argList);
    return ret;    
}

Val* Function_prototype_bind(Js* e, Val* oarg, Val* othis, Val* arguments, Val* newTarget) {
    Val* target = othis;
    List* argList = NULL;
    Val* args = NULL, *ret = NULL, *f = NULL, *targetHasLength = NULL;
    Val* targetLen = NULL, *status = NULL, *desc = NULL;
    Val* thisArg = GetArg(e,arguments, 0);
    Val* targetName = NULL;
    Val* prefix = NULL;
    Val* vl = NULL;
    int l = 0;

    if(!ValIsTrueDel(e, IsCallable(e, target)))
        RET(ThrowTypeError(e, "not callable", 0,0));

    argList = ListNew(e);    
    for(int i=1; i < arguments->list->count; i++)
        ListAddValue(e, argList, GetArg(e, arguments, i));
    args = ValNewList(e, argList);
    f = BoundFunctionCreate(e, target, thisArg, args);
    targetHasLength = HasOwnProp(e, target, e->strLength);
    RET_IF_AB(targetHasLength);
    if(ValIsTrue(e, targetHasLength)) {
        targetLen = DoGet(e, target, e->strLength, target);
        RET_IF_AB(targetLen);
        if(targetLen->type != TYPE_NUM)
            l = 0;
        else
            l = targetLen->num - args->list->count;
        if(l < 0) l = 0;
    }
    else 
        l = 0;

    vl = ValNewNum(e, l);

    desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, vl);
    PropSetWritable(e, desc->desc, FALSE);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, TRUE);

    status = DefinePropOrThrow(e, f, e->strLength, desc);
    RET_IF_AB(status);
    targetName = Get(e, target, e->strName);
    RET_IF_AB(targetName);
    if(targetName->type != TYPE_STR) {
        ValDel(e, targetName);
        targetName = ValNewStrA(e, "");
    }
    ValDel(e, status);
    prefix = ValNewStrA(e, "bound");
    status = SetFunctionName(e, f, targetName, prefix);
    RET_IF_AB(status);
    RET_VAL(f);

exit:
    IFD(prefix);
    IFD(targetName);
    IFD(vl);
    IFD(desc);
    IFD(status);
    IFD(targetLen);
    IFD(f);
    IFD(targetHasLength);
    IFD(thisArg);
    IFD(args);
    return ret;    
}

Val* Function_prototype_call(Js* e, Val* oarg, Val* othis, Val* arguments, Val* newTarget) {
    Val* func = oarg, *ret = NULL, *thisArg = GetArg(e, arguments, 0);
    List* list = NULL;
    Val* argList = NULL;

    if(!ValIsTrueDel(e, IsCallable(e, func)))
        RET(ThrowTypeError(e, "not callable", 0, 0));

    list = ListNew(e);
    argList = ValNewList(e, list);
    for(int i=1; i < arguments->list->count; i++) 
        ListAddValue(e, list, GetArg(e, arguments,i));
    PrepareForTailCall(e);
    ret = DoCall(e, othis, thisArg, argList);

exit:
    IFD(argList);
    IFD(thisArg);
    return ret;
}

Val* CloneObject(Js* e, Val* source) {    
    Val* dest = ValNewObject(e);
    Object* s = source->obj, *d = dest->obj;

    // Clone prototype
    ValAssign(e, &d->prototype, s->prototype);

    // Clone all properties
    for(Property* p = s->properties; p; p = p->next) 
        ValDel(e, Put(e, dest, p->name, p->value, FALSE));

    // Clone all slots
    for(Property* p = s->slots; p; p = p->next) 
        ObjectSetSlot(e, dest->obj, p->name->descA, p->value, FALSE, FALSE);

    // Clone all methods
    for(Property* p = s->methods; p; p = p->next) 
        ObjectSetMethod(e, dest->obj, p->name->descA, p->value->ptr, FALSE);

    return dest;  
}

Val* CloneMethod(Js* e, Val* function, Val* newHome) {
    // Since built-in functions are the same, I think it is safe
    // to simply fully clone the object including prototype and all
    // methods and slots. This will work for every single object type
    Val* clone = CloneObject(e, function);
    ObjectSetSlot(e, clone->obj, _Extensible_, ValNewBool(e, TRUE), TRUE, TRUE);
    if(ObjectGetSlotRef(e, clone->obj, _NeedsSuper_)) {
        ObjectSetSlot(e, clone->obj, _HomeObject_, newHome, TRUE, FALSE);
    }

    // We need to retain the parser if it exists on thie function
    Property* prop = ObjectGetSlotRef(e, clone->obj, _Parser_);
    if(prop) {
        ParserRetain(prop->value->ptr);
    }
    return clone;
}

Val* BoundFunctionClone(Js* e, Val* function) {
    // Since built-in functions are the same, I think it is safe
    // to simply fully clone the object including prototype and all
    // methods and slots. This will work for every single object type
    Val* clone = CloneObject(e, function);
    ObjectSetSlot(e, clone->obj, _Extensible_, ValNewBool(e, TRUE), TRUE, TRUE);
    return clone;
}

Val* Function_prototype_toMethod(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* newHome = GetArg(e, args,0), *ret = NULL;
    Val* func = othis;
    if(newHome->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object", 0, 0));
    if(ObjectGetMethod(e, func->obj, _Call_) ==  BoundFunctionCall)
        RET(BoundFunctionClone(e, func));
    if(ValIsFunc(e, func))
        RET(CloneMethod(e, func, newHome));
    RET(ThrowTypeError(e, "failed to clone method", 0,0));

exit:
    IFD(newHome);
    return ret;    
}

Val* Function_prototype_toString(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* func = othis, *ret = NULL, *name = NULL, *def = ValNewStrA(e, "[object Function]");

    // Ensure it is a function
    if(!ValIsFunc(e, func))
        RET_VAL(def); // RET(ThrowTypeError(e));

    // Ensure it has a parser
    Parser* p = (Parser*) ObjectGetSlotPtr(e, func, _Parser_);
    if(!p)
        RET_VAL(def); // RET(ThrowTypeError(e));

    // Get the function name
    name = GetA(e, func, "name");
    RET_IF_AB(name);

    if(ValIsUndef(name))
        RET_VAL(def); // RET(ThrowTypeError(e));

    // Find it in the functions list of the parser (@todo: need to find last one?)
    for(FuncDef* fd = p->functions; fd; fd = fd->next) {
        if(ValIsTrueDel(e, SameValue(e, fd->name, name))) {
            Tokenizer* tk = p->tk;
            int startOffset = TkGetTokOffset(e, tk, fd->startToken);
            int endOffset = TkGetTokOffset(e, tk, fd->endToken);
            Str* s = StrNewLength(e, endOffset-startOffset+1);
            for(int i=startOffset; i <= endOffset; i++) {
                s->chars[i-startOffset] = tk->input[i];
            }
            ret = ValNew(e);
            ret->type = TYPE_STR;
            ret->str = s;
            goto exit;
        }
    }

    RET_VAL(def);
exit:
    IFD(def);
    IFD(name);
    return ret;
}

NativeMethod Function_prototype_methods[] = {
    { "apply", Function_prototype_apply, 2}
   ,{ "bind", Function_prototype_bind, 1}
   ,{ "call", Function_prototype_call, 1}
   ,{ "toMethod", Function_prototype_toMethod, 1}
   ,{ "toString", Function_prototype_toString, 0}
};



Val* BooleanConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* value = GetArg(e, args, 0);
    Val* ret = NULL, *b = NULL, *O = 0;
    b = ToBoolean(e, value);    
    if(ValIsUndef(newTarget)) 
        RET_VAL(b);
    O = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->booleanPrototype, NULL);
    ObjectSetSlot(e, O->obj, _BooleanData_, b, TRUE, FALSE);
    RET_VAL(O);
exit:
    IFD(O);
    IFD(b);
    IFD(value);    
    return ret;
}


Val* thisBooleanValue(Js* e, Val* value) {
    if(value->type == TYPE_BOOL) 
        return ValClone(e, value);
    if(value->type == TYPE_OBJ && ObjectGetSlotRef(e, value->obj, _BooleanData_)) {
        Val* b = ObjectGetSlot(e, value->obj, _BooleanData_);
        if(!ValIsUndef(b))
            return ValClone(e, b);
        ValDel(e, b);
    }
    return ThrowTypeError(e, "not a boolean", 0,0);
}

Val* Boolean_prototype_toString(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    Val* b = thisBooleanValue(e, othis), *ret =NULL;
    RET_IF_AB(b);
    if(b->b)
        RET(ValNewStrA(e, "true"));
    RET(ValNewStrA(e, "false"));

exit:
    IFD(b);
    return ret;    
}

Val* Boolean_prototype_valueOf(Js* e, Val* oarg, Val* othis, Val* args, Val* newTarget) {
    return thisBooleanValue(e, othis);
}

NativeMethod Boolean_prototype_methods[] = {
   { "toString", Boolean_prototype_toString, 0}
  ,{ "valueOf", Boolean_prototype_valueOf, 0}
};


Val* SymbolConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* desc = GetArg(e, args, 0);
    Val* ret = NULL;
    Val* descString = 0; 
    Val* obj = 0;

    if(ValIsUndef(desc)) 
        descString = ValNew(e);
    else 
        descString = ToString(e, desc);

    if(!ValIsUndef(newTarget)) 
        RET(ThrowTypeError(e, "cannot construct symbol", 0,0));


    RET(SymbolEntryNew(e, descString->str));
exit:
    IFD(obj);
    IFD(descString);
    IFD(desc);    
    return ret;
}

Val* StdConsCall(Js* e, Val* o, Val* args) {
    Val* F = o;
    return Construct(e, F, args, NULL);
}




Val* Symbol_for(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *key = GetArg(e, args, 0);
    Val* stringKey = ToString(e, key);
    RET_IF_AB(stringKey);
    Str* skey = stringKey->str;

    heap* h = e->memory[SE].data;
    if(!h->blocks)
        RET(SymbolEntryNew(e, skey));

    for(int i=0; i < h->blocks->count; i++) {
        vec** pblock = vec_get(h->blocks, i);
        vec* block = *pblock;
        for(int j=0; j < block->count; j++) {
            mitem* mi = vec_get(block, j);
            char* p = (char*) mi;
            p += sizeof(mitem);
            Str** se = (Str**) p;
            Str* s = *se;
            if(s && StrEqStr(e, s, skey))
                RET(ValNewSymbol(e, (char*) s));
        }
    }        

    RET(SymbolEntryNew(e, skey));
exit:
    IFD(stringKey);
    IFD(key);    
    return ret;
}


Val* Symbol_keyFor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* sym = GetArg(e, args, 0);
    Val* ret = NULL;
    if(sym->type != TYPE_SYMA)
        RET(ThrowTypeError(e, "not a symbol", 0, 0));

    // @todo: This will not work for built-in symbols until we switch them
    //        to use SymbolEntryNew() instead of a hardcoded char* 
    Str* s = (Str*) sym->descA;
    RET(ValNewStr(e, s));

exit:
    IFD(sym);
    return ret;    
}

NativeMethod Symbol_methods[] = {
    { "for", Symbol_for, 1},
    { "keyFor", Symbol_keyFor, 1}
};

Val* SymbolDescriptiveString(Js* e, Val* sym) {
    assert(sym->type == TYPE_SYMA);
    Str* desc = NULL;
    if(!sym->descA)
        desc = e->strEmpty->str;
    else 
        desc = (Str*) sym->descA;

    DynStr* ds = DynStrNew(e, 20);
    DynStrAddStrA(e, ds, "Symbol(");
    DynStrAddStr(e, ds, desc);
    DynStrAddStrA(e, ds, ")");
    Val* result = ValNewStr(e, ds->str);
    DynStrDel(e, ds);
    return result;
}

Val* Symbol_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* s = othis;
    Val* sym;
    if(s->type == TYPE_SYMA)
        sym = s;
    else {
        if(s->type != TYPE_OBJ)
            return ThrowTypeError(e, "not an object",0,0);
        if(ObjectGetSlotRef(e, s->obj, _SymbolData_) == NULL)
            return ThrowTypeError(e, "not a symbol", 0, 0);
        sym = ObjectGetSlot(e, s->obj, _SymbolData_);
    }
    return SymbolDescriptiveString(e, sym);
}

Val* Symbol_prototype_valueOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* s = othis;
    if(s->type == TYPE_SYMA)
        return ValClone(e, s);
    if(s->type != TYPE_OBJ)
        return ThrowTypeError(e, "not an object", 0, 0);
    if(ObjectGetSlotRef(e, s->obj, _SymbolData_) == NULL)
        return ThrowTypeError(e, "not a symbol", 0, 0);
    return ValClone(e, ObjectGetSlot(e, s->obj, _SymbolData_));
}


Val* Symbol_prototype_toPrimitive(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
  return Symbol_prototype_valueOf(e, o, othis, args, newTarget);  
}


NativeMethod Symbol_prototype_methods[] = {
    { "toString", Symbol_prototype_toString, 0},
    { "valueOf", Symbol_prototype_valueOf, 0}
};


Val* CoreErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* proto, Val* newTarget) {
    Val* ret = NULL, *desc = NULL, *status = NULL, *msg = NULL;
    Val* message = GetArg(e, args, 0);

    if(ValIsUndef(newTarget))
        newTarget = o;

    Val* O = OrdinaryCreateFromConstructor(e, newTarget, proto, NULL);
    RET_IF_AB(O);


    // Per 19.5.1.1.5 any value other than undefined
    ObjectSetSlot(e, O->obj, _ErrorData_, ValNewBool(e, TRUE), TRUE, TRUE);
    if(!ValIsUndef(message)) {
        msg = ToString(e, message);
        RET_IF_AB(msg);
        desc = ValNewDesc(e);
        PropSetValue(e, desc->desc, msg);
        PropSetConfigurable(e, desc->desc, TRUE);
        PropSetWritable(e, desc->desc, TRUE);
        PropSetEnumerable(e, desc->desc, FALSE);
        status = DefinePropOrThrow(e, O, e->strMessage, desc);    
        RET_IF_AB(status);
    }
    RET_VAL(O);

exit:
    IFD(desc);
    IFD(status);
    IFD(msg);
    IFD(message);
    IFD(O);
    return ret;    
}


Val* ErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->errorPrototype, newTarget);
}

Val* EvalErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->evalErrorPrototype, newTarget);
}

Val* RangeErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->rangeErrorPrototype, newTarget);
}

Val* ReferenceErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->referenceErrorPrototype, newTarget);
}

Val* SyntaxErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->syntaxErrorPrototype, newTarget);
}

Val* TypeErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->typeErrorPrototype, newTarget);
}

Val* URIErrorConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return CoreErrorConstructor(e, o, othis, args, CurrentRealm(e)->uriErrorPrototype, newTarget);
}

Val* Error_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis, *ret = NULL, *name = NULL, *msg = NULL;
    if(O->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object", 0,0));
    name = GetA(e, O, "name");
    RET_IF_AB(name);
    if(ValIsUndef(name)) {
        ValDel(e, name);
        name = ValNewStrA(e, "Error");
    }
    else {
        Val* temp = ToString(e, name);
        ValDel(e, name);
        name = temp;        
    }
    msg = GetA(e, O, "message");
    RET_IF_AB(msg);
    if(ValIsUndef(msg)) {
        ValDel(e, msg);
        msg = ValNewStrA(e, "");
    }
    else {
        Val* temp = ToString(e, msg);
        ValDel(e, msg);
        msg = temp;
    }
    if(name->str->length == 0)
        RET_VAL(msg);
    if(msg->str->length == 0)
        RET_VAL(name);
    DynStr* ds = DynStrNew(e, name->str->length + msg->str->length+1);
    DynStrAddStr(e, ds, name->str);
    DynStrAddStrA(e, ds, ": ");
    DynStrAddStr(e, ds, msg->str);
    ret = ValNewStr(e, ds->str);
    DynStrDel(e, ds);

exit:
    IFD(name);
    IFD(msg);    
    return ret;
}

NativeMethod Error_prototype_methods[] = {
    { "toString", Error_prototype_toString, 0}
};



Val* NumberConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* value = NULL, *n = NULL, *ret = NULL, *O = 0;
    if(args->list->count == 0) {
        n = ValNewNum(e, 0);
    }        
    else {
        value = GetArg(e, args, 0);
        n = ToNumber(e, value);
        RET_IF_AB(n);
    }
    if(ValIsUndef(newTarget))
        RET_VAL(n);
    O = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->numberPrototype, NULL);
    RET_IF_AB(O);
    ObjectSetSlot(e, O->obj, _NumberData_, n, TRUE, FALSE);
    RET_VAL(O);
exit:
    IFD(O);
    IFD(n);
    IFD(value);    
    return ret;
}


Val* Number_isInteger(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* nv = GetArg(e, args, 0), *ret = NULL, *iv = NULL;
    if(nv->type != TYPE_NUM)
        RET(ValNewBool(e, FALSE));
    number n = nv->num;
    if(isnan(n) || n == INFINITY || n == -INFINITY)
        RET(ValNewBool(e, FALSE));
    iv = ToInteger(e, nv);
    if(iv->num == n)
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));

exit:
    IFD(iv);
    IFD(nv);
    return ret;    
}

Val* Number_isSafeInteger(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* nv = GetArg(e, args, 0), *ret = NULL, *iv = NULL;
    if(nv->type != TYPE_NUM)
        RET(ValNewBool(e, FALSE));
    number n = nv->num;
    if(isnan(n) || n == INFINITY || n == -INFINITY)
        RET(ValNewBool(e, FALSE));
    iv = ToInteger(e, nv);
    if(iv->num != n)
        RET(ValNewBool(e, FALSE));
    if(fabs(iv->num) <= (pow(2, 53)-1))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));

exit:
    IFD(iv);
    IFD(nv);
    return ret;    
}

Val* Number_isNaN(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* nv = GetArg(e, args, 0), *ret = NULL, *num = 0;
    num = ToNumber(e, nv);
    RET_IF_AB(num);
    number n = num->num;
    if(isnan(n))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));

exit:
    IFD(num);
    IFD(nv);
    return ret;    
}

Val* thisNumberValue(Js* e, Val* value) {
    if(value->type == TYPE_NUM)
        return ValClone(e, value);
    if(value->type == TYPE_OBJ && ObjectGetSlotRef(e, value->obj, _NumberData_)) {
        Val* n = ObjectGetSlot(e, value->obj, _NumberData_);
        if(!ValIsUndef(n))
            return ValClone(e, n);
    }
    return ThrowTypeError(e, "not a number", 0,0);
}



NativeMethod Number_methods[] = {
    { "isFinite", isFinite, 1},
    { "isInteger", Number_isInteger, 1},
    { "isNaN", Number_isNaN, 1},
    { "isSafeInteger", Number_isSafeInteger, 1},
    { "parseInt", parseInt, 1},
    { "parseFloat", parseFloat, 1},
};



int Number_toExp_compute_e_n_range(int minn, int maxn, uint32 step, int f, number x) {
    int mine = -500, maxe = 500;
    number minv = DBL_MAX;
    int nv = 0;
    for(int e = mine; e < maxe; e++) {
        for(int n = minn; n <= maxn; n+=step) {
            number v = fabs(n * pow(10, e-f) - x);
            if(v < minv) {
                minv = fabs(v);
                nv = n;
            }
        }
    }
    return nv;
}

int FractionToInt(number x, int f) {
    number fp = pow(10,f);
    while(x < fp) {
        x = x* 10;
    }
    return (int) x;
}

void Number_toExp_compute_e_n(int f, number x, int* pe, int* pn) {
    int mine = -500, maxe = 500;
    int minn = (int) pow(10, f), maxn = (int) pow(10, f+1);
    number minv = DBL_MAX;
    int ev=0, nv=0;
    
    int xx = 0;
    number xp = x;
    if(xp >= 1) {
        while(xp < minn)
            xp *= 10;
        int ix = (int) xp;
        number frac = xp - ix;
        if(frac >= 0.5)
            ix++;
        xx = ix;
    }
    else {
        // If x < 1 then we need to make sure x gets to the
        // form where it has F integer digits
        xx = FractionToInt(x, f);
    }

    // Narrow down the range of n
    for(int ff = f; ff > 1; ff--) {
        uint32 step = pow(10, ff-1);
        if(step == 0)
            continue;
        int n = Number_toExp_compute_e_n_range(minn, maxn, step, f, x);
        if(n < xx) {
            minn = n;
            maxn = minn + step;
        }
        else {
            minn = n - step;
            maxn = n;
        }
    }
    
    for(int e = mine; e < maxe; e++) {
        for(int n = minn; n <= maxn; n+=1) {
            number v = fabs(n * pow(10, e-f) - x);
            if(v < minv) {
                minv = fabs(v);
                ev = e;
                nv = n;
            }
        }
    }
    *pe = ev;
    *pn = nv;
}

void Number_toExp_compute_e_n_f(number x, int* pe, int* pn, int* pf) {
    number minv = DBL_MAX;
    int e, n;
    
    for(int f = 0; f <= 20; f++) {
        Number_toExp_compute_e_n(f, x, &e, &n);
        number v = fabs(n * pow(10, e-f) -x);
        if(v < minv) {
            minv = v;
            *pf = f;
            *pn = n;
            *pe = e;
        }
    }
}

Val* Number_prototype_toExponential(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* x = NULL, *ret = NULL, *fv = NULL, *fractionDigits = GetArg(e, args, 0);
    Val* m = NULL;
    int ee = 0, n = 0, f = 0;
    Val* d = NULL, *c = NULL;

    DynStr* s = NULL;

    x = thisNumberValue(e, othis);
    RET_IF_AB(x);

    fv = ToInteger(e, fractionDigits);
    RET_IF_AB(fv);
    f = (int) fv->num;

    if(isnan(x->num))
        RET(ValNewStrA(e, "NaN"));

    s = DynStrNew(e, 20);
    if(x->num < 0) {
        DynStrAdd(e, s, '-');
        x->num = - x->num;
    }
    if(isinf(x->num)) {
        DynStrAddStrA(e, s, "Infinity");
        ret = ValNewStr(e, s->str);
        DynStrDel(e, s);
        s = NULL;
        goto exit;
    }

    if(f < 0 || f > 20)
        RET(ThrowRangeError(e, "range must be between 0 and 20",0,0));
    if(x->num == 0) {
        Str* sm = StrNewLength(e, f+1);
        for(int i=0; i < sm->length; i++) 
            sm->chars[i] = 0x30;
        m = ValNewStr(e, sm);
        StrDel(e, sm);
        ee = 0;
    }
    else {
        if(!ValIsUndef(fractionDigits)) 
            Number_toExp_compute_e_n(f, x->num, &ee, &n);        
        else 
            Number_toExp_compute_e_n_f(x->num, &ee, &n, &f);
        char buff[40];
        sprintf(buff, "%d", n);
        m = ValNewStrA(e, buff);
    }

    if(f != 0) {
        Str* ss = StrNewLength(e, m->str->length +1);
        ss->chars[0] = m->str->chars[0];
        ss->chars[1] = '.';
        for(int i=1; i < m->str->length; i++) 
            ss->chars[i+1] = m->str->chars[i];
        ValDel(e, m);
        m = ValNew(e);
        m->str = ss;
        m->type = TYPE_STR;
    }
    if(ee == 0) {
        c = ValNewStrA(e, "+");
        d = ValNewStrA(e, "0");
    }
    else {
        if(ee > 0)
            c = ValNewStrA(e, "+");
        else {
            c =  ValNewStrA(e, "-");
            ee = -ee;
        }
        char buff[40];
        sprintf(buff, "%d", ee);
        d = ValNewStrA(e, buff);
    }

    DynStr* ds = DynStrNew(e, s->str->length + m->str->length + 3);
    DynStrAddStr(e, ds, s->str);
    DynStrAddStr(e, ds, m->str);
    DynStrAdd(e, ds, 'e');
    if(c) DynStrAddStr(e, ds, c->str);
    if(d) DynStrAddStr(e, ds, d->str);
    ret = ValNewStr(e, ds->str);
    DynStrDel(e, ds);

exit:
    if(s) DynStrDel(e, s);
    IFD(m);
    IFD(d);
    IFD(c);
    IFD(fractionDigits);
    IFD(fv);
    IFD(x);    
    return ret;
}

int Number_toFixed_compute_n(int f, number x) {
    int n1 =(int) ( x * pow(10,f) );
    int n2 = n1 + 1;
    int nv = 0;
    number vmin = DBL_MAX;
    for(int n=n1; n <= n2; n++) {
        number v = fabs((n / pow(10, f)) - x);
        if(v < vmin) {
            vmin = v;
            nv = n;
        }
    }
    return nv;
}

Val* Number_prototype_toFixed(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *fractionDigits = GetArg(e, args, 0), *x = NULL;
    Val* fv = NULL;
    DynStr* s = NULL;
    int f = 0;
    Val* m = NULL;

    x = thisNumberValue(e, othis);
    RET_IF_AB(x);

    if(!ValIsUndef(fractionDigits)) {
        fv = ToInteger(e, fractionDigits);
        RET_IF_AB(fv);
        f = fv->num;
    }

    if(f < 0 || f > 20)
        RET(ThrowRangeError(e, "must be between 0 and 20", 0,0));
    if(isnan(x->num))
        RET(ValNewStrA(e, "NaN"));

    s = DynStrNew(e, 10);
    if(x->num < 0) {
        DynStrAdd(e, s, '-');
        x->num = - x->num;
    }
    if(x->num > pow(10, 21))
        m = ToString(e, x);
    else {
        int n = Number_toFixed_compute_n(f, x->num);
        if(n == 0)
            m = ValNewStrA(e, "0");
        else {
            char buff[40];
            sprintf(buff, "%d", n);
            m = ValNewStrA(e, buff);
        }
        if(f != 0) {
            int k = m->str->length;
            if(k <= f) {
                int l = f + 1 - k;
                Str* z = StrNewLength(e, l);
                for(int i=0; i < l; i++)
                    z->chars[i] = 0x0030;
                DynStr* ds = DynStrNew(e, z->length + m->str->length);
                DynStrAddStr(e, ds, z);
                DynStrAddStr(e, ds, m->str);
                k = f + 1;
                StrDel(e, z);
                ValDel(e, m);
                m = ValNewStr(e, ds->str);
                DynStrDel(e, ds);
            }
            Str* z = StrNewLength(e, m->str->length+1);
            for(int i=0; i < (k-f); i++) 
                z->chars[i] = m->str->chars[i];
            z->chars[k-f] = '.';
            for(int i = (k-f); i < m->str->length; i++)
                z->chars[i+1] = m->str->chars[i];
            ValDel(e, m);
            m = ValNew(e);
            m->type = TYPE_STR;
            m->str = z;
        }
    }
    DynStr* ds = DynStrNew(e, s->str->length + m->str->length);
    DynStrAddStr(e, ds, s->str);
    DynStrAddStr(e, ds, m->str);
    ret = ValNewStr(e, ds->str);
    DynStrDel(e, ds);

exit:
    if(s) DynStrDel(e, s);
    IFD(fractionDigits);
    IFD(fv);
    IFD(x);
    IFD(m);
    return ret;
}

Val* Number_prototype_toLocaleString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *x = thisNumberValue(e, othis);
    RET_IF_AB(x);
    RET(ToString(e, x));
exit:
    IFD(x);    
    return ret;
}

void Number_toPrecision_compute_e_n(int p, number x, int* pe, int* pn) {
    Number_toExp_compute_e_n(p-1, x, pe, pn);
}

Val* Number_prototype_toPrecision(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *x = NULL, *precision = GetArg(e, args, 0);
    Val* pv = NULL, *s = NULL, *m = NULL;

    x = thisNumberValue(e, othis);
    RET_IF_AB(x);
    if(ValIsUndef(precision))
        RET(ToString(e, x));

    pv = ToInteger(e, precision);
    RET_IF_AB(pv);
    int p = pv->num;
    if(isnan(x->num))
        RET(ValNewStrA(e, "NaN"));

    if(isinf(x->num)) {
        if(x->num < 0)
            RET(ValNewStrA(e, "-Infinity"));
        RET(ValNewStrA(e, "Infinity"));        
    }

    if(x->num < 0) {
        s = ValNewStrA(e, "-");
        x->num = - x->num;
    }
    else
        s = ValNewStrA(e, "");

    if(p < 1 || p > 21)
        RET(ThrowRangeError(e, "must be between 1 and 21", 0, 0));

    int ee, n;
    uchar c;
    if(x->num == 0) {
        Str* st = StrNewLength(e, p);
        for(int i=0; i < st->length; i++)
            st->chars[i] = 0x0030;
        m = ValNew(e);
        m->type = TYPE_STR;
        m->str = st;
        ee = 0;
    }
    else {
        Number_toPrecision_compute_e_n(p, x->num, &ee, &n);
        char buff[40];
        sprintf(buff, "%d", n);
        m = ValNewStrA(e, buff);
        if(ee < -6 || ee >= p) {
            assert(e != 0);
            Str* st = StrNewLength(e, m->str->length+1);
            st->chars[0] = m->str->chars[0];
            st->chars[1] = 0x002E;  // '.'
            for(int i=1; i < m->str->length; i++)
                st->chars[i+1] = m->str->chars[i];
            ValDel(e, m);
            m = ValNew(e);
            m->type = TYPE_STR;
            m->str = st;
            if(ee > 0) {
                c = '+';
            }
            else {
                c = '-';
                ee = -ee;
            }
            char buff[40];
            sprintf(buff, "%c%d", c, ee);
            Val* d = ValNewStrA(e, buff);
            DynStr* ds = DynStrNew(e, s->str->length + m->str->length+1 + d->str->length);
            DynStrAddStr(e, ds, s->str);
            DynStrAddStr(e, ds, m->str);
            DynStrAdd(e, ds, 0x0065);   // e
            DynStrAddStr(e, ds, d->str);
            ValDel(e, d);
            Val* t = ValNewStr(e, ds->str);
            DynStrDel(e, ds);
            RET_VAL(t);
        }
    }
    if(ee == (p-1)) {
        DynStr* ds = DynStrNew(e, s->str->length + m->str->length);
        DynStrAddStr(e, ds, s->str);
        DynStrAddStr(e, ds, m->str);
        Val* t = ValNewStr(e, ds->str);
        DynStrDel(e, ds);
        RET_VAL(t);        
    }

    if(e >= 0) {
        Str* st = StrNewLength(e, m->str->length+1);
        for(int i=0; i < (ee+1); i++) 
            st->chars[i] = m->str->chars[i];
        st->chars[ee+1] = 0x002E;
        for(int i = ee+1; i < m->str->length; i++) 
            st->chars[i+1] = m->str->chars[i];
        ValDel(e, m);
        m = ValNew(e);
        m->type = TYPE_STR;
        m->str = st;
    }
    else {
        Str* st = StrNewLength(e, 2 + ee + 1 + m->str->length);
        st->chars[0] = 0x0030;
        st->chars[1] = 0x002E;
        for(int i=0; i < -(ee+1); i++) 
            st->chars[i+2] = 0x0030;
        for(int i=0; i < m->str->length; i++)
            st->chars[i + 2 + -(ee+1)] = m->str->chars[i];
        ValDel(e, m);
        m = ValNew(e);
        m->type = TYPE_STR;
        m->str = st;
    }
    Str* st = StrNewLength(e, m->str->length + s->str->length);
    for(int i=0; i < s->str->length; i++)
        st->chars[i] = s->str->chars[i];
    for(int i=0; i < m->str->length; i++)
        st->chars[s->str->length+i] = m->str->chars[i];
    ret = ValNew(e);
    ret->type = TYPE_STR;
    ret->str = st;
exit:
    IFD(m);
    IFD(s);
    IFD(pv);
    IFD(precision);
    IFD(x);    
    return ret;
}

Val* Number_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *radix = GetArg(e, args, 0), *x = NULL;
    Val* radixNumber = NULL;

    x = thisNumberValue(e, othis);
    RET_IF_AB(x);

    if(ValIsUndef(radix))
        radixNumber = ValNewNum(e, 10);
    else
        radixNumber = ToInteger(e, radix);
    RET_IF_AB(radixNumber);
    if(radixNumber->num < 2 || radixNumber->num > 36)
        RET(ThrowRangeError(e, "must be between 2 and 36", 0,0));
    if(radixNumber->num == 10)
        RET(ToString(e, x));

    char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    DynStr* ds = DynStrNew(e, 20);
    int n = (int) x->num;
    int r = (int) radixNumber->num;
    while(n > 0) {
        int mod = n % r;
        n = n / r;
        DynStrAdd(e, ds, digits[mod]);
    }

    // Reverse the string
    Str* s = StrNewLength(e, ds->str->length);
    for(int i=ds->str->length-1, j=0; i >=0; i--)
        s->chars[j++] = ds->str->chars[i];
    ret = ValNew(e);
    ret->type = TYPE_STR;
    ret->str = s;
    DynStrDel(e, ds);

exit:
    IFD(radixNumber);
    IFD(x);
    IFD(radix);
    return ret;    
}

Val* Number_prototype_valueOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return thisNumberValue(e, othis);
}

NativeMethod Number_prototype_methods[] = {
    { "toExponential", Number_prototype_toExponential, 1},
    { "toFixed", Number_prototype_toFixed, 1},
    { "toLocaleString", Number_prototype_toLocaleString, 0},
    { "toPrecision", Number_prototype_toPrecision, 1},
    { "toString", Number_prototype_toString, 1},
    { "valueOf", Number_prototype_valueOf, 0},
};


#define STDMATHPRE      Val* a0 = GetArg(e, args, 0), *xv = ToNumber(e, a0);\
    Val* ret = NULL;\
    RET_IF_AB(xv);\
    number x = xv->num;\
    number r;

#define STDMATHPOST     RET(ValNewNum(e, r));\
exit:\
    IFD(a0);\
    IFD(xv);\
    return ret;

#define STDFUNC(n) Val* n(Js* e, Val* o, Val* othis, Val* args,Val* newTarget)

STDFUNC(Math_abs) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isnegzero(x)) r = 0;
    else if(x == -INFINITY) r = INFINITY;
    else r = fabs(x);
    STDMATHPOST;
}

STDFUNC(Math_acos) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if (x > 1) r = NAN;
    else if (x < -1) r = NAN;
    else if (x == 1) r = 0;
    else r = acos(x);
    STDMATHPOST;
}

STDFUNC(Math_acosh) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if (x < 1) r = NAN;
    else if (x == 1) r = 0;
    else if (x == INFINITY) r = INFINITY;
    else r = acosh(x);
    STDMATHPOST;
}

STDFUNC(Math_asin) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if (x > 1) r = NAN;
    else if (x < -1) r = NAN;
    else if (x == 0) r = 0;
    else if (isnegzero(x)) r = -0;
    else r = asin(x);
    STDMATHPOST;
}

STDFUNC(Math_asinh) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if (isposzero(x)) r = +0;
    else if (isnegzero(x)) r = -0;
    else if (x == +INFINITY) r = +INFINITY;
    else if (x == -INFINITY) r = -INFINITY;
    else r = asinh(x);
    STDMATHPOST;
}

STDFUNC(Math_atan) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if (isposzero(x)) r = +0;
    else if (isnegzero(x)) r = -0;
    else if (x == +INFINITY) r = +PI/2;
    else if (x == -INFINITY) r = -PI/2;
    else r = atan(x);
    STDMATHPOST;
}

STDFUNC(Math_atanh) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if (x < -1) r = NAN;
    else if (x > 1) r = NAN;
    else if (x == -1) r = -INFINITY;
    else if (x == +1) r = INFINITY;
    else if (isposzero(x)) r = +0;
    else if (isnegzero(x)) r = -0;
    else r = atanh(x);
    STDMATHPOST;
}

Val* Math_atan2(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *yv = GetArg(e, args, 0), *xv = GetArg(e, args, 1);

    number x = xv->num;
    number y = yv->num;
    number r;

    if(isnan(x) || isnan(y)) r = NAN;
    else if( y > 0 && isposzero(x)) r = PI/2;
    else if( y > 0 && isnegzero(x)) r = -PI/2;
    else if( isposzero(y) && x > 0) r = +0;
    else if( isposzero(y) && isposzero(x)) r = +0;
    else if( isposzero(y) && isnegzero(x)) r = PI;
    else if( isposzero(y) && x < 0) r = PI;
    else if( isnegzero(y) && x > 0) r = -0;
    else if( isnegzero(y) && isposzero(x))  r = -0;
    else if( isnegzero(y) && isnegzero(x)) r = -PI;
    else if( isnegzero(y) && x < 0) r = -PI;
    else if( y < 0 && isposzero(x)) r = -PI/2;
    else if( y < 0 && isnegzero(x)) r = -PI/2;
    else if( y > 0 && !isinf(y) && x == +INFINITY) r = +0;
    else if( y > 0 && !isinf(y) && x == -INFINITY) r = PI;
    else if( y < 0 && !isinf(y) && x == +INFINITY) r = -0;
    else if( y < 0 && !isinf(y) && x == +INFINITY) r = -0;
    else if( y < 0 && !isinf(y) && x == -INFINITY) r = -PI;
    else if( y == +INFINITY && !isinf(x)) r = PI/2;
    else if( y == -INFINITY && !isinf(x)) r = -PI/2;
    else if( y == +INFINITY && x == +INFINITY) r = PI/4;
    else if( y == +INFINITY && x == -INFINITY) r = +3*PI/4;
    else if( y == -INFINITY && x == +INFINITY) r = -PI/4;
    else if( y == -INFINITY && x == -INFINITY) r = -3*PI/4;
    else r = atan2(y, x);

    RET(ValNewNum(e, r));
exit:
    IFD(xv);
    IFD(yv);
    return ret;    
}

STDFUNC(Math_cbrt) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -INFINITY;
    else r = cbrt(x);
    STDMATHPOST;
}

STDFUNC(Math_ceil) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -INFINITY;
    else if(x < 0 && x > -1) r = -0;
    else r = ceil(x);
    STDMATHPOST;
}

Val* Math_clz32(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *x = GetArg(e, args, 0), *n = ToUint32(e, x);
    RET_IF_AB(n);
    int p = 0;
    uint32 un = (uint32) n->num;
    uint32 mask = 0x80000000;
    while(mask > 0) {
        uint32 res = (un & mask);
        if(res != 0)
            break;
        p++;
        mask = mask >> 1;
    }
    RET(ValNewNum(e, p));

exit:
    IFD(x);
    IFD(n);
    return ret;    
}


STDFUNC(Math_cos) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = 1;
    else if(isnegzero(x)) r = 1;
    else if(x == +INFINITY) r = NAN;
    else if(x == -INFINITY) r = NAN;
    else r = cos(x);
    STDMATHPOST;
}

STDFUNC(Math_cosh) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = 1;
    else if(isnegzero(x)) r = 1;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -INFINITY;
    else r = cosh(x);
    STDMATHPOST;
}

STDFUNC(Math_exp) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = 1;
    else if(isnegzero(x)) r = 1;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = +0;
    else r = exp(x);
    STDMATHPOST;
}

STDFUNC(Math_expm1) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -1;
    else r = expm1(x);
    STDMATHPOST;
}

STDFUNC(Math_floor) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -INFINITY;
    else if(x > 0 && x < 1) r = 0;
    else r = floor(x);
    STDMATHPOST;
}

STDFUNC(Math_fround) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = x;
    else if(isnegzero(x)) r = x;
    else if(x == +INFINITY) r = x;
    else if(x == -INFINITY) r = x;
    else r = (number) ((float) x);
    STDMATHPOST;
}

Val* Math_hypot(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *a = NULL, *n = NULL;
    int count = args->list->count;
    number sum = 0;
    for(int i=0; i < count; i++) {
        a = GetArg(e, args, i);
        n = ToNumber(e, a);
        RET_IF_AB(n);
        IFZ(a);
        if(n->num == +INFINITY)
            RET(ValNewNum(e, +INFINITY));
        if(n->num == -INFINITY)
            RET(ValNewNum(e, +INFINITY));
        if(isnan(n->num))
            sum = NAN;
        if(sum != NAN)
            sum += n->num * n->num;
        IFZ(n);
    }
    if(!isnan(sum))
        sum = sqrt(sum);

    RET(ValNewNum(e, sum));

exit:
    IFD(n);
    IFD(a);
    return ret;    
}

Val* Math_imul(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* x = GetArg(e, args, 0), *y = GetArg(e, args, 1), *ret = NULL;
    Val* a = NULL, *b = NULL;

    a = ToUint32(e, x);
    RET_IF_AB(a);
    b = ToUint32(e, y);
    RET_IF_AB(b);
    unsigned long na = (unsigned long) a->num;
    unsigned long nb = (unsigned long) b->num;
    unsigned long product = (na * nb) % 0x100000000;
    if(product >= (1 << 31))
        product -= 0x100000000;
    RET(ValNewNum(e, product));

exit:
    IFD(x);
    IFD(y);
    IFD(a);
    IFD(b);
    return ret;    
}

STDFUNC(Math_log) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(x < 0) r = NAN;
    else if(x == 0) r = -INFINITY;
    else if(x == 1) r = 0;
    else if(x == +INFINITY) r = +INFINITY;
    else r = log(x);
    STDMATHPOST;
}

STDFUNC(Math_log1p) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(x < -1) r = NAN;
    else if(x == -1) r = -INFINITY;
    else if(x == 0) r = 0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else r = log1p(x);
    STDMATHPOST;
}

STDFUNC(Math_log10) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(x < 0) r = NAN;
    else if(x == 0) r = -INFINITY;
    else if(isnegzero(x)) r = -INFINITY;
    else if(x == 1) r = 0;
    else if(x == +INFINITY) r = +INFINITY;
    else r = log10(x);
    STDMATHPOST;
}

STDFUNC(Math_log2) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(x < 0) r = NAN;
    else if(x == 0) r = -INFINITY;
    else if(isnegzero(x)) r = -INFINITY;
    else if(x == 1) r = 0;
    else if(x == +INFINITY) r = +INFINITY;
    else r = log2(x);
    STDMATHPOST;
}

Val* Math_max(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *min = ValNewNum(e, -DBL_MIN), *v = NULL, *n = NULL, *res = NULL;
    if(args->list->count ==0)
        RET(ValNewNum(e, -INFINITY));
    for(int i=0; i < args->list->count; i++) {
        v = GetArg(e, args, i);
        n = ToNumber(e, v);
        RET_IF_AB(n);
        res = AbstractRelational(e, n, min, TRUE);
        if(isposzero(n->num) && isnegzero(min->num)) 
            min->num = +0;
        else if(!ValIsTrue(e, res)) {
            ValDel(e, min);
            min = n;
            n = NULL;
        }
        IFZ(res);
        IFZ(n);
        IFZ(v);
    }
    RET_VAL(min);
exit:
    IFD(res);
    IFZ(n);
    IFD(min);
    IFD(v);
    return ret;    
}

Val* Math_min(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *max = ValNewNum(e, DBL_MAX), *v = NULL, *n = NULL, *res = NULL;
    if(args->list->count ==0)
        RET(ValNewNum(e, -INFINITY));
    for(int i=0; i < args->list->count; i++) {
        v = GetArg(e, args, i);
        n = ToNumber(e, v);
        RET_IF_AB(n);
        res = AbstractRelational(e, n, max, TRUE);
        if(isnegzero(n->num) && isposzero(max->num)) 
            max->num = +0;
        else if(ValIsTrue(e, res)) {
            ValDel(e, max);
            max = n;
            n = NULL;
        }
        IFZ(res);
        IFZ(n);
        IFZ(v);
    }
    RET_VAL(max);
exit:
    IFD(res);
    IFZ(n);
    IFD(max);
    IFD(v);
    return ret;    
}

bool_t isInt(number n) {
    return (floor(n) == n);
//    int in = (int) n;
//    int din = (number) in;
//    return (din == n);
}

bool_t isOddInt(number n) {
    if(!isInt(n)) return FALSE;
    int in = (int) n;
    return ((in % 2) != 0);
}

Val* Math_pow(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *a0 = GetArg(e, args, 0), *a1 = GetArg(e, args, 1);
    Val* xv = NULL, *yv = NULL;

    xv = ToNumber(e, a0);
    RET_IF_AB(xv);
    yv = ToNumber(e, a1);
    RET_IF_AB(yv);

    number x = xv->num;
    number y = yv->num;
    number r;

    if(x == 0) r = 1;
    else if(isnegzero(x)) r = 1;
    else if(isnan(x)) r = NAN;
    else if(isnan(x) && y != 0) r = NAN;
    else if(fabs(x) > 1 && y == +INFINITY) r = +INFINITY;
    else if(fabs(x) > 1 && y == -INFINITY) r = +0;
    else if(fabs(x) == 1 && y == +INFINITY) r = NAN;
    else if(fabs(x) == 1 && y == -INFINITY) r = NAN;
    else if(fabs(x) < 1 && y == +INFINITY) r = +0;
    else if(fabs(x) < 1 && y == -INFINITY) r = +INFINITY;
    else if(x == +INFINITY && y > 0) r = +INFINITY;
    else if(x == +INFINITY && y < 0) r = 0;
    else if(x == -INFINITY && y > 0 && isOddInt(y)) r = -INFINITY;
    else if(x == -INFINITY && y > 0 && !isOddInt(y)) r = +INFINITY;
    else if(x == -INFINITY && isOddInt(y)) r = -0;
    else if(x == -INFINITY && y < 0 && !isOddInt(y)) r = +0;
    else if(isposzero(x) && y > 0) r = +0;
    else if(isposzero(x) && y < 0) r = +INFINITY;
    else if(isnegzero(x) && y > 0 && isOddInt(y)) r = -0;
    else if(isnegzero(x) && y > 0 && !isOddInt(y)) r = +0;
    else if(isnegzero(x) && y < 0 && isOddInt(y)) r = -INFINITY;
    else if(isnegzero(x) && y < 0 && !isOddInt(y)) r = +INFINITY;
    else if(!isinf(x) && x < 0 && !isinf(y) && !isInt(y)) r = NAN;
    else r = pow(x, y);
    
    RET(ValNewNum(e, r));
exit:
    IFD(a0);
    IFD(a1);
    IFD(xv);
    IFD(yv);
    return ret;
}

Val* Math_random(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    number rm = (number) RAND_MAX;
    number r = (number) rand();
    return ValNewNum(e, r / rm);
}

STDFUNC(Math_round) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -INFINITY;
    else if(x > 0 && x < 0.5) r = +0;
    else if(x < 0 && x >= -0.5) r = -0;
    else if(x < 0 && !isInt(x)) r = round(x) + 1;
    else r = round(x);
    STDMATHPOST;
}

STDFUNC(Math_sign) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x < 0) r = -1;
    else r = 1;
    STDMATHPOST;
}

STDFUNC(Math_sin) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY || x == -INFINITY) r = NAN;
    else r = sin(x);
    STDMATHPOST;
}

STDFUNC(Math_sinh) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else if(x == -INFINITY) r = -INFINITY;
    else r = sinh(x);
    STDMATHPOST;
}

STDFUNC(Math_sqrt) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(x < 0) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = +INFINITY;
    else r = sqrt(x);
    STDMATHPOST;
}

STDFUNC(Math_tan) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY || x == -INFINITY) r = NAN;
    else r = tan(x);
    STDMATHPOST;
}

STDFUNC(Math_tanh) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = 1;
    else if(x == -INFINITY) r = -1;
    else r = tanh(x);
    STDMATHPOST;
}


STDFUNC(Math_trunc) {
    STDMATHPRE;
    if(isnan(x)) r = NAN;
    else if(isposzero(x)) r = +0;
    else if(isnegzero(x)) r = -0;
    else if(x == +INFINITY) r = 1;
    else if(x == -INFINITY) r = -1;
    else if(x > 0 && x < 1) r = +0;
    else if(x <0 && x > -1) r = -0;
    else r = trunc(x);
    STDMATHPOST;
}

NativeMethod Math_methods[] = {
    { "abs", Math_abs, 1},
    { "acos", Math_acos, 1},
    { "acosh", Math_acosh, 1},
    { "asin", Math_asin, 1},
    { "asinh", Math_asinh, 1},
    { "atan", Math_atan, 1},
    { "atanh", Math_atanh, 1},
    { "atan2", Math_atan2, 2},
    { "cbrt", Math_cbrt, },
    { "ceil", Math_ceil, 1},
    { "clz32", Math_clz32, 1},
    { "cos", Math_cos, 1},
    { "cosh", Math_cosh, 1},
    { "exp", Math_exp, 1},
    { "expm1", Math_expm1, 1},
    { "floor", Math_floor, 1},
    { "fround", Math_fround, 1},
    { "hypot", Math_hypot, 2},
    { "imul", Math_imul, 2},
    { "log", Math_log, 1},
    { "log1p", Math_log1p, 1},
    { "log10", Math_log10, 1},
    { "log2", Math_log2, 1},
    { "max", Math_max, 2},
    { "min", Math_min, 2},
    { "pow", Math_pow, 2},
    { "random", Math_random, 0},

    { "round", Math_round, 1},
    { "sign", Math_sign, 1},
    { "sin", Math_sin, 1},
    { "sinh", Math_sinh, 1},
    { "sqrt", Math_sqrt, 1},
    { "tan", Math_tan, 1},
    { "tanh", Math_tanh, 1},
    { "trunc", Math_trunc, 1},
};


/////// Date objects //////////
const number msPerDay = 86400000;
number Day(number t) {
    return floor(t / msPerDay);
}

number TimeWithinDay(number t) {
    return fmod(t, msPerDay);
}

int DaysInYear(int y) {
    if( (y % 4) != 0) return 365;
    if( (y % 4) == 0 && (y %100) != 0) return 366;
    if( (y %100) == 0 && (y % 400) != 0) return 365;
    if( (y % 400) == 0) return 366;
    return 365;
}

int DayFromYear(number y) {
    return 365 * (y - 1970) + floor((y-1969)/4) - floor((y-1901)/100) + floor((y-1601)/400);
}

number TimeFromYear(number y) {
    return msPerDay * (number) DayFromYear(y);
}

int YearFromTimeRange(int s, int e, int i, number t) {
    if(i < 1) 
        return s;
    for(int y = s; y <= e; y += i) {
        number yt = TimeFromYear(y);
        if(yt > t) {
            if(i == 1)
                return (y-1);
            return YearFromTimeRange(y-i, y, i/10, t);
        }
    }
    return e + 1;
}
int YearFromTime(number t) {
    int y = YearFromTimeRange(1000, 3000, 100, t);
    if(y <= 3000)
        return y;
    
    return YearFromTimeRange(-10000, 10000, 100, t);
}

int DayWithinYear(number t) {
    int d1 = Day(t);
    int y =YearFromTime(t);
    int d2 = DayFromYear(y);
    return d1 - d2;
}

int InLeapYear(number t) {
    return (DaysInYear(YearFromTime(t)) == 366);
}

int MonthFromTime(number t) {
    int d = DayWithinYear(t);
    int l = InLeapYear(t);

    if(d >= 0 && d < 31) return 0;
    if(d >= 31 && d < (59+l)) return 1;
    int r[] = { 59, 90+l, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
    int count = sizeof(r) / sizeof(int);
    for(int m = 0; m < count-1; m++) {
        if(d >= (r[m]+l) && d < (r[m+1] + l)) return m + 2;
    }
    assert(0);
}

int DateFromTime(number t) {
    int m = MonthFromTime(t);
    int d = DayWithinYear(t);
    int l = InLeapYear(t);

    switch(m) {
        case 0: return d +1;
        case 1: return d - 30;
        case 2: return d - 58 - l;
        case 3: return d - 89 - l;
        case 4: return d - 119 - l;
        case 5: return d - 150 - l;
        case 6: return d - 180 - l;
        case 7: return d - 211 - l;
        case 8: return d - 242 - l;
        case 9: return d - 272 - l;
        case 10: return d - 303 - l;
        case 11: return d - 333 - l;
    }
    assert(0);
}

// 0 = Sunday
int WeekDay(number t) {
    int di = (int) Day(t);
    return (di + 4) % 7;
}

const int HoursPerDay = 24;
const int MinutesPerHour = 60;
const int SecondsPerMinute = 60;
const int msPerSecond = 1000;
const int msPerMinute = msPerSecond * SecondsPerMinute;
const int msPerHour = msPerMinute * MinutesPerHour;


#include <time.h>
#include <sys/time.h>
number now() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    unsigned long long millisecondsSinceEpoch = (unsigned long long)(tv.tv_sec) * 1000 +
                                                (unsigned long long)(tv.tv_usec) / 1000;
    number n = (number) millisecondsSinceEpoch;
    return n;
}

number LocalTZA(Js* e) {
    if(!isnan(e->localTZA))
        return e->localTZA;
    struct timeval tv;
    struct timezone tz;
    gettimeofday(&tv, &tz);
    int secs = -tz.tz_minuteswest*60;
    number ret = (secs*msPerSecond);
    return ret;
}

number DaylightSavingTA(Js* e) {
    time_t local;
    struct tm result;
    localtime_r(&local, &result);
    return result.tm_isdst * 60 * 1000;
}

number LocalTime(Js* e, number t) {
    number dst = DaylightSavingTA(e);
    if(isnan(e->localTZA))
        dst =  0;
    return t + LocalTZA(e) + dst;
}

number UTC(Js* e, number t) {
    number dst = DaylightSavingTA(e);
    if(!isnan(e->localTZA))
        dst =  0;
    return t - LocalTZA(e) - dst;
}


int HourFromTime(number t) {
    return (int) fmod(floor(t / msPerHour), HoursPerDay);
}

int MinFromTime(number t) {
    return (int) fmod(floor(t / msPerMinute), MinutesPerHour);
}

int SecFromTime(number t) {
    return (int) fmod(floor(t/msPerSecond), SecondsPerMinute);
}

int msFromTime(number t) {
    return (int) fmod(t, msPerSecond);
}

number MakeTime(number h, number m, number s, number ms) {
    return h * msPerHour + m * msPerMinute + s * msPerSecond + ms;
}

int MakeDay(number year, number month, number date) {
    if(isinf(year) || isinf(month) || isinf(date))
        return NAN;
    int y = (int) year, m = (int) month, dt = (int) date;
    int ym = y + floor(month / 12);
    int mn = m % 12;
    number t = TimeFromYear(ym);
    int day;
    for(day = 0; day < 366; day++) {
        number t2 = t + day*msPerDay;
        int m2 = MonthFromTime(t2);
        if(m2 == mn) {
            return Day(t2) + dt - 1;
            
        }
    }
    return NAN;
}

number MakeDate(number day, number time) {
    if(isinf(day) || isinf(time))
        return NAN;
    return day * msPerDay + time;
}

number TimeClip(number t) {
    if(isinf(t))
        return NAN;

    if(fabs(t) > 8.64e15) return NAN;
    long int it = (long int) t;
    number nt = (number) it;
    return nt + (+0);
}


Val* ToDateString(Js* e, number t) {
    if(isnan(t))
        return ValNewStrA(e, "Invalid Date");

    number lt = LocalTime(e, t);
    int year = YearFromTime(lt);
    int month = MonthFromTime(lt);
    int date = DateFromTime(lt);
    char buff[255];
    int w = WeekDay(lt);
    int h = HourFromTime(lt);
    int m = MinFromTime(lt);
    int s = SecFromTime(lt);
//    int mi = msFromTime(lt);
    int tz = LocalTZA(e);
    int tzh = tz / 1000/60/60;
    char* sign = "+";
    if(tz < 0) {
        sign = "-";
        tzh = -tzh;
    }
    int tzm = (tz / 1000 / 60) % 60;
    char* days[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    sprintf(buff, "%s %s %d %d %02d:%02d:%02d GMT%s%02d%02d", days[w], months[month], date, year, h, m, s, sign, tzh, tzm);
    return ValNewStrA(e, buff);
}

bool_t ObjIsDateUninit(Js* e, Val* o) {
    if(o->type != TYPE_OBJ)
        return FALSE;
    if(!ObjectGetSlotRef(e, o->obj, _DateValue_))
        return FALSE;
    if(ObjectGetSlot(e, o->obj, _DateValue_)->type != TYPE_UNDEF)
        return FALSE;
    return TRUE;
}

Val* thisTimeValue(Js *e, Val* value) {
    if(value->type == TYPE_OBJ && ObjectGetSlotRef(e, value->obj, _DateValue_)) {
        Val* n = ObjectGetSlot(e, value->obj, _DateValue_);
        if(!ValIsUndef(n))
            return ValClone(e, n);
    }
    return ThrowTypeError(e, "not a date", 0, 0);
}

uchar getAt(uchar* p, int len, int pos) {
    if(pos >= len)
        return 0;
    return p[pos];
}

bool_t getNumber(Js* e, uchar* p, int len, int* ppos, int count, int* res) {
    int n = 0;
    int pos = *ppos;
    for(int i = 0; i < count; i++) {
        uchar c = getAt(p,len,pos+i);
        if(!c)
            return FALSE;
        if(c < '0' || c > '9')
            return FALSE;
        n = n * 10 + (c - '0');
    }
    *res = n;
    *ppos = (pos +count);
    return TRUE;
}


Val* DateParseString(Js* e, Val* v) {
    int YYYY=0, MM=0, DD=0, HH=0, mm=0, ss=0, sss=0;
    assert(v->type == TYPE_STR);
    uchar* p = v->str->chars;
    int len = v->str->length;
    int pos = 0;
    if(getAt(p, len, pos) == '+') {
        pos++;
        if(!getNumber(e, p, len, &pos, 6, &YYYY))    
            return ValNewNum(e, NAN);
    }
    else if(getAt(p, len, pos) == '-') {
        pos++;
        if(!getNumber(e, p, len, &pos, 6, &YYYY))    
            return ValNewNum(e, NAN);
        YYYY = -YYYY;
    }
    else if(!getNumber(e, p, len, &pos, 4, &YYYY))
        return ValNewNum(e, NAN);
    if(getAt(p, len, pos++) != '-')
        return ValNewNum(e, NAN);
    if(!getNumber(e, p, len, &pos, 2, &MM))
        return ValNewNum(e, NAN);
    if(getAt(p, len, pos++) != '-')
        return ValNewNum(e, NAN);
    if(!getNumber(e, p, len, &pos, 2, &DD))
        return ValNewNum(e, NAN);        
    if(getAt(p, len, pos++) != 'T')
        return ValNewNum(e, MakeDate(MakeDay(YYYY, MM-1, DD), MakeTime(HH, mm, ss, sss)));
    if(!getNumber(e, p, len, &pos, 2, &HH))
        return ValNewNum(e, NAN);
    if(getAt(p, len, pos++) != ':')
        return ValNewNum(e, MakeDate(MakeDay(YYYY, MM-1, DD), MakeTime(HH, mm, ss, sss)));
    if(!getNumber(e, p, len, &pos, 2, &mm))
        return ValNewNum(e, NAN);   
    if(getAt(p, len, pos++) != ':')
        return ValNewNum(e, MakeDate(MakeDay(YYYY, MM-1, DD), MakeTime(HH, mm, ss, sss)));
     if(!getNumber(e, p, len, &pos, 2, &ss))
        return ValNewNum(e, NAN);
    uchar c = getAt(p, len, pos);

    if(c != 'Z' && c != '+' && c != '-') {
        if(getAt(p, len, pos++) != '.')
            return ValNewNum(e, MakeDate(MakeDay(YYYY, MM-1, DD), MakeTime(HH, mm, ss, sss)));
         if(!getNumber(e, p, len, &pos, 3, &sss))
            return ValNewNum(e, NAN);   
    }
    int sign = 1;

    if(getAt(p, len, pos) == 'Z' || pos == len)
        return ValNewNum(e, MakeDate(MakeDay(YYYY, MM-1, DD), MakeTime(HH, mm, ss, sss)));
    else if(getAt(p, len, pos) != '+' && getAt(p, len, pos) != '-')
        return ValNewNum(e, NAN);
    if(getAt(p, len, pos) != '-')
        sign = -1;

    pos++;
    int ZH=0, ZM = 0;
    if(!getNumber(e, p, len, &pos, 2, &ZH))
        return ValNewNum(e, NAN);       
    if(getAt(p, len, pos++) != ':')
        return ValNewNum(e, NAN);           
    if(!getNumber(e, p, len, &pos, 2, &ZM))
        return ValNewNum(e, NAN);           

    number tza = sign * (ZH*MinutesPerHour*SecondsPerMinute*msPerSecond +
                     ZM*SecondsPerMinute*msPerSecond);
    number final = MakeDate(MakeDay(YYYY, MM-1, DD), MakeTime(HH, mm, ss, sss)) + (number) tza;
    return ValNewNum(e, final);
}

Val* DateCreateZero(Js* e, Val* o, Val* othis, Val* args, Val* newTarget)  {
    if(!ValIsUndef(newTarget)) {
        Val* O = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->datePrototype, 0);
        if(ValIsAbrupt(e, O))
            return O;
        ObjectSetSlot(e, O->obj, _DateValue_, ValNewNum(e, now()), TRUE, TRUE);
        return O;
    }
    return ToDateString(e, now());
}

Val* DateCreateOneArg(Js* e, Val* o, Val* othis, Val* args, Val* newTarget)  {
    Val* tv = NULL, *ret = NULL, *v = NULL, *value = GetArg(e, args, 0), *O = 0;
    assert(args->list->count == 1);
    if(!ValIsUndef(newTarget)) {
        if(value->type == TYPE_OBJ && ObjectGetSlotRef(e, value->obj, _DateValue_))
            tv = thisTimeValue(e, value);
        else {
            v = ToPrimitive(e, value, NULL);
            if(v->type == TYPE_STR) {
                tv = DateParseString(e, v);
            }
            else {
                tv = ToNumber(e, v);
            }
        }    
        RET_IF_AB(tv);
        O = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->datePrototype, 0);
        RET_IF_AB(O);
        ObjectSetSlot(e, O->obj, _DateValue_, ValNewNum(e, TimeClip(tv->num)), TRUE, TRUE);
        RET_VAL(O);
    }
    RET(ToDateString(e, now()));

exit:
    IFD(O);
    IFD(value);
    IFD(v);
    IFD(tv);
    return ret;
}

Val* DateConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* year = NULL, *month = NULL, *date = NULL, *hours = NULL, *minutes = NULL;
    Val* seconds = NULL, *ms = NULL;
    Val* y = NULL, *m = NULL, *dt = NULL, *h = NULL, *min = NULL, *s = NULL, *milli = NULL;
    Val* ret = NULL, *O = 0;
    int numArgs = args->list->count;
    if(numArgs == 0)
        return DateCreateZero(e, o, othis, args, newTarget);
    if(numArgs == 1)
        return DateCreateOneArg(e, o, othis, args, newTarget);
    if(numArgs < 2)
        RET(ThrowTypeError(e, "2 or more arguments expected", 0, 0));
    year = GetArg(e, args, 0);
    month = GetArg(e, args, 1);
    if(numArgs > 2) date = GetArg(e, args, 2);
    if(numArgs > 3) hours = GetArg(e, args, 3);
    if(numArgs > 4) minutes = GetArg(e, args, 4);
    if(numArgs > 5) seconds = GetArg(e, args, 5);
    if(numArgs > 6) ms = GetArg(e, args, 6);

    if(!ValIsUndef(newTarget)) {
        y = ToNumber(e, year);
        RET_IF_AB(y);
        m = ToNumber(e, month);
        RET_IF_AB(m);
        if(date) dt = ToNumber(e, date); else dt = ValNewNum(e, 1);
        RET_IF_AB(dt);
        if(hours) h = ToNumber(e, hours); else h = ValNewNum(e, 0);
        RET_IF_AB(h);
        if(minutes) min = ToNumber(e, minutes); else min = ValNewNum(e, 0);
        RET_IF_AB(min);
        if(seconds) s = ToNumber(e, seconds); else s = ValNewNum(e, 0);
        RET_IF_AB(s);
        if(ms) milli = ToNumber(e, ms); else milli = ValNewNum(e, 0);
        RET_IF_AB(milli);
        int yi = (int) y->num;
        number yr = yi;
        if(!isnan(y->num) && yi >= 0 && yi <= 99)
            yr = yi + 1900;
        number finalDate = MakeDate(MakeDay(yr, m->num, dt->num), MakeTime(h->num, min->num, s->num, milli->num));
        O = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->datePrototype, 0);
        RET_IF_AB(O);
        ObjectSetSlot(e, O->obj, _DateValue_, ValNewNum(e, UTC(e, finalDate)), TRUE, TRUE);
        RET_VAL(O);
    }
    RET(ToDateString(e, now()));

exit:
    IFD(O);
    IFD(year);
    IFD(month);
    IFD(date);
    IFD(hours);
    IFD(minutes);
    IFD(seconds);
    IFD(ms);
    IFD(y);
    IFD(m);
    IFD(dt);
    IFD(h);
    IFD(min);
    IFD(s);
    IFD(milli);
    return ret;    
}

Val* Date_now(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ValNewNum(e, now());
}


Val* Date_parse(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* s = GetArg(e, args, 0), *ret = NULL, *sarg = ToString(e, s);
    RET_IF_AB(sarg);
    if(ValIsUndef(s))
        RET(ValNewNum(e, NAN));
    RET(DateParseString(e, sarg));
exit:
    IFD(sarg);
    IFD(s);
    return ret;
}

Val* Date_UTC(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* year = NULL, *month = NULL, *date = NULL;
    Val* y = NULL, *m = NULL, *dt = NULL;
    Val* hours = NULL, *minutes = NULL, *seconds = NULL, *ms = NULL;
    Val* h = NULL, *min = NULL, *s = NULL, *milli = NULL;
    Val* ret = NULL;
    int ac = args->list->count;

    if(ac > 0) year = GetArg(e, args, 0);
    if(ac > 1) month = GetArg(e, args, 1);
    if(ac > 2) date = GetArg(e, args, 2);
    if(ac > 3) hours = GetArg(e, args, 3);
    if(ac > 4) minutes = GetArg(e, args, 4);
    if(ac > 5) seconds = GetArg(e, args, 5);
    if(ac > 6) ms = GetArg(e, args, 6);

    if(year) y = ToNumber(e, year); else y = ValNewNum(e, 1970);
    RET_IF_AB(y);
    if(month) m = ToNumber(e, month); else m = ValNewNum(e, 0);
    RET_IF_AB(m);
    if(date) dt = ToNumber(e, date); else dt = ValNewNum(e, 1);
    RET_IF_AB(dt);
    if(hours) h = ToNumber(e, hours); else h = ValNewNum(e, 0);
    RET_IF_AB(h);
    if(minutes) min = ToNumber(e, minutes); else min = ValNewNum(e, 0);
    RET_IF_AB(min);
    if(seconds) s = ToNumber(e, seconds); else s = ValNewNum(e, 0);
    RET_IF_AB(s);
    if(ms) milli = ToNumber(e, ms); else milli = ValNewNum(e, 0);

    int yi = (int) y->num;
    if(!isnan(y->num) && yi >= 0 && yi <= 99)
        yi = yi + 1900;
    RET(ValNewNum(e, TimeClip(MakeDate(MakeDay(yi,m->num,dt->num), MakeTime(h->num,min->num,s->num, milli->num)))));

exit:
    IFD(milli);
    IFD(s);
    IFD(min);
    IFD(h);
    IFD(ms);
    IFD(seconds);
    IFD(minutes);
    IFD(hours);
    IFD(dt);
    IFD(m);
    IFD(y);
    IFD(date);
    IFD(month);
    IFD(year);
    return ret;    
}

NativeMethod Date_methods[] = {
    { "now", Date_now, 0 },
    { "parse", Date_parse, 1 },
    { "UTC", Date_UTC, 7 },
};


#define DATEGETFUNC(n,f, l) Val* n(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) { \
    Val* t = thisTimeValue(e, othis);\
    if(ValIsAbrupt(e, t))\
        return t;\
    if(isnan(t->num))\
        return t;\
    Val* ret = ValNewNum(e, f(l(e, t->num)));\
    ValDel(e, t);\
    return ret;\
}

number nop0(number n) {
    return n;
}

number nop(Js* e, number n) {
    return n;
}

Val* Date_prototype_getTimezoneOffset(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) { 
    Val* t = thisTimeValue(e, othis);
    if(ValIsAbrupt(e, t))
        return t;
    if(isnan(t->num))
        return t;
    Val* ret = ValNewNum(e, (t->num - LocalTime(e, t->num)) / msPerMinute);
    ValDel(e, t);
    return ret;
}

DATEGETFUNC(Date_prototype_getDate, DateFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getDay, WeekDay, LocalTime);
DATEGETFUNC(Date_prototype_getFullYear, YearFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getHours, HourFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getMilliseconds, msFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getMinutes, MinFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getMonth, MonthFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getSeconds, SecFromTime, LocalTime);
DATEGETFUNC(Date_prototype_getTime, nop0, nop);

DATEGETFUNC(Date_prototype_getUTCDate, DateFromTime, nop);
DATEGETFUNC(Date_prototype_getUTCDay, WeekDay, nop);
DATEGETFUNC(Date_prototype_getUTCFullYear, YearFromTime, nop);
DATEGETFUNC(Date_prototype_getUTCHours, HourFromTime, nop);
DATEGETFUNC(Date_prototype_getUTCMilliseconds, msFromTime, nop);
DATEGETFUNC(Date_prototype_getUTCMinutes, MinFromTime, nop);
DATEGETFUNC(Date_prototype_getUTCMonth, MonthFromTime, nop);
DATEGETFUNC(Date_prototype_getUTCSeconds, SecFromTime, nop);

// Get argument value or NULL
Val* Arg(Js* e, Val* args, int index) {
    if(index >= args->list->count)
        return NULL;

    return GetArg(e, args, index);
}

Val* Date_prototype_set(Js* e, Val* obj, Val* year, Val* month, Val* date, Val* hours,  
                                         Val* minutes, Val* seconds, Val* milliseconds, 
                                         bool_t utc) {
    Val* ret = NULL;
    Val* y = NULL, *m = NULL, *dt = NULL, *h = NULL, *min = NULL, *s = NULL, *ms = NULL;

    Val* vt = thisTimeValue(e, obj);
    number t = vt->num;
    if(!utc) t = LocalTime(e, t);

    if(!year) year = ValNewNum(e, YearFromTime(t));
    if(!month) month = ValNewNum(e, MonthFromTime(t));
    if(!date) date = ValNewNum(e, DateFromTime(t));
    if(!hours) hours = ValNewNum(e, HourFromTime(t));
    if(!minutes) minutes = ValNewNum(e, MinFromTime(t));
    if(!seconds) seconds = ValNewNum(e, SecFromTime(t));
    if(!milliseconds) milliseconds = ValNewNum(e, msFromTime(t));

    y = ToNumber(e, year);
    RET_IF_AB(y);
    m = ToNumber(e, month);
    RET_IF_AB(m);
    dt = ToNumber(e, date);
    RET_IF_AB(dt);
    h = ToNumber(e, hours);
    RET_IF_AB(h);
    min = ToNumber(e, minutes);
    RET_IF_AB(min);
    s = ToNumber(e, seconds);
    RET_IF_AB(s);
    ms = ToNumber(e, milliseconds);
    RET_IF_AB(ms);

    number day = MakeDay(y->num, m->num, dt->num);
    number time = MakeTime(h->num, min->num, s->num, ms->num);
    number newDate = MakeDate(day, time);
    number u;
    if(utc)
        u = TimeClip(newDate);
    else
       u = TimeClip(UTC(e, newDate));
    ObjectSetSlot(e, obj->obj, _DateValue_, ValNewNum(e, u), TRUE, TRUE);
    RET(ValNewNum(e, u));

exit:
    IFD(y);
    IFD(m);
    IFD(dt);
    IFD(h);
    IFD(min);
    IFD(s);
    IFD(ms);
    IFD(vt);
    IFD(year);
    IFD(month);
    IFD(date);
    IFD(hours);
    IFD(minutes);
    IFD(seconds);
    IFD(milliseconds);
    return ret;    
}

#define A(n)    Arg(e,args,n)

Val* Date_prototype_setDate(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, A(0), 0, 0, 0, 0, FALSE);
}

Val* Date_prototype_setFullYear(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, A(0), A(1), A(2), 0, 0, 0, 0, FALSE);
}

Val* Date_prototype_setHours(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, A(0), A(1), A(2), A(3), FALSE);
}

Val* Date_prototype_setMilliseconds(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, 0, 0, 0, A(0), FALSE);
}

Val* Date_prototype_setMinutes(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, 0, A(0), A(1), A(2), FALSE);
}

Val* Date_prototype_setMonth(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, A(0), A(1), 0, 0, 0, 0, FALSE);
}

Val* Date_prototype_setSeconds(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, 0, 0, A(0), A(1), FALSE);
}


Val* Date_prototype_setTime(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *time = GetArg(e, args, 0), *t = NULL;

    t = ToNumber(e, time);
    RET_IF_AB(t);
    number v = TimeClip(t->num);
    ObjectSetSlot(e, othis->obj, _DateValue_, ValNewNum(e, v), TRUE, TRUE);
    RET(ValNewNum(e, v));
exit:
    IFD(time);
    IFD(t);    
    return ret;
}

Val* Date_prototype_setUTCDate(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, A(0), 0, 0, 0, 0, TRUE);
}

Val* Date_prototype_setUTCFullYear(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, A(0), A(1), A(2), 0, 0, 0, 0, TRUE);
}

Val* Date_prototype_setUTCHours(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, A(0), A(1), A(2), A(3), TRUE);
}

Val* Date_prototype_setUTCMilliseconds(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, 0, 0, 0, A(0), TRUE);
}

Val* Date_prototype_setUTCMinutes(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, 0, A(0), A(1), A(2), TRUE);
}

Val* Date_prototype_setUTCMonth(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, A(0), A(1), 0, 0, 0, 0, TRUE);
}

Val* Date_prototype_setUTCSeconds(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_set(e, othis, 0, 0, 0, 0, 0, A(0), A(1), TRUE);
}

Val* Date_prototype_toDateString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* tv = thisTimeValue(e, othis);
    if(ValIsAbrupt(e, tv))
        return tv;

    number t = tv->num;
    if(isnan(t)) {
        ValDel(e, tv);
        return ValNewStrA(e, "Invalid Date");
    }

    number lt = LocalTime(e, t);
    int year = YearFromTime(lt);
    int month = MonthFromTime(lt);
    int date = DateFromTime(lt);
    char buff[255];
    int w = WeekDay(lt);
    char* days[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    sprintf(buff, "%s %s %d %d", days[w], months[month], date, year);
    ValDel(e, tv);
    return ValNewStrA(e, buff);
}

Val* Date_prototype_toISOString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* tv = thisTimeValue(e, othis);
    if(ValIsAbrupt(e, tv)) {
        ValDel(e, tv);
        return tv;
    }

    number t = tv->num;
    if(isnan(t))
        return ValNewStrA(e, "Invalid Date");    
    if(isnan(t))
        return ValNewStrA(e, "Invalid Date");

    number lt = t;
    int year = YearFromTime(lt);
    int month = MonthFromTime(lt)+1;
    int date = DateFromTime(lt);
    char buff[255];
    int h = HourFromTime(lt);
    int m = MinFromTime(lt);
    int s = SecFromTime(lt);
    int mi = msFromTime(lt);
    sprintf(buff, "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ", year, month, date, h, m, s, mi);
    ValDel(e, tv);
    return ValNewStrA(e, buff);
}

Val* Date_prototype_toJSON(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *O = NULL, *tv = NULL, * n = ValNewNum(e, 0);
    Val* strToISOString = ValNewStrA(e, "toISOString");
    List* l = ListNew(e); 
    Val* a = ValNewList(e, l);

    O = ToObject(e, othis);
    tv = ToPrimitive(e, O, n);
    RET_IF_AB(tv);
    if(tv->type == TYPE_NUM && isinf(tv->num))
        RET(ValNewNull(e));
    ret = Invoke(e, O, strToISOString, a);
exit:
    IFD(a);
    IFD(strToISOString);
    IFD(n);
    IFD(O);
    IFD(tv);    
    return ret;
}

Val* Date_prototype_toLocaleDateString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_toDateString(e, o, othis, args, newTarget);
}


Val* Date_prototype_toLocaleTimeString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    char buff[255];
    Val* tv = thisTimeValue(e, othis);
    if(ValIsAbrupt(e, tv))
        return tv;

    number t = tv->num;
    ValDel(e, tv);
    if(isnan(t)) {
        return ValNewStrA(e, "Invalid Date");
    }
    t = LocalTime(e, t);
    sprintf(buff, "%02d:%02d:%02d", HourFromTime(t), MinFromTime(t), SecFromTime(t));
    return ValNewStrA(e, buff);
}

Val* Date_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    number tv = NAN;
    if(ObjectGetSlotRef(e, othis->obj, _DateValue_))
        tv = ObjectGetSlotRef(e, othis->obj, _DateValue_)->value->num;
    return ToDateString(e, tv);
}

Val* Date_prototype_toLocaleString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_toString(e, o,othis, args, newTarget);
}


Val* Date_prototype_toTimeString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_toLocaleTimeString(e, o, othis, args, newTarget);
}

Val* Date_prototype_toUTCString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
     number tv = NAN;
    if(ObjectGetSlotRef(e, othis->obj, _DateValue_))
        tv = UTC(e, ObjectGetSlotRef(e, othis->obj, _DateValue_)->value->num);
    return ToDateString(e, tv);
}

Val* Date_prototype_valueOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Date_prototype_getTime(e, o, othis, args, newTarget);
}

Val* Date_prototype_toPrimitive(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL;
    Val* tryFirst = NULL;
    Val* hint = GetArg(e, args, 0);

    if(othis->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object", 0, 0));

    if(ValIsUndef(hint) || ValEqStrA(e, hint, "default") || ValEqStrA(e, hint, "string")) 
        tryFirst = ValNewStrA(e, "string");
    else if(ValEqStrA(e, hint, "number"))
        tryFirst = ValNewStrA(e, "number");
    else
        RET(ThrowTypeError(e, "invalid hint", 0, 0));
    RET(OrdinaryToPrimitive(e, othis, tryFirst));

exit:
    IFD(hint);
    IFD(tryFirst);
    return ret;
}

NativeMethod Date_prototype_methods[] = {
    { "getDate", Date_prototype_getDate, 0 },
    { "getDay", Date_prototype_getDay, 0 },
    { "getFullYear", Date_prototype_getFullYear, 0 },
    { "getHours", Date_prototype_getHours, 0 },
    { "getMilliseconds", Date_prototype_getMilliseconds, 0 },
    { "getMinutes", Date_prototype_getMinutes, 0 },
    { "getMonth", Date_prototype_getMonth, 0 },
    { "getSeconds", Date_prototype_getSeconds, 0 },
    { "getTime", Date_prototype_getTime, 0 },
    { "getTimezoneOffset", Date_prototype_getTimezoneOffset, 0 },
    { "getUTCDate", Date_prototype_getUTCDate, 0 },
    { "getUTCDay", Date_prototype_getUTCDay, 0 },
    { "getUTCFullYear", Date_prototype_getUTCFullYear, 0 },
    { "getUTCHours", Date_prototype_getUTCHours, 0 },
    { "getUTCMilliseconds", Date_prototype_getUTCMilliseconds, 0 },
    { "getUTCMinutes", Date_prototype_getUTCMinutes, 0 },
    { "getUTCMonth", Date_prototype_getUTCMonth, 0 },
    { "getUTCSeconds", Date_prototype_getUTCSeconds, 0 },    
    { "setDate", Date_prototype_setDate, 1 },    
    { "setFullYear", Date_prototype_setFullYear, 3},    
    { "setHours", Date_prototype_setHours, 4},
    { "setMilliseconds", Date_prototype_setMilliseconds, 1},
    { "setMinutes", Date_prototype_setMinutes, 3},
    { "setMonth", Date_prototype_setMonth, 2},
    { "setSeconds", Date_prototype_setSeconds, 2},
    { "setTime", Date_prototype_setTime, 1},
    { "setUTCDate", Date_prototype_setUTCDate, 1 },    
    { "setUTCFullYear", Date_prototype_setUTCFullYear, 3},    
    { "setUTCHours", Date_prototype_setUTCHours, 4},
    { "setUTCMilliseconds", Date_prototype_setUTCMilliseconds, 1},
    { "setUTCMinutes", Date_prototype_setUTCMinutes, 3},
    { "setUTCMonth", Date_prototype_setUTCMonth, 2},
    { "setUTCSeconds", Date_prototype_setUTCSeconds, 2},   

    { "toDateString", Date_prototype_toDateString, 0},
    { "toISOString", Date_prototype_toISOString, 0},
    { "toJSON", Date_prototype_toJSON, 1},
    { "toLocaleDateString", Date_prototype_toLocaleDateString, 0},
    { "toLocaleString", Date_prototype_toLocaleString, 0},    
    { "toLocaleTimeString", Date_prototype_toLocaleTimeString, 0},
    { "toString", Date_prototype_toString, 0},
    { "toTimeString", Date_prototype_toTimeString, 0},
    { "toUTCString", Date_prototype_toUTCString, 0},
    { "valueOf", Date_prototype_valueOf, 0},
};



//////// String Methods
Val* SetLength(Js* e, Val* o, int length) {
    Val* vn = ValNewNum(e, length);
    Val* desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, vn);
    ValDel(e, vn);
    PropSetConfigurable(e, desc->desc, FALSE);
    PropSetWritable(e, desc->desc, FALSE);
    PropSetEnumerable(e, desc->desc, FALSE);
    Val* ret = DefinePropOrThrow(e, o, e->strLength, desc);    
    ValDel(e, desc);
    return ret;
}

Val* StringConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *value = Arg(e, args, 0), *s = NULL, *extensible = NULL;
    Val* status = NULL;

    if(!value) 
        s = ValNewStrA(e, "");
    else {
        if(ValIsUndef(newTarget) && value->type == TYPE_SYMA) 
            RET(SymbolDescriptiveString(e, value));
        s = ToString(e, value);
    }
    if(ValIsUndef(newTarget))
        RET_VAL(s);

    RET(StringCreate(e, CurrentRealm(e)->stringPrototype, s));

exit:    
    IFD(status);
    IFD(extensible);
    IFD(s);
    IFD(value);
    return ret;
}

Val* String_fromCharCode(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* code = NULL, *cu = NULL, *ret = NULL;
    int len = args->list->count;
    Str* str = StrNewLength(e, len);
    for(int i=0; i < len; i++) {
        code = GetArg(e, args, i);
        cu = ToUint16(e, code);
        RET_IF_AB(cu);
        str->chars[i] =  (uint16) cu->num;
        IFZ(code);
        IFZ(cu);
    }
    RET(ValNewStr(e, str));
exit:
    StrDel(e, str);
    IFD(code);
    IFD(cu);
    return ret;
}


Val* String_fromCodePoint(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* code = NULL, *cu = NULL, *ci = NULL, *ret = NULL;
    int len = args->list->count;
    DynStr* str = DynStrNew(e, len);
    for(int i=0; i < len; i++) {
        code = GetArg(e, args, i);
        cu = ToNumber(e, code);
        RET_IF_AB(cu);
        ci = ToInteger(e, cu);
        if(!ValIsTrueDel(e, SameValue(e, cu, ci))) 
            RET(ThrowRangeError(e, "integer conversion failed",0,0));
        if(cu->num < 0 || cu->num >= 0x10FFFF)
            RET(ThrowRangeError(e, "must be between 0 and 0x10ffff",0,0));
        uchar cu1, cu2;
        bool_t two = Utf16Encode((int32) cu->num, &cu1, &cu2);
        DynStrAdd(e, str, cu1);
        if(two)
            DynStrAdd(e, str, cu2);
        IFZ(ci);
        IFZ(code);
        IFZ(cu);
    }
    ret = StrFromDynStr(e, str);
    str = NULL;
exit:
    if(str)DynStrDel(e, str);
    IFD(ci);
    IFD(code);
    IFD(cu);
    return ret;
}

Val* String_raw(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *cooked = NULL, *rawValue = NULL, *raw = NULL;
    Val* literalSegments = NULL, *callSite = NULL, *len = NULL;
    Val* nextIndex = NULL, *nextKey = NULL, *next = NULL, *nextSeg = NULL;
    Val* nextSub = NULL;

    DynStr* stringElements = DynStrNew(e, 0);

    callSite = GetArg(e, args, 0);
    Item* substitutions = NULL;
    if(args->list->count > 0)
        substitutions = args->list->head->next;
    int numberOfSubsitutions = args->list->count - 1;
    cooked = ToObject(e, callSite);
    RET_IF_AB(cooked);
    rawValue = GetA(e, cooked, "raw");
    raw = ToObject(e, rawValue);
    RET_IF_AB(raw);
    len = GetA(e, raw, "length");
    literalSegments = ToLength(e, len);
    RET_IF_AB(literalSegments);
    if(literalSegments <= 0)
        RET(ValNewStrA(e, ""));
    nextIndex = ValNewNum(e, 0);
    while(TRUE) {
        nextKey = ToString(e, nextIndex);
        next = Get(e, raw, nextKey);
        nextSeg = ToString(e, next);
        RET_IF_AB(nextSeg);
        DynStrAddStr(e, stringElements, nextSeg->str);
        if(nextIndex->num + 1 == literalSegments->num) {
            ret = StrFromDynStr(e, stringElements);
            stringElements = NULL;
            goto exit;
        }
        IFZ(next);
        if(nextIndex->num < numberOfSubsitutions) {
            next = ValClone(e, substitutions->value);
            substitutions = substitutions->next;
        }
        else {
            next = ValNewStrA(e, "");
        }
        nextSub = ToString(e, next);
        RET_IF_AB(nextSub);
        DynStrAddStr(e, stringElements, nextSub->str);
        IFZ(next);
        IFZ(nextSub);
        IFZ(nextSeg);
        IFZ(nextKey);
        nextIndex->num++;
    }


exit:
    IFD(nextSub);
    IFD(nextSeg);
    IFD(nextIndex);
    IFD(nextKey);
    IFD(next);
    IFD(len);
    IFD(callSite);
    IFD(cooked);
    IFD(rawValue);
    IFD(raw);
    IFD(literalSegments);
    if(stringElements) DynStrDel(e, stringElements);
    return ret;    
}

NativeMethod String_methods[] = {
    { "fromCharCode", String_fromCharCode, 1},
    { "fromCodePoint", String_fromCodePoint, 1},
    { "raw", String_raw, 1}
};


Val* thisStringValue(Js* e, Val* value) {
    if(value->type == TYPE_STR) 
        return ValClone(e, value);
    if(value->type == TYPE_OBJ && ObjectGetSlotRef(e, value->obj, _StringData_)) {
        Val* s = ObjectGetSlotRef(e, value->obj, _StringData_)->value;
        if(!ValIsUndef(s))
            return ValClone(e, s);
    }
    return ThrowTypeError(e, "not a string", 0, 0);
}

Val* String_prototype_charAt(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *S = NULL, *pos = GetArg(e, args, 0), *position = NULL, *ret = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    position = ToInteger(e, pos);
    RET_IF_AB(position);
    int size = S->str->length;
    if(position->num < 0 || position->num >= size)
        RET(ValNewStrA(e, ""));
    Str* s = StrNewLength(e, 1);
    s->chars[0] = S->str->chars[(int) position->num];
    ret = ValNewStr(e, s);
    StrDel(e, s);

exit:
    IFD(O);
    IFD(S);
    IFD(pos);
    IFD(position);
    return ret;    
}



Val* String_prototype_charCodeAt(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *S = NULL, *pos = GetArg(e, args, 0), *position = NULL, *ret = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    position = ToInteger(e, pos);
    RET_IF_AB(position);
    int size = S->str->length;
    if(position->num < 0 || position->num >= size)
        RET(ValNewNum(e, NAN));
    RET(ValNewNum(e, S->str->chars[(int) position->num]));

exit:
    IFD(O);
    IFD(S);
    IFD(pos);
    IFD(position);
    return ret;    
}

Val* String_prototype_codePointAt(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *S = NULL, *pos = GetArg(e, args, 0), *position = NULL, *ret = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    position = ToInteger(e, pos);
    RET_IF_AB(position);
    int size = S->str->length;
    int ipos = (int) position->num;
    if(ipos < 0 || ipos >= size)
        RET(ValNewNum(e, NAN));
    uchar first = S->str->chars[ipos];
    uchar second;
    if(first < 0xD800 || first > 0xDBFF || (ipos+1) == size)
        RET(ValNewNum(e, first));
    second = S->str->chars[ipos+1];
    uint32 uf = (uint32) first;
    uint32 us = (uint32) second;
    uint32 cp = ((uf - 0xD800) * 1024) + (us - 0xDC00) + 0x10000;
    RET(ValNewNum(e, cp));

exit:
    IFD(O);
    IFD(S);
    IFD(pos);
    IFD(position);
    return ret;    
}

Val* String_prototype_concat(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *O = NULL, *S = NULL, *nextString = NULL;
    DynStr* ds = NULL;
    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    ds = DynStrNew(e, S->str->length*2);
    DynStrAddStr(e, ds, S->str);
    for(Item* a = args->list->head; a; a = a->next) {
        nextString = ToString(e, a->value);
        RET_IF_AB(nextString);
        DynStrAddStr(e, ds, nextString->str);
        IFZ(nextString);
    }
    ret = StrFromDynStr(e, ds);
    ds = NULL;

exit:
    IFD(nextString);
    IFD(O);
    IFD(S);
    if(ds) DynStrDel(e, ds);
    return ret;    
}
int min(int i1, int i2) {
    if(i1 < i2) return i1;
    return i2;
}

int max(int i1, int i2) {
    if(i1 > i2) return i1;
    return i2;
}

Val* String_prototype_contains(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *O = NULL, *S = NULL, *searchString = GetArg(e, args, 0);
    Val* isRegExp = NULL, *getRegExp = NULL, *searchStr = NULL, *position = NULL, *pos = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    if(searchString->type == TYPE_OBJ) {
        getRegExp = Get(e, searchString, e->isRegExp);
        isRegExp = ToBoolean(e, getRegExp);
        RET_IF_AB(isRegExp);
        if(ValIsTrue(e, isRegExp))
            RET(ThrowTypeError(e, "regular expression not allowed", 0,0));
    }
    searchStr = ToString(e, searchString);
    RET_IF_AB(searchStr);
    position = GetArg(e, args, 1);
    if(ValIsUndef(position))
        pos = ValNewNum(e, 0);
    else
        pos = ToInteger(e, position);
    RET_IF_AB(pos);
    int len = S->str->length;
    int start = min(max(pos->num, 0), len);
    int searchLen = searchStr->str->length;
    for(int k = start; (k + searchLen) < len; k++) {
        bool_t found = TRUE;
        for(int i=0; i < searchLen; i++) {
            if(S->str->chars[k+i] != searchStr->str->chars[i]) {
                found = FALSE;
                break;
            }
        }
        if(found)
            RET(ValNewBool(e, TRUE));
    }
    RET(ValNewBool(e, FALSE));

exit:
    IFD(O);
    IFD(S);
    IFD(searchStr);
    IFD(searchString);
    IFD(isRegExp);
    IFD(getRegExp);
    IFD(pos);
    IFD(position);
    return ret;    
}

Val* String_prototype_endsWith(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *O = NULL, *S = NULL, *searchString = GetArg(e, args, 0);
    Val* isRegExp = NULL, *getRegExp = NULL, *searchStr = NULL, *endPosition = NULL, *pos = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    if(searchString->type == TYPE_OBJ) {
        getRegExp = Get(e, searchString, e->isRegExp);
        isRegExp = ToBoolean(e, getRegExp);
        RET_IF_AB(isRegExp);
        if(ValIsTrue(e, isRegExp))
            RET(ThrowTypeError(e, "regular expression not allowed", 0, 0));
    }
    searchStr = ToString(e, searchString);
    int len = S->str->length;
    RET_IF_AB(searchStr);
    endPosition = GetArg(e, args, 1);
    if(ValIsUndef(endPosition))
        pos = ValNewNum(e, len);
    else
        pos = ToInteger(e, endPosition);
    RET_IF_AB(pos);
    int end = min(max(pos->num, 0), len);
    int searchLen = searchStr->str->length;
    int start = end  - searchLen;
    if(start < 0)
        RET(ValNewBool(e, FALSE));
    for(int k = start; (k + searchLen) <= end; k++) {
        bool_t found = TRUE;
        for(int i=0; i < searchLen; i++) {
            if(S->str->chars[k+i] != searchStr->str->chars[i]) {
                found = FALSE;
                break;
            }
        }
        if(found)
            RET(ValNewBool(e, TRUE));
    }
    RET(ValNewBool(e, FALSE));

exit:
    IFD(O);
    IFD(S);
    IFD(searchStr);
    IFD(searchString);
    IFD(isRegExp);
    IFD(getRegExp);
    IFD(pos);
    IFD(endPosition);
    return ret;    
}


Val* String_prototype_coreIndexOf(Js* e, Val* o, Val* othis, Val* args, bool_t getMax) {
    Val* ret = NULL, *searchString = GetArg(e, args, 0), *position = GetArg(e, args, 1);
    Val* O = NULL, *pos = NULL, *S = NULL, *searchStr = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    searchStr = ToString(e, searchString);
    RET_IF_AB(searchStr);
    pos = (ValIsUndef(position)) ? ValNewNum(e, 0) : ToInteger(e, position);
    RET_IF_AB(pos);
    int ipos = (int) pos->num;
    int len = S->str->length;
    int start = min(max(ipos, 0), len);
    int searchLen = searchStr->str->length;
    int maxFound = -1;

    for(int k = start; (k+searchLen) <= len; k++) {
        bool_t found = TRUE;
        for(int i=0; i < searchLen; i++) {
            if(S->str->chars[k+i] != searchStr->str->chars[i]) {
                found = FALSE;
                break;
            }
        }
        if(found) {
            if(!getMax)
                RET(ValNewNum(e, k));
            maxFound = k;
        }
        
    }
    RET(ValNewNum(e, maxFound));

exit:
    IFD(O);
    IFD(S);
    IFD(searchString);
    IFD(searchStr);
    IFD(position);
    IFD(pos);
    return ret;
}

Val* IsRegExp(Js* e, Val* argument) {
    Val* ret = 0, *isRegExp = 0;

    if(!ValIsObject(argument))
        RET(ValNewBool(e, FALSE));
    isRegExp = Get(e, argument, e->match);
    RET_IF_AB(isRegExp);
    if(!ValIsUndef(isRegExp))
        RET(ToBoolean(e, isRegExp));
    if(ObjectGetSlotRef(e, argument->obj, _RegExpMatcher_))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));
exit:
    IFD(isRegExp);
    return ret;
}

Val* String_prototype_includes(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *O = RequireObjectCoercible(e, othis), *searchString = GetArg(e, args, 0);
    Val* position = GetArg(e, args, 1), *S = 0, *searchStr = 0, *pos = 0;
    Val* isRegExp = 0;

    S = ToString(e, O);
    RET_IF_AB(S);
    isRegExp = IsRegExp(e, searchString);
    RET_IF_AB(isRegExp);
    if(ValIsTrue(e, isRegExp))
        RET(ThrowTypeError(e, "regular expression not allowed",0,0));
    searchStr = ToString(e, searchString);
    RET_IF_AB(searchStr);
    pos = ToInteger(e, position);
    RET_IF_AB(pos);
    int len = S->str->length;
    int start = min(max(pos->num, 0), len);
    int searchLen = searchStr->str->length;

    for(int k = start; (k+searchLen) <= len; k++) {
        bool_t found = TRUE;
        for(int i=0; i < searchLen; i++) {
            if(S->str->chars[k+i] != searchStr->str->chars[i]) {
                found = FALSE;
                break;
            }
        }
        if(found) {
            RET(ValNewBool(e, TRUE));
        }
        
    }
    RET(ValNewBool(e, FALSE));

exit:
    IFD(isRegExp);
    IFD(O);
    IFD(searchString);
    IFD(position);
    IFD(S);
    IFD(searchStr);
    IFD(pos);
    return ret;    
}

Val* String_prototype_indexOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return String_prototype_coreIndexOf(e, o, othis, args, FALSE);
}

Val* String_prototype_lastIndexOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return String_prototype_coreIndexOf(e, o, othis, args, TRUE);
}

// @todo - use platform API
int Platform_LocalCompare(uchar* s1, int l1, uchar* s2, int l2) {
    if(l1 < l2)
        return (l1 -l2);
    if(l1 > l2)
        return (l1 - l2);
    for(int i=0; i < l1; i++) {
        uchar c1 = s1[i];
        uchar c2 = s2[i];
        if(c1 < c2)
            return (c1 -c2);
        if(c1 > c2)
            return (c1 - c2);        
    }
    return 0;
}

// @todo use Platform API
uchar Platform_toLowerChar(Js* e, uchar c) {
    if(c >= 'A' && c <= 'Z')
        return (c + 'a' - 'A');
    return c;
}

uchar Platform_toLocaleLowerChar(Js* e, uchar c) {
    return Platform_toLowerChar(e, c);      // @todo
}


// @todo use Platform API
uchar Platform_toUpperChar(Js* e, uchar c) {
    if(c >= 'a' && c <= 'z')
        return (c + 'A' - 'a');
    return c;
}

uchar Platform_toLocaleUpperChar(Js* e, uchar c) {
    return Platform_toUpperChar(e, c);      // @todo
}

Val* String_prototype_localeCompare(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *S = NULL, *that = GetArg(e, args, 0), *That = NULL, *ret = NULL;

    O = RequireObjectCoercible(e, othis);
    S = ToString(e, O);
    RET_IF_AB(S);
    That = ToString(e, that);
    RET_IF_AB(That);
    int res = Platform_LocalCompare(S->str->chars, S->str->length, That->str->chars, That->str->length);
    RET(ValNewNum(e, res));
exit:
    IFD(O);
    IFD(S);
    IFD(that);
    IFD(That);
    return ret;    
}
Val* RegExpCreate(Js* e, Val* body, Val* flags);
Val* Call1(Js* e, Val* target, Val* othis, Val* a1);
Val* String_prototype_match(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *regexp = GetArg(e, args, 0);
    Val* ret = NULL, *rx = NULL, *flags = ValNew(e);
    Val* matcher = 0;

    RET_IF_AB(S);
    if(regexp->type == TYPE_OBJ) {
        matcher = GetMethod(e, regexp, e->match);
        RET_IF_AB(matcher);
        if(!ValIsUndef(matcher))
            RET(Call1(e, matcher, regexp, O));
    }
    else
        rx = RegExpCreate(e, regexp, flags);
    RET_IF_AB(rx);
    List* l = ListNew(e);
    ListAddValue(e, l, ValClone(e, S));
    Val* a = ValNewList(e, l);
    ret = Invoke(e, rx, e->match, a);
    ValDel(e, a);
exit:
    IFD(matcher);
    IFD(O);
    IFD(S);
    IFD(regexp);
    IFD(rx);
    IFD(flags);
    return ret;
}

Val* Platform_normalizeString(Js* e, Val* source) {
    return ValClone(e, source);     // @todo: Use platform API
}

Val* String_prototype_normalize(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *form = Arg(e, args, 0), 
         *f = NULL, *ret = NULL;

    RET_IF_AB(S);
    if(!form)
        form = ValNewStrA(e, "NFC");
     f = ToString(e, form);
     RET_IF_AB(f);
     if(! (ValEqStrA(e, f, "NFC") || ValEqStrA(e, f, "NFD") || ValEqStrA(e ,f, "NFKC") || ValEqStrA(e, f, "NFKD")))
        RET(ThrowRangeError(e, "NFC, NFD, NKFC, or NKFD expected",0,0));
    ret = Platform_normalizeString(e, S);
exit:
    IFD(O);
    IFD(S);
    IFD(form);
    IFD(f);
    return ret;    
}

Val* String_prototype_repeat(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *count = GetArg(e, args, 0),
             *ret = NULL, *n = NULL;
    DynStr* ds = NULL;
    RET_IF_AB(S);
    n = ToInteger(e, count);
    RET_IF_AB(n);
    if(n->num < 0) 
        RET(ThrowRangeError(e, "must be >= 0", 0,0));
    if(n->num == INFINITY)
        RET(ThrowRangeError(e, "infinity not allowed",0,0));
    int in = (int) n->num;
    ds = DynStrNew(e, S->str->length * in);
    for(int i=0; i < in; i++) 
        DynStrAddStr(e, ds, S->str);

    ret = StrFromDynStr(e, ds);
    ds = NULL;
exit:
    IFD(O);
    IFD(S);
    IFD(count);
    IFD(n);
    if(ds) DynStrDel(e, ds);
    return ret;
}

Val* Invoke2(Js* e, Val* target, char* method, Val* a1, Val* a2) {
    Val* name = ValNewStrA(e, method);
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    ListAddValue(e, al, ValClone(e, a2));
    Val* a = ValNewList(e, al);
    Val* ret = Invoke(e, target, name, a);
    ValDel(e, a);
    ValDel(e, name);
    return ret;
}

Val* Invoke1(Js* e, Val* target, char* method, Val* a1) {
    Val* name = ValNewStrA(e, method);
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    Val* a = ValNewList(e, al);
    Val* ret = Invoke(e, target, name, a);
    ValDel(e, a);
    ValDel(e, name);
    return ret;
}

Val* Invoke0(Js* e, Val* target, char* method) {
    Val* name = ValNewStrA(e, method);
    List* al = ListNew(e);
    Val* a = ValNewList(e, al);
    Val* ret = Invoke(e, target, name, a);
    ValDel(e, a);
    ValDel(e, name);
    return ret;
}

Val* Construct1(Js* e, Val* othis, Val* a1, Val* newTarget) {
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    Val* a = ValNewList(e, al);    
    Val* ret = Construct(e, othis, a, NULL);
    ValDel(e, a);
    return ret;
}

Val* Construct2(Js* e, Val* othis, Val* a1, Val* a2) {
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    ListAddValue(e, al, ValClone(e, a2));
    Val* a = ValNewList(e, al);    
    Val* ret = Construct(e, othis, a, NULL);
    ValDel(e, a);
    return ret;
}

Val* Construct3(Js* e, Val* othis, Val* a1, Val* a2, Val* a3) {
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    ListAddValue(e, al, ValClone(e, a2));
    ListAddValue(e, al, ValClone(e, a3));
    Val* a = ValNewList(e, al);    
    Val* ret = Construct(e, othis, a, NULL);
    ValDel(e, a);
    return ret;
}
Val* Call0(Js* e, Val* target, Val* othis) {
    Val* o = (othis) ? ValClone(e, othis) : ValNew(e);
    List* al = ListNew(e);
    Val* a = ValNewList(e, al);    
    Val* ret = DoCall(e, target, o, a);
    ValDel(e, o);
    ValDel(e, a);
    return ret;
}

Val* Call1(Js* e, Val* target, Val* othis, Val* a1) {
    Val* o = (othis) ? ValClone(e, othis) : ValNew(e);
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    Val* a = ValNewList(e, al);    
    Val* ret = DoCall(e, target, o, a);
    ValDel(e, o);
    ValDel(e, a);
    return ret;
}


Val* Call2(Js* e, Val* target, Val* othis, Val* a1, Val* a2) {
    Val* o = (othis) ? ValClone(e, othis) : ValNew(e);
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    ListAddValue(e, al, ValClone(e, a2));
    Val* a = ValNewList(e, al);    
    Val* ret = DoCall(e, target, o, a);
    ValDel(e, o);
    ValDel(e, a);
    return ret;
}

Val* Call3(Js* e, Val* target, Val* othis, Val* a1, Val* a2, Val* a3) {
    Val* o = (othis) ? ValClone(e, othis) : ValNew(e);
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    ListAddValue(e, al, ValClone(e, a2));
    ListAddValue(e, al, ValClone(e, a3));
    Val* a = ValNewList(e, al);    
    Val* ret = DoCall(e, target, o, a);
    ValDel(e, o);
    ValDel(e, a);
    return ret;
}

Val* Call4(Js* e, Val* target, Val* othis, Val* a1, Val* a2, Val* a3, Val* a4) {
    Val* o = (othis) ? ValClone(e, othis) : ValNew(e);
    List* al = ListNew(e);
    ListAddValue(e, al, ValClone(e, a1));
    ListAddValue(e, al, ValClone(e, a2));
    ListAddValue(e, al, ValClone(e, a3));
    ListAddValue(e, al, ValClone(e, a4));
    Val* a = ValNewList(e, al);    
    Val* ret = DoCall(e, target, o, a);
    ValDel(e, o);
    ValDel(e, a);
    return ret;
}

Val* EmptyList(Js* e) {
    List* l = ListNew(e);
    return ValNewList(e, l);
}


Val* GetReplaceSubstitution(Js* e, Val* matched, Val* string, int position, Val* captures, Val* replacement) {
    assert(matched->type == TYPE_STR);
    int matchLength = matched->str->length;
    assert(string->type == TYPE_STR);
    int stringLength = string->str->length;
    assert(position <= string->str->length);
    assert(replacement->type == TYPE_STR);
    int tailPos  = position + matchLength;
    DynStr* result = DynStrNew(e, string->str->length + replacement->str->length);  // guestimate
    for(int i = 0; i < replacement->str->length; i++) {
        uchar c1 = replacement->str->chars[i];
        uchar c2 = 0;
        if(i < (replacement->str->length-1))
            c2 = replacement->str->chars[i+1];
        if(c1 != '$') 
            DynStrAdd(e, result, c1);
        else {
            if(c2 == '$') {
                DynStrAdd(e, result, '$');
                i++;
            }
            else if(c2 == '&') {
                DynStrAddStr(e, result, matched->str);
                i++;
            }
            else if(c2 == '`') {
                if(position == 0)
                    i++;
                else {
                    for(int j=0; j < position; j++) 
                        DynStrAdd(e, result, string->str->chars[j]);
                    i++;
                }
            }
            else if(c2 == '\'') {
                if(tailPos >= stringLength) 
                    i++;
                else {
                    for(int j=tailPos; j < string->str->length; j++)
                        DynStrAdd(e, result, string->str->chars[j]);
                    i++;
                }
            }
            else { 
                uchar c3 = 0;
                if(i < (replacement->str->length -2))
                    c3 = replacement->str->chars[i+2];
                int n = -1;
                if(c2 >= '0' && c2 <= '9' && c3 >= '0' && c3 <= '9') {
                    n = (c2 - '0') * 10 + (c3 - '0');
                    i += 2;
                }
                else if(c2 >= '1' && c2 <= '9') {
                    n = c2 - '0';
                    i++;
                }
                if(n >= 0) {
                    Val* cap = GetArg(e, captures, n-1);
                    DynStrAddStr(e, result, cap->str);
                    ValDel(e, cap);
//                    i++;
                }
            }
        }
    }
    return StrFromDynStr(e, result);
}

Val* String_prototype_replace(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *string = ToString(e, O), *searchValue = GetArg(e, args, 0);
    Val* replaceValue = GetArg(e, args, 1), *functionalReplace = NULL, *searchString = NULL;
    Val* ret = NULL, *matched = NULL, *replValue = NULL, *replStr = NULL, *captures = NULL;
    DynStr* newString = NULL;
    Val *replacer = 0;

    RET_IF_AB(string);

    if(ValIsObject(searchValue)) {  // @todo: Convert to object?
        replacer = GetMethod(e, searchValue, e->replace);
        RET_IF_AB(replacer);
        if(!ValIsUndef(replacer)) 
            RET(Call2(e, replacer, searchValue, O, replaceValue));
    }
    // if(searchValue->type == TYPE_OBJ && ValIsTrueDel(e, HasProp(e, searchValue, e->isRegExp)))
    //     RET(Invoke2(e, searchValue, "replace", string, replaceValue));
    searchString = ToString(e, searchValue);
    RET_IF_AB(searchString);
    functionalReplace = IsCallable(e, replaceValue);
    if(!ValIsTrue(e, functionalReplace)) {
        Val* rv = ToString(e, replaceValue);
        ValDel(e, replaceValue);
        replaceValue = rv;
        RET_IF_AB(replaceValue);
    }
    int pos = -1;
    for(pos =0; (pos+searchString->str->length) <= string->str->length; pos++) {
        bool_t found = TRUE;
        for(int i=0; i < searchString->str->length; i++) {
            if(searchString->str->chars[i] != string->str->chars[pos+i]) {
                found = FALSE;
                break;
            }
        }
        if(found)
            break;
    }
    matched = ValClone(e, searchString);
    int count = matched->str->length;;

    if(pos < 0)
        RET_VAL(string);
    if(ValIsTrue(e, functionalReplace)) {
        Val* posVal = ValNewNum(e, pos);
        replValue = Call3(e, replaceValue, NULL, matched, posVal, string);
        ValDel(e, posVal);
        replStr = ToString(e, replValue);
        RET_IF_AB(replStr);
    }
    else {
        captures = EmptyList(e);
        replStr = GetReplaceSubstitution(e, matched, string, pos, captures, replaceValue);
    }
    int tailPos = pos + count;
    newString = DynStrNew(e, pos + replStr->str->length + (string->str->length-tailPos));
    for(int i=0; i < pos; i++) 
        DynStrAdd(e, newString, string->str->chars[i]);
    DynStrAddStr(e, newString, replStr->str);
    for(int i=tailPos; i < string->str->length; i++)
        DynStrAdd(e, newString, string->str->chars[i]);
    ret = StrFromDynStr(e, newString);
    newString = NULL;

exit:
    IFD(replacer);
    IFD(captures);
    IFD(replStr);
    IFD(replValue);
    IFD(O);
    IFD(searchValue);
    IFD(replaceValue);
    IFD(string);
    IFD(functionalReplace);
    IFD(searchString);
    IFD(matched);
    if(newString) DynStrDel(e, newString);
    return ret;    
}

Val* String_prototype_search(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *string = ToString(e, O), *regexp = GetArg(e, args, 0);
    Val* ret = NULL, *rx = NULL;
    RET_IF_AB(string);
    if(regexp->type == TYPE_OBJ && ValIsTrueDel(e, HasProp(e, regexp, e->isRegExp)))
        rx = ValClone(e, regexp);
    else
        rx = RegExpCreate(e, regexp, NULL);
    RET_IF_AB(rx);
    RET(Invoke1(e, rx, "search", string));

exit:
    IFD(O);
    IFD(string);
    IFD(regexp);
    IFD(rx);
    return ret;
}

Val* String_prototype_slice(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *ret= NULL;
    Val* start = GetArg(e, args, 0), *end = GetArg(e, args, 1), *intStart = NULL, *intEnd = NULL;

    RET_IF_AB(S);
    int len = S->str->length;
    intStart = ToInteger(e, start);
    if(ValIsUndef(end)) 
        intEnd = ValNewNum(e, len);
    else 
        intEnd = ToInteger(e, end);
    int from, to;
    if(intStart->num < 0) 
        from = max(len + intStart->num, 0);
    else
        from = min(intStart->num, len);
    if(intEnd < 0)
        to = max(len + intEnd->num, 0);
    else
        to = min(intEnd->num, len);
    int span = max(to - from, 0);
    Str* s = StrNewLength(e, span);
    for(int i=0; i < span; i++) 
        s->chars[i] = S->str->chars[from+i];
    ret = ValNewStr(e, s);
    StrDel(e, s);
    
exit:
    IFD(O);
    IFD(S);
    IFD(start);
    IFD(end);
    IFD(intStart);
    IFD(intEnd);
    return ret;    
}

Val* ValFromStr(Js* e, Str* s) {
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s;
    return v;
}


int  SplitMatch(Js* e, Val* S, int q, Val* R) {
    int r = R->str->length;
    int s = S->str->length;
    if(q+r > s)
        return 0;
    for(int i=0; i < r; i++) {
        if(S->str->chars[q+i] != R->str->chars[i])
            return 0;
    }
    return q+r;
}

void CreateDataPropA(Js* e, Val* obj, int index, Val* v) {
    Val* n = ValNewNum(e, index);
    Val* s = ToString(e, n);
    Val* r = CreateDataProp(e, obj, s, v);
    ValDel(e, s);
    ValDel(e, n);
    ValDel(e, r);
    ValDel(e, v);
}

Val* String_prototype_split(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *separator = GetArg(e, args, 0), *limit = GetArg(e, args, 1);
    Val* S = NULL, *A = NULL, *ret = NULL, *lim = NULL, *R = NULL, *splitter = 0;
    Val* zero = ValNewStrA(e, "0");

    RET_IF_AB(O);
    if(separator->type == TYPE_OBJ) {
        splitter = GetMethod(e, separator, e->split);
        RET_IF_AB(splitter);
        if(!ValIsUndef(splitter))
            RET(Call2(e, splitter, separator, O, limit));
    }
    S = ToString(e, O);
    RET_IF_AB(S);
    A = ArrayCreate(e, NULL, 0);
    int lengthA = 0;
    if(ValIsUndef(limit)) 
        lim = ValNewNum(e, pow(2, 53) - 1);
    else
        lim = ToLength(e, limit);
    int s = S->str->length;
    int p = 0;
    R = ToString(e, separator);
    RET_IF_AB(R);
    if(lim->num == 0)
        RET_VAL(A);
    if(ValIsUndef(separator)) {
        ValDel(e, CreateDataProp(e, A, zero, S));
        RET_VAL(A);
    }
    if(s == 0) {
        int z = SplitMatch(e, S, 0, R);
        if(!z)
            RET_VAL(A);
        ValDel(e, CreateDataProp(e, A, zero, S));
        RET_VAL(A);
    }
    int q = p;
    while(q != s) {
        int ee = SplitMatch(e, S, q, R);
        if(!ee)
            q = q + 1;
        else {
            if(ee == p)
                q = q + 1;
            else {
                Str* st = StrNewLength(e, q-p);
                for(int i=p; i < q; i++)
                    st->chars[i-p] = S->str->chars[i];
                Val* T = ValFromStr(e, st);
                CreateDataPropA(e, A, lengthA, T);
                lengthA++;
                if(lengthA == lim->num)
                    RET_VAL(A);
                p = ee;
                q = p;
            }
        }
    }
    Str *st = StrNewLength(e, s-p);
    for(int i =0; i < (s-p); i++) {
        st->chars[i] = S->str->chars[p+i];
    }
    Val* T = ValFromStr(e, st);
    CreateDataPropA(e, A, lengthA, T);
    RET_VAL(A);

exit:
    IFD(splitter);
    IFD(zero);
    IFD(R);
    IFD(lim);
    IFD(O);
    IFD(S);
    IFD(separator);
    IFD(limit);
    IFD(A);
    return ret;
}

Val* String_prototype_startsWith(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *searchString = GetArg(e, args, 0);
    Val* searchStr = NULL, *ret = NULL, *isRegExp = NULL;
    Val* position = GetArg(e, args, 1), *pos = NULL;

    RET_IF_AB(S);
    if(searchString->type == TYPE_OBJ) {
        Val* res = Get(e, searchString, e->isRegExp);
        isRegExp = ToBoolean(e, res);
        ValDel(e, res);
        RET_IF_AB(isRegExp);
        if(ValIsTrue(e, isRegExp))
            RET(ThrowTypeError(e, "regular expression not allowed",0,0));
    }
    searchStr = ToString(e, searchString);
    RET_IF_AB(searchStr);
    pos = (ValIsUndef(position)) ? ValNewNum(e, 0) : ToInteger(e, position);
    RET_IF_AB(pos);
    int len = S->str->length;
    int ipos = (int) pos->num;
    int start = min(max(ipos, 0), len);
    int searchlength = searchStr->str->length;
    if(searchlength + start > len)
        RET(ValNewBool(e, FALSE));
    bool_t found = TRUE;
    for(int i = start; i < (start + searchlength); i++) {
        if( (i+start) > len) {
            found = FALSE;
            break;
        }
        if(S->str->chars[i] != searchStr->str->chars[i-start]) {
            found = FALSE;
            break;
        }
    }
    RET(ValNewBool(e, found));
exit:
    IFD(O);
    IFD(S);
    IFD(searchString);
    IFD(searchStr);
    IFD(isRegExp);
    IFD(position);
    IFD(pos);
    return ret;    
}

typedef uchar (*CharCvtFunc)(Js* e, uchar c);

Val* String_prototype_charConvert(Js* e, Val* o, Val* othis, Val* args, CharCvtFunc cvt) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *ret = NULL;

    RET_IF_AB(S);
    Str* s = StrNewLength(e, S->str->length);
    for(int i=0; i < S->str->length; i++) 
        s->chars[i] = cvt(e, S->str->chars[i]);
    RET(ValFromStr(e, s));

exit:
    IFD(O);
    IFD(S);
    return ret;
}

Val* String_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return thisStringValue(e, othis);
}

Val* String_prototype_toLowerCase(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return String_prototype_charConvert(e, o, othis, args, Platform_toLowerChar);
}

Val* String_prototype_toUpperCase(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return String_prototype_charConvert(e, o, othis, args, Platform_toUpperChar);
}

Val* String_prototype_toLocaleLowerCase(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return String_prototype_charConvert(e, o, othis, args, Platform_toLocaleLowerChar);
}

Val* String_prototype_toLocaleUpperCase(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return String_prototype_charConvert(e, o, othis, args, Platform_toLocaleUpperChar);
}

Val* String_prototype_substring(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *intEnd = NULL;
    Val* intStart = NULL, *ret = NULL;
    Val* start = GetArg(e, args, 0), *end = GetArg(e, args, 1);
    RET_IF_AB(S);
    int len = S->str->length;
    intStart = ToInteger(e, start);
    intEnd = (ValIsUndef(end)) ? ValNewNum(e, len) : ToInteger(e, end);
    int finalStart = min(max((int) intStart->num, 0), len);
    int finalEnd = min(max((int) intEnd->num, 0), len);
    int from = min(finalStart, finalEnd);
    int to = max(finalStart, finalEnd);
    Str* s = StrNewLength(e, to - from);
    for(int i=0; i < (to - from); i++) 
        s->chars[i] = S->str->chars[from+i];
    RET(ValFromStr(e, s));

exit:
    IFD(O);
    IFD(S);
    IFD(intEnd);
    IFD(intStart);
    IFD(start);
    IFD(end);
    return ret;    
}


Val* String_prototype_trim(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *ret = NULL;
    RET_IF_AB(S);
    DynStr* ds = DynStrNew(e, S->str->length);

    // Remove leading spaces
    int i;
    for(i=0; i < S->str->length; i++)  {
        uchar c = S->str->chars[i];
        if(!TkIsSpace(NULL, c))
            break;
    }

    // Add everything else and remember position of last non-space
    int lastNonSpace = i;
    for(int j=i; j < S->str->length; j++) {
        uchar c = S->str->chars[j];
        if(!TkIsSpace(NULL, c))
            lastNonSpace = j;
        DynStrAdd(e, ds, c);
    }

    // Trim the length to be lastNoneSpace - i
    ds->str->length = lastNonSpace - i + 1;
    RET(StrFromDynStr(e, ds));
exit:
    IFD(O);
    IFD(S);
    return ret;    
}

Val* String_prototype_valueOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return thisStringValue(e, othis);
}


Val* CreateStringIterator(Js* e, Val* s);

Val* String_prototype_iterator(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = RequireObjectCoercible(e, othis), *S = ToString(e, O), *ret = NULL;
    RET_IF_AB(S);

    RET(CreateStringIterator(e, S));
exit:
    IFD(O);
    IFD(S);    
    return ret;
}

Val* CreateStringIterator(Js* e, Val* s) {
    assert(s->type == TYPE_STR);
    Val* iterator = ObjectCreate(e, CurrentRealm(e)->stringIteratorPrototype, NULL);
    ObjectSetSlot(e, iterator->obj, _IteratedString_, s, FALSE, FALSE);
    ObjectSetSlot(e, iterator->obj, _StringIteratorNextIndex_, ValNewNum(e, 0), FALSE, TRUE);
    return iterator;
}

Val* StringIterator_prototype_next(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *und = ValNew(e), *resultString = NULL, *t = ValNewBool(e, TRUE), *f = ValNewBool(e, FALSE);

    if(othis->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));

    Object* O = othis->obj;
    if(!ObjectGetSlotRef(e, O, _IteratedString_) || !ObjectGetSlotRef(e, O, _StringIteratorNextIndex_))
        RET(ThrowTypeError(e, "not a string iterator",0,0));
    Val* s = ObjectGetSlotRef(e, O, _IteratedString_)->value;
    if(ValIsUndef(s))
        RET(CreateResultObject(e, und, t));
    int position = ObjectGetSlotRef(e, O, _StringIteratorNextIndex_)->value->num;
    int len = s->str->length;
    if(position >= len) {
        ObjectSetSlot(e, O, _IteratedString_, und, TRUE, FALSE);
        RET(CreateResultObject(e, und, t));
    }
    uchar first = s->str->chars[position];
    if(first < 0xD800 || first > 0xDBFF || (position+1) == len) {
        resultString = ValFromStr(e, StrNewLength(e, 1));
        resultString->str->chars[0] = first;
    }
    else {
        uchar second = s->str->chars[position+1];
        if(second < 0xDC00 || second > 0xDFFF) {
            resultString = ValFromStr(e, StrNewLength(e, 1));
            resultString->str->chars[0] = first;
        }
        else {
            resultString = ValFromStr(e, StrNewLength(e, 2));
            resultString->str->chars[0] = first;
            resultString->str->chars[1] = second;
        }
    }
    int resultSize = resultString->str->length;
    ObjectSetSlot(e, O, _StringIteratorNextIndex_, ValNewNum(e, position + resultSize), TRUE, TRUE);
    RET(CreateResultObject(e, resultString, f));

exit:
    IFD(t);
    IFD(f);
    IFD(und);
    IFD(resultString);
    return ret;    
}


NativeMethod String_prototype_methods[] = {
    { "charAt", String_prototype_charAt, 1},
    { "charCodeAt", String_prototype_charCodeAt, 1},
    { "codePointAt", String_prototype_codePointAt, 1},
    { "concat", String_prototype_concat, 1},
    { "contains", String_prototype_contains, 1},
    { "endsWith", String_prototype_endsWith, 1},
    { "includes", String_prototype_includes, 1},
    { "indexOf", String_prototype_indexOf, 1},
    { "lastIndexOf", String_prototype_lastIndexOf, 1},
    { "localeCompare", String_prototype_localeCompare, 1},
    { "match", String_prototype_match, 1},
    { "normalize", String_prototype_normalize, 1},
    { "repeat", String_prototype_repeat, 1},
    { "replace", String_prototype_replace, 2},
    { "search", String_prototype_search, 1},
    { "slice", String_prototype_slice, 2},
    { "split", String_prototype_split, 2},
    { "startsWith", String_prototype_startsWith, 1},
    { "substring", String_prototype_substring, 2},
    { "toLowerCase", String_prototype_toLowerCase, 0},
    { "toLowerCase", String_prototype_toLowerCase, 0},
    { "toUpperCase", String_prototype_toUpperCase, 0},
    { "toLocaleUpperCase", String_prototype_toLocaleUpperCase, 0},
    { "toLocaleLowerCase", String_prototype_toLocaleLowerCase, 0},
    { "toString", String_prototype_toString, 0},
    { "trim", String_prototype_trim, 0},
    { "valueOf", String_prototype_valueOf, 0},
};

NativeMethod StringIterator_prototype_methods[] = {
    { "next", StringIterator_prototype_next, 0},
};

Val* DefinePropOrThrowWriteable(Js* e, Val* obj, Val* key, Val* v) {
    Val* desc = ValNewDesc(e);
    if(!v)
        v = ValNew(e);
    PropSetValue(e, desc->desc, v);
    PropSetConfigurable(e, desc->desc, FALSE);
    PropSetWritable(e, desc->desc, TRUE);
    PropSetEnumerable(e, desc->desc, FALSE);
    Val* ret = DefinePropOrThrow(e, obj, key, desc);    
    ValDel(e, desc);
    ValDel(e, v);
    return ret;
}

Val* EscapeRegExpPattern(Js* e, Val* P, Val* F) {
    DynStr* S = DynStrNew(e, P->str->length);

    for(int i=0; i < P->str->length; i++) {
        uchar c = P->str->chars[i];
        if(TkIsLineTerm(c)) {
            DynStrAddStrA(e, S, "\\n"); // @todo: Validate this
        }
        else if(c == '/') {
            DynStrAdd(e, S, '\\');
            DynStrAdd(e, S, '/');
        }
        else 
            DynStrAdd(e, S, c);
    }
    return StrFromDynStr(e, S);
}

///////////// Platform REGEX Implementation
Val* SubstringFromToIncluding(Js* e, Val* S, int startIndex, int endIncluding) {
    int len = endIncluding - startIndex + 1;
    Str* sret = StrNewLength(e, len);
    for(int i=startIndex, j = 0; i <= endIncluding; i++, j++) {
        sret->chars[j] = S->str->chars[i];
    }
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = sret;
    return v;
}

Val* SubstringFromToExcluding(Js* e, Val* S, int startIndex, int endIncluding) {
    int len = endIncluding - startIndex;
    Str* sret = StrNewLength(e, len);
    for(int i=startIndex, j = 0; i < endIncluding; i++, j++) {
        sret->chars[j] = S->str->chars[i];
    }
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = sret;
    return v;
}
bool_t StrContainsChar(Js* e, Val* s, uchar c);
Val* SetA(Js* e, Val* obj, char* key, Val* v, bool_t strict, bool_t del);

// #define REGEX_POSIX
#ifndef REGEX_POSIX
#define REGEX_PCRE2
#endif

#ifdef REGEX_PCRE2      ///////////////////////////////// REGEX_PCRE2

#define PCRE2_CODE_UNIT_WIDTH 16

#include <stdio.h>
#include <string.h>
#include "pcre2.h"

Val* ValNewStrChars(Js* e, uchar* cp) {
    int len = 0;
    uchar* c = cp;
    while(*c++) len++;
    Str* s = StrNewLength(e, len);
    for(int i=0; i < len; i++)
        s->chars[i] = cp[i];
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s;
    return v;
}

Val* RegExpParse(Js* e, Val* pattern, Val* flags, bool_t isBmp) {   
    pcre2_code *re;
    int errornumber;
    PCRE2_SIZE erroroffset;
    int cflags = 0;

    if(StrContainsChar(e, flags, 'i'))
        cflags |= PCRE2_CASELESS;
    if(StrContainsChar(e, flags, 'm'))
        cflags |= PCRE2_MULTILINE;
    if(StrContainsChar(e, flags, 'u'))
        cflags |= PCRE2_UTF;

    cflags |= PCRE2_MATCH_UNSET_BACKREF;
    re = pcre2_compile(pattern->str->chars, pattern->str->length, cflags, &errornumber, &erroroffset, NULL);
    if (re == NULL) {
      PCRE2_UCHAR buffer[256];
      pcre2_get_error_message(errornumber, buffer, sizeof(buffer));
      Val* s = ValNewStrChars(e, buffer);
      Val* r =  ThrowTypeError(e, "regex parse error ", s, 0);   // @todo: report error
      ValDel(e, s);
      return r;
    }
    return ValNewPtr(e, re);    
}

void RegExpDestruct(Js *e, Object* re) {
    Val* matcher = ObjectGetSlot(e, re, _RegExpMatcher_);

    // Free the regexp if present
    if(!ValIsUndef(matcher)) {
        pcre2_code *re = (pcre2_code *) matcher->ptr;
        pcre2_code_free(re);
    }
}

void _CreateDataProp(Js* e, Val* o, char* p, Val* v, bool_t del) {
    Val* P = ValNewStrA(e, p);
    Val* ret = CreateDataProp(e, o, P, v);
    ValDel(e, P);
    if(del) ValDel(e, v);
    ValDel(e, ret);
}

void _CreateDataPropIndex(Js* e, Val* A, int i, Val* v) {
    char buffer[255];
    sprintf(buffer, "%d", i);
    _CreateDataProp(e, A, buffer, v, FALSE);
}

// PCRE2 based RegExp support
Val* MatcherCall(Js* e, Val* R, Val* matcher, Val* S, int lastIndex, bool_t unicode, bool_t global, bool_t sticky) {
    int length = S->str->length;
    Val* setStatus = 0, *ret = 0, *A = 0, *matchedSubstr = 0, *capturedValue = 0;
    pcre2_code *re = (pcre2_code *) matcher->ptr;
    pcre2_match_data *match_data = 0;
    match_data = pcre2_match_data_create_from_pattern(re, NULL);
    int rc = PCRE2_ERROR_NOMATCH;

    while(rc == PCRE2_ERROR_NOMATCH) {
        if(lastIndex > length) {
            setStatus = SetA(e, R, "lastIndex", ValNewNum(e, 0), TRUE, TRUE);
            RET_IF_AB(setStatus);
            RET(ValNewNull(e));
        }
        rc = pcre2_match(re, S->str->chars,  length, lastIndex, 0, match_data, NULL);
        if(rc < 0) {
            if(sticky) {
                setStatus = SetA(e, R, "lastIndex", ValNewNum(e, 0), TRUE, TRUE);
                RET_IF_AB(setStatus);
                RET(ValNewNull(e));
            }
            lastIndex++;
        }
    }
    PCRE2_SIZE *ovector = pcre2_get_ovector_pointer(match_data);
//    lastIndex = ovector[0];
    int ei = (int) ovector[1];

    if(global || sticky) {
        setStatus = SetA(e, R, "lastIndex", ValNewNum(e, ei), TRUE, TRUE);
        RET_IF_AB(setStatus);        
    }
    int n;
    pcre2_pattern_info(re, PCRE2_INFO_CAPTURECOUNT, &n);
    A = ArrayCreateN(e, n + 1);
    int matchIndex = (int) ovector[0];
    _CreateDataProp(e, A, "index", ValNewNum(e, matchIndex), TRUE);
    _CreateDataProp(e, A, "input", S, FALSE);

    matchedSubstr = SubstringFromToExcluding(e, S, matchIndex, ei);
    _CreateDataProp(e, A, "0", matchedSubstr, FALSE);
    for(int i = 1; i <=n; i++ ) {
        int start = (int) ovector[i*2];
        int end = (int) ovector[i*2 + 1];
        if(start < 0 || start == end)
            capturedValue = ValNew(e);
        else 
            capturedValue = SubstringFromToExcluding(e, S, start, end);
        _CreateDataPropIndex(e, A, i, capturedValue);
        IFZ(capturedValue);        
    }
    RET_VAL(A);
exit:
    if(match_data)    
        pcre2_match_data_free(match_data); 
    IFD(setStatus);
    IFD(A);
    IFD(matchedSubstr);
    IFD(capturedValue);
  
    return ret;
}

#endif  ///////////////////////////////// REGEX_PCRE2

#ifdef REGEX_POSIX  ///////////////////////////////// REGEX_POSIX

#include <regex.h>


wchar_t* WcharFromStr(Js* e, Str* source, size_t* plen, bool_t unicode) {
    int len = source->length;
    if(unicode) {
        int l = 0;
        for(int i=0; i < len; i++) {
            uchar c1 = source->chars[i];
            if( (c1 >= 0 && c1 <= 0xD7ff ) || (c1 >= 0xE000 && c1 <= 0xFFFF) ) {
                l++;
                continue;
            } 
       
            uchar c2 = source->chars[i+1];
    
            if( (c1 >= 0xD800 && c1 <= 0xDBFF) && (c2 >= 0xDC00 && c2 <= 0xDFFF) ) {
                i++;
                l++;
            }
        }
        *plen = l;
        wchar_t* chars = (wchar_t*) _malloc(sizeof(wchar_t)*(l+1));
        wchar_t* wc = chars;
        for(int i=0; i < len; i++) {
            uchar c1 = source->chars[i];
            if( (c1 >= 0 && c1 <= 0xD7ff ) || (c1 >= 0xE000 && c1 <= 0xFFFF) ) {
                *wc++ = c1;
                continue;
            }
               
            uchar c2 = source->chars[i+1];
            if( (c1 >= 0xD800 && c1 <= 0xDBFF) && (c2 >= 0xDC00 && c2 <= 0xDFFF) ) {
                *wc =  (c1 - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;            
                wc++;
                i++;
                continue;
            }
        } 
        chars[l] = 0;
        return chars;
    }
    *plen = len;
    wchar_t* chars = (wchar_t*) _malloc(sizeof(wchar_t)*(len+1));
    for(int i=0; i < len; i++) 
        chars[i] = source->chars[i];
    chars[len] = 0;
    return chars;

}



int _regwncomp(int useLen, int log, regex_t* preg, wchar_t* pattern, size_t len, int cflags) {
    int res = 0;
    if(useLen)
        res = regwncomp(preg, pattern, len, cflags);
    else
        res = regwcomp(preg, pattern, cflags);
    if(!log)
        return res;
    if(useLen)
        printf("%d = regwncomp(preg, \"%ls\", %ld, %d)\t", res, pattern, len, cflags);
    else
        printf("%d = regwcomp(preg, \"%ls\", %d)\t\t", res, pattern, cflags);
    return res;
}

int _regwnexec(int useLen, int log, regex_t* preg, wchar_t* source, size_t len, size_t ncap, regmatch_t* pcap, int eflags) {
    int res = 0;
    if(useLen)
        res = regwnexec(preg, source, len, ncap, pcap, eflags);
    else
        res = regwexec(preg, source, ncap, pcap, eflags);
    if(!log)
        return res;
    if(useLen)
        printf("%d = regwnexec(preg, \"%ls\", %ld, %d) => so:%lld, eo:%lld\n", res, source, len, eflags, pcap[0].rm_so, pcap[0].rm_eo);
    else
        printf("%d = regwexec(preg, \"%ls\", %d) => so:%lld, eo:%lld\n", res, source, eflags,
           pcap[0].rm_so, pcap[0].rm_eo);
    return res;
}



Val* RegExpParse(Js* e, Val* pattern, Val* flags, bool_t isBmp) {   
    regex_t* preg = (regex_t*) _malloc(sizeof(regex_t));
    assert(preg);
    size_t len;
    wchar_t* wpattern = WcharFromStr(e, pattern->str, &len, isBmp);
    int cflags = REG_EXTENDED | REG_ENHANCED;
    if(StrContainsChar(e, flags, 'i'))
        cflags |= REG_ICASE;
    if(StrContainsChar(e, flags, 'm'))
        cflags |= REG_NEWLINE;
    int res = _regwncomp(1, 0, preg, wpattern, len, cflags);
    _free(wpattern);
    if(res != 0) {

        size_t needed = regerror(res, preg, 0, 0);
        char* message = (char*) _malloc(needed+1);
        regerror(res, preg, message, needed);
        Val* msg = ValNewStrA(e, message);
        vpl(e, msg);
        _free(message);
        ValDel(e, msg);

        regfree(preg);
        return ThrowTypeError(e, "feild to parse RegExp", 0,0);   // @todo: report error
    }
    else 
        return ValNewPtr(e, preg);    
}

void RegExpDestruct(Js *e, Object* re) {
    Val* matcher = ObjectGetSlot(e, re, _RegExpMatcher_);

    // Free the regexp if present
    if(!ValIsUndef(matcher)) {
        regex_t* preg = (regex_t*) matcher->ptr;
        regfree(preg);
    }
}

bool_t MatcherFailed(int res, regmatch_t* match) {
    if(res != 0)
        return TRUE;
    if(match[0].rm_so != 0)
        return TRUE;
    return FALSE;
}

int UtfGetCharIndex(Js* e, Val* str, int index) {
    return index;       // @todo: implement
}

Val* MatcherCall(Js* e, Val* R, Val* matcher, Val* S, int lastIndex, bool_t unicode, bool_t global, bool_t sticky) {
    Val* ret = 0, *setStatus = 0, *A = 0, *matchedSubstr = 0, *matchIndex = 0;
    Val* capturedValue = 0;
    Val* strLastIndex = ValNewStrA(e, "lastIndex"), *strIndex = ValNewStrA(e, "index"), *strInput = ValNewStrA(e, "input");
    Val* zero = ValNewNum(e, 0);
    const int SUCCESS = 0, FAIL = 1;
    int  res = FAIL;
    size_t length = S->str->length;
    regex_t* preg = (regex_t*) matcher->ptr;
    size_t nmatch = 1 + preg->re_nsub;
    regmatch_t* pmatch = (regmatch_t*) _malloc(nmatch*sizeof(regmatch_t));
    wchar_t* widestr = WcharFromStr(e, S->str, &length, unicode);
    size_t ei = length-1;
    while(res != SUCCESS) {
        if(lastIndex > length) {
            setStatus = Put(e, R, strLastIndex, zero, TRUE);
            RET_IF_AB(setStatus);
            RET(ValNewNull(e));
        }
        int eflags = 0;
        if(lastIndex > 0)
            eflags |= REG_NOTBOL;
        res = _regwnexec(1, 0, preg, widestr + lastIndex, length - lastIndex, nmatch, pmatch, eflags);
        if(MatcherFailed(res, pmatch)) {
            res = FAIL;
            if(sticky == TRUE) {
                setStatus = Put(e, R, strLastIndex, zero, TRUE);
                RET_IF_AB(setStatus);
                RET(ValNewNull(e));
            }
            lastIndex++;
        }
        else {
            ei = pmatch[0].rm_eo + lastIndex;
            res = SUCCESS;
        }
    }
    if(unicode) {
        ei = (size_t) UtfGetCharIndex(e, S, (int) ei);
    }
    if(global == TRUE || sticky == TRUE) {
        Val* vn = ValNewNum(e, ei);
        setStatus = Put(e, R, strLastIndex, vn, TRUE);
        ValDel(e, vn);
        RET_IF_AB(setStatus);
    }
    size_t n = preg->re_nsub; // MatcherNumCaptures(e, r);
    Val* vl = ValNewNum(e, n+1);
    A = ArrayCreate(e, vl, NULL);
    ValDel(e, vl);
    matchIndex = ValNewNum(e, lastIndex);
    ValDel(e, CreateDataProp(e, A, strIndex, matchIndex));
    ValDel(e, CreateDataProp(e, A, strInput, S));
    matchedSubstr = SubstringFromToExcluding(e, S, lastIndex, (int) ei);
    ValDel(e, CreateDataProp(e, A, e->strZero, matchedSubstr));
    Val* vi = ValNewNum(e, 0);
    for(int i=0; i < n; i++) {
        regmatch_t *capture = &pmatch[i+1];
        
        if(capture->rm_so == -1)
            capturedValue = ValNew(e);
        else if(unicode)
            capturedValue = 0; // @todo: StrUtf16Encode(e, capture);
        else 
            capturedValue = SubstringFromToExcluding(e, S, (int) capture->rm_so, (int) capture->rm_eo);
        vi->num = i+1;
        Val* si = ToString(e, vi);
        ValDel(e, CreateDataProp(e, A, si, capturedValue));
        ValDel(e, si);
        IFZ(capturedValue);
    }
    ValDel(e, vi);
    RET_VAL(A);
exit:    
    _free(widestr);
    IFD(zero);
    IFD(capturedValue);
    IFD(strLastIndex);
    IFD(strIndex);
    IFD(strInput);
    IFD(A);
    IFD(matchedSubstr);
    IFD(matchIndex);
    if(pmatch) _free(pmatch);
    IFD(setStatus);
    return ret;           // @todo: implement
}



#endif               ///////////////////////////////// REGEX_POSIX

////////////// End platform REGEX Implementation

Val* RegExpAlloc(Js* e, Val* newTarget) {
    Val* obj = 0, *ret = 0, *status = 0, *strLastIndex = ValNewStrA(e, "lastIndex");
    obj = OrdinaryCreateFromConstructor(e, newTarget, CurrentRealm(e)->regExpPrototype, NULL);
    RET_IF_AB(obj);
    ObjectSetSlot(e, obj->obj, _RegExpMatcher_, ValNew(e), 0, 1);
    ObjectSetSlot(e, obj->obj, _OriginalSource_, ValNew(e), 0, 1);
    ObjectSetSlot(e, obj->obj, _OriginalFlags_, ValNew(e), 0, 1);
    status = DefinePropOrThrowWriteable(e, obj, strLastIndex, NULL);;
    RET_IF_AB(status);
    RET_VAL(obj);
exit:
    IFD(strLastIndex);
    IFD(status);
    IFD(obj);    
    return ret;
}

Val* RegExp_getSpecies(Js* e, Val* o, Val* othis, Val* oargs, Val* newTarget) {
    return ValClone(e, othis);
}




Val* RegExpInitialize(Js* e, Val* obj, Val* pattern, Val* flags) {
    Val* ret = 0, *P = 0, *F = 0, *setStatus = 0, *matcher = 0;
    Val* strLastIndex = 0, *li = 0;

    if(ValIsUndef(pattern))
        P = ValNewStrA(e, "");
    else
        P = ToString(e, pattern);
    RET_IF_AB(P);
    if(ValIsUndef(flags))
        F = ValNewStrA(e, "");
    else
        F = ToString(e, flags);
    RET_IF_AB(F);
    bool_t BMP = FALSE;
    for(int i=0; i < F->str->length; i++) {
        uchar c = F->str->chars[i];
        if(c == 'u')
            BMP = TRUE;
        if(c != 'g' && c != 'i' && c != 'm' && c != 'u' && c != 'y')
            RET(ThrowSyntaxError(e, "g, i, m, or y expected",0,0));
    }

    matcher = RegExpParse(e, P, F, BMP);
    RET_IF_AB(matcher);
    ObjectSetSlot(e, obj->obj, _OriginalSource_, P, TRUE, FALSE);
    ObjectSetSlot(e, obj->obj, _OriginalFlags_, F, TRUE, FALSE);
    ObjectSetSlot(e, obj->obj, _RegExpMatcher_, matcher, TRUE, FALSE);
    ObjectSetMethod(e, obj->obj, _Destruct_, RegExpDestruct, FALSE);
    strLastIndex = ValNewStrA(e, "lastIndex");
    li = ValNewNum(e, 0);
    setStatus = Put(e, obj, strLastIndex, li, TRUE);
    RET_IF_AB(setStatus);
    RET(ValClone(e, obj));

exit:
    IFD(strLastIndex);
    IFD(li);
    IFD(matcher);
    IFD(P);
    IFD(F);
    IFD(setStatus);

    return ret;
}

Val* RegExpCreate(Js* e, Val* P, Val* F) {
    Val* obj = RegExpAlloc(e, CurrentRealm(e)->regExpConstructor);
    if(ValIsAbrupt(e, obj))
        return obj;
    Val* ret = RegExpInitialize(e, obj, P, F);
    ValDel(e, obj);
    return ret;
}


Val* RegExpConstructor(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* ret = NULL, *pattern = GetArg(e, args, 0), *flags = GetArg(e, args, 1);
    Val* patternIsRegExp = IsRegExp(e, pattern);
    Val* patternConstructor = 0, *P = 0, *O = 0, *F = 0;
    Val* newTarget;
    RET_IF_AB(patternIsRegExp);
    if(!ValIsUndef(NewTarget)) 
        newTarget = NewTarget;
    else  {
        newTarget = o;
        if(ValIsTrue(e, patternIsRegExp) && ValIsUndef(flags)) {
            patternConstructor = GetA(e, pattern, "constructor");
            RET_IF_AB(patternConstructor);
            if(ValIsTrueDel(e, SameValue(e, newTarget, patternConstructor)))
                RET_VAL(pattern);
        }
    }
    if(ValIsObject(pattern) && ObjectGetSlotRef(e, pattern->obj, _RegExpMatcher_)) {
        P = ObjectGetSlot(e, pattern->obj, _OriginalSource_);
        P = ValClone(e, P);
        if(ValIsUndef(flags))  {
            F = ObjectGetSlot(e, pattern->obj, _OriginalFlags_);
            F = ValClone(e, F);
        }
        else
            F = ValClone(e, flags);
    }
    else if(ValIsTrue(e, patternIsRegExp)) {
        P = GetA(e, pattern, "source");
        RET_IF_AB(P);
        if(ValIsUndef(flags)) {
            F = GetA(e, pattern, "flags");
            RET_IF_AB(F);
        }
        else
            F = ValClone(e, flags);
    }
    else {
        P = ValClone(e, pattern);
        F = ValClone(e, flags);        
    }

    O = RegExpAlloc(e, newTarget);
    RET(RegExpInitialize(e, O, P, F));

exit:    
    IFD(F);
    IFD(P);
    IFD(O);
    IFD(patternConstructor);
    IFD(pattern);
    IFD(flags);
    IFD(patternIsRegExp);
    return ret;
}

bool_t StrContainsChar(Js* e, Val* s, uchar c) {
    for(int i=0; i < s->str->length; i++) {
        if(s->str->chars[i] == c)
            return TRUE;
    }
    return FALSE;
}


Val* RegExpBuiltinExec(Js* e, Val* R, Val* S) {
    Val* lastIndex = 0, *global = 0, *sticky = 0, *matcher = 0, *flags = 0;
    Val* setStatus = 0, *r = 0, *ret = 0;

    Val* vli = GetA(e, R, "lastIndex");
    lastIndex = ToLength(e, vli);
    ValDel(e, vli);
    RET_IF_AB(lastIndex);
    Val* vgl = GetA(e, R, "global");
    global = ToBoolean(e, vgl);
    ValDel(e, vgl);
    RET_IF_AB(global);
    Val* vst = GetA(e, R, "sticky");
    sticky = ToBoolean(e, vst);
    ValDel(e, vst);
    RET_IF_AB(sticky);
    int i;
    if(global->b == FALSE && sticky->b == FALSE)
        i = 0;
    matcher = ObjectGetSlot(e, R->obj, _RegExpMatcher_);
    flags = ObjectGetSlot(e, R->obj, _OriginalFlags_);
    bool_t fullUnicode = FALSE;
    if(StrContainsChar(e, flags, 'u'))
        fullUnicode = TRUE;

    RET(MatcherCall(e, R, matcher, S, lastIndex->num, fullUnicode, global->b, sticky->b));
exit:
    IFD(lastIndex);
    IFD(global);
    IFD(sticky);
    IFD(setStatus);
    IFD(r);
    return ret;
}

Val* RegExpExec(Js* e, Val* R, Val* S) {
    Val* exec = 0, *result = 0, * ret = 0;

    if(!ValIsObject(R))
        RET(ThrowTypeError(e, "not an object", 0,0));
    if(S->type != TYPE_STR)
        RET(ThrowTypeError(e, "not a string", 0,0));
    exec = GetA(e, R, "exec");
    RET_IF_AB(exec);
    if(ValIsTrueDel(e, IsCallable(e, exec))) {
        result = Call1(e, exec, R, S);
        RET_IF_AB(result);
        if(result->type != TYPE_OBJ && result->type != TYPE_NULL)
            RET(ThrowTypeError(e, "null or object expected",0,0));
        RET_VAL(result);
    }
    if(!ObjectGetSlotRef(e, R->obj, _RegExpMatcher_))
        RET(ThrowTypeError(e, "not a regular expression",0,0));
    RET(RegExpBuiltinExec(e, R, S));
exit:
    IFD(exec);
    IFD(result);
    return ret;
}

Val* RegExp_prototype_exec(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* R = 0, * S = 0, *ret =0, *string = GetArg(e, args, 0);

    if(!ValIsObject(othis))
        RET(ThrowTypeError(e, "not an object",0,0));
    R = ValClone(e, othis);
    if(othis->obj == CurrentRealm(e)->regExpPrototype->obj) {
        ValDel(e, R);
        R = RegExpCreate(e, e->strEmpty, e->strEmpty);
        RET_IF_AB(R);
    }
    if(!ObjectGetSlotRef(e, R->obj, _RegExpMatcher_))
        RET(ThrowTypeError(e, "not a regular expression",0,0));
    S = ToString(e, string);
    RET_IF_AB(S);
    RET(RegExpBuiltinExec(e, R, S));

exit:
    IFD(string);
    IFD(R);
    IFD(S);
    return ret;    
}

Val* GetBool(Js* e, Val* obj, char* key) {
    Val* v = GetA(e, obj, key);
    Val* r = ToBoolean(e, v);
    ValDel(e, v);
    return r;
}

Val* RegExp_prototype_getFlags(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* global = 0, *ignoreCase = 0, *multiline = 0, *unicode = 0, *sticky = 0;
    Val* ret = 0;
    Val* R = othis;
    DynStr* result = 0;
    if(R->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    result = DynStrNew(e, 8);
    global = GetBool(e, R, "global");
    RET_IF_AB(global);
    if(ValIsTrue(e, global))
        DynStrAdd(e, result, 'g');
    ignoreCase = GetBool(e, R, "ignoreCase");
    RET_IF_AB(ignoreCase);
    if(ValIsTrue(e, ignoreCase))
        DynStrAdd(e, result, 'i');
    multiline = GetBool(e, R, "multiline");
    RET_IF_AB(multiline);
    if(ValIsTrue(e, multiline))
        DynStrAdd(e, result, 'm');
    unicode = GetBool(e, R, "unicode");
    RET_IF_AB(unicode);
    if(ValIsTrue(e, unicode))
        DynStrAdd(e, result, 'u');
    sticky = GetBool(e, R, "sticky");
    RET_IF_AB(sticky);
    if(ValIsTrue(e, sticky))
        DynStrAdd(e, result, 'y');
    ret = StrFromDynStr(e, result);
    result = 0;
exit:
    IFD(global);
    IFD(ignoreCase);
    IFD(multiline);
    IFD(unicode);
    IFD(sticky);
    if(result) DynStrDel(e, result);
    return ret;    
}

Val* RegExp_prototype_flagVal(Js* e, Val* R, char flag) {
    Val* ret = 0;
    if(R->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "invalid flag ",0, &flag));
    if(!ObjectGetSlotRef(e, R->obj, _OriginalFlags_))
        RET(ThrowTypeError(e, "flags not found", 0,0));
    Val* flags = ObjectGetSlot(e, R->obj, _OriginalFlags_);
    if(StrContainsChar(e, flags, flag))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));
exit:
    return ret;    
}

Val* RegExp_prototype_getGlobal(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    return RegExp_prototype_flagVal(e, othis, 'g');
}

Val* RegExp_prototype_getIgnoreCase(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    return RegExp_prototype_flagVal(e, othis, 'i');
}

Val* RegExp_prototype_getMultiline(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    return RegExp_prototype_flagVal(e, othis, 'm');
}

Val* RegExp_prototype_getSticky(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    return RegExp_prototype_flagVal(e, othis, 'y');
}

Val* RegExp_prototype_getUnicode(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    return RegExp_prototype_flagVal(e, othis, 'u');
}

Val* SetA(Js* e, Val* obj, char* key, Val* v, bool_t strict, bool_t del) {
    Val* sk = ValNewStrA(e, key);
    Val* status = Put(e, obj, sk, v, strict);
    if(del)
        ValDel(e, v);
    ValDel(e, sk);
    return status;
}

Val* RegExp_prototype_match(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* ret=0, *S=0, *global=0, *setStatus=0, *result=0, *matchValue=0,*matchStr=0;
    Val* status=0, *thisIndex=0, *string = GetArg(e, args, 0), *A=0, *n = 0;

    Val* rx = othis;
    if(rx->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    S = ToString(e, string);
    RET_IF_AB(S);
    global = GetBool(e, rx, "global");
    RET_IF_AB(global);
    if(!global->b) {
        RET(RegExpExec(e, rx, S));
    }
    else {
        setStatus = SetA(e, rx, "lastIndex", ValNewNum(e, 0), TRUE, TRUE);
        RET_IF_AB(setStatus);
        A = ArrayCreate(e, NULL, NULL);
        n = ValNewNum(e, 0);
        while(TRUE) {
            result = RegExpExec(e, rx, S);
            RET_IF_AB(result);
            if(ValIsNull(result)) {
                if(n->num == 0) {
                    RET_VAL(result);
                }
                else {
                    RET_VAL(A);
                }
            }
            else {
                matchValue = GetA(e, result, "0");
                RET_IF_AB(matchValue);
                matchStr = ToString(e, matchValue);
                RET_IF_AB(matchStr);
                Val* sn = ToString(e, n);
                status = CreateDataProp(e, A, sn, matchStr);
                ValDel(e, sn);
                assert(ValIsTrue(e, status));
                if(matchStr->str->length == 0) {
                    Val* li = GetA(e, rx, "lastIndex");
                    thisIndex = ToLength(e, li);
                    ValDel(e, li);
                    RET_IF_AB(thisIndex);
                    thisIndex->num++;
                    setStatus = SetA(e, rx, "lastIndex", thisIndex, TRUE, FALSE);
                }
                n->num++;
                IFZ(setStatus);
                IFZ(thisIndex);
                IFZ(status);
                IFZ(matchValue);
                IFZ(matchStr);
            }
            IFZ(result);
        }
    }

exit:
    IFD(S);
    IFD(n);
    IFD(A);
    IFD(string);
    IFD(thisIndex);
    IFD(status);
    IFD(matchStr);
    IFD(matchValue);
    IFD(result);
    IFD(setStatus);
    IFD(global);
    return ret;
}

Val* RegExp_prototype_replace(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* ret=0, *S=0, *lengthS=0, *functionalReplace=0, *global=0;
    Val* results=0, *done=0, *result=0, *matchStr=0, *thisIndex=0, *setStatus=0;
    Val* accumulatedResult=0, *nextSourcePosition=0, *nCaptures=0, *matched=0;
    Val* position=0, *n=0, *captures = 0, *capN = 0, *replacerArgs=0, *replValue=0;
    Val* replacement=0, *string = GetArg(e, args, 0), *replaceValue = GetArg(e, args, 1);
    Val* und = ValNew(e);
    Val* rx = othis;
    if(rx->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    S = ToString(e, string);
    RET_IF_AB(S);
    lengthS = ValNewNum(e, S->str->length);
    functionalReplace = IsCallable(e, replaceValue);
    if(functionalReplace->b == FALSE) {
        Val* rv = ToString(e, replaceValue);
        ValDel(e, replaceValue);
        replaceValue = rv;
        RET_IF_AB(replaceValue);
    }
    global = GetBool(e, rx, "global");
    RET_IF_AB(global);
    if(global->b == TRUE) {
        setStatus = SetA(e, rx, "lastIndex", ValNewNum(e, 0), TRUE, TRUE);
        RET_IF_AB(setStatus);
        IFZ(setStatus);
    }
    results = ValNewListEmpty(e);
    done = ValNewBool(e, FALSE);
    while(done->b == FALSE) {
        result = RegExpExec(e, rx, S);
        RET_IF_AB(result);
        if(ValIsNull(result)) 
            done->b = TRUE;
        else {
            ListAddValue(e, results->list, result);
            result = 0;     // added to list by reference
            if(global->b == FALSE) 
                done->b = TRUE;
            else {
                Val* g0 = Get(e, result, e->strZero);
                matchStr = ToString(e, g0);
                ValDel(e, g0);
                RET_IF_AB(matchStr);
                if(matchStr->str->length == 0) {
                    Val* li = GetA(e, rx, "lastIndex");
                    thisIndex = ToLength(e, li);
                    ValDel(e, li);
                    RET_IF_AB(thisIndex);
                    thisIndex->num++;
                    setStatus = SetA(e, rx, "lastIndex", thisIndex, TRUE, FALSE);
                    RET_IF_AB(setStatus);
                }
            }
        }
        IFZ(result);
        IFZ(matchStr);
        IFZ(thisIndex);
        IFZ(setStatus);
    }

    accumulatedResult = ValNewStrA(e,"");
    nextSourcePosition = ValNewNum(e, 0);
    for(Item* i=results->list->head; i; i = i->next) {
        Val* result = i->value;
        Val* l = GetA(e, result, "length");
        nCaptures = ToLength(e, l);
        ValDel(e, l);
        RET_IF_AB(nCaptures);
        nCaptures->num = max(nCaptures->num -1, 0);
        Val* g0 = Get(e, result, e->strZero);
        matched = ToString(e, g0);
        ValDel(e, g0);
        RET_IF_AB(matched);
        int matchLength = matched->str->length;
        Val* gi = GetA(e, result, "index");
        position = ToInteger(e, gi);
        ValDel(e, gi);
        RET_IF_AB(position);
        position->num = max(min(position->num, lengthS->num), 0);
        n = ValNewNum(e, 1);
        captures = ValNewListEmpty(e);
        while(n->num <= nCaptures->num) {
            Val* sn = ToString(e, n);
            capN = Get(e, result, sn);
            ValDel(e, sn);
            if(capN->type != TYPE_UNDEF) {
                Val* s = ToString(e, capN);
                ValDel(e, capN);
                capN = s;
            }
            RET_IF_AB(capN);
            ListAddValue(e, captures->list, capN);
            capN = 0;
            n->num++;
        }
        if(functionalReplace->b) {
            replacerArgs = ValNewListEmpty(e);
            ListAddValue(e, replacerArgs->list, matched);
            matched = 0;
            ListConcat(e, replacerArgs->list, captures->list);
            ListAddValue(e, replacerArgs->list, ValClone(e, position));
            ListAddValue(e, replacerArgs->list, ValClone(e, S));

            replValue = DoCall(e, replaceValue, und, replacerArgs);
            replacement = ToString(e, replValue);
        }
        else {
            replacement = GetReplaceSubstitution(e, matched, S, position->num, captures, replaceValue);
        }
        RET_IF_AB(replacement);
        if(position->num >= nextSourcePosition->num) {
            int len = accumulatedResult->str->length + position->num - nextSourcePosition->num + replacement->str->length;
            Str* sr = StrNewLength(e, len);
            int j = 0;
            for(int i=0; i < accumulatedResult->str->length; i++) 
                sr->chars[j++] = accumulatedResult->str->chars[i];
            for(int i=nextSourcePosition->num; i < position->num; i++ )
                sr->chars[j++] = S->str->chars[i];
            for(int i=0; i < replacement->str->length; i++) 
                sr->chars[j++] = replacement->str->chars[i];
            StrDel(e, accumulatedResult->str);
            accumulatedResult->str = sr;
            nextSourcePosition->num = position->num + matchLength;
        }

        IFZ(nCaptures);
        IFZ(matched);
        IFZ(position);
        IFZ(captures);
        IFZ(replacerArgs);
        IFZ(replValue);
        IFZ(replacement);
        IFZ(n);
    }
    if(nextSourcePosition->num >= lengthS->num)
        RET_VAL(accumulatedResult);

    int len = accumulatedResult->str->length + S->str->length - nextSourcePosition->num;
    Str* sr = StrNewLength(e, len);
    int j = 0;
    for(int i=0; i < accumulatedResult->str->length; i++) 
        sr->chars[j++] = accumulatedResult->str->chars[i];
    for(int i=nextSourcePosition->num; i < S->str->length; i++ )
        sr->chars[j++] = S->str->chars[i];
    StrDel(e, accumulatedResult->str);
    accumulatedResult->str = sr;
    RET_VAL(accumulatedResult);

exit:
    IFD(und);
    IFD(string);
    IFD(replaceValue);
    IFD(replacement);
    IFD(replValue);
    IFD(replacerArgs);
    IFD(capN);
    IFD(captures);
    IFD(position);
    IFD(matched);
    IFD(nCaptures);
    IFD(nextSourcePosition);
    IFD(accumulatedResult);
    IFD(setStatus);
    IFD(thisIndex);
    IFD(matchStr);
    IFD(result);
    IFD(done);
    IFD(results);
    IFD(global);
    IFD(functionalReplace);
    IFD(lengthS);
    IFD(S);    
    return ret;
}


Val* RegExp_prototype_search(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* ret=0, *S=0, *status=0, *result=0, *string = GetArg(e, args, 0), *rx = othis;
    Val* previousLastIndex =0;
    if(rx->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    S = ToString(e, string);
    RET_IF_AB(S);
    previousLastIndex = GetA(e, rx, "lastIndex");
    RET_IF_AB(previousLastIndex);
    status = SetA(e, rx, "lastIndex", ValNewNum(e, 0), TRUE, TRUE);
    RET_IF_AB(status);
    result = RegExpExec(e, rx, S);
    RET_IF_AB(result);
    status = SetA(e, rx, "lastIndex", previousLastIndex, TRUE, FALSE);
    RET_IF_AB(status);
    if(ValIsNull(result))
        RET(ValNewNum(e, -1));
    RET(GetA(e, result, "index"));

exit:
    IFD(previousLastIndex);
    IFD(S);
    IFD(status);
    IFD(result);
    IFD(string);    
    return ret;
}


Val* RegExp_prototype_getSource(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* R=othis;
    if(R->type != TYPE_OBJ)
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, R->obj, _OriginalFlags_))
        return ThrowTypeError(e, "flags not found",0,0);
    if(!ObjectGetSlotRef(e, R->obj, _OriginalSource_))
        return ThrowTypeError(e, "source not found",0,0);
    Val* src = ObjectGetSlot(e, R->obj, _OriginalSource_);
    Val* flags = ObjectGetSlot(e, R->obj, _OriginalFlags_);
    return EscapeRegExpPattern(e, src, flags);
}
Val* SpeciesConstructor(Js* e, Val* O, Val* defaultConstructor);

Val* StrAddChars(Js* e, Val* s, char* c) {
    int len = (int) strlen(c);
    Str* ns = StrNewLength(e, s->str->length+len);
    int i=0;
    for(; i < s->str->length; i++)
        ns->chars[i] = s->str->chars[i];
    while(*c)
        ns->chars[i++] = *c++;
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = ns;
    return v;
}

Val* RegExp_prototype_split(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* string=GetArg(e, args, 0), *limit=GetArg(e, args, 1), *ret =0;
    Val* S=0, *C=0, *flags=0, *newFlags=0, *splitter=0, *A=0, *lim=0, *z=0;
    Val* q=0, *p=0, *size=0, *ee=0, *T=0, *lengthA=0, *i=0;
    Val* setStatus=0, *numberOfCaptures=0, *nextCapture=0;
    Val* rx = othis;


    if(rx->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    S = ToString(e, string);
    RET_IF_AB(S);
    C = SpeciesConstructor(e, rx, CurrentRealm(e)->regExpConstructor);
    RET_IF_AB(C);


    Val* gf = GetA(e, rx, "flags");
    flags = ToString(e, gf);
    ValDel(e, gf);
    RET_IF_AB(flags);
    bool_t unicodeMatching = FALSE;
    if(StrContainsChar(e, flags, 'u'))
        unicodeMatching = TRUE;
    if(StrContainsChar(e, flags, 'y'))
        newFlags = ValClone(e, flags);
    else 
        newFlags = StrAddChars(e, flags, "y");


    splitter = Construct2(e, C, rx, newFlags);
    RET_IF_AB(splitter);

    A = ArrayCreate(e, NULL, NULL);
    lengthA = ValNewNum(e, 0);
    if(ValIsUndef(limit))
        lim = ValNewNum(e, pow(2, 53)-1);
    else
        lim = ToLength(e, limit);
    RET_IF_AB(lim);
    size = ValNewNum(e, S->str->length);
    p = ValNewNum(e, 0);
    if(lim->num == 0)
        RET_VAL(A);
    if(size->num == 0) {
        z = RegExpExec(e, splitter, S);
        RET_IF_AB(z);
        if(!ValIsNull(z))
            RET_VAL(A);
        ValDel(e, CreateDataProp(e, A, e->strZero, S));
        RET_VAL(A);
    }
    
    
    q = ValClone(e, p);
    while(q->num < size->num) {
        setStatus = SetA(e, splitter, "lastIndex", q, TRUE, FALSE);
        RET_IF_AB(setStatus);
        IFZ(setStatus);
        z = RegExpExec(e, splitter, S);
        RET_IF_AB(z);
        if(ValIsNull(z)) {
            if(unicodeMatching) {
                uchar first = S->str->chars[(int) q->num];
                if(first >= 0xD800 && first <= 0xDBFF && (q->num +1) != size->num) {
                    uchar second = S->str->chars[(int) q->num+1];
                    if(second >= 0xDC00 && second <= 0xDFFF)
                        q->num = q->num + 1;
                }
            }
            q->num = q->num + 1;
        }
        else {
            Val* gli = GetA(e, splitter, "lastIndex");
            ee = ToLength(e, gli);
            ValDel(e, gli);
            RET_IF_AB(ee);
            if(ee->num == p->num) {
                if(unicodeMatching) {
                    uchar first = S->str->chars[(int) q->num];
                    if(first >= 0xD800 && first <= 0xDBFF && (q->num+1) != size->num) {
                        q->num++;
                    }
                }
                q->num++;
            }
            else {
                ValDel(e, q);
                q = GetA(e, z, "index");
                T = SubstringFromToExcluding(e, S, p->num, q->num);
                Val* sla = ToString(e, lengthA);
                ValDel(e, CreateDataProp(e, A, sla, T));
                ValDel(e, sla);
                lengthA->num++;
                if(lengthA->num == lim->num)
                    RET_VAL(A);
                p->num = ee->num;
                i = ValNewNum(e, 0);
                Val* gl = GetA(e, z, "length");
                numberOfCaptures = ToLength(e, gl);
                ValDel(e, gl);
                RET_IF_AB(numberOfCaptures);
                numberOfCaptures->num = max(numberOfCaptures->num-1, 0);
                i->num = 1;
                while(i->num <= numberOfCaptures->num) {
                    Val* si = ToString(e, i);
                    nextCapture = Get(e, z, si);
                    ValDel(e, si);
                    RET_IF_AB(nextCapture);
                    Val* sla = ToString(e, lengthA);
                    ValDel(e, CreateDataProp(e, A, sla, nextCapture));
                    ValDel(e, sla);
                    i->num++;
                    lengthA->num++;
                    if(lengthA->num == lim->num)
                        RET_VAL(A);
                    IFZ(nextCapture);                    
                }
                q->num = p->num;
            }
        }
        IFZ(i);
        IFZ(T);
        IFZ(ee);
        IFZ(z);
        IFZ(numberOfCaptures);
    }
    T = SubstringFromToExcluding(e, S, p->num, size->num);
    Val* sla = ToString(e, lengthA);
    ValDel(e, CreateDataProp(e, A, sla, T));
    ValDel(e, sla);
    RET_VAL(A);

exit:
    IFD(string);
    IFD(limit);    
    IFD(S);
    IFD(C);
    IFD(flags);
    IFD(newFlags);
    IFD(splitter);
    IFD(A);
    IFD(lim);
    IFD(z);
    IFD(q);
    IFD(p);
    IFD(size);
    IFD(ee);
    IFD(T);
    IFD(lengthA);
    IFD(i);
    IFZ(setStatus);
    IFZ(numberOfCaptures);
    IFZ(nextCapture);
    return ret;
}

Val* RegExp_prototype_test(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* ret=0, *s=GetArg(e, args, 0), *match=0, *string=0;
    Val* R = othis;
    if(R->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    string = ToString(e, s);
    RET_IF_AB(string);
    if(R->obj == CurrentRealm(e)->regExpPrototype->obj)
        RET(ValNewBool(e, TRUE));
    match = RegExpExec(e, R, string);
    RET_IF_AB(match);
    if(!ValIsNull(match))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));
exit:
    IFD(s);
    IFD(string);
    IFD(match);
    return ret;    
}

Val* RegExp_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* NewTarget) {
    Val* ret=0, *pattern=0, *flags=0;
    DynStr* result=0;
    Val* R = othis;
    if(R->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    Val* gs = GetA(e, R, "source");
    pattern = ToString(e, gs);
    ValDel(e, gs);
    RET_IF_AB(pattern);
    Val* gf = GetA(e, R, "flags");
    flags = ToString(e, gf);
    ValDel(e, gf);
    RET_IF_AB(flags);
    result = DynStrNew(e, pattern->str->length + flags->str->length+2);
    DynStrAdd(e, result, '/');
    DynStrAddStr(e, result, pattern->str);
    DynStrAdd(e, result, '/');
    DynStrAddStr(e, result, flags->str);
    ret = StrFromDynStr(e, result);
    result = 0;
exit:
    IFD(pattern);
    IFD(flags);
    if(result) DynStrDel(e, result);
    return ret;    
}

NativeMethod RegExp_methods[] = {
};

NativeMethod RegExp_prototype_methods[] = {
    { "exec", RegExp_prototype_exec, 1},
    { "test", RegExp_prototype_test, 1},
    { "toString", RegExp_prototype_toString, 1},
};



// 22.1 Array Objects
bool_t IsSparse(Js* e, Val* o) {
    Val* len = NULL, *ulen = NULL, *elem = NULL;

    bool_t ret = FALSE;
    len = Get(e, o, e->strLength);
    ulen = ToUint32(e, len);
    unsigned int ilen = ulen->num;
    for(int i=0; i < ilen; i++) {
        char buff[25];
        sprintf(buff, "%d", i);
        elem = GetA(e, o, buff);
        if(ValIsUndef(elem)) {
            ret = TRUE;
            goto exit;
        }
        IFZ(elem);
    }

exit:
    IFD(len);
    IFD(ulen);
    IFD(elem);
    return ret;
}


Val* ConstructFromArray(Js* e, Val* O, Val* len) {
    Val* A = NULL, *C = 0, *ret = NULL;

    if(IsArray(e, O)) {
            C = GetA(e, O,"constructor");
            RET_IF_AB(C);
            if(ValIsTrueDel(e, IsConstructor(e, C))) {
                Realm* thisRealm = CurrentRealm(e);
                if(thisRealm == GetFunctionRealm(e, C)) {
                    Val * a = (len) ? ValClone(e, len) : ValNewNum(e, 0);
                    A = Construct1(e, C, a, NULL);
                    ValDel(e, a);
                }
            }
        }
    if(!A)
        A = ArrayCreate(e, 0, NULL);
    RET_IF_AB(A);
    RET_VAL(A);
exit:
    IFD(C);
    IFD(A);
    return ret;         
}

Val* ArrayCreateZero(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *proto = 0, *num = 0; 
    if(!newTarget) newTarget = o;
    proto = GetPrototypeFromConstructor(e, newTarget, CurrentRealm(e)->arrayPrototype);
    RET_IF_AB(proto);
    num = ValNewNum(e, 0);
    RET(ArrayCreate(e, num, proto));
exit:
    IFD(proto);
    IFD(num);
    return ret;    
}

Val* ArrayCreateLen(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *array = NULL;
    Val* putStatus = NULL, *len = GetArg(e, args, 0), *defineStatus = NULL, *intLen = NULL;
    Val* proto = 0;
    if(!newTarget) newTarget = o;

    proto = GetPrototypeFromConstructor(e, newTarget, CurrentRealm(e)->arrayPrototype);
    RET_IF_AB(proto);
    array = ArrayCreate(e, 0, proto);

    RET_IF_AB(array);
    if(len->type != TYPE_NUM) {
        defineStatus = CreateDataPropOrThrow(e, array, e->strZero, len);
        RET_IF_AB(defineStatus);
        intLen = ValNewNum(e, 1);
    }
    else {
        intLen = ToUint32(e, len);
        if(intLen->num != len->num)
            RET(ThrowRangeError(e, "length not an integer",0,0));        
    }
    putStatus = Put(e, array, e->strLength, intLen, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(array);
exit:
    IFD(proto);
    IFD(intLen);
    IFD(defineStatus);
    IFD(putStatus);
    IFD(array);
    IFD(len);
    return ret;    
}

Val* ArrayCreateMany(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = NULL, *array = NULL;
    Val* putStatus = NULL, *defineStatus = NULL;
    Val* numArgs = ValNewNum(e, args->list->count);
    Val* proto = 0;

    if(!newTarget) newTarget = o;
    proto = GetPrototypeFromConstructor(e, newTarget, CurrentRealm(e)->arrayPrototype);
    RET_IF_AB(proto);
    array = ArrayCreate(e, numArgs, proto);

    RET_IF_AB(array);
    for(int k=0; k < args->list->count; k++) {
        char buff[25];
        sprintf(buff, "%d", k);
        Val* pk = ValNewStrA(e, buff);
        Val* itemK = Arg(e, args, k);
        assert(itemK);
        defineStatus = CreateDataPropOrThrow(e, array, pk, itemK);
        IFZ(itemK);
        IFZ(pk);
        RET_IF_AB(defineStatus);     
        IFZ(defineStatus);   
    }
    putStatus = Put(e, array, e->strLength, numArgs, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(array);
exit:
    IFD(proto);
    IFD(defineStatus);
    IFD(putStatus);
    IFD(numArgs);
    IFD(array);
    return ret;    
}

Val* ArrayConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    if(!args || args->list->count == 0)
        return ArrayCreateZero(e, o, othis, args, newTarget);
    if(args->list->count == 1)
        return ArrayCreateLen(e, o, othis, args, newTarget);    
    return ArrayCreateMany(e, o, othis, args, newTarget); 
}

Val* Array_prototype_iterator(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ArrayIteratorPrototypeIteratorCall(e, o, othis, args, newTarget);
}

Val* Array_from(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* C = NULL, *ret = NULL, *items = NULL, *arrayLike = GetArg(e, args, 0);
    Val* mapfn = GetArg(e, args, 1), *thisArg = GetArg(e, args, 2), *usingIterator = NULL;
    Val* A = NULL, *iterator = NULL, *pk = NULL, *next = NULL, *mappedValue = NULL;
    Val* defineStatus = NULL, *len = NULL, *lenValue = NULL, *kValue = NULL, *putStatus = NULL;
    Val* T = NULL, *nextValue = NULL;

    C = ValClone(e, othis);
    items = ToObject(e, arrayLike);
    RET_IF_AB(items);
    bool_t mapping = TRUE;
    if(ValIsUndef(mapfn))
        mapping = FALSE;
    else {
        if(!ValIsTrueDel(e, IsCallable(e, mapfn)))
            RET(ThrowTypeError(e, "not callable",0,0));
        T = ValClone(e, thisArg);
        mapping = TRUE;
    }
    usingIterator = CheckIterable(e, items);
    RET_IF_AB(usingIterator);
    if(!ValIsUndef(usingIterator)) {
        if(ValIsTrueDel(e, IsConstructor(e, C))) 
            A = DoConstruct(e, C, NULL, NULL);
        else 
            A = ArrayCreate(e, 0, NULL);
        RET_IF_AB(A);
        iterator = GetIterator(e, items, usingIterator);
        RET_IF_AB(iterator);
        Val k;
        ValInitNum(&k, 0);
        while(TRUE) {
            pk = ToString(e, &k);
            next = IteratorStep(e, iterator);
            RET_IF_AB(next);
            if(next->type == TYPE_BOOL && next->b == FALSE) {
                putStatus = Put(e, A, e->strLength, &k, TRUE);
                RET_IF_AB(putStatus);
                RET_VAL(A);
            }
            nextValue = IteratorValue(e, next);
            RET_IF_AB(nextValue);
            if(mapping) {
                mappedValue = Call2(e, mapfn, T, nextValue, &k);
                RET_IF_AB(mappedValue);
            }
            else {
                mappedValue = ValClone(e, nextValue);
            }
            defineStatus = CreateDataPropOrThrow(e, A, pk, mappedValue);
            RET_IF_AB(defineStatus);
            k.num++;
            IFZ(pk);
            IFZ(next);
            IFZ(nextValue);
            IFZ(mappedValue);
            IFZ(defineStatus);
        }
    }
    lenValue = Get(e, items, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(ValIsTrueDel(e, IsConstructor(e, C))) 
        A = Construct1(e, C, len, NULL);
    else
        A = ArrayCreate(e, len, NULL);
    RET_IF_AB(A);
    Val k;
    ValInitNum(&k, 0);
    while(k.num < len->num) {
        pk = ToString(e, &k);
        kValue = Get(e, items, pk);
        RET_IF_AB(kValue);
        if(mapping) {
            mappedValue = Call2(e, mapfn, T, kValue, &k);
            RET_IF_AB(mappedValue);
        }
        else
            mappedValue = ValClone(e, kValue);
        defineStatus = CreateDataPropOrThrow(e, A, pk, mappedValue);
        RET_IF_AB(defineStatus);
        k.num++;
        IFZ(pk);
        IFZ(kValue);
        IFZ(mappedValue);
        IFZ(defineStatus);
    }
    putStatus = Put(e, A, e->strLength, len, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(A);

exit:
    IFD(C);
    IFD(T);
    IFD(items);
    IFD(arrayLike);
    IFD(mapfn);
    IFD(thisArg);
    IFD(usingIterator);
    IFD(A);
    IFD(iterator);
    IFD(pk);
    IFD(next);
    IFD(mappedValue);
    IFD(defineStatus);
    IFD(len);
    IFD(lenValue);
    IFD(kValue);
    IFD(putStatus);
    IFD(nextValue);
    return ret;

}

Val* Array_isArray(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* arg = GetArg(e, args, 0);
    Val* ret = NULL;
    if(arg->type != TYPE_OBJ)
        ret = ValNewBool(e, FALSE);
    else {
        if(IsArray(e, arg))
            ret = ValNewBool(e, TRUE);
        else
            ret = ValNewBool(e, TRUE);
    }
    ValDel(e, arg);
    return ret;
}

Val* Array_of(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* pk = NULL, *defineStatus = NULL, *kValue = NULL, *ret = NULL, *A = NULL;
    Val* len = ValNewNum(e, args->list->count), *putStatus = NULL;
    Val* C = othis;
    if(ValIsTrueDel(e, IsConstructor(e, C))) 
        A = Construct1(e, C, len, NULL);
    else
        A = ArrayCreate(e, len, NULL);
    RET_IF_AB(A);
    Val k;
    ValInitNum(&k, 0);
    Item* arg = args->list->head;
    while(k.num < len->num) {
        kValue = arg->value;
        pk = ToString(e, &k);
        defineStatus = CreateDataPropOrThrow(e, A, pk, kValue);
        RET_IF_AB(defineStatus);
        k.num++;
        IFZ(pk);
        IFZ(defineStatus);
        arg = arg->next;
    }
    putStatus = Put(e, A, e->strLength, len, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(A);

exit:
    IFD(pk);
    IFD(defineStatus);
    IFD(putStatus);
    IFD(pk);
    IFD(A);
    IFD(len);
    return ret;
}

Val* IsConcatSpreadable(Js* e, Val* O) {
    Val* ret = NULL, *spreadable = NULL;

    if(O->type != TYPE_OBJ)
        RET(ValNewBool(e, FALSE));
    spreadable = Get(e, O, e->isConcatSpreadable);
    RET_IF_AB(spreadable);
    if(!ValIsUndef(spreadable))
        RET(ToBoolean(e, spreadable));
    if(IsArray(e, O))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));
exit:
    IFD(spreadable);
    return ret;    

}

// Return a list of items in an array plus arguments
// This is used by Array.prototype.concat
List* ListFromArrayAndArgs(Js* e, Val* array, Val* args) {
    List* list = ListNew(e);
    Val* vlen = Get(e, array, e->strLength);
    int l = vlen->num;
    for(int i=0; i < l; i++) {
        char buff[25];
        sprintf(buff, "%d", i);
        ListAddValue(e, list, GetA(e, array, buff));
    }

    // Now add the arguments
    Item* i = args->list->head;
    while(i) {
        ListAddValue(e, list, ValClone(e, i->value));
        i = i->next;
    }
    ValDel(e, vlen);
    return list;
}

Val* Array_prototype_concat(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *A = NULL, *len = NULL, *k = NULL, *E = NULL, *P = NULL, *lenVal = NULL;
    Val* n = NULL, *ret = NULL, *putStatus = NULL, *status = NULL, *spreadable = NULL, *subElement = NULL;
    Val* exists = NULL;
    List* items = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    A = ConstructFromArray(e, O, 0);
    RET_IF_AB(A);
    n = ValNewNum(e, 0);
    items = ListFromArrayAndArgs(e, O, args);
    Item* item = items->head;
    while(item) {
        E = item->value;
        spreadable = IsConcatSpreadable(e, E);
        RET_IF_AB(spreadable);
        if(ValIsTrue(e, spreadable)) {
            k = ValNewNum(e, 0);
            lenVal = Get(e, E, e->strLength);
            len = ToLength(e, lenVal);
            RET_IF_AB(len);
            while(k->num < len->num) {
                P = ToString(e, k);
                exists = HasProp(e, E, P);
                RET_IF_AB(exists);
                if(ValIsTrue(e, exists)) {
                    subElement = Get(e, E, P);
                    RET_IF_AB(subElement);
                    Val* strN = ToString(e, n);
                    status = CreateDataPropOrThrow(e, A, strN, subElement);
                    ValDel(e, strN);
                    RET_IF_AB(status);                    
                }
                n->num++;
                k->num++;
                IFZ(P);
                IFZ(exists);
                IFZ(subElement);
                IFZ(status);
                IFZ(exists);
            }
        }
        else {
            Val* strN = ToString(e, n);
            status = CreateDataPropOrThrow(e, A, strN, E);
            ValDel(e, strN);
            RET_IF_AB(status);
            IFZ(status);
            n->num++;
        }
        IFZ(spreadable);
        item = item->next;
    }
    putStatus = Put(e, A, e->strLength, n, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(A);

exit:
    IFD(O);
    IFD(A);
    IFD(len);
    IFD(k);
    IFD(P);
    IFD(lenVal);
    IFD(n);
    IFD(exists);
    IFD(subElement);
    IFD(spreadable);
    IFD(putStatus);
    IFD(status);
    if(items) ListDel(e, items);
    return ret;    

}

Val* ToStringFromInt(Js* e, number i) {
    Val n;
    ValInitNum(&n,i);
    return ToString(e, &n);
}

Val* Array_prototype_copyWithin(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *lenVal = NULL, *len = NULL, *relativeTarget = NULL, *relativeStart = NULL, *relativeEnd = NULL;
    Val* target = GetArg(e, args, 0), *start = GetArg(e, args, 1), *end = GetArg(e, args, 2);
    Val* fromKey = NULL, *toKey = NULL, *fromPresent = NULL, *putStatus = NULL, *deleteStatus = NULL;
    Val* ret = NULL, *fromVal = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    relativeTarget = ToInteger(e, target);
    RET_IF_AB(relativeTarget);
    int to, from;
    if(relativeTarget->num < 0)
        to = max((len->num + relativeTarget->num), 0);
    else
        to = min(relativeTarget->num, len->num);
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);
    if(relativeStart->num < 0)
        from = max((len->num + relativeStart->num), 0);
    else
        from = min(relativeStart->num, len->num);
    if(ValIsUndef(end)) 
        relativeEnd = ValClone(e, len);
    else
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);
    int final;
    if(relativeEnd->num < 0)
        final = max((len->num + relativeEnd->num), 0);
    else
        final = min(relativeEnd->num, len->num);
    int count = min(final - from, len->num - to);
    int direction;
    if(from < to && to < (from + count)) {
        direction = -1;
        from = from + count - 1;
        to = to + count - 1;
    }
    else 
        direction = 1;
    while(count > 0) {
        fromKey = ToStringFromInt(e, from);
        toKey = ToStringFromInt(e, to);
        fromPresent = HasProp(e, O, fromKey);
        RET_IF_AB(fromPresent);
        if(ValIsTrue(e, fromPresent)) {
            fromVal = Get(e, O, fromKey);
            RET_IF_AB(fromVal);
            putStatus = Put(e, O, toKey, fromVal, TRUE);
            RET_IF_AB(putStatus);
            IFZ(putStatus);
            IFZ(fromVal);
        }
        else {
            deleteStatus = DeletePropOrThrow(e, O, toKey);
            RET_IF_AB(deleteStatus);
            IFZ(deleteStatus);
        }
        IFZ(fromKey);
        IFZ(toKey);
        IFZ(fromPresent);
        from = from + direction;
        to = to + direction;
        count = count - 1;
    }

    RET_VAL(O);
    

exit:
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(relativeTarget);
    IFD(relativeStart);
    IFD(target);
    IFD(start);
    IFD(end);
    IFD(fromKey);
    IFD(toKey);
    IFD(fromPresent);
    IFD(putStatus);
    IFD(deleteStatus);
    IFD(relativeEnd);
    IFD(fromVal);
    return ret;    
}

Val* Array_prototype_entries(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = ToObject(e, othis);
    if(ValIsAbrupt(e, O))
        return O;
    Val* kind = ValNewStrA(e, "key+value");
    Val* ret = CreateArrayIterator(e, O, kind);
    ValDel(e, O);
    ValDel(e, kind);
    return ret;
}

Val* Array_prototype_every(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* ret = NULL, *O = NULL, *lenValue = NULL, *len = NULL, *k = NULL, *pk = NULL;
    Val* kPresent = NULL, *kValue = NULL, *testResult = NULL, *T = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn))) 
        RET(ThrowTypeError(e, "not callable",0,0));

    T = thisArg;
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            testResult = Call3(e, callbackfn, T, kValue, k, O);
            RET_IF_AB(testResult);
            if(!ValIsTrueDel(e, ToBoolean(e, testResult)))
                RET(ValNewBool(e, FALSE));
            IFZ(kValue);
            IFZ(testResult);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
    }
    RET(ValNewBool(e, TRUE));
    
exit:
    IFD(callbackfn);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kPresent);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}

Val* Array_prototype_fill(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* value = GetArg(e, args, 0), *start = GetArg(e, args, 1), *end = GetArg(e, args, 2);
    Val* O = NULL, *lenVal = NULL, *len = NULL, *k = NULL, *relativeStart = NULL, *relativeEnd = NULL;
    Val* pk = NULL, *putStatus = NULL, *ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);

    if(relativeStart->num < 0)
        k = ValNewNum(e, max((len->num + relativeStart->num), 0));
    else
        k = ValNewNum(e, min(relativeStart->num, len->num));
    if(ValIsUndef(end))
        relativeEnd = ValClone(e, len);
    else 
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);

    int final = 0;
    if(relativeEnd->num < 0)
        final = max((len->num + relativeEnd->num), 0);
    else
        final = min(relativeEnd->num, len->num);
    while(k->num < final) {
        pk = ToString(e, k);
        putStatus = Put(e, O, pk, value, TRUE);
        RET_IF_AB(putStatus);
        k->num++;
        IFZ(pk);
        IFZ(putStatus);
    }
    RET_VAL(O);
exit:
    IFD(value);
    IFD(start);
    IFD(end);
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(k);
    IFD(relativeStart);
    IFD(relativeEnd);
    IFD(pk);
    IFD(putStatus);
    return ret;    
}

Val* Array_prototype_filter(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *T = NULL, *A = NULL;
    Val *k = NULL, *pk = NULL, *kValue = NULL, *selected = NULL;
    Val* status = NULL, *ret = NULL, *to = NULL, *kPresent = NULL;
    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    T = thisArg;
    A = ConstructFromArray(e, O,0);
    RET_IF_AB(A);
    k = ValNewNum(e, 0);
    to = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            selected = Call3(e, callbackfn, T, kValue, k, O);
            RET_IF_AB(selected);
            if(ValIsTrueDel(e, ToBoolean(e, selected))) {
                Val* tos = ToString(e, to);
                status = CreateDataPropOrThrow(e, A, tos, kValue);
                ValDel(e, tos);
                RET_IF_AB(status);
                to->num++;
                IFZ(status);
            }
            IFZ(kValue);
            IFZ(selected);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
    }
    RET_VAL(A);
exit:
    IFD(kPresent);
    IFD(to);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(A);
    IFD(k);
    IFD(pk);
    IFD(kValue);
    IFD(selected);
    IFD(status);
    return ret;    
}

Val* Array_prototype_find(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* predicate = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *T = NULL, *k = NULL;
    Val* pk = NULL, *kValue = NULL, *testResult = NULL, *ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, predicate)))
        RET(ThrowTypeError(e, "not callable",0,0));
    T = thisArg;
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kValue = Get(e, O, pk);
        RET_IF_AB(kValue);
        testResult = Call3(e, predicate, T, kValue, k, O);
        RET_IF_AB(testResult);
        if(ValIsTrueDel(e, ToBoolean(e, testResult)))
            RET_VAL(kValue);
        k->num++;
        IFZ(pk);
        IFZ(kValue);
        IFZ(testResult);
    }
    RET(ValNew(e));
exit:
    IFD(predicate);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}

Val* Array_prototype_findIndex(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* predicate = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *T = NULL, *k = NULL;
    Val* pk = NULL, *kValue = NULL, *testResult = NULL, *ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, predicate)))
        RET(ThrowTypeError(e, "not callable",0,0));
    T = thisArg;
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kValue = Get(e, O, pk);
        RET_IF_AB(kValue);
        testResult = Call3(e, predicate, T, kValue, k, O);
        RET_IF_AB(testResult);
        if(ValIsTrueDel(e, ToBoolean(e, testResult)))
            RET_VAL(k);
        k->num++;
        IFZ(pk);
        IFZ(kValue);
        IFZ(testResult);
    }
    RET(ValNewNum(e,-1));
exit:
    IFD(predicate);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}

Val* Array_prototype_forEach(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *T = NULL, *k = NULL;
    Val* pk = NULL, *kValue = NULL, *funcResult = NULL, *ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    T = thisArg;
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        Val* kPresent = HasProp(e, O, pk);
        if(ValIsTrueDel(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            funcResult = Call3(e, callbackfn, T, kValue, k, O);
            RET_IF_AB(funcResult);
            IFZ(kValue);
            IFZ(funcResult);
        }
        k->num++;
        IFZ(pk);
    }
    RET(ValNew(e));
exit:
    IFD(callbackfn);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kValue);
    IFD(funcResult);
    return ret;    
}

Val* Array_prototype_indexOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* searchElement = GetArg(e, args, 0), *fromIndex = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *n = NULL, *k = NULL;
    Val* kPresent = NULL, *elementK = NULL, *same = NULL, *ret = NULL, *pk = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(len->num == 0)
        RET(ValNewNum(e, -1));
    if(ValIsUndef(fromIndex))
        n = ValNewNum(e, 0);
    else
        n = ToInteger(e, fromIndex);
    RET_IF_AB(n);
    if(n->num >= len->num)
        RET(ValNewNum(e, -1));
    if(n->num >= 0) 
        k = ValClone(e, n);
    else 
        k = ValNewNum(e, len->num - fabs(n->num));
    if(k->num < 0)
        k->num = 0;
    while(k->num < len->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            elementK = Get(e, O, pk);
            RET_IF_AB(elementK);
            same = StrictEquality(e, searchElement, elementK);
            if(ValIsTrue(e, same))
                RET_VAL(k);
            IFZ(elementK);
            IFZ(same);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
    }
    RET(ValNewNum(e, -1));
exit:
    IFD(pk);
    IFD(searchElement);
    IFD(fromIndex);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(n);
    IFD(k);
    IFD(kPresent);
    IFD(elementK);
    IFD(same);
    return ret;    
}

Val* Array_prototype_join(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* separator = GetArg(e, args, 0);
    Val* O = NULL, *lenVal = NULL, *len = NULL, *sep = NULL, *element0 = NULL;
    Val* k = NULL, *pk = NULL, *element = NULL, *ret = NULL, *next = NULL;
    DynStr* R = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    if(ValIsUndef(separator))
        sep = ValNewStrA(e, ",");
    else
        sep = ToString(e, separator);
    if(len->num == 0)
        RET(ValNewStrA(e, ""));
    element0 = Get(e, O, e->strZero);

    R = DynStrNew(e, len->num* 4);
    if(!ValIsUndef(element0) &&  !ValIsNull(element0)) {
        next = ToString(e, element0);
        RET_IF_AB(next);
        DynStrAddStr(e, R, next->str);
        IFZ(next);
    }
    k = ValNewNum(e, 1);
    while(k->num < len->num) {
        DynStrAddStr(e, R, sep->str);
        pk = ToString(e, k);
        element = Get(e, O, pk);
        if(ValIsUndef(element) || ValIsNull(element))
            next = ValNewStrA(e, "");
        else
            next = ToString(e, element);
        RET_IF_AB(next);
        DynStrAddStr(e, R, next->str);
        k->num++;
        IFZ(pk);
        IFZ(element);
        IFZ(next);
    }
    ret = StrFromDynStr(e, R);
    R = NULL;
exit:
    if(R) DynStrDel(e, R);
    IFD(next);
    IFD(separator);
    IFD(sep);
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(element);
    IFD(element0);
    IFD(k);
    IFD(pk);
    return ret;    
}


Val* Array_prototype_keys(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = ToObject(e, othis);
    if(ValIsAbrupt(e, O))
        return O;
    Val* kind = ValNewStrA(e, "key");
    Val* ret = CreateArrayIterator(e, O, kind);
    ValDel(e, O);
    ValDel(e, kind);
    return ret;
}

Val* Array_prototype_lastIndexOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* searchElement = GetArg(e, args, 0), *fromIndex = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *n = NULL, *k = 0, *kPresent = 0;
    Val* elementK = NULL, *same = NULL, *ret = NULL, *pk = NULL;
    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(len->num == 0)
        RET(ValNewNum(e, -1));
    if(ValIsUndef(fromIndex))
        n = ValNewNum(e, len->num-1);
    else 
        n = ToInteger(e, fromIndex);
    RET_IF_AB(n);
    if(n->num >= 0)
        k = ValNewNum(e, min(n->num, len->num -1));
    else
        k = ValNewNum(e, len->num - fabs(n->num));
    while(k->num >= 0) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            elementK = Get(e, O, pk);
            RET_IF_AB(elementK);
            same = StrictEquality(e, searchElement, elementK);
            if(ValIsTrue(e, same))
                RET_VAL(k);
            IFZ(elementK);
            IFZ(same);
        }
        IFZ(kPresent);
        IFZ(pk);
        k->num--;
    }
    RET(ValNewNum(e, -1));

exit:
    IFD(pk);
    IFD(searchElement);
    IFD(fromIndex);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(n);
    IFD(k);
    IFD(elementK);
    IFD(kPresent);
    IFD(same);
    return ret;    
}

Val* Array_prototype_map(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *A = NULL;
    Val* k = NULL, *kPresent = NULL, *kValue = NULL, *status = NULL, *pk = NULL;
    Val* ret = NULL, *mappedValue = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    Val* T = thisArg;

    A = ConstructFromArray(e, O,0);
    RET_IF_AB(A);

    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            mappedValue = Call3(e, callbackfn, T, kValue, k, O);
            RET_IF_AB(mappedValue);
            status = CreateDataPropOrThrow(e, A, pk, mappedValue);
            RET_IF_AB(status);
            IFZ(kValue);
            IFZ(mappedValue);
            IFZ(status);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
    }
    RET_VAL(A);

exit:
    IFD(mappedValue);
    IFD(pk);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(A);
    IFD(k);
    IFD(kPresent);
    IFD(kValue);
    IFD(status);
    return ret;    
}

Val* Array_prototype_pop(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = ToObject(e, othis), *lenValue = NULL, *len = NULL, *putStatus = NULL;
    Val* deleteStatus = NULL, *element = NULL, * ret = NULL;
    Val* newLen = NULL, *indx = NULL;

    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(len->num == 0) {
        putStatus = Put(e, O, e->strLength, len, TRUE);
        RET_IF_AB(putStatus);
        RET(ValNew(e));
    }
    newLen = ValNewNum(e, len->num - 1);
    indx = ToString(e, newLen);
    element = Get(e, O, indx);
    RET_IF_AB(element);
    deleteStatus = DeletePropOrThrow(e, O, indx);
    RET_IF_AB(deleteStatus);
    putStatus = Put(e, O, e->strLength, newLen, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(element);

exit:
    IFD(newLen);
    IFD(indx);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(putStatus);
    IFD(deleteStatus);
    IFD(element);
    return ret;    
}

Val* Array_prototype_push(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = ToObject(e, othis), *lenVal = NULL, *n = NULL;
    Val* putStatus = NULL, *ret = NULL, *pk = NULL;

    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    n = ToLength(e, lenVal);
    RET_IF_AB(n);
    for(Item* item = args->list->head; item; item = item->next) {
        pk = ToString(e, n);
        putStatus = Put(e, O, pk, item->value, TRUE);
        RET_IF_AB(putStatus);
        n->num++;
        IFZ(pk);
        IFZ(putStatus);
    }
    putStatus = Put(e, O, e->strLength, n, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(n);
exit:
    IFD(O);
    IFD(lenVal);
    IFD(n);
    IFD(pk);
    IFD(putStatus);
    return ret;    
}


Val* Array_prototype_reduce(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *initialValue = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *k = NULL, *pk = NULL;
    Val* kPresent = NULL, *accumulator = NULL, *kValue = NULL, *ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    if(len->num == 0 && ValIsUndef(initialValue))
        RET(ThrowTypeError(e, "no initial value",0,0));
    k = ValNewNum(e, 0);
    if(!ValIsUndef(initialValue)) {
        accumulator = ValClone(e, initialValue);
    }
    else {
        while(k->num < len->num) {
            pk = ToString(e, k);
            kPresent = HasProp(e, O, pk);
            RET_IF_AB(kPresent);
            if(ValIsTrue(e, kPresent)) {
                accumulator = Get(e, O, pk);
                RET_IF_AB(accumulator);
                IFZ(pk);
                k->num++;
                break;
            }
            IFZ(kPresent);
            IFZ(pk);
            k->num++;
        }
    }
    if(!kPresent)
        RET(ThrowTypeError(e, 0,pk, " not found"));
    ValDel(e, kPresent);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            Val* temp = Call4(e, callbackfn, NULL, accumulator, kValue, k, O);
            RET_IF_AB(temp);
            ValDel(e, accumulator);
            accumulator = temp;
            IFZ(kValue);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
    }
    RET_VAL(accumulator);

exit:
    IFD(callbackfn);
    IFD(initialValue);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kPresent);
    IFD(accumulator);
    IFD(kValue);
    return ret;    
}


Val* Array_prototype_reduceRight(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *initialValue = GetArg(e, args, 1);
    Val* O = NULL, *lenValue = NULL, *len = NULL, *k = NULL, *pk = NULL;
    Val* kPresent = NULL, *accumulator = NULL, *kValue = NULL, *ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    if(len->num == 0 && ValIsUndef(initialValue))
        RET(ThrowTypeError(e, "initial value expected",0,0));
    k = ValNewNum(e, len->num-1);
    if(!ValIsUndef(initialValue)) {
        accumulator = ValClone(e, initialValue);
    }
    else {
        while(k->num >= 0) {
            pk = ToString(e, k);
            kPresent = HasProp(e, O, pk);
            RET_IF_AB(kPresent);
            if(ValIsTrue(e, kPresent)) {
                accumulator = Get(e, O, pk);
                RET_IF_AB(accumulator);
                IFZ(pk);
                k->num--;
                break;
            }
            IFZ(kPresent);
            IFZ(pk);
            k->num--;
        }
    }
    if(!kPresent)
        RET(ThrowTypeError(e, 0, pk, " not found"));
    ValDel(e, kPresent);
    while(k->num >= 0) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            Val* temp = Call4(e, callbackfn, NULL, accumulator, kValue, k, O);
            RET_IF_AB(temp);
            ValDel(e, accumulator);
            accumulator = temp;
            IFZ(kValue);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num--;
    }
    RET_VAL(accumulator);

exit:
    IFD(callbackfn);
    IFD(initialValue);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kPresent);
    IFD(accumulator);
    IFD(kValue);
    return ret;    
}


Val* Array_prototype_reverse(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *lenVal = NULL, *len = NULL, *upperP = NULL, *lowerP = NULL;
    Val* middle = NULL, *lower = NULL, *upper = NULL, *upperExists = NULL, *lowerExists = NULL;
    Val* upperValue = NULL, *lowerValue = NULL, *putStatus = NULL, *deleteStatus = NULL;
    Val* ret = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    if(len->num < 0)
        RET_VAL(O);     // @spec this is unclear in the spec but causes T262 hangs
    middle = ValNewNum(e, floor(len->num/2));
    lower = ValNewNum(e, 0);
    upper = ValNewNum(e, 0);
    while(lower->num != middle->num) {
        upper->num = len->num - lower->num - 1;
        upperP = ToString(e, upper);
        lowerP = ToString(e, lower);
        lowerExists = HasProp(e, O, lowerP);
        RET_IF_AB(lowerExists);
        if(ValIsTrue(e, lowerExists)) {
            lowerValue = Get(e, O, lowerP);
            RET_IF_AB(lowerValue);
        }
        upperExists = HasProp(e, O, upperP);
        RET_IF_AB(upperExists);
        if(ValIsTrue(e, upperExists)) {
            upperValue = Get(e, O, upperP);
            RET_IF_AB(upperValue);
        }
        if(ValIsTrue(e, lowerExists) && ValIsTrue(e, upperExists)) {
            putStatus = Put(e, O, lowerP, upperValue, TRUE);
            RET_IF_AB(putStatus);
            ValDel(e, putStatus);
            putStatus = Put(e, O, upperP, lowerValue, TRUE);
            RET_IF_AB(putStatus);
            IFZ(putStatus);
        }
        else if(!ValIsTrue(e, lowerExists) && ValIsTrue(e, upperExists)) {
            putStatus = Put(e, O, lowerP, upperValue, TRUE);
            RET_IF_AB(putStatus);
            IFZ(putStatus);
            deleteStatus = DeletePropOrThrow(e, O, upperP);
            RET_IF_AB(deleteStatus);
            IFZ(deleteStatus);
        }
        else if(ValIsTrue(e, lowerExists) && !ValIsTrue(e, upperExists)) {
            deleteStatus = DeletePropOrThrow(e, O, lowerP);
            RET_IF_AB(deleteStatus);
            IFZ(deleteStatus);
            putStatus = Put(e, O, upperP, lowerValue, TRUE);
            RET_IF_AB(putStatus);
            IFZ(putStatus);
        }
        else {
            // Nothing to do
        }
        lower->num++;
        IFZ(lowerValue);
        IFZ(upperValue);
        IFZ(lowerP);
        IFZ(upperP);
        IFZ(lowerExists);
        IFZ(upperExists);
    }
    RET_VAL(O);

exit:
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(upperP);
    IFD(lowerP);
    IFD(middle);
    IFD(lower);
    IFD(upper);
    IFD(upperExists);
    IFD(lowerExists);
    IFD(upperValue);
    IFD(lowerValue);
    IFD(putStatus);
    IFD(deleteStatus);
    return ret;    
}

Val* Array_prototype_shift(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = NULL, *lenVal = NULL, *len = NULL, *k = NULL, *from = NULL;
    Val* to = NULL, *fromPresent = NULL, *deleteStatus = NULL, *putStatus = NULL;
    Val* first = NULL, *ret = NULL, *fromVal = NULL;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    if(len->num == 0) {
        putStatus = Put(e, O, e->strLength, len, TRUE);
        RET_IF_AB(putStatus);
        RET(ValNew(e));
    }
    first = Get(e, O, e->strZero);
    RET_IF_AB(first);
    k = ValNewNum(e, 1);
    while(k->num < len->num) {
        from = ToString(e, k);
        Val km;
        ValInitNum(&km, k->num -1);
        to = ToString(e, &km);
        fromPresent = HasProp(e, O, from);
        RET_IF_AB(fromPresent);
        if(ValIsTrue(e, fromPresent)) {
            fromVal = Get(e, O, from);
            RET_IF_AB(fromVal);
            putStatus = Put(e, O, to, fromVal, TRUE);
            RET_IF_AB(putStatus);
            IFZ(fromVal);
            IFZ(putStatus);
        }
        else {
            deleteStatus = DeletePropOrThrow(e, O, to);
            RET_IF_AB(deleteStatus);
            IFZ(deleteStatus);
        }
        IFZ(from);
        IFZ(to);
        IFZ(fromPresent);
        k->num++;
    }
    len->num--;
    from = ToString(e, len);
    deleteStatus = DeletePropOrThrow(e, O, from);
    RET_IF_AB(deleteStatus);
    putStatus = Put(e, O, e->strLength, len, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(first);

exit:
    IFD(fromVal);
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(k);
    IFD(from);
    IFD(to);
    IFD(fromPresent);
    IFD(deleteStatus);
    IFD(putStatus);
    IFD(first);
    return ret;
}

number Min(number n1, number n2) {
    if(n1 < n2)
        return n1;
    return n2;
}

number Max(number n1, number n2) {
    if(n1 > n2)
        return n1;
    return n2;
}

Val* Array_prototype_slice(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* start = GetArg(e, args, 0), *end = GetArg(e, args, 1);
    Val* O = 0, *lenVal = 0, *len = 0, *relativeStart = 0, *relativeEnd = 0;
    Val* A = 0, *ret = 0, *n = 0, *k = 0, *pk = 0, *kPresent = 0;
    Val* kValue = 0, *putStatus = 0, *final = 0, *count = 0, *status = 0;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);
    if(relativeStart->num < 0)
        k = ValNewNum(e, Max((len->num + relativeStart->num), 0));
    else
        k = ValNewNum(e, Min(relativeStart->num, len->num));
    if(ValIsUndef(end)) 
        relativeEnd = ValClone(e, len);
    else
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);
    if(relativeEnd->num < 0)
        final = ValNewNum(e, Max((len->num + relativeEnd->num), 0));
    else
        final = ValNewNum(e, Min(relativeEnd->num, len->num));

    count = ValNewNum(e, Max(final->num - k->num, 0));
    A = ConstructFromArray(e, O,0);
    RET_IF_AB(A);
    n = ValNewNum(e, 0);
    while(k->num < final->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            Val* pn = ToString(e, n);
            status = CreateDataPropOrThrow(e, A, pn, kValue);
            ValDel(e, pn);
            RET_IF_AB(status);
            IFZ(kValue);
            IFZ(status);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
        n->num++;
    }    
    putStatus = Put(e, A, e->strLength, n, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(A);
exit:
    IFD(status);
    IFD(count);
    IFD(start);
    IFD(end);
    IFD(O);  
    IFD(lenVal);
    IFD(len);
    IFD(relativeStart);
    IFD(relativeEnd);
    IFD(A);
    IFD(n);
    IFD(k);
    IFD(pk);
    IFD(kPresent);
    IFD(kValue);
    IFD(putStatus);
    IFD(final);
    return ret;  
}


Val* Array_prototype_some(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* O = 0, *lenValue = 0, *len = 0, *k = 0, *pk = 0, *kPresent = 0, *kValue = 0;
    Val* testResult = 0, *ret = 0;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenValue = Get(e, O, e->strLength);
    len = ToLength(e, lenValue);
    RET_IF_AB(len);
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    Val* T = thisArg;
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kPresent = HasProp(e, O, pk);
        RET_IF_AB(kPresent);
        if(ValIsTrue(e, kPresent)) {
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            testResult = Call3(e, callbackfn, T, kValue, k, O);
            RET_IF_AB(testResult);
            if(ValIsTrueDel(e, ToBoolean(e, testResult)))
                RET(ValNewBool(e, TRUE));
            IFZ(kValue);
            IFZ(testResult);
        }
        IFZ(pk);
        IFZ(kPresent);
        k->num++;
    }
    RET(ValNewBool(e, FALSE));

exit:
    IFD(callbackfn);
    IFD(thisArg);
    IFD(O);
    IFD(lenValue);
    IFD(len);
    IFD(k);
    IFD(pk);
    IFD(kPresent);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}

number StringCompare(Js* e, Str* x, Str* y) {
    for(int k=0; k < x->length; k++) {
        if(k >= y->length)
            return 1;
        uchar m = x->chars[k];
        uchar n = y->chars[k];
        if(m < n)
            return -1;
        else if(m > n)
            return 1;
    }
    return 0;
}

Val* SortCompare(Js* e, Val* comparefn, Val* x, Val* y) {
    Val* ret = 0, *v = 0, *xString = 0, *yString = 0;

    if(ValIsUndef(x) && ValIsUndef(y))
        RET(ValNewNum(e, 0));
    if(ValIsUndef(x))
        RET(ValNewNum(e, 1));
    if(ValIsUndef(y))
        RET(ValNewNum(e, -1));
    if(!ValIsUndef(comparefn)) {
        if(!ValIsTrueDel(e, IsCallable(e, comparefn)))
            RET(ThrowTypeError(e, "not callable",0,0));
        v = Call2(e, comparefn, NULL, x, y);
        RET_IF_AB(v);
        if(v->type == TYPE_NUM && isnan(v->num))
            RET(ValNewNum(e, 0));
        RET_VAL(v);
    }
    xString = ToString(e, x);
    RET_IF_AB(xString);
    yString = ToString(e, y);
    RET_IF_AB(yString);
    number n = StringCompare(e, xString->str, yString->str);
    RET(ValNewNum(e, n));
exit:   
    IFD(xString);
    IFD(yString);
    IFD(v); 
    return ret;
}

Val* Array_prototype_sort(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* comparefn = GetArg(e, args, 0), *ret = 0, *O = 0, *lenVal = 0, *len = 0;
    Val* pkx = 0, *pky = 0, *vx = 0, *vy = 0, *putStatus = 0, *k = 0, *j = 0;
    Val* hx = 0, *hy = 0, *status = 0;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);

    k = ValNewNum(e, 0);
    j = ValNewNum(e, 0);
    while(k->num < len->num) {
        pky = ToString(e, k);
        hy = HasProp(e, O, pky);
        RET_IF_AB(hy);
        if(!ValIsTrue(e, hy)) {
            IFZ(pky);
            IFZ(hy);
            k->num++;
            continue;
        }
        vy = Get(e, O, pky);
        RET_IF_AB(vy);
        j->num = k->num + 1;
        while(j->num < len->num) {
            pkx = ToString(e, j);
            hx = HasProp(e, O, pkx);
            RET_IF_AB(hx);
            if(!ValIsTrue(e, hx)) {
                IFZ(pkx);
                IFZ(hx);
                j->num++;
                continue;
            }
            vx = Get(e, O, pkx);
            RET_IF_AB(vx);
            status = SortCompare(e, comparefn, vx, vy);
            RET_IF_AB(status);
            if(status->num < 0) {
                ValDel(e, status);
                status = Put(e, O, pkx, vy, TRUE);
                RET_IF_AB(status);
                ValDel(e, status);
                status = Put(e, O, pky, vx, TRUE);
                RET_IF_AB(status);
            }
            IFZ(status);
            IFZ(pkx);
            IFZ(hx);
            IFZ(vx);
            j->num++;
        }

        k->num++;
        IFZ(pky);
        IFZ(hy);
        IFZ(vy);
    }
    RET_VAL(O);

exit:
    IFD(status);
    IFD(hx);
    IFD(hy);
    IFD(comparefn);
    IFD(lenVal);
    IFD(len);
    IFD(pkx);
    IFD(k);
    IFD(j);
    IFD(pky);
    IFD(vx);
    IFD(vy);
    IFD(putStatus);
    return ret;    
}

Val* Array_prototype_splice(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* start = GetArg(e, args, 0), *deleteCount = GetArg(e, args, 1);
    Val* O = 0, *lenVal = 0, *len = 0, *relativeStart = 0, *actualDeleteCount = 0;
    Val* dc = 0, *A = 0, *k = 0, *from = 0, *fromPresent = 0, *fromValue = 0;
    Val* status = 0, *putStatus = 0, *to = 0, *toPresent = 0, *deleteStatus = 0;
    Val* actualStart = 0, *ret = 0;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);
    if(relativeStart->num < 0)
        actualStart = ValNewNum(e, Max((len->num + relativeStart->num), 0));
    else
        actualStart = ValNewNum(e, Min(relativeStart->num, len->num));
    if(args->list->count == 0)
        actualDeleteCount = ValNewNum(e, 0);
    else if(args->list->count == 1)
        actualDeleteCount = ValNewNum(e, len->num - actualStart->num);
    else {
        dc = ToInteger(e, deleteCount);
        RET_IF_AB(dc);
        actualDeleteCount = ValNewNum(e, Min(max(dc->num,0), len->num - actualStart->num));
    }
    A = ConstructFromArray(e, O, actualDeleteCount);
    RET_IF_AB(A);
    k = ValNewNum(e, 0);
    while(k->num < actualDeleteCount->num) {
        Val vf;
        ValInitNum(&vf, actualStart->num + k->num);
        from = ToString(e, &vf);
        fromPresent = HasProp(e, O, from);
        RET_IF_AB(fromPresent);
        if(ValIsTrue(e, fromPresent)) {
            fromValue = Get(e, O, from);
            RET_IF_AB(fromValue);
            Val* pk = ToString(e, k);
            status = CreateDataPropOrThrow(e, A, pk, fromValue);
            ValDel(e, pk);
            RET_IF_AB(status);
            IFZ(fromValue);
        }
        IFZ(from);
        IFZ(fromPresent);
        IFZ(status);
        k->num++;
    }
    putStatus = Put(e, A, e->strLength, actualDeleteCount, TRUE);
    RET_IF_AB(putStatus);
    int itemCount = args->list->count -2;
    IFZ(putStatus);

    if(itemCount < actualDeleteCount->num) {
        k->num = actualStart->num;
        while(k->num < (len->num - actualDeleteCount->num)) {
            from = ToStringFromInt(e, k->num + actualDeleteCount->num);
            to = ToStringFromInt(e, k->num + itemCount);
            fromPresent = HasProp(e, O, from);
            RET_IF_AB(fromPresent);
            if(ValIsTrue(e, fromPresent)) {
                fromValue = Get(e, O, from);
                RET_IF_AB(fromValue);
                putStatus = Put(e, O, to, fromValue, TRUE);
                RET_IF_AB(putStatus);
            }
            else {
                deleteStatus = DeletePropOrThrow(e, O, to);
                RET_IF_AB(deleteStatus);
            }
            k->num++;
            IFZ(from);
            IFZ(to);
            IFZ(fromPresent);
            IFZ(fromValue);
            IFZ(putStatus);
            IFZ(deleteStatus);
        }
        k->num = len->num;
        while(k->num > (len->num - actualDeleteCount->num + itemCount)) {
            from = ToStringFromInt(e, k->num -1);
            deleteStatus = DeletePropOrThrow(e, O, from);
            IFZ(from);
            RET_IF_AB(deleteStatus);
            IFZ(deleteStatus);
            k->num--;
        }
    }
    else if(itemCount > actualDeleteCount->num) {
        k->num = len->num - actualDeleteCount->num;
        while(k->num > actualStart->num) {
            from = ToStringFromInt(e, k->num + actualDeleteCount->num -1);
            to = ToStringFromInt(e, k->num + itemCount - 1);
            fromPresent = HasProp(e, O, from);
            RET_IF_AB(fromPresent);
            if(ValIsTrue(e, fromPresent)) {
                fromValue = Get(e, O, from);
                RET_IF_AB(from);
                putStatus = Put(e, O, to, fromValue, TRUE);
                RET_IF_AB(putStatus);
                IFZ(putStatus);
                IFZ(fromValue);
            }
            else {
                deleteStatus = DeletePropOrThrow(e, O, to);
                RET_IF_AB(deleteStatus);
                IFZ(deleteStatus);
            }
            k->num--;
            IFZ(from);
            IFZ(to);
            IFZ(fromPresent);
        }
    }
    k->num = actualStart->num;
    for(Item* item = args->list->head->next->next; item; item = item->next) {
        to = ToString(e, k);
        putStatus = Put(e, O, to, item->value, TRUE);
        RET_IF_AB(putStatus);
        IFZ(putStatus);
        IFZ(to);
        k->num++;
    }
    k->num = len->num - actualDeleteCount->num + itemCount;
    putStatus = Put(e, O, e->strLength, k, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(A);
exit:
    IFD(start);
    IFD(deleteCount);
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(relativeStart);
    IFD(actualDeleteCount);
    IFD(dc);
    IFD(A);
    IFD(k);
    IFD(from);
    IFD(fromPresent);
    IFD(fromValue);
    IFD(status);
    IFD(putStatus);
    IFD(to);
    IFD(toPresent);
    IFD(deleteStatus);
    IFD(actualStart);
    return ret;    

}

Val* Array_prototype_toLocaleString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* array = 0, *arrayLen = 0, *len = 0, *firstElement = 0, *k = 0, *nextElement =0;
    Val* ret = 0, *separator = 0, *s = 0, *ss = 0, *pk = 0;
    DynStr* R = 0;

    array = ToObject(e, othis);
    RET_IF_AB(array);
    arrayLen = Get(e, array, e->strLength);
    len = ToLength(e, arrayLen);
    RET_IF_AB(len);
    R = DynStrNew(e, len->num*10);
    separator = ValNewStrA(e, ",");
    firstElement = Get(e, array, e->strZero);
    RET_IF_AB(firstElement);
    if(!ValIsUndef(firstElement)) {
        s = Invoke0(e, firstElement, "toLocaleString");
        ss = ToString(e, s);
        RET_IF_AB(ss);
        DynStrAddStr(e, R, ss->str);
        IFZ(s);
        IFZ(ss);
    }
    k = ValNewNum(e, 1);
    while(k->num < len->num) {
        DynStrAddStr(e, R, separator->str);
        pk = ToString(e, k);
        nextElement = Get(e, array, pk);
        RET_IF_AB(nextElement);
        if(!ValIsUndef(nextElement) && !ValIsNull(nextElement)) {
            s = Invoke0(e, nextElement, "toLocaleString");
            ss = ToString(e, s);
            RET_IF_AB(ss);
            DynStrAddStr(e, R, ss->str);
            IFZ(s);
            IFZ(ss);            
        }
        k->num++;
        IFZ(pk);
        IFZ(nextElement);
    }
    ret = StrFromDynStr(e, R);
    R = 0;

exit:
    IFD(pk);
    IFD(s);
    IFD(ss);
    if(R) DynStrDel(e, R);
    IFD(separator);
    IFD(array);
    IFD(arrayLen);
    IFD(len);
    IFD(firstElement);
    IFD(nextElement);
    IFD(k);
    return ret;   
}


Val* Array_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* array = 0, *ret = 0, *func = 0;
    array = ToObject(e, othis);
    RET_IF_AB(array);
    func = GetA(e, array, "join");
    RET_IF_AB(func);
    if(!ValIsTrueDel(e, IsCallable(e, func))) {
        ValDel(e, func);
        func = ValClone(e, CurrentRealm(e)->objProto_toString);
    }
    RET(Call0(e, func, array));

exit:
    IFD(array);
    IFD(func);
    return ret;    
}


Val* Array_prototype_unshift(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = 0, *lenVal = 0, *len = 0, *k = 0, *from = 0, *to = 0;
    Val* fromPresent = 0, *fromValue = 0, *putStatus = 0, *deleteStatus = 0;
    Val* j =0, *ret = 0;

    O = ToObject(e, othis);
    RET_IF_AB(O);
    lenVal = Get(e, O, e->strLength);
    len = ToLength(e, lenVal);
    RET_IF_AB(len);
    int argCount = args->list->count;
    if(argCount > 0) {
        k = ValNewNum(e, len->num);
        while(k->num > 0) {
            from = ToStringFromInt(e, k->num-1);
            to = ToStringFromInt(e, k->num + argCount -1);
            fromPresent = HasProp(e, O, from);
            RET_IF_AB(fromPresent);
            if(ValIsTrue(e, fromPresent)) {
                fromValue = Get(e, O, from);
                RET_IF_AB(fromValue);
                putStatus = Put(e, O, to, fromValue, TRUE);
                RET_IF_AB(putStatus);
                IFZ(fromValue);
                IFZ(putStatus);
            }
            else {
                deleteStatus = DeletePropOrThrow(e, O, to);
                RET_IF_AB(deleteStatus);
                IFZ(deleteStatus);
            }
            IFZ(from);
            IFZ(to);
            IFZ(fromPresent);
            k->num--;
        }
        j = ValNewNum(e, 0);
        for(Item* i = args->list->head; i; i = i->next) {
            from = ToString(e, j);
            putStatus = Put(e, O, from, i->value, TRUE);
            RET_IF_AB(putStatus);
            IFZ(from);
            IFZ(putStatus);
            j->num++;
        }
    }
    len->num += argCount;
    putStatus = Put(e, O, e->strLength, len, TRUE);
    RET_IF_AB(putStatus);
    RET_VAL(len);

exit:
    IFD(O);
    IFD(lenVal);
    IFD(len);
    IFD(k);
    IFD(from);
    IFD(to);
    IFD(fromPresent);
    IFD(fromValue);
    IFD(putStatus);
    IFD(deleteStatus);
    IFD(j);
    return ret;    
}


Val* Array_prototype_values(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = ToObject(e, othis), *ret = 0, *kind = ValNewStrA(e, "value");
    RET_IF_AB(O);
    RET(CreateArrayIterator(e, O, kind));
exit:
    IFD(kind);
    IFD(O);
    return ret;    
}


NativeMethod Array_methods[] = {  
    { "from", Array_from, 1},
    { "isArray", Array_isArray, 1},
    { "of", Array_of, 1},
};

NativeMethod Array_prototype_methods[] = {    
    { "concat", Array_prototype_concat, 1},
    { "copyWithin", Array_prototype_copyWithin, 2},
    { "entries", Array_prototype_entries, 0},
    { "every", Array_prototype_every, 1},
    { "fill", Array_prototype_fill, 1},
    { "filter", Array_prototype_filter, 1},
    { "find", Array_prototype_find, 1}, 
    { "findIndex", Array_prototype_findIndex, 1}, 
    { "forEach", Array_prototype_forEach, 1}, 
    { "indexOf", Array_prototype_indexOf, 1}, 
    { "join", Array_prototype_join, 1}, 
    { "keys", Array_prototype_keys, 0}, 
    { "lastIndexOf", Array_prototype_lastIndexOf, 1}, 
    { "map", Array_prototype_map, 1}, 
    { "pop", Array_prototype_pop, 0}, 
    { "push", Array_prototype_push, 1}, 
    { "reduce", Array_prototype_reduce, 1}, 
    { "reduceRight", Array_prototype_reduceRight, 1}, 
    { "reverse", Array_prototype_reverse, 0}, 
    { "shift", Array_prototype_shift, 0}, 
    { "slice", Array_prototype_slice, 2}, 
    { "some", Array_prototype_some, 1}, 
    { "sort", Array_prototype_sort, 1}, 
    { "splice", Array_prototype_splice, 2}, 
    { "toLocaleString", Array_prototype_toLocaleString, 0}, 
    { "toString", Array_prototype_toString, 0}, 
    { "unshift", Array_prototype_unshift, 1}, 
    { "values", Array_prototype_values, 0}, 
};

void SetConfig(Js* e, Val* obj, char* p, Val* v) {
    Val* key = ValNewStrA(e, p);
    Val* desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, v);
    PropSetConfigurable(e, desc->desc, TRUE);
    PropSetWritable(e, desc->desc, FALSE);
    PropSetEnumerable(e, desc->desc, FALSE);
    Val* ret = DefinePropOrThrow(e, obj, key, desc);    
    ValDel(e, ret);
    ValDel(e, desc);
    ValDel(e, key);
    ValDel(e, v);
}



Val* ArrayIterator_prototype_unscopables(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* blacklist = ObjectCreate(e, NULL, NULL);
    SetConfig(e, blacklist, "copyWithin", ValNewBool(e, TRUE));
    SetConfig(e, blacklist, "entries", ValNewBool(e, TRUE));
    SetConfig(e, blacklist, "fill", ValNewBool(e, TRUE));
    SetConfig(e, blacklist, "find", ValNewBool(e, TRUE));
    SetConfig(e, blacklist, "findIndex", ValNewBool(e, TRUE));
    SetConfig(e, blacklist, "keys", ValNewBool(e, TRUE));
    SetConfig(e, blacklist, "values", ValNewBool(e, TRUE));
    return blacklist;
}

NativeMethod ArrayIterator_prototype_methods[] = {   
    { "next", ArrayIteratorPrototypeNextCall, 0},
    { "values", ArrayPrototypeValuesCall, 0}
};

Val* SpeciesConstructor(Js* e, Val* O, Val* defaultConstructor) {
    Val* ret = 0, *C = 0, *S = 0;
    assert(O->type == TYPE_OBJ);
    C = GetA(e, O, "constructor");
    RET_IF_AB(C);
    if(ValIsUndef(C))
        RET(ValClone(e, defaultConstructor));
    if(!ValIsObject(C))
        RET(ThrowTypeError(e, "not an object",0,0));
    S = Get(e, C, e->species);
    RET_IF_AB(S);
    if(ValIsNull(S) || ValIsUndef(S))
        RET(ValClone(e,defaultConstructor));
    if(ValIsTrueDel(e, IsConstructor(e, S)))
        RET_VAL(S);
    RET(ThrowTypeError(e, "not a constructor",0,0));

exit:
    IFD(C);
    IFD(S);
    return ret;
}

Val* AllocateArrayBuffer(Js* e, Val* constructor, Val* byteLength) {
    Val* ret = 0, *obj = 0, *block = 0;

    obj = OrdinaryCreateFromConstructor(e, constructor, CurrentRealm(e)->arrayBufferPrototype, 0);
    block = CreateByteDataBlock(e, byteLength);
    RET_IF_AB(block);
    RET_IF_AB(obj);
    ObjectSetSlot(e, obj->obj, _ArrayBufferData_, block, FALSE, FALSE);
    ObjectSetSlot(e, obj->obj, _ArrayBufferByteLength_, byteLength, FALSE, FALSE);
    RET_VAL(obj);
exit:
    IFD(obj);
    IFD(block);
    return ret;    
}

bool_t IsDetachedBuffer(Js* e, Val* arrayBuffer) {
    assert(ObjectGetSlotRef(e, arrayBuffer->obj, _ArrayBufferData_));
    if(ValIsNull(ObjectGetSlot(e, arrayBuffer->obj, _ArrayBufferData_)))
        return TRUE;
    return FALSE;
}

void DetachArrayBuffer(Js* e, Val* arrayBuffer) {
    assert(ObjectGetSlotRef(e, arrayBuffer->obj, _ArrayBufferData_));
    ObjectSetSlot(e, arrayBuffer->obj, _ArrayBufferData_, ValNewNull(e), 1,1);
    ObjectSetSlot(e, arrayBuffer->obj, _ArrayBufferByteLength_, ValNewNum(e,0), 1,1);
}

void CopyDataBlockBytes(Js* e, Val* toBlock, int toIndex, Val* fromBlock, int fromIndex, int count) {
    assert(toBlock->type == TYPE_BLOCK);
    assert(fromBlock->type == TYPE_BLOCK);
    assert(toIndex >= 0 && fromIndex >= 0);
    int fromSize = fromBlock->block->size;
    assert( (fromIndex + count) <= fromSize);
    int toSize = toBlock->block->size;
    assert((toIndex + count) <= toSize);
    while(count > 0) {
        toBlock->block->data[toIndex++] = fromBlock->block->data[fromIndex++];
        count--;
    }
}

Val* CloneArrayBuffer(Js* e, Val* srcBuffer, Val* srcByteOffset, Val* cloneConstructor) {
    assert(ValIsObject(srcBuffer));
    assert(ObjectGetSlotRef(e, srcBuffer->obj, _ArrayBufferData_));
    Val* ret = 0, *targetBuffer = 0;
    if(!cloneConstructor) {
        cloneConstructor = SpeciesConstructor(e, srcBuffer, CurrentRealm(e)->arrayBufferConstructor);
        RET_IF_AB(cloneConstructor);
        if(IsDetachedBuffer(e, srcBuffer))
            RET(ThrowTypeError(e, "buffer detached",0,0));        
    }
    else 
        cloneConstructor = ValClone(e, cloneConstructor);
    
    assert(ValIsTrueDel(e, IsConstructor(e, cloneConstructor)));
    Val* srcLength = ObjectGetSlot(e, srcBuffer->obj, _ArrayBufferByteLength_);
    assert(srcByteOffset->num <= srcLength->num);
    int cloneLength = srcLength->num - srcByteOffset->num;
    Val* srcBlock = ObjectGetSlot(e, srcBuffer->obj, _ArrayBufferData_);
    Val cl;
    ValInitNum(&cl, cloneLength);
    targetBuffer = AllocateArrayBuffer(e, cloneConstructor, &cl);
    RET_IF_AB(targetBuffer);
    if(IsDetachedBuffer(e, srcBuffer))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    Val* targetBlock = ObjectGetSlot(e, targetBuffer->obj, _ArrayBufferData_);
    CopyDataBlockBytes(e, targetBlock, 0, srcBlock, srcByteOffset->num, cloneLength);
    RET_VAL(targetBuffer);
exit:
    IFD(targetBuffer);
    IFD(cloneConstructor);
    return ret;    
}

Val* GetValueFromBuffer(Js* e, Val* buffer, int indexedPosition, int elementType, bool_t* isLittleEndian) {
    assert(buffer->type == TYPE_OBJ);
    assert(!IsDetachedBuffer(e, buffer));

    Val* block = ObjectGetSlot(e, buffer->obj, _ArrayBufferData_);
    if(ValIsUndef(block))
        return ThrowTypeError(e, "not an ArrayBuffer",0,0);

    // int elementSize = ElementSizeFromType(e, type);
    uint8* data = block->block->data + indexedPosition;

    // @todo: handle isLittleEndian
    switch(elementType) {
        case ELEMENT_TYPE_INT8:
            return ValNewNum(e, *((int8*) data));
        case ELEMENT_TYPE_UINT8:
            return ValNewNum(e, *((uint8*) data));
        case ELEMENT_TYPE_UINT8_CLAMPED:
            return ValNewNum(e, *((uint8*) data));
        case ELEMENT_TYPE_INT16:
            return ValNewNum(e, *((int16*) data));
        case ELEMENT_TYPE_UINT16:
            return ValNewNum(e, *((uint16*) data));
        case ELEMENT_TYPE_INT32:
            return ValNewNum(e, *((int32*) data));
        case ELEMENT_TYPE_UINT32:
            return ValNewNum(e, *((uint32*) data));
        case ELEMENT_TYPE_FLOAT32:
            return ValNewNum(e, *((float*) data));
        case ELEMENT_TYPE_FLOAT64:
            return ValNewNum(e, *((double*) data));
    }
    assert(0);
    return NULL;
}

Val* SetValueInBuffer(Js* e, Val* buffer, int indexedPosition, int elementType, Val* numValue, bool_t* isLittleEndian) {
    assert(buffer->type == TYPE_OBJ);
    assert(!IsDetachedBuffer(e, buffer));

    Val* block = ObjectGetSlot(e, buffer->obj, _ArrayBufferData_);
    if(ValIsUndef(block))
        return ThrowTypeError(e, "not an ArrayBuffer",0,0);
    // char* data = ((char*) block->ptr) + indexedPosition;
    uint8* data = block->block->data + indexedPosition;
    // @todo: handle isLittleEndian
    switch(elementType) {
        case ELEMENT_TYPE_INT8:
            *((int8*) data) = (int8) numValue->num;
            break;
        case ELEMENT_TYPE_UINT8:
            *((uint8*) data) = (uint8) numValue->num;
            break;
        case ELEMENT_TYPE_UINT8_CLAMPED:
            *((uint8*) data) = (uint8) numValue->num;
            break;
        case ELEMENT_TYPE_INT16:
            *((int16*) data) = (int16) numValue->num;
            break;
        case ELEMENT_TYPE_UINT16:
            *((uint16*) data) = (uint16) numValue->num;
            break;
        case ELEMENT_TYPE_INT32:
            *((int32*) data) = (int32) numValue->num;
            break;
        case ELEMENT_TYPE_UINT32:
            *((uint32*) data) = (uint32) numValue->num;
            break;
        case ELEMENT_TYPE_FLOAT32:
            *((float*) data) = (float) numValue->num;
            break;
        case ELEMENT_TYPE_FLOAT64:
            *((double*) data) = (double) numValue->num;
            break;
    }

    return ValNewCompU(e, COMP_NORMAL, NULL, NULL);
}

Val* ArrayBufferConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret =0, *length = GetArg(e, args, 0), *numberLength = 0, *byteLength = 0;
    if(ValIsUndef(newTarget))
        RET(ThrowTypeError(e, "construct expected",0,0));

    numberLength = ToNumber(e, length);
    byteLength = ToLength(e, numberLength);
    RET_IF_AB(byteLength);
    if(!ValIsTrueDel(e, SameValueZero(e, numberLength, byteLength)))
        RET(ThrowRangeError(e, "invalid length",0,0));
    RET(AllocateArrayBuffer(e, newTarget, byteLength));
exit:
    IFD(length);
    IFD(numberLength);
    IFD(byteLength);    
    return ret;
}

Val* ArrayBuffer_isView(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *arg = GetArg(e, args, 0);

    if(!ValIsObject(arg))
        RET(ValNewBool(e, FALSE));
    if(ObjectGetSlotRef(e, arg->obj, _ViewArrayBuffer_))
        RET(ValNewBool(e, TRUE));
    RET(ValNewBool(e, FALSE));
exit:
    IFD(arg);
    return ret;    
}

Val* ArrayBuffer_getSpecies(Js* e, Val* o, Val* othis, Val* oargs, Val* newTarget) {
    return ValClone(e, othis);
}

Val* ArrayBuffer_prototype_getByteLength(Js* e, Val* o, Val* othis, Val* oargs, Val* newTarget) {
    Val* O = othis;
    if(!ValIsObject(O))
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _ArrayBufferData_))
        return ThrowTypeError(e, "not an ArrayBuffer",0,0);
    if(IsDetachedBuffer(e, O))
        return ThrowTypeError(e, "buffer detached",0,0);
    return ValClone(e, ObjectGetSlot(e, O->obj, _ArrayBufferByteLength_));
}

NativeMethod ArrayBuffer_methods[] = { 
    { "isView", ArrayBuffer_isView, 1} 
};

Val* ArrayBuffer_prototype_slice(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis, *ret = 0, *relativeStart = 0, *start = GetArg(e, args, 0), *len = 0;
    Val* end = GetArg(e, args, 1),  *relativeEnd = 0, *ctor = 0, *_new = 0;
    if(!ValIsObject(O))
        RET(ThrowTypeError(e, "not an object",0,0));
    if(!ObjectGetSlotRef(e, O->obj, _ArrayBufferData_))
        RET(ThrowTypeError(e, "not an ArrayBuffer",0,0));
    if(IsDetachedBuffer(e, O))
        RET(ThrowTypeError(e, "not an ArrayBuffer",0,0));
    len = ObjectGetSlot(e, O->obj, _ArrayBufferByteLength_);
    int ilen = (int) len->num;
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);
    int irs = (int) relativeStart->num;
    int first, final;
    if(irs < 0) first = max(ilen + irs, 0); else first = min(irs, ilen);
    if(ValIsUndef(end))
        relativeEnd = ValClone(e, len);
    else
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);
    int ire = (int) relativeEnd->num;
    if(ire < 0) final = max(ilen + ire, 0); else final = min(ire, ilen);
    int newLen = max(final - first, 0);
    ctor = SpeciesConstructor(e, O, CurrentRealm(e)->arrayBufferConstructor);
    RET_IF_AB(ctor);
    Val vnewLen;
    ValInitNum(&vnewLen, newLen);
    _new = Construct1(e, ctor, &vnewLen, NULL);
    RET_IF_AB(_new);
    if(!ObjectGetSlotRef(e, _new->obj, _ArrayBufferData_))
        RET(ThrowTypeError(e, "not an ArrayBuffer",0,0));
    if(IsDetachedBuffer(e, _new))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    if(ValIsTrueDel(e, SameValue(e, _new, O)))
        RET(ThrowTypeError(e, "same buffer",0,0));
    if(ObjectGetSlot(e, _new->obj, _ArrayBufferByteLength_)->num < newLen)
        RET(ThrowTypeError(e, "invalid length",0,0));
    if(IsDetachedBuffer(e, O))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    Val* fromBuff = ObjectGetSlot(e, O->obj, _ArrayBufferData_);
    Val* toBuff = ObjectGetSlot(e, _new->obj, _ArrayBufferData_);
    CopyDataBlockBytes(e, toBuff, 0, fromBuff, first, newLen);
    RET_VAL(_new);

exit:
    IFD(relativeStart);
    IFD(start);
    IFD(end);
    IFD(relativeEnd);
    IFD(ctor);
    IFD(_new);    
    return ret;
}


NativeMethod ArrayBuffer_prototype_methods[] = {  
    { "slice", ArrayBuffer_prototype_slice, 2}
};


void SetPrivate(Js* e, Val* obj, Val* key, Val* v) {
    Val* desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, v);
    PropSetConfigurable(e, desc->desc, FALSE);
    PropSetWritable(e, desc->desc, FALSE);
    PropSetEnumerable(e, desc->desc, FALSE);
    Val* ret = DefinePropOrThrow(e, obj, key, desc);    
    ValDel(e, ret);
    ValDel(e, desc);
}

void SetPrivateW(Js* e, Val* obj, Val* key, Val* v) {
    Val* desc = ValNewDesc(e);
    PropSetValue(e, desc->desc, v);
    PropSetConfigurable(e, desc->desc, TRUE);
    PropSetWritable(e, desc->desc, TRUE);
    PropSetEnumerable(e, desc->desc, FALSE);
    Val* ret = DefinePropOrThrow(e, obj, key, desc);    
    ValDel(e, ret);
    ValDel(e, desc);
}

void SetPrivateADel(Js* e, Val* obj, char* key, Val* v) {
    Val* p = ValNewStrA(e, key);
    SetPrivate(e, obj, p, v);
    ValDel(e, p);
    ValDel(e, v);
}

void SetPrivateA(Js* e, Val* obj, char* key, Val* v) {
    Val* p = ValNewStrA(e, key);
    SetPrivate(e, obj, p, v);
    ValDel(e, p);
}

void SetPrivateAW(Js* e, Val* obj, char* key, Val* v) {
    Val* p = ValNewStrA(e, key);
    SetPrivateW(e, obj, p, v);
    ValDel(e, p);
}

void InitMethods(Js* e, Realm* realm, Val* obj, NativeMethod* methods, int numMethods) {
    for(int i=0; i < numMethods; i++) {
        NativeMethod* method = &methods[i];
        Val* f = CreateBuiltinFunction(e, realm, method->func);
        PutA(e, f, "length", ValNewNum(e, method->length), TRUE);
        SetPrivateAW(e, obj, method->name, f);
        ValDel(e, f);
    }
}


void SetPrivateMethod(Js* e, Realm* realm, Val* obj, Val* key, StepsPtr func, int length) {
    Val* f = CreateBuiltinFunction(e, realm, func);
    PutA(e, f, "length", ValNewNum(e, length), TRUE);
    SetPrivate(e, obj, key, f);
    ValDel(e, f);    
}

Val* DefineGlobalCons(Js* e, Val* global,  char* name, Realm* realm, StepsPtr func, int len, NativeMethod* methods, int numMethods, Val* proto, Val** target) {
    Val* c = CreateBuiltinFunction(e, realm, func);
    InitMethods(e, realm, c, methods, numMethods);
    PutA(e, c, "length", ValNewNum(e, len), TRUE);
    SetPrivate(e, c, e->strPrototype, proto);
    Val* ret = ValClone(e,c);
    DefineGlobalProperty(e, global, name, c);   // WARNING - this deletes c
    if(target) {
        ValAssign(e, target, ret);
    }
    return ret;   
}




void InitErrorCons(Js* e, Val* global, char* name, Realm* realm, StepsPtr call, Val* proto, Val** target ) {
    Val* cons = DefineGlobalCons(e, global, name, realm, call, 1, NULL, 0, proto, target);  
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, proto, "constructor", cons);
    PutA(e, proto, "message", ValNewStrA(e, ""), TRUE);
    PutA(e, proto, "name", ValNewStrA(e, name), TRUE);
    InitMethods(e, realm, proto, Error_prototype_methods, METHCOUNT(Error_prototype_methods));
    ValDel(e, cons);  
}

void InitObjectCons(Js* e, Val* global, Realm* realm) {
    Val* cons;
    cons = DefineGlobalCons(e, global, "Object", realm, ObjectConstructor, 1, Object_methods, METHCOUNT(Object_methods), realm->objectPrototype, &realm->objectConstructor);
    SetPrivateA(e, realm->objectPrototype, "constructor", cons);    
    InitMethods(e, realm, realm->objectPrototype, Object_prototype_methods, METHCOUNT(Object_prototype_methods));
    ValDel(e, cons);    
}


void InitFunctionCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NFN) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "Function", realm, FunctionConstructor, 1, Function_methods, METHCOUNT(Function_methods), realm->functionPrototype, &realm->functionConstructor);    
    PutA(e, realm->functionPrototype, "name", ValNewStrA(e, ""), TRUE);
    PutA(e, realm->functionPrototype, "length", ValNewNum(e, 0), TRUE);
    SetPrivateA(e, realm->functionPrototype, "constructor", cons);
    InitMethods(e, realm, realm->functionPrototype, Function_prototype_methods, METHCOUNT(Function_prototype_methods));
    ValDel(e, cons);
}

void InitBooleanCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NBL) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "Boolean", realm, BooleanConstructor, 1, NULL, 0, realm->booleanPrototype, &realm->booleanObject);  
    SetPrivateA(e, realm->booleanPrototype, "constructor", cons);
    InitMethods(e, realm, realm->booleanPrototype, Boolean_prototype_methods, METHCOUNT(Boolean_prototype_methods));
    ValDel(e, cons);  
}

void InitSymbolCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NSY) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "Symbol", realm, SymbolConstructor, 1, Symbol_methods, METHCOUNT(Symbol_methods), realm->symbolPrototype, &realm->symbolConstructor);
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, cons, "hasInstance", e->hasInstance);
    SetPrivateA(e, cons, "isConcatSpreadable", e->isConcatSpreadable);
    SetPrivateA(e, cons, "isRegExp", e->isRegExp);
    SetPrivateA(e, cons, "iterator", e->iterator);
    SetPrivateA(e, realm->symbolPrototype, "constructor", cons);
    InitMethods(e, realm, realm->symbolPrototype, Symbol_prototype_methods, METHCOUNT(Symbol_prototype_methods));
    Val* proto = realm->symbolPrototype;
    SetPrivateMethod(e, realm, proto, e->toPrimitive, Symbol_prototype_toPrimitive, 1);
    Val* s = ValNewStrA(e, "Symbol");
    ValDel(e, Put(e, proto, e->toStringTag, s, TRUE));
    ValDel(e, s);
    SetPrivateA(e, proto, "unscopables", e->unscopables);
    ValDel(e, cons);      
}

void InitErrorsCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NER) return;
    InitErrorCons(e, global, "Error", realm, ErrorConstructor, realm->errorPrototype, &realm->errorObject);
    InitErrorCons(e, global, "EvalError", realm, EvalErrorConstructor, realm->evalErrorPrototype, &realm->evalErrorObject);
    InitErrorCons(e, global, "ReferenceError", realm, ReferenceErrorConstructor, realm->referenceErrorPrototype, &realm->referenceErrorObject);
    InitErrorCons(e, global, "SyntaxError", realm, SyntaxErrorConstructor, realm->syntaxErrorPrototype, &realm->syntaxErrorObject);
    InitErrorCons(e, global, "RangeError", realm, RangeErrorConstructor, realm->rangeErrorPrototype, &realm->rangeErrorObject);
    
    InitErrorCons(e, global, "TypeError", realm, TypeErrorConstructor, realm->typeErrorPrototype, &realm->typeErrorObject);
    InitErrorCons(e, global, "URIError", realm, URIErrorConstructor, realm->uriErrorPrototype, &realm->uriErrorObject);
}


void InitNumberCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NNU) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "Number", realm, NumberConstructor, 1, Number_methods, METHCOUNT(Number_methods), realm->numberPrototype, &realm->numberObject);
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, realm->numberPrototype, "constructor", cons);
    InitMethods(e, realm, realm->numberPrototype, Number_prototype_methods, METHCOUNT(Number_prototype_methods));
    SetPrivateADel(e, cons, "EPSILON", ValNewNum(e, 2.2204460492503130808472633361816e-16));
    SetPrivateADel(e, cons, "MAX_SAFE_INTEGER", ValNewNum(e, 9007199254740991));
    SetPrivateADel(e, cons, "MAX_VALUE", ValNewNum(e, 1.7976931348623157e308));
    SetPrivateADel(e, cons, "MIN_SAFE_INTEGER", ValNewNum(e, -9007199254740991));
    SetPrivateADel(e, cons, "MIN_VALUE", ValNewNum(e, 5e-324));
    SetPrivateADel(e, cons, "NaN", ValNewNum(e, NAN));
    SetPrivateADel(e, cons, "NEGATIVE_INFINITY", ValNewNum(e, -INFINITY));
    SetPrivateADel(e, cons, "POSITIVE_INFINITY", ValNewNum(e, INFINITY));
    ValDel(e, cons); 
}
void AddNativeGetter(Js* e, Val* obj, Val* key, StepsPtr proc);
void AddNativeGetterA(Js* e, Val* obj, char* key, StepsPtr proc);
void InitArrayBufferCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NTA) return;
    Val* cons;
    Val* proto = realm->arrayBufferPrototype;
    cons = DefineGlobalCons(e, global, "ArrayBuffer", realm, ArrayBufferConstructor, 1, ArrayBuffer_methods, METHCOUNT(ArrayBuffer_methods), proto, &realm->arrayBufferConstructor);
    AddNativeGetter(e, cons, e->species, ArrayBuffer_getSpecies);
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, proto, "constructor", cons);
    InitMethods(e, realm, proto, ArrayBuffer_prototype_methods, METHCOUNT(ArrayBuffer_prototype_methods));
    AddNativeGetterA(e, proto, "byteLength", ArrayBuffer_prototype_getByteLength);
    ValDel(e, cons); 
}

void InitMathCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NMT) return;
    Val* math = ObjectCreate(e, realm->objectPrototype, NULL);
    DefineGlobalProperty(e, global, "Math", ValClone(e, math));
    SetPrivateADel(e, math, "E", ValNewNum(e, 2.7182818284590452354));
    SetPrivateADel(e, math, "LN10", ValNewNum(e, 2.302585092994046));
    SetPrivateADel(e, math, "LN2", ValNewNum(e, 0.6931471805599453));
    SetPrivateADel(e, math, "LOG10E", ValNewNum(e, 0.4342944819032518));
    SetPrivateADel(e, math, "LOG2E", ValNewNum(e, 1.4426950408889634));
    SetPrivateADel(e, math, "PI", ValNewNum(e, 3.1415926535897932));
    SetPrivateADel(e, math, "SQRT1_2", ValNewNum(e, 0.7071067811865476));
    SetPrivateADel(e, math, "SQRT2", ValNewNum(e, 1.4142135623730951));
    Val* s = ValNewStrA(e, "Math");
    ValDel(e, Put(e, math, e->toStringTag, s, TRUE));
    ValDel(e, s);
    InitMethods(e, realm, math, Math_methods, METHCOUNT(Math_methods));
    ValDel(e, math);
}

void InitDateCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NDT) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "Date", realm, DateConstructor, 1, Date_methods, METHCOUNT(Date_methods), realm->datePrototype, &realm->dateObject);
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, realm->datePrototype, "constructor", cons);
    SetPrivateMethod(e, realm, realm->datePrototype, e->toPrimitive, Date_prototype_toPrimitive, 1);
    InitMethods(e, realm, realm->datePrototype, Date_prototype_methods, METHCOUNT(Date_prototype_methods));
    ValDel(e, cons);      
}

void InitStringCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NST) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "String", realm, StringConstructor, 1, String_methods, METHCOUNT(String_methods), realm->stringPrototype, &realm->stringConstructor);
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, realm->stringPrototype, "constructor", cons);
    InitMethods(e, realm, realm->stringPrototype, String_prototype_methods, METHCOUNT(String_prototype_methods));
    SetPrivateMethod(e, realm, realm->stringPrototype, e->iterator, String_prototype_iterator, 0);    
    InitMethods(e, realm, realm->stringIteratorPrototype, StringIterator_prototype_methods, METHCOUNT(StringIterator_prototype_methods));
    Val* si = ValNewStrA(e, "String Iterator");
    ValDel(e, Put(e, realm->stringIteratorPrototype, e->toStringTag, si, TRUE));    
    ValDel(e, si);
    ValDel(e, cons);         
}

void InitRegExpCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NRE) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "RegExp", realm, RegExpConstructor, 1, RegExp_methods, METHCOUNT(RegExp_methods), realm->regExpPrototype, &realm->regExpConstructor);
    AddNativeGetter(e, cons, e->species, RegExp_getSpecies);    
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, realm->regExpPrototype, "constructor", cons);
    InitMethods(e, realm, realm->regExpPrototype, RegExp_prototype_methods, METHCOUNT(RegExp_prototype_methods));
    AddNativeGetterA(e, realm->regExpPrototype, "flags", RegExp_prototype_getFlags);
    AddNativeGetterA(e, realm->regExpPrototype, "global", RegExp_prototype_getGlobal);
    AddNativeGetterA(e, realm->regExpPrototype, "ignoreCase", RegExp_prototype_getIgnoreCase);
    AddNativeGetterA(e, realm->regExpPrototype, "multiline", RegExp_prototype_getMultiline);
    AddNativeGetterA(e, realm->regExpPrototype, "sticky", RegExp_prototype_getSticky);
    AddNativeGetterA(e, realm->regExpPrototype, "unicdoe", RegExp_prototype_getUnicode);
    SetPrivateMethod(e, realm, realm->regExpPrototype, e->match, RegExp_prototype_match, 1);
    SetPrivateMethod(e, realm, realm->regExpPrototype, e->replace, RegExp_prototype_replace, 2);
    SetPrivateMethod(e, realm, realm->regExpPrototype, e->search, RegExp_prototype_search, 1);
    AddNativeGetterA(e, realm->regExpPrototype, "source", RegExp_prototype_getSource);
    SetPrivateMethod(e, realm, realm->regExpPrototype, e->split, RegExp_prototype_split, 2);    
    ValDel(e, cons);         
}

void InitArrayCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NAR) return;
    Val* cons;
    cons = DefineGlobalCons(e, global, "Array", realm, ArrayConstructor, 1, Array_methods, METHCOUNT(Array_methods), realm->arrayPrototype, &realm->arrayConstructor);
    ValDel(e, DoSetPrototypeOf(e, cons, realm->functionPrototype));
    SetPrivateA(e, realm->arrayPrototype, "constructor", cons);
    InitMethods(e, realm, realm->arrayPrototype, Array_prototype_methods, METHCOUNT(Array_prototype_methods));
    SetPrivateMethod(e, realm, realm->arrayPrototype, e->iterator, ArrayPrototypeValuesCall, 0);    
    InitMethods(e, realm, realm->arrayIteratorPrototype, ArrayIterator_prototype_methods, METHCOUNT(ArrayIterator_prototype_methods));
    Val* si = ValNewStrA(e, "Array Iterator");
    ValDel(e, Put(e, realm->arrayIteratorPrototype, e->toStringTag, si, TRUE)); 
    SetPrivateMethod(e, realm, realm->arrayIteratorPrototype, e->unscopables, ArrayIterator_prototype_unscopables, 0);    
    ValDel(e, si);
    ValDel(e, cons);         
}

Val* TypedArrayFrom(Js* e, Val* constructor, Val* items, Val* mapfn, Val* thisArg);

Val* TypedArray_from(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *source = GetArg(e, args, 0), *mapfn = GetArg(e, args, 1), *thisArg = GetArg(e, args, 2);
    Val* C = othis;
    if(!ValIsTrueDel(e, IsConstructor(e, C)))
        RET(ThrowTypeError(e, "not a constructor",0,0));
    Val* f = mapfn;
    if(!ValIsUndef(f)) {
        if(!ValIsTrueDel(e, IsCallable(e, f)))
            RET(ThrowTypeError(e, "not callable",0,0));
    }
    Val* t = thisArg;
    RET(TypedArrayFrom(e, C, source, f, t));

exit:
    IFD(source);
    IFD(mapfn);
    IFD(thisArg);    
    return ret;
}
Val* AllocateTypedArray(Js* e, Val* newTarget, Val* length);
Val* TypedArray_of(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *len = 0, *status = 0, *k = 0, *pk = 0, *newObj = 0;

    len = ValNewNum(e, args->list->count);
    Item* items = args->list->head;
    Val* C = othis;
    if(!ValIsTrueDel(e, IsConstructor(e, C)))
        RET(ThrowTypeError(e, "not a constructor",0,0));

    newObj = AllocateTypedArray(e, C, len);
    RET_IF_AB(newObj);
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        Val* kValue = items->value;
        items = items->next;
        pk = ToString(e, k);
        status = Put(e, newObj, pk, kValue, TRUE);
        RET_IF_AB(status);
        IFZ(status);
        k->num++;
    }
    RET_VAL(newObj);
exit:
    IFD(newObj);
    IFD(len);
    IFD(status);
    IFD(k);
    IFD(pk);
    return ret;
}

void AddNativeGetter(Js* e, Val* obj, Val* key, StepsPtr proc) {
    Val* desc = ValNewDesc(e);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, FALSE);
    Val* getter = CreateBuiltinFunction(e, CurrentRealm(e), proc);
    desc->desc->get = getter;
    Val* status =  DefinePropOrThrow(e, obj, key, desc);
    ValDel(e, desc);
    ValDel(e, status);
}

void AddNativeGetterA(Js* e, Val* obj, char* key, StepsPtr proc) {
    Val* prop = ValNewStrA(e, key);
    AddNativeGetter(e, obj, prop, proc);
    ValDel(e, prop);
}

void AddNativeSetter(Js* e, Val* obj, Val* key, StepsPtr proc) {
    Val* desc = ValNewDesc(e);
    PropSetEnumerable(e, desc->desc, FALSE);
    PropSetConfigurable(e, desc->desc, FALSE);
    Val* fn = CreateBuiltinFunction(e, CurrentRealm(e), proc);
    desc->desc->set = fn;
    Val* status =  DefinePropOrThrow(e, obj, key, desc);
    ValDel(e, desc);
    ValDel(e, status);
}

void AddNativeSetterA(Js* e, Val* obj, char* key, StepsPtr proc) {
    Val* prop = ValNewStrA(e, key);
    AddNativeSetter(e, obj, prop, proc);
    ValDel(e, prop);
}

Val* TypedArray_getSpecies(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ValClone(e, othis);
}

NativeMethod TypedArray_methods[] = {  
    { "from", TypedArray_from, 1},
    { "of", TypedArray_of, 0 }
};

Val* TypedArray_prototype_getBuffer(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis;
    if(!ValIsObject(O))
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _ViewArrayBuffer_))
        return ThrowTypeError(e, "not a TypedArray",0,0);
    return ValClone(e, ObjectGetSlot(e, O->obj, _ViewArrayBuffer_));
}

Val* TypedArray_prototype_getByteLength(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis;
    if(!ValIsObject(O))
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _ViewArrayBuffer_))
        return ThrowTypeError(e, "not a TypedArray",0,0);
    Val* buffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, buffer))
        return ValNewNum(e, 0);
    return ValClone(e, ObjectGetSlot(e, O->obj, _ByteLength_));
}

Val* TypedArray_prototype_getByteOffset(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis;
    if(!ValIsObject(O))
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _ViewArrayBuffer_))
        return ThrowTypeError(e, "not a TypedArray",0,0);
    Val* buffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, buffer))
        return ValNewNum(e, 0);
    return ValClone(e, ObjectGetSlot(e, O->obj, _ByteOffset_));
}

Val* TypedArray_prototype_getLength(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis;
    if(!ValIsObject(O))
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _ViewArrayBuffer_))
        return ThrowTypeError(e, "not a TypedArray",0,0);
    Val* buffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, buffer))
        return ValNewNum(e, 0);
    return ValClone(e, ObjectGetSlot(e, O->obj, _ArrayLength_));
}

Val* TypedArray_prototype_getToStringTag(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis;
    if(!ValIsObject(O))
        return ValNew(e);
    if(!ObjectGetSlotRef(e, O->obj, _TypedArrayName_))
        return ValNew(e);
    return ValClone(e, ObjectGetSlot(e, O->obj, _TypedArrayName_));
}

Val* TypedArray_prototype_getConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ValClone(e, CurrentRealm(e)->typedArrayIntrinsic);
}

Val* ValidateTypedArray(Js* e, Val* O) {
    if(!ValIsObject(O))
        return ThrowTypeError(e, "not an object",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _TypedArrayName_))
        return ThrowTypeError(e, "not a TypedArray",0,0);
    if(!ObjectGetSlotRef(e, O->obj, _ViewArrayBuffer_))
        return ThrowTypeError(e, "not a TypedArray", 0,0);    
    Val* buffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, buffer))
        return ThrowTypeError(e, "buffer detached",0,0);
    return ValClone(e, buffer);
}

Val* TypedArray_prototype_copyWithin(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* O = othis, *relativeTarget = NULL, *relativeStart = NULL, *relativeEnd = NULL;
    Val* target = GetArg(e, args, 0), *start = GetArg(e, args, 1), *end = GetArg(e, args, 2);
    Val* ret = NULL, *len = 0, *buffer =  0;

    buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);

    len = ObjectGetSlot(e, othis->obj, _ArrayLength_);
    relativeTarget = ToInteger(e, target);
    RET_IF_AB(relativeTarget);
    int to, from;
    if(relativeTarget->num < 0)
        to = max((len->num + relativeTarget->num), 0);
    else
        to = min(relativeTarget->num, len->num);
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);
    if(relativeStart->num < 0)
        from = max((len->num + relativeStart->num), 0);
    else
        from = min(relativeStart->num, len->num);
    if(ValIsUndef(end)) 
        relativeEnd = ValClone(e, len);
    else
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);
    int final;
    if(relativeEnd->num < 0)
        final = max((len->num + relativeEnd->num), 0);
    else
        final = min(relativeEnd->num, len->num);
    int count = min(final - from, len->num - to);
    int direction;
    if(from < to && to < (from + count)) {
        direction = -1;
        from = from + count - 1;
        to = to + count - 1;
    }
    else 
        direction = 1;
    Val* constructorName = ObjectGetSlot(e, othis->obj, _TypedArrayName_);
    int elementSize = ElementSizeFromConstructor(e, constructorName);
    Val* fb = ObjectGetSlot(e, buffer->obj, _ArrayBufferData_);
    while(count > 0) {
        uint8* toptr = fb->block->data + elementSize * to;
        uint8* fromptr = fb->block->data + elementSize * from;
        memcpy(toptr, fromptr, elementSize);
        from = from + direction;
        to = to + direction;
        count = count - 1;
    }
    RET(ValClone(e,O));
    
exit:
    IFD(buffer);
    IFD(relativeTarget);
    IFD(relativeStart);
    IFD(target);
    IFD(start);
    IFD(end);
    IFD(relativeEnd);
    return ret;    
}

Val* TypedArray_prototype_entries(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* valid = ValidateTypedArray(e, othis);
    if(ValIsAbrupt(e, valid))
        return valid;
    ValDel(e, valid);
    Val* kind = ValNewStrA(e, "key+value");
    Val* ret = CreateArrayIterator(e, othis, kind);
    ValDel(e, kind);
    return ret;
}

Val* TypedArray_prototype_every(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val* ret = NULL, *buffer = 0;
    Val* kValue = NULL, *testResult = NULL, *T = NULL;

    buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn))) 
        RET(ThrowTypeError(e, "not callable",0,0));

    T = thisArg;
    for(int k = 0; k < len; k++) {
        kValue = IntegerIndexedElementGet(e, othis, k);
        RET_IF_AB(kValue);
        Val kv;
        ValInitNum(&kv, k);
        testResult = Call3(e, callbackfn, T, kValue, &kv, othis);
        RET_IF_AB(testResult);
        if(!ValIsTrueDel(e, ToBoolean(e, testResult)))
            RET(ValNewBool(e, FALSE));
        IFZ(kValue);
        IFZ(testResult);
    }
    RET(ValNewBool(e, TRUE));
    
exit:
    IFD(buffer);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}


Val* TypedArray_prototype_fill(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* value = GetArg(e, args, 0), *start = GetArg(e, args, 1), *end = GetArg(e, args, 2);
    Val *relativeStart = NULL, *relativeEnd = NULL;
    Val *putStatus = NULL, *ret = NULL, *buffer = 0;

    buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);

    int k;
    if(relativeStart->num < 0)
        k = max((len + relativeStart->num), 0);
    else
        k = min(relativeStart->num, len);
    if(ValIsUndef(end))
        relativeEnd = ValNewNum(e, len);
    else 
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);

    int final = 0;
    if(relativeEnd->num < 0)
        final = max((len + relativeEnd->num), 0);
    else
        final = min(relativeEnd->num, len);
    for(; k < final; k++) {
        putStatus = IntegerIndexedElementSet(e, othis, k, value);
        RET_IF_AB(putStatus);
        IFZ(putStatus);
    }
    RET(ValClone(e, othis));
exit:
    IFD(buffer);
    IFD(value);
    IFD(start);
    IFD(end);
    IFD(relativeStart);
    IFD(relativeEnd);
    return ret;    
}

Val* ConstructorFromType(Js* e, Val* array) {
    Val* typeName = ObjectGetSlot(e, array->obj, _TypedArrayName_);
    int elementType = ElementTypeFromConstructor(e, typeName);
    Realm* realm = CurrentRealm(e);
    switch(elementType) {
        case ELEMENT_TYPE_INT8:
            return ValClone(e, realm->int8ArrayObject);
        case ELEMENT_TYPE_UINT8:
            return ValClone(e, realm->uint8ArrayObject);
        case ELEMENT_TYPE_UINT8_CLAMPED:
            return ValClone(e, realm->uint8ClampedArrayObject);
        case ELEMENT_TYPE_INT16:
            return ValClone(e, realm->int16ArrayObject);
        case ELEMENT_TYPE_UINT16:
            return ValClone(e, realm->uint16ArrayObject);
        case ELEMENT_TYPE_INT32:
            return ValClone(e, realm->int32ArrayObject);
        case ELEMENT_TYPE_UINT32:
            return ValClone(e, realm->uint32ArrayObject);
        case ELEMENT_TYPE_FLOAT32:
            return ValClone(e, realm->float32ArrayObject);
        case ELEMENT_TYPE_FLOAT64:
            return ValClone(e, realm->float64ArrayObject);
    }
    assert(0);
}

Val* TypedArray_prototype_filter(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val *T = NULL, *A = NULL, *C = 0;
    Val *kValue = NULL, *selected = NULL, *defaultConstructor = 0;
    Val* status = NULL, *ret = NULL, *to = NULL, *buffer = 0, *kept = 0;

    buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    T = thisArg;
    defaultConstructor = ConstructorFromType(e, othis);
    C = SpeciesConstructor(e, othis, defaultConstructor);
    int k = 0, captured = 0;
    kept = ValNewListEmpty(e);

    for(;k < len; k++) {
        kValue =  IntegerIndexedElementGet(e, othis, k);
        RET_IF_AB(kValue);
        Val vk;
        ValInitNum(&vk, k);
        selected = Call3(e, callbackfn, T, kValue, &vk, othis);
        RET_IF_AB(selected);
        if(ValIsTrueDel(e, ToBoolean(e, selected))) {
            captured++;
            ListAddValue(e, kept->list, kValue);
            kValue = 0;
        }
        IFZ(kValue);
        IFZ(selected);
    }
    Val kc;
    ValInitNum(&kc, captured);
    A = AllocateTypedArray(e, C, &kc);
    RET_IF_AB(A);
    Item* item = kept->list->head;
    for(int i=0; i < captured; i++) {
        status = IntegerIndexedElementSet(e, A, i, item->value);
        RET_IF_AB(status);
        item = item->next;
        IFZ(status);
    }
    RET_VAL(A);
exit:
    IFD(kept);
    IFD(C);
    IFD(defaultConstructor);
    IFD(buffer);
    IFD(to);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(A);
    IFD(kValue);
    IFD(selected);
    IFD(status);
    return ret;    
}

Val* TypedArray_prototype_find(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* predicate = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val *T = NULL;
    Val* buffer = 0, *kValue = NULL, *testResult = NULL, *ret = NULL;

    buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;
    if(!ValIsTrueDel(e, IsCallable(e, predicate)))
        RET(ThrowTypeError(e, "predicate not callable",0,0));
    T = thisArg;
    int k = 0; 
    while(k < len) {
        kValue =  IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        testResult = Call3(e, predicate, T, kValue, &vk, othis);
        RET_IF_AB(testResult);
        if(ValIsTrueDel(e, ToBoolean(e, testResult)))
            RET_VAL(kValue);
        k++;
        IFZ(kValue);
        IFZ(testResult);
    }
    RET(ValNew(e));
exit:
    IFD(buffer);
    IFD(predicate);
    IFD(thisArg);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}


Val* TypedArray_prototype_findIndex(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* predicate = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val *kValue = NULL, *testResult = NULL, *ret = NULL, *buffer = 0;

    buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;
    if(!ValIsTrueDel(e, IsCallable(e, predicate)))
        RET(ThrowTypeError(e, "predicate not callable",0,0));
    Val* T = thisArg;
    int k = 0;
    while(k < len) {
        kValue =  IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        testResult = Call3(e, predicate, T, kValue, &vk, othis);
        RET_IF_AB(testResult);
        if(ValIsTrueDel(e, ToBoolean(e, testResult)))
            RET(ValNewNum(e, k));
        k++;
        IFZ(kValue);
        IFZ(testResult);
    }
    RET(ValNewNum(e,-1));
exit:
    IFD(buffer);
    IFD(predicate);
    IFD(thisArg);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}


Val* TypedArray_prototype_forEach(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val *kValue = NULL, *funcResult = NULL, *ret = NULL;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;
    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    Val* T = thisArg;
    int k = 0;
    while(k < len) {
        kValue = IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        funcResult = Call3(e, callbackfn, T, kValue, &vk, othis);
        RET_IF_AB(funcResult);
        IFZ(kValue);
        IFZ(funcResult);
        k++;
    }
    RET(ValNew(e));
exit:
    IFD(buffer);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(kValue);
    IFD(funcResult);
    return ret;    
}

Val* TypedArray_prototype_indexOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* searchElement = GetArg(e, args, 0), *fromIndex = GetArg(e, args, 1);
    Val *elementK = NULL, *same = NULL, *ret = NULL;
    Val* n = 0;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;
    if(len == 0)
        RET(ValNewNum(e, -1));
    if(ValIsUndef(fromIndex))
        n = ValNewNum(e, 0);
    else
        n = ToInteger(e, fromIndex);
    RET_IF_AB(n);
    if(n->num >= len)
        RET(ValNewNum(e, -1));

    int k;
    if(n->num >= 0) 
        k = (int) n->num;
    else 
        k = len - abs((int) n->num);
    if(k < 0)
        k = 0;
    while(k < len) {
        elementK = IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(elementK);
        same = StrictEquality(e, searchElement, elementK);
        if(ValIsTrue(e, same))
            RET(ValNewNum(e, k));
        IFZ(elementK);
        IFZ(same);
        k++;
    }
    RET(ValNewNum(e, -1));
exit:
    IFD(buffer);
    IFD(searchElement);
    IFD(fromIndex);
    IFD(n);
    IFD(elementK);
    IFD(same);
    return ret;    
}

Val* TypedArray_prototype_join(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* separator = GetArg(e, args, 0);
    Val *sep = NULL, *element0 = NULL;
    Val *element = NULL, *ret = NULL, *next = NULL;
    DynStr* R = NULL;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    if(ValIsUndef(separator))
        sep = ValNewStrA(e, ",");
    else
        sep = ToString(e, separator);
    if(len == 0)
        RET(ValNewStrA(e, ""));
    element0 = IntegerIndexedElementGet(e, othis, 0); 

    R = DynStrNew(e, len * 4);
    if(!ValIsUndef(element0) &&  !ValIsNull(element0)) {
        next = ToString(e, element0);
        RET_IF_AB(next);
        DynStrAddStr(e, R, next->str);
        IFZ(next);
    }
    int k = 1;
    while(k < len) {
        DynStrAddStr(e, R, sep->str);
        element = IntegerIndexedElementGet(e, othis, k); 
        if(ValIsUndef(element) || ValIsNull(element))
            next = ValNewStrA(e, "");
        else
            next = ToString(e, element);
        RET_IF_AB(next);
        DynStrAddStr(e, R, next->str);
        k++;
        IFZ(element);
        IFZ(next);
    }
    ret = StrFromDynStr(e, R);
    R = NULL;
exit:
    IFD(buffer);
    if(R) DynStrDel(e, R);
    IFD(next);
    IFD(separator);
    IFD(sep);
    IFD(element);
    IFD(element0);
    return ret;    
}


Val* TypedArray_prototype_keys(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* valid = ValidateTypedArray(e, othis);
    if(ValIsAbrupt(e, valid))
        return valid;
    Val* kind = ValNewStrA(e, "key");
    Val* ret = CreateArrayIterator(e, othis, kind);
    ValDel(e, valid);
    ValDel(e, kind);
    return ret;
}

Val* TypedArray_prototype_lastIndexOf(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* searchElement = GetArg(e, args, 0), *fromIndex = GetArg(e, args, 1);
    Val *n = NULL;
    Val* elementK = NULL, *same = NULL, *ret = NULL;
    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    if(len == 0)
        RET(ValNewNum(e, -1));
    if(ValIsUndef(fromIndex))
        n = ValNewNum(e, len-1);
    else 
        n = ToInteger(e, fromIndex);
    RET_IF_AB(n);
    int k;
    if(n->num >= 0)
        k = min(n->num, len -1);
    else
        k = len - fabs(n->num);
    while(k >= 0) {
        elementK =  IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(elementK);
        same = StrictEquality(e, searchElement, elementK);
        if(ValIsTrue(e, same))
            RET(ValNewNum(e, k));
        IFZ(elementK);
        IFZ(same);
        k--;
    }
    RET(ValNewNum(e, -1));

exit:
    IFD(buffer);
    IFD(searchElement);
    IFD(fromIndex);
    IFD(n);
    IFD(elementK);
    IFD(same);
    return ret;    
}


Val* TypedArray_prototype_map(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val *A = NULL, *kValue = NULL, *status = NULL;
    Val* ret = NULL, *mappedValue = NULL, *defaultConstructor = 0, *C = 0;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    Val* T = thisArg;
    defaultConstructor = ConstructorFromType(e, othis);
    C = SpeciesConstructor(e, othis, defaultConstructor);
    RET_IF_AB(C);

    Val vl; ValInitNum(&vl, len);
    A = AllocateTypedArray(e, C, &vl);
    RET_IF_AB(A);

    int k = 0;
    while(k < len) {
        kValue =  IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        mappedValue = Call3(e, callbackfn, T, kValue, &vk, othis);
        RET_IF_AB(mappedValue);
        status = IntegerIndexedElementSet(e, A, k, mappedValue); 
        RET_IF_AB(status);
        IFZ(kValue);
        IFZ(mappedValue);
        IFZ(status);
        k++;
    }
    RET_VAL(A);

exit:
    IFD(C);
    IFD(defaultConstructor);
    IFD(buffer);
    IFD(mappedValue);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(A);
    IFD(kValue);
    IFD(status);
    return ret;    
}


Val* TypedArray_prototype_reduce(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *initialValue = GetArg(e, args, 1);
    Val *accumulator = NULL, *kValue = NULL, *ret = NULL;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    if(len == 0 && ValIsUndef(initialValue))
        RET(ThrowTypeError(e, "initial value expected",0,0));
    if(!ValIsUndef(initialValue)) {
        accumulator = ValClone(e, initialValue);
    }
    else {
        accumulator = IntegerIndexedElementGet(e, othis, 0); 
        RET_IF_AB(accumulator);
    }
    int k = 1;
    while(k < len) {
        kValue = IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        Val* temp = Call4(e, callbackfn, NULL, accumulator, kValue, &vk, othis);
        RET_IF_AB(temp);
        ValDel(e, accumulator);
        accumulator = temp;
        IFZ(kValue);
        k++;
    }
    RET_VAL(accumulator);

exit:
    IFD(buffer);
    IFD(callbackfn);
    IFD(initialValue);
    IFD(accumulator);
    IFD(kValue);
    return ret;    
}

Val* TypedArray_prototype_reduceRight(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *initialValue = GetArg(e, args, 1);
    Val *accumulator = NULL, *kValue = NULL, *ret = NULL;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    if(len == 0 && ValIsUndef(initialValue))
        RET(ThrowTypeError(e, "initial value expected",0,0));
    int k = len-1;
    if(!ValIsUndef(initialValue)) {
        accumulator = ValClone(e, initialValue);
    }
    else {
        accumulator =  IntegerIndexedElementGet(e, othis, k);
        RET_IF_AB(accumulator);
        k--;
    }
    while(k >= 0) {
        kValue =  IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        Val* temp = Call4(e, callbackfn, NULL, accumulator, kValue, &vk, othis);
        RET_IF_AB(temp);
        ValDel(e, accumulator);
        accumulator = temp;
        IFZ(kValue);
        k--;
    }
    RET_VAL(accumulator);

exit:
    IFD(buffer);
    IFD(callbackfn);
    IFD(initialValue);
    IFD(accumulator);
    IFD(kValue);
    return ret;    
}

Val* TypedArray_prototype_reverse(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* upperValue = NULL, *lowerValue = NULL, *putStatus = NULL;
    Val* ret = NULL;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    int middle = len/2;
    int lower = 0;
    int upper = 0;
    while(lower != middle) {
        upper = len - lower - 1;
        lowerValue = IntegerIndexedElementGet(e, othis, lower);
        RET_IF_AB(lowerValue);
        upperValue = IntegerIndexedElementGet(e, othis, upper);
        RET_IF_AB(upperValue);
        putStatus = IntegerIndexedElementSet(e, othis, lower, upperValue);
        RET_IF_AB(putStatus);
        ValDel(e, putStatus);
        putStatus = IntegerIndexedElementSet(e, othis, upper, lowerValue);
        RET_IF_AB(putStatus);
        lower++;
        IFZ(lowerValue);
        IFZ(upperValue);
        IFZ(putStatus);
    }
    RET(ValClone(e, othis));

exit:
    IFD(buffer);
    IFD(upperValue);
    IFD(lowerValue);
    IFD(putStatus);
    return ret;    
}


Val* TypedArray_prototoype_setFromArray(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *array = GetArg(e, args, 0), *offset = GetArg(e, args, 1);
    Val* targetOffset = 0, *src = 0, *srcLen = 0, *srcLength = 0, *pk = 0, *kValue = 0, *kNumber = 0;

    Val* target = othis;
    if(target->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    if(!ObjectGetSlotRef(e, target->obj, _TypedArrayName_))
        RET(ThrowTypeError(e, "not a TypedArray",0,0));
    targetOffset = ToInteger(e, offset);
    RET_IF_AB(targetOffset);
    if(targetOffset->num < 0)
        RET(ThrowRangeError(e, "negative offset", 0,0));
    Val* targetBuffer = ObjectGetSlot(e, target->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, targetBuffer))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    Val* targetLength = ObjectGetSlot(e, target->obj, _ArrayLength_);
    Val* targetName = ObjectGetSlot(e, target->obj, _TypedArrayName_);
    int targetElementSize = ElementSizeFromConstructor(e, targetName);
    int targetType = ElementTypeFromConstructor(e, targetName);
    Val* targetByteOffset = ObjectGetSlot(e, target->obj, _ByteOffset_);
    src = ToObject(e, array);
    RET_IF_AB(src);
    srcLen = Get(e, src, e->strLength);
    srcLength = ToLength(e, srcLen);
    RET_IF_AB(srcLength);
    if((srcLength->num + targetOffset->num) > targetLength->num)
        RET(ThrowRangeError(e, "invalid offset",0,0));
    int targetByteIndex = targetOffset->num * targetElementSize + targetByteOffset->num;
    int k = 0;
    int limit = targetByteIndex + targetElementSize * min(srcLength->num, targetLength->num - targetOffset->num);
    while(targetByteIndex < limit) {
        Val vk; ValInitNum(&vk, k);
        pk = ToString(e, &vk);
        kValue = Get(e, src, pk);
        kNumber = ToNumber(e, kValue);
        RET_IF_AB(kNumber);
        if(IsDetachedBuffer(e, targetBuffer))
            RET(ThrowTypeError(e, "buffer detached",0,0));
        ValDel(e, SetValueInBuffer(e, targetBuffer, targetByteIndex, targetType, kNumber, NULL));
        k++;
        targetByteIndex += targetElementSize;
        IFZ(pk);
        IFZ(kValue);
        IFZ(kNumber);
    }
    RET(ValNew(e));
exit:
    IFD(array);
    IFD(offset);
    IFD(targetOffset);
    IFD(src);
    IFD(srcLen);
    IFD(srcLength);
    IFD(pk);
    IFD(kValue);
    IFD(kNumber);
    return ret;    
}

Val* TypedArray_prototoype_setFromTypedArray(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* typedArray = GetArg(e, args, 0), *offset = GetArg(e, args, 1);
    Val* target = 0, *ret =0, *targetOffset = 0, *value = 0, *status = 0, *srcBuffer = 0;
    
    target = othis;
    if(target->type != TYPE_OBJ)
        RET(ThrowTypeError(e, "not an object",0,0));
    if(!ObjectGetSlotRef(e, target->obj, _TypedArrayName_))
        RET(ThrowTypeError(e, "not a TypedArray",0,0));
    targetOffset = ToInteger(e, offset);
    RET_IF_AB(targetOffset);
    Val* targetBuffer = ObjectGetSlot(e, target->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, targetBuffer))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    int targetLength = ObjectGetSlot(e, target->obj, _ArrayLength_)->num;
    srcBuffer = ValClone(e, ObjectGetSlot(e, typedArray->obj, _ViewArrayBuffer_));
    if(IsDetachedBuffer(e, srcBuffer))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    Val* targetName = ObjectGetSlot(e, target->obj, _TypedArrayName_);
    int targetType = ElementTypeFromConstructor(e, targetName);
    int targetElementSize = ElementSizeFromType(e, targetType);
    int targetByteOffset = ObjectGetSlot(e, target->obj, _ByteOffset_)->num;
    Val* srcName = ObjectGetSlot(e, typedArray->obj, _TypedArrayName_);
    int srcType = ElementTypeFromConstructor(e, srcName);
    int srcElementSize = ElementSizeFromType(e, srcType);
    int srcLength = ObjectGetSlot(e, typedArray->obj, _ArrayLength_)->num;
    int srcByteOffset = ObjectGetSlot(e, typedArray->obj, _ByteOffset_)->num;
    if( (srcLength + targetOffset->num) > targetLength)
        RET(ThrowRangeError(e, "invalid offset",0,0));

    int srcByteIndex;
    if(srcBuffer->obj == targetBuffer->obj) {
        ValDel(e, srcBuffer);
        Val sbo; ValInitNum(&sbo, srcByteOffset);
        srcBuffer = CloneArrayBuffer(e, targetBuffer, &sbo, CurrentRealm(e)->arrayBufferConstructor);
        RET_IF_AB(srcBuffer);
        srcByteIndex = 0;
    }
    else {
        srcByteIndex = srcByteOffset;
    }
    int targetByteIndex = targetOffset->num * targetElementSize + targetByteOffset;
    int limit = targetByteIndex + targetElementSize * min(srcLength, targetLength - targetOffset->num);
    if(srcType != targetType) {
        while(targetByteIndex < limit) {
            value = GetValueFromBuffer(e, srcBuffer, srcByteIndex, ELEMENT_TYPE_UINT8, NULL);
            status = SetValueInBuffer(e, targetBuffer, targetByteIndex, ELEMENT_TYPE_UINT8, value, NULL);
            IFZ(value);
            IFZ(status);
            srcByteIndex += srcElementSize;
            targetByteIndex += targetElementSize;
        }
    }
    else {
        while(targetByteIndex < limit) {
            value = GetValueFromBuffer(e, srcBuffer, srcByteIndex, ELEMENT_TYPE_UINT8, NULL);
            ValDel(e, SetValueInBuffer(e, targetBuffer, targetByteIndex, ELEMENT_TYPE_UINT8, value, NULL));
            IFZ(value);
            srcByteIndex += srcElementSize;
            targetByteIndex += targetElementSize;
        }
    }
    RET(ValNew(e));
exit:
    IFD(srcBuffer);
    IFD(typedArray);
    IFD(offset);
    IFD(targetOffset);
    IFD(value);
    IFD(status);
    return ret;    
}

Val* TypedArray_prototype_set(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* a0 = Arg(e, args, 0);
    if(!a0)
        return ThrowTypeError(e, "argument expected",0,0);

    if(a0->type == TYPE_OBJ && !ObjectGetSlotRef(e, a0->obj, _TypedArrayName_) && IsArray(e, a0)) {
        ValDel(e, a0);
        return TypedArray_prototoype_setFromArray(e, o, othis, args, newTarget);
    }
    ValDel(e, a0);
    return TypedArray_prototoype_setFromTypedArray(e, o, othis, args, newTarget);
}

Val* TypedArray_prototype_slice(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *valid = 0, *start = GetArg(e, args, 0), *end = GetArg(e, args, 1);
    Val* A = 0, *relativeStart = 0, *relativeEnd = 0, *defaultConstructor = 0;
    Val* C = 0, *kValue = 0, *status = 0, *pk = 0, *pn = 0;

    Val* O = othis;
    valid = ValidateTypedArray(e, O);
    RET_IF_AB(valid);
    int len = ObjectGetSlot(e, O->obj, _ArrayLength_)->num;
    relativeStart = ToInteger(e, start);
    RET_IF_AB(relativeStart);
    int k;
    if(relativeStart->num < 0)
        k = max(len + relativeStart->num, 0);
    else
        k = min(relativeStart->num, len);

    if(ValIsUndef(end))
        relativeEnd = ValNewNum(e, len);
    else
        relativeEnd = ToInteger(e, end);
    RET_IF_AB(relativeEnd);
    int final;
    if(relativeEnd->num < 0)
        final = max((len + relativeEnd->num), 0);
    else
        final = min(relativeEnd->num, len);
    int count = max(final - k, 0);
    defaultConstructor = ConstructorFromType(e, O);
    C = SpeciesConstructor(e, O, defaultConstructor);
    RET_IF_AB(C);
    Val vc; ValInitNum(&vc, count);
    A = AllocateTypedArray(e, C, &vc);
    RET_IF_AB(A);
    int srcType = ElementTypeFromConstructor(e, ObjectGetSlot(e, O->obj, _TypedArrayName_));
    int targetType = ElementTypeFromConstructor(e, ObjectGetSlot(e, A->obj, _TypedArrayName_));
    Val* targetBuffer = ObjectGetSlot(e, A->obj, _ViewArrayBuffer_);
    int n = 0;
    if(srcType != targetType) {
        while(k < final) {
            Val vk; ValInitNum(&vk, k);
            pk = ToString(e, &vk);
            kValue = Get(e, O, pk);
            RET_IF_AB(kValue);
            Val vn; ValInitNum(&vn, n);
            pn = ToString(e, &vn);
            status = Put(e, A, pn, kValue, TRUE);
            RET_IF_AB(status);
            k++;
            n++;
            IFZ(kValue);
            IFZ(pn);
            IFZ(pk);
        }
    }
    else {
        Val* srcBuffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
        if(IsDetachedBuffer(e, srcBuffer))
            RET(ThrowTypeError(e, "buffer detached",0,0));
        int elementSize = ElementSizeFromConstructor(e, ObjectGetSlot(e, O->obj, _TypedArrayName_));
        int srcByteOffset = ObjectGetSlot(e, O->obj, _ByteOffset_)->num;
        int targetByteIndex = 0;
        int srcByteIndex = k * elementSize + srcByteOffset;
        while(targetByteIndex < (count * elementSize)) {
            kValue = GetValueFromBuffer(e, srcBuffer, srcByteIndex, ELEMENT_TYPE_UINT8, NULL);
            ValDel(e, SetValueInBuffer(e, targetBuffer, targetByteIndex, ELEMENT_TYPE_UINT8, kValue, NULL));
            IFZ(kValue);
            srcByteIndex++;
            targetByteIndex++;
        }
    }
    RET_VAL(A);

exit:
    IFD(A);
    IFD(pk);
    IFD(pn);
    IFD(kValue);
    IFD(status);
    IFD(C);
    IFD(defaultConstructor);
    IFD(relativeEnd);
    IFD(relativeStart);
    IFD(start);
    IFD(end);
    IFD(valid);
    return ret;    
}

Val* TypedArray_prototype_some(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* callbackfn = GetArg(e, args, 0), *thisArg = GetArg(e, args, 1);
    Val *kValue = 0, *testResult = 0, *ret = 0;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    if(!ValIsTrueDel(e, IsCallable(e, callbackfn)))
        RET(ThrowTypeError(e, "not callable",0,0));
    Val* T = thisArg;
    int k = 0;
    while(k < len) {
        kValue = IntegerIndexedElementGet(e, othis, k); 
        RET_IF_AB(kValue);
        Val vk; ValInitNum(&vk, k);
        testResult = Call3(e, callbackfn, T, kValue, &vk, othis);
        RET_IF_AB(testResult);
        if(ValIsTrueDel(e, ToBoolean(e, testResult)))
            RET(ValNewBool(e, TRUE));
        IFZ(kValue);
        IFZ(testResult);
        k++;
    }
    RET(ValNewBool(e, FALSE));

exit:
    IFD(buffer);
    IFD(callbackfn);
    IFD(thisArg);
    IFD(kValue);
    IFD(testResult);
    return ret;    
}

bool_t ValIsNan(Val* v) {
    return (v->type == TYPE_NUM && isnan(v->num));
}

Val* TypedArraySortCompare(Js* e, Val* comparefn, Val* buffer, Val* x, Val* y) {
    Val* ret = 0, *v = 0;

    if(!ValIsUndef(comparefn)) {
        if(!ValIsTrueDel(e, IsCallable(e, comparefn)))
            RET(ThrowTypeError(e, "not callable",0,0));
        v = Call2(e, comparefn, NULL, x, y);
        RET_IF_AB(v);
        if(IsDetachedBuffer(e, buffer))
            RET(ThrowTypeError(e, "buffer detached",0,0));
        if(ValIsNan(v))
            RET(ValNewNum(e, 0));
        RET_VAL(v);
    }
    if(ValIsNan(x) && ValIsNan(y))
        RET(ValNewNum(e, 0));
    if(ValIsNan(x))
        RET(ValNewNum(e, 1));
    if(ValIsNan(y))
        RET(ValNewNum(e, -1));
    if(x->num < y->num)
        RET(ValNewNum(e, -1));
    if(x->num > y->num)
        RET(ValNewNum(e, 1));
    RET(ValNewNum(e, 0));

exit:   
    IFD(v); 
    return ret;
}


Val* TypedArray_prototype_sort(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* comparefn = GetArg(e, args, 0), *ret = 0;
    Val* putStatus = 0, *status = 0;
    Val* vy = 0, *vx = 0;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    int k = 0;
    int j = 0;
    while(k < len) {
        vy = IntegerIndexedElementGet(e, othis, k);
        RET_IF_AB(vy);
        j = k + 1;
        while(j < len) {
            vx = IntegerIndexedElementGet(e, othis, j); 
            RET_IF_AB(vx);
            status = TypedArraySortCompare(e, comparefn, buffer, vx, vy);
            RET_IF_AB(status);
            if(status->num < 0) {
                ValDel(e, status);
                status = IntegerIndexedElementSet(e, othis, j, vy); 
                RET_IF_AB(status);
                ValDel(e, status);
                status = IntegerIndexedElementSet(e, othis, k, vx); 
                RET_IF_AB(status);
            }
            IFZ(status);
            IFZ(vx);
            j++;
        }

        k++;
        IFZ(vy);
    }
    RET(ValClone(e, othis));

exit:
    IFD(vy);
    IFD(vx);
    IFD(status);
    IFD(buffer);
    IFD(comparefn);
    IFD(putStatus);
    return ret;    
}

Val* TypedArray_prototype_subarray(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *begin = GetArg(e, args, 0), *end = GetArg(e, args, 1);
    Val* beginInt = 0, *endInt = 0, *constructor = 0, *defaultConstructor = 0;

    Val* O = othis;
    if(!ValIsObject(O))
        RET(ThrowTypeError(e, "not an object",0,0));
    if(!ObjectGetSlotRef(e, O->obj, _TypedArrayName_))
        RET(ThrowTypeError(e, "not a TypedArray",0,0));
    Val* buffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
    int srcLength = ObjectGetSlot(e, O->obj, _ArrayLength_)->num;
    beginInt = ToInteger(e, begin);
    RET_IF_AB(beginInt);
    if(beginInt->num < 0)
        beginInt->num = srcLength + beginInt->num;
    int beginIndex = min(srcLength, max(0, beginInt->num));
    endInt = ToInteger(e, end);
    RET_IF_AB(endInt);
    if(endInt->num < 0)
        endInt->num = srcLength + endInt->num;
    int endIndex = max(0, min(srcLength, endInt->num));
    if(endIndex < beginIndex)
        endIndex = beginIndex;
    int newLength = endIndex - beginIndex;
    Val* constructorName = ObjectGetSlot(e, O->obj, _TypedArrayName_);
    int elementSize = ElementSizeFromConstructor(e, constructorName);
    int srcByteOffset = ObjectGetSlot(e, O->obj, _ByteOffset_)->num;
    int beginByteOffset = srcByteOffset + beginIndex * elementSize;
    defaultConstructor = ConstructorFromType(e, O);
    constructor = SpeciesConstructor(e, O, defaultConstructor);
    RET_IF_AB(constructor);
    Val vbbo; ValInitNum(&vbbo, beginByteOffset);
    Val vnl; ValInitNum(&vnl, newLength);
    RET(Construct3(e, constructor, buffer, &vbbo, &vnl));

exit:
    IFD(constructor);
    IFD(defaultConstructor);
    IFD(endInt);
    IFD(beginInt);
    IFD(begin);
    IFD(end);
    return ret;    
}


Val* TypedArray_prototype_toLocaleString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* firstElement = 0, *nextElement =0;
    Val* ret = 0, *separator = 0, *s = 0, *ss = 0;
    DynStr* R = 0;

    Val* buffer = ValidateTypedArray(e, othis);
    RET_IF_AB(buffer);
    int len = (int) ObjectGetSlot(e, othis->obj, _ArrayLength_)->num;

    R = DynStrNew(e, len*10);
    separator = ValNewStrA(e, ",");
    firstElement = IntegerIndexedElementGet(e, othis, 0); 
    RET_IF_AB(firstElement);
    if(!ValIsUndef(firstElement)) {
        s = Invoke0(e, firstElement, "toLocaleString");
        ss = ToString(e, s);
        RET_IF_AB(ss);
        DynStrAddStr(e, R, ss->str);
        IFZ(s);
        IFZ(ss);
    }
    int k = 1;
    while(k < len) {
        DynStrAddStr(e, R, separator->str);
        nextElement = IntegerIndexedElementGet(e, othis, k);
        RET_IF_AB(nextElement);
        if(!ValIsUndef(nextElement) && !ValIsNull(nextElement)) {
            s = Invoke0(e, nextElement, "toLocaleString");
            ss = ToString(e, s);
            RET_IF_AB(ss);
            DynStrAddStr(e, R, ss->str);
            IFZ(s);
            IFZ(ss);            
        }
        k++;
        IFZ(nextElement);
    }
    ret = StrFromDynStr(e, R);
    R = 0;

exit:
    IFD(buffer);
    IFD(s);
    IFD(ss);
    if(R) DynStrDel(e, R);
    IFD(separator);
    IFD(firstElement);
    IFD(nextElement);
    return ret;   
}


Val* TypedArray_prototype_toString(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return Array_prototype_toString(e, o, othis, args, newTarget);
}

Val* TypedArray_prototype_values(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* valid = ValidateTypedArray(e, othis);
    if(ValIsAbrupt(e, valid))
        return valid;
    ValDel(e, valid);
    Val *kind = ValNewStrA(e, "value");
    Val* ret = CreateArrayIterator(e, othis, kind);
    ValDel(e, kind);
    return ret;
}

NativeMethod TypedArray_prototype_methods[] = {    
    { "copyWithin", TypedArray_prototype_copyWithin, 2},
    { "entries", TypedArray_prototype_entries, 0},
    { "every", TypedArray_prototype_every, 1},
    { "fill", TypedArray_prototype_fill, 1},
    { "filter", TypedArray_prototype_filter, 1},
    { "find", TypedArray_prototype_find, 1},
    { "findIndex", TypedArray_prototype_findIndex, 1},
    { "forEach", TypedArray_prototype_forEach, 1},
    { "indexOf", TypedArray_prototype_indexOf, 1},
    { "join", TypedArray_prototype_join, 1}, 
    { "keys", TypedArray_prototype_keys, 0}, 
    { "lastIndexOf", TypedArray_prototype_lastIndexOf, 1},
    { "map", TypedArray_prototype_map, 1},
    { "reduce", TypedArray_prototype_reduce, 1},
    { "reduceRight", TypedArray_prototype_reduceRight, 1},
    { "reverse", TypedArray_prototype_reverse, 0}, 
    { "set", TypedArray_prototype_set, 1}, 
    { "slice", TypedArray_prototype_slice, 2}, 
    { "some", TypedArray_prototype_some, 1}, 
    { "sort", TypedArray_prototype_sort, 1}, 
    { "subarray", TypedArray_prototype_subarray, 1}, 
    { "toLocaleString", TypedArray_prototype_toLocaleString, 0}, 
    { "toString", TypedArray_prototype_toString, 0}, 
    { "values", TypedArray_prototype_values, 0}, 
};


typedef Val* (*ConvFunc)(Js* e, Val* v);
// void TypedArrayDestruct(Js* e, Object* o) {
//     jprintf(e, 0, "TypedArrayDestruct\n");
// }

Val* AllocateTypedArray(Js* e, Val* newTarget, Val* length) {
    Val* ret = 0, *constructorName = 0, *subclass = 0, *proto = 0, *obj = 0;
    Val* elementSize = 0, *byteLength = 0, *data = 0;

    assert(ValIsTrueDel(e, IsConstructor(e, newTarget)));
    if(ValIsTrueDel(e, SameValue(e, CurrentRealm(e)->typedArrayIntrinsic, newTarget)))
        RET(ThrowTypeError(e, "TypedArray constructor error",0,0));

    constructorName = ValNew(e);
    subclass = ValClone(e, newTarget);
    while(ValIsUndef(constructorName)) {
        if(ValIsNull(subclass))
            RET(ThrowTypeError(e, "null subclass",0,0));
        if(ValIsTrueDel(e, SameValue(e, CurrentRealm(e)->typedArrayIntrinsic, subclass)))
            RET(ThrowTypeError(e, "subclass not TypedArray",0,0));
        if(ObjectGetSlotRef(e, subclass->obj, _TypedArrayConstructorName_)) {
            ValDel(e, constructorName);
            constructorName = ValClone(e, ObjectGetSlot(e, subclass->obj, _TypedArrayConstructorName_));
        }
        Val* sc = DoGetPrototypeOf(e, subclass);
        ValDel(e, subclass);
        subclass = sc;
        RET_IF_AB(subclass);
    }
    proto = GetPrototypeFromConstructor(e, newTarget, CurrentRealm(e)->typedArrayPrototype);
    RET_IF_AB(proto);
    obj = IntegerIndexedObjectCreate(e, proto);
    ObjectSetSlot(e, obj->obj, _TypedArrayName_, constructorName, FALSE, FALSE);
    ObjectSetSlot(e, obj->obj, _ViewArrayBuffer_, ValNew(e), FALSE, TRUE);
    if(ValIsUndef(length)) {
        ObjectSetSlot(e, obj->obj, _ByteLength_, ValNewNum(e,0), FALSE, TRUE);
        ObjectSetSlot(e, obj->obj, _ByteOffset_, ValNewNum(e,0), FALSE, TRUE);
        ObjectSetSlot(e, obj->obj, _ArrayLength_, ValNewNum(e,0), FALSE, TRUE);
    }
    else {
        elementSize = ValNewNum(e, ElementSizeFromConstructor(e, constructorName));
        byteLength = ValNewNum(e, length->num * elementSize->num);
        data = AllocateArrayBuffer(e, CurrentRealm(e)->arrayBufferConstructor, byteLength);
        RET_IF_AB(data);
        ObjectSetSlot(e, obj->obj, _ViewArrayBuffer_, data, TRUE, FALSE);
        ObjectSetSlot(e, obj->obj, _ByteLength_, byteLength, FALSE, FALSE);
        ObjectSetSlot(e, obj->obj, _ByteOffset_, ValNewNum(e,0), FALSE, TRUE);
        ObjectSetSlot(e, obj->obj, _ArrayLength_, length, FALSE, FALSE);
    }
    // ObjectSetMethod(e, obj->obj, _Destruct_, TypedArrayDestruct, FALSE);
    // jprintf(e, 0, "TypedArrayAlloc\n");
    RET_VAL(obj);

exit:
    IFD(constructorName);
    IFD(subclass);
    IFD(proto);
    IFD(obj);
    IFD(elementSize);
    IFD(byteLength);
    IFD(data);

    return ret;
}

Val* TypedArrayConsLength(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret =0, *length = GetArg(e, args, 0), *numberLength = 0, *elementLength = 0;
    if(ValIsUndef(newTarget))
        RET(ThrowTypeError(e, "construct expected",0,0));
    numberLength = ToNumber(e, length);
    elementLength = ToLength(e, numberLength);
    RET_IF_AB(elementLength);
    if(!ValIsTrueDel(e, SameValueZero(e, numberLength, elementLength)))
        RET(ThrowRangeError(e, "invalid length",0,0));
    RET(AllocateTypedArray(e, newTarget, elementLength));

exit:
    IFD(length);
    IFD(numberLength);
    IFD(elementLength);
    return ret;
}







Val* TypedArrayConsType(Js* e, Val* typedArray, Val* newTarget) {
    Val* ret = 0, *O = 0, *data = 0, *bufferConstructor = 0;

    if(ValIsUndef(newTarget))
        RET(ThrowTypeError(e, "construct exprected",0,0));
    O = AllocateTypedArray(e, newTarget, NULL);
    RET_IF_AB(O);
    Val* srcArray = typedArray;
    Val* srcData = ObjectGetSlot(e, srcArray->obj, _ViewArrayBuffer_);
    if(IsDetachedBuffer(e, srcData))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    Val* constructorName = ObjectGetSlot(e, O->obj, _TypedArrayName_);
    int elementType = ElementTypeFromConstructor(e, constructorName);
    Val* elementLength = ObjectGetSlot(e, srcArray->obj, _ArrayLength_);
    Val* srcName = ObjectGetSlot(e, srcArray->obj, _TypedArrayName_);
    int srcType = ElementTypeFromConstructor(e, srcName);
    int srcElementSize = ElementSizeFromConstructor(e, srcName);
    Val* srcByteOffset = ObjectGetSlot(e, srcArray->obj, _ByteOffset_);
    int elementSize = ElementSizeFromConstructor(e, constructorName);
    int byteLength = elementSize * (int) elementLength->num;
    if(elementType == srcType) {
        data = CloneArrayBuffer(e, srcData, srcByteOffset, NULL);
        RET_IF_AB(data);
    }
    else {
        bufferConstructor = SpeciesConstructor(e, srcData, CurrentRealm(e)->arrayBufferConstructor);
        RET_IF_AB(bufferConstructor);
        Val bl;
        ValInitNum(&bl, byteLength);
        data = AllocateArrayBuffer(e, bufferConstructor, &bl);
        if(IsDetachedBuffer(e, srcData))
            RET(ThrowTypeError(e, "buffer detached",0,0));
        int srcByteIndex = (int) srcByteOffset->num;
        int targetByteIndex = 0;
        int count = (int) elementLength->num;
        while(count > 0) {
            Val* value = GetValueFromBuffer(e, srcData, srcByteIndex, srcType, NULL);
            Val* status = SetValueInBuffer(e, data, targetByteIndex, elementType, value, NULL);
            ValDel(e, status);
            ValDel(e, value);
            srcByteIndex += srcElementSize;
            targetByteIndex += elementSize;
            count--;
        }
    }
    Val bl;
    ValInitNum(&bl, byteLength);
    ObjectSetSlot(e, O->obj, _ViewArrayBuffer_, data, FALSE, FALSE);
    ObjectSetSlot(e, O->obj, _ByteLength_, &bl, FALSE, FALSE);
    ObjectSetSlot(e, O->obj, _ByteOffset_, ValNewNum(e, 0), FALSE, TRUE);
    ObjectSetSlot(e, O->obj, _ArrayLength_, elementLength, FALSE, FALSE);
    RET_VAL(O);
exit:   
    IFD(data);
    IFD(bufferConstructor); 
    IFD(O);
    return ret;
}

bool_t YesNext(Val* next) {
    if(next->type == TYPE_BOOL)
        return next->b;
    return TRUE;
}
Property* ArrayGetLenProp(Js* e, Val* A);
Val* FastTypedFromNumArray(Js* e, Val* C, Val* A) {
    Property* len = ArrayGetLenProp(e, A);
    Val*  T = AllocateTypedArray(e, C, len->value);
    Val* buffer = ObjectGetSlot(e, T->obj, _ViewArrayBuffer_);
    Val* arrayTypeName = ObjectGetSlot(e, T->obj, _TypedArrayName_);
    Val* offset = ObjectGetSlot(e, T->obj, _ByteOffset_);
    int elementType = ElementTypeFromConstructor(e, arrayTypeName);
    int elementSize = ElementSizeFromConstructor(e, arrayTypeName);

    // Start with the second property since the first is the length always
    int index = 0;
    for(Property* p = A->obj->properties->next; p; p = p->next) {
        Val* numValue = p->value;
        int indexedPosition = (index * elementSize) + (int) offset->num;
        Val* status = SetValueInBuffer(e, buffer, indexedPosition, elementType, numValue, NULL);
        index++;
        ValDel(e, status);
    }
    return T;
}

Val* TypedArrayFrom(Js* e, Val* constructor, Val* items, Val* mapfn, Val* thisArg) {
    Val* ret = 0, *C = 0, *T = 0, *usingIterator = 0, *iterator = 0;
    Val* values = 0, *next = 0, *nextValue = 0, *len = 0, *targetObj = 0;
    Val* k = 0, *pk = 0, *kValue = 0, *mappedValue = 0, *setStatus = 0, *arrayLike = 0;

    C = constructor;
    assert(ValIsTrueDel(e, IsConstructor(e, C)));
    assert(ValIsUndef(mapfn) || ValIsTrueDel(e, IsCallable(e, mapfn)));
    bool_t mapping;
    if(ValIsUndef(mapfn))
        mapping = FALSE;
    else {
        T = thisArg;
        mapping = TRUE;
    }

    // @opt if items is a contiguous number array and we are not mapping
    // then use a special fast path for creating the typed array efficiently
    // from the array object
   uint32 flags = items->obj->flags;
   if((flags & OBJ_ARRAY) && (flags & OBJ_CONT) &&  (flags& OBJ_ALLNUM))
       RET(FastTypedFromNumArray(e, C, items));

    usingIterator = GetMethod(e, items, e->iterator);
    RET_IF_AB(usingIterator);
    if(!ValIsUndef(usingIterator)) {
        iterator = GetIterator(e, items, usingIterator);
        RET_IF_AB(iterator);
        values = ValNewListEmpty(e);
        next = ValNewBool(e, TRUE);
        while(YesNext(next)) {
            IFZ(next);
            next = IteratorStep(e, iterator);
            RET_IF_AB(next);
            if(YesNext(next)) {
                nextValue = IteratorValue(e, next);
                RET_IF_AB(nextValue);
                ListAddValue(e, values->list, nextValue);
                nextValue = 0;
            }
        }
        len = ValNewNum(e, values->list->count);
        targetObj  = AllocateTypedArray(e, C, len);
        RET_IF_AB(targetObj);
        k = ValNewNum(e, 0);
        Item* ki = values->list->head;
        while(k->num < len->num) {
            kValue = ki->value;
            ki = ki->next;
            pk = ToString(e, k);
            if(mapping) {
                mappedValue = Call2(e, mapfn, T, kValue, k);
                RET_IF_AB(mappedValue);                
            }
            else 
                mappedValue = ValClone(e, kValue);                
            setStatus = Put(e, targetObj, pk, mappedValue, TRUE);
            IFZ(pk);
            RET_IF_AB(setStatus);
            IFZ(mappedValue);
            IFZ(setStatus);
            k->num++;
        }
        kValue = 0;     // Since we never allocate it here
        RET_VAL(targetObj);
    }
    arrayLike = ToObject(e, items);
    RET_IF_AB(arrayLike);
    Val* lv = Get(e, arrayLike, e->strLength);
    len = ToLength(e, lv);
    ValDel(e, lv);
    RET_IF_AB(len);
    targetObj = AllocateTypedArray(e, C, len);
    RET_IF_AB(targetObj);
    k = ValNewNum(e, 0);
    while(k->num < len->num) {
        pk = ToString(e, k);
        kValue = Get(e, arrayLike, pk);
        RET_IF_AB(kValue);
        if(mapping) {
            mappedValue = Call2(e, mapfn, T, kValue, k);
            RET_IF_AB(mappedValue);
        }
        else 
            mappedValue = ValClone(e, kValue);

        setStatus = Put(e, targetObj, pk, mappedValue, TRUE);
        RET_IF_AB(setStatus);
        IFZ(setStatus);
        IFZ(mappedValue);
        IFZ(kValue);
        k->num++;
    }
    RET_VAL(targetObj);

exit:
    IFD(len);
    IFD(usingIterator);
    IFD(iterator);
    IFD(values);
    IFD(next);
    IFD(nextValue);
    IFD(targetObj);
    IFD(k);
    IFD(pk);
    IFD(kValue);
    IFD(mappedValue);
    IFD(setStatus);
    IFD(arrayLike);  
    return ret;
}

Val* TypedArrayConsObject(Js* e, Val* object, Val* newTarget) {
    if(ValIsUndef(newTarget))
        return ThrowTypeError(e, "construct expected",0,0);
    return TypedArrayFrom(e, newTarget, object, NULL, NULL);
}

Val* TypedArrayConsBuffer(Js* e, Val* buffer, Val* args, Val* newTarget) {
    Val* ret = 0, *O = 0, *newLength = 0, *byteOffset = GetArg(e, args, 1), *length = GetArg(e, args, 2);
    Val* offset = 0, *newByteLength = 0;

    if(ValIsUndef(newTarget))
        RET(ThrowTypeError(e, "construct exprected",0,0));
    O = AllocateTypedArray(e, newTarget, NULL);
    RET_IF_AB(O);
    Val* constructorName = ObjectGetSlot(e, O->obj, _TypedArrayName_);
    int elementSize = ElementSizeFromConstructor(e, constructorName);
    offset = ToInteger(e, byteOffset);
    RET_IF_AB(offset);
    if(offset->num < 0)
        RET(ThrowRangeError(e, "negative offset",0,0));
    if(((int) offset->num %  elementSize) != 0)
        RET(ThrowRangeError(e, "invalid offset",0,0));
    if(IsDetachedBuffer(e, buffer))
        RET(ThrowTypeError(e, "buffer detached",0,0));
    Val* bufferByteLength = ObjectGetSlot(e, buffer->obj, _ArrayBufferByteLength_);
    if(ValIsUndef(length)) {
        if(fmod(bufferByteLength->num, elementSize) != 0)
            RET(ThrowRangeError(e, "invalid length",0,0));
        newByteLength = ValNewNum(e, bufferByteLength->num - offset->num);
        if(newByteLength->num < 0)
            RET(ThrowRangeError(e, "invalid length",0,0));
    }
    else {
        newLength = ToLength(e, length);
        RET_IF_AB(newLength);
        newByteLength = ValNewNum(e, newLength->num * elementSize);
        if( (offset->num + newByteLength->num) > bufferByteLength->num)
            RET(ThrowRangeError(e, "invalid offset",0,0));
    }
    ObjectSetSlot(e, O->obj, _ViewArrayBuffer_, buffer, FALSE, FALSE);
    ObjectSetSlot(e, O->obj, _ByteLength_, newByteLength, FALSE, FALSE);
    ObjectSetSlot(e, O->obj, _ByteOffset_, offset, 0, 0);
    ObjectSetSlot(e, O->obj, _ArrayLength_, ValNewNum(e, newByteLength->num / (number) elementSize), 0, 1);
    RET_VAL(O);

exit:
    IFD(newByteLength);
    IFD(offset);
    IFD(byteOffset);
    IFD(length);
    IFD(O);
    IFD(newLength);
    return ret;
}

Val* TypedArrayConstructor(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* typedArray = 0, *ret = 0;

    if(args->list->count > 0 && args->list->head->value->type != TYPE_OBJ)
        RET(TypedArrayConsLength(e, o, othis, args, newTarget));

    typedArray = GetArg(e, args, 0);
    if(ValIsObject(typedArray) && ObjectGetSlotRef(e, typedArray->obj, _TypedArrayName_))
        RET(TypedArrayConsType(e, typedArray, newTarget));

    if(ValIsObject(typedArray) && !ObjectGetSlotRef(e, typedArray->obj, _TypedArrayName_) &&
            !ObjectGetSlotRef(e, typedArray->obj, _ArrayBufferData_))
        RET(TypedArrayConsObject(e, typedArray, newTarget));

    if(ValIsObject(typedArray) && ObjectGetSlotRef(e, typedArray->obj, _ArrayBufferData_))
        RET(TypedArrayConsBuffer(e, typedArray, args, newTarget));

    RET(ThrowTypeError(e, "TypedArray constructor error",0,0));
exit:
    IFD(typedArray);
    return ret;    
}

Val* TypedArray(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *super = 0;
    if(ValIsUndef(newTarget))
        RET(ThrowTypeError(e, "construct exprected",0,0));
    super = DoGetPrototypeOf(e, o);
    RET_IF_AB(super);
    if(!ValIsTrueDel(e, IsConstructor(e, super)))
        RET(ThrowTypeError(e, "not constructor", 0,0));
    RET(Construct(e, super, args, newTarget));
exit:
    IFD(super);    
    return ret;
}

void InitTypedArray(Js* e, Val* global, Realm* realm, char* name, Val** target, Val* proto, int size) {
    Val* cons;
    //  Val* proto = realm->typedArrayIntrinsic;
    ValDel(e, DoSetPrototypeOf(e, proto, realm->typedArrayPrototype));
    cons = DefineGlobalCons(e, global, name, realm, TypedArray, 3, 0, 0, proto, target);
    ObjectSetSlot(e, cons->obj, _TypedArrayConstructorName_, ValNewStrA(e, name), 0,1);
    SetPrivateADel(e, cons, "BYTES_PER_ELEMENT", ValNewNum(e, size));
    ValDel(e, DoSetPrototypeOf(e, cons, realm->typedArrayIntrinsic));
    ValDel(e, cons);    
}

void InitTypedArrayCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NTA) return;
    if(realm->typedArrayIntrinsic)
        ValDel(e, realm->typedArrayIntrinsic);

    Val* tai = CreateBuiltinFunction(e, realm, TypedArrayConstructor);
     ValDel(e, DoSetPrototypeOf(e, tai, realm->functionPrototype));
    realm->typedArrayIntrinsic = tai;
    InitMethods(e, realm, tai, TypedArray_methods, METHCOUNT(TypedArray_methods));
    InitMethods(e, realm, realm->typedArrayPrototype, TypedArray_prototype_methods, METHCOUNT(TypedArray_prototype_methods));
    PutA(e, tai, "length", ValNewNum(e, 3), TRUE);
    PutA(e, tai, "name", ValNewStrA(e, "TypedArray"), TRUE);
    AddNativeGetter(e, tai, e->species, TypedArray_getSpecies);
    Val* proto = realm->typedArrayPrototype;
    SetPrivateMethod(e, realm, proto, e->iterator, TypedArray_prototype_values, 0);    

    SetPrivate(e, tai, e->strPrototype, proto);
    AddNativeGetterA(e, proto, "buffer", TypedArray_prototype_getBuffer);
    AddNativeGetterA(e, proto, "byteLength", TypedArray_prototype_getByteLength);
    AddNativeGetterA(e, proto, "byteOffset", TypedArray_prototype_getByteOffset);
    AddNativeGetterA(e, proto, "coonstructor", TypedArray_prototype_getConstructor);
    AddNativeGetterA(e, proto, "length", TypedArray_prototype_getLength);
    AddNativeGetter(e, proto, e->toStringTag, TypedArray_prototype_getToStringTag);
    InitTypedArray(e, global, realm, "Int8Array", &realm->int8ArrayObject, realm->int8ArrayPrototype, 1);

    if(e->noInit & NAT)
        return;
    InitTypedArray(e, global, realm, "Uint8Array", &realm->uint8ArrayObject, realm->uint8ArrayPrototype, 1);    
    InitTypedArray(e, global, realm, "Uint8ClampedArray", &realm->uint8ClampedArrayObject, realm->uint8ClampedArrayPrototype, 1);    

    InitTypedArray(e, global, realm, "Int16Array", &realm->int16ArrayObject, realm->int16ArrayPrototype, 2);    
    InitTypedArray(e, global, realm, "Uint16Array", &realm->uint16ArrayObject, realm->uint16ArrayPrototype, 2);    

    InitTypedArray(e, global, realm, "Int32Array", &realm->int32ArrayObject, realm->int32ArrayPrototype, 4);    
    InitTypedArray(e, global, realm, "Uint32Array", &realm->uint32ArrayObject, realm->uint32ArrayPrototype, 4);        

    InitTypedArray(e, global, realm, "Float32Array", &realm->float32ArrayObject, realm->float32ArrayPrototype, 4);    
    InitTypedArray(e, global, realm, "Float64Array", &realm->float64ArrayObject, realm->float64ArrayPrototype, 8);            

}

Val* InternalizeJSONProperty(Js* e, Val* holder, Val* name, Val* reviver) {
    Val* v = 0, *I = 0, *len = 0, *newElement = 0;
    Val* status = 0, *keys = 0, *P = 0, *ret = 0, *si = 0;
    Val* result = 0, *done = 0;
    bool_t isArray;

    v = Get(e, holder, name);
    RET_IF_AB(v);
    if(ValIsObject(v)) {
        isArray = IsArray(e, v);
        if(isArray) {
            I = ValNewNum(e, 0);
            Val* vl = GetA(e, v, "length");
            len = ToLength(e, vl);
            ValDel(e, vl);
            RET_IF_AB(len);
            while(I->num < len->num) {
                si = ToString(e, I);
                newElement = InternalizeJSONProperty(e, v, si, reviver);
                RET_IF_AB(newElement);
                if(ValIsUndef(newElement)) 
                    status = DoDelete(e, v, si);
                else 
                    status = CreateDataProp(e, v, si, newElement);
                RET_IF_AB(status);
                IFZ(si);
                IFZ(newElement);
                IFZ(status);
                I->num++;
            }
        }
        else {
            keys = DoOwnPropertyKeys(e, v);
            RET_IF_AB(keys);
            while(TRUE) {
                result = IteratorNext(e, keys, NULL);
                done = IteratorComplete(e, result);
                if(!ValIsTrueDel(e, done)) {
                    P = IteratorValue(e, result);
                    newElement = InternalizeJSONProperty(e, v, P, reviver);
                    RET_IF_AB(newElement);
                    if(ValIsUndef(newElement)) 
                        status = DoDelete(e, v, P);
                    else 
                        status = CreateDataProp(e, v, P, newElement);
                    RET_IF_AB(status);
                    IFZ(P);
                    IFZ(newElement);
                    IFZ(status);
                }
                else
                    break;
                IFZ(result);
            }
        }
    }
    RET(Call2(e, reviver, holder, name, v));
exit:
    IFD(result);
    IFD(si);
    IFD(v);
    IFD(I);
    IFD(len);
    IFD(newElement);
    IFD(status);
    IFD(keys);
    IFD(P);
    return ret;    
}

Val* ParseJsonChars(Js* e, Tokenizer* tk, char* source) {
    TkTokenizeA(e, tk, source,0,0,0);
    return JsonParse(e, tk, NULL);
}

Val* ParseJsonStr(Js* e, Tokenizer* tk, Str* source) {
    TkTokenizeS(e, tk, source,0,0); 
    return JsonParse(e, tk, NULL);
}

Val* JSON_parse(Js* e, Val* o, Val* othis, Val* args, Val* nt) {
    Val* text = GetArg(e, args, 0), *reviver = GetArg(e, args, 1), * ret = 0;
    Val* JText = 0, *root = 0, *rootName = 0, *status = 0, *unfiltered = 0;
    Tokenizer* lex = TkNew(e);
    lex->jsonMode = TRUE;

    JText = ToString(e, text);
    RET_IF_AB(JText);
    unfiltered = ParseJsonStr(e, lex, JText->str);
    JText->type = TYPE_UNDEF;       // the string is now owned by the tokenizer
    RET_IF_AB(unfiltered);
    if(ValIsTrueDel(e, IsCallable(e, reviver))) {
        root = ObjectCreate(e, CurrentRealm(e)->objectPrototype, 0);
        rootName = ValNewStrA(e, "");
        status = CreateDataProp(e, root, rootName, unfiltered);
        RET(InternalizeJSONProperty(e, root, rootName, reviver));
    }
    else {
        RET_VAL(unfiltered);
    }
exit:
    TkDel(e, lex);
    IFD(JText);
    IFD(unfiltered);
    IFD(root);
    IFD(rootName);
    IFD(status);
    IFD(text);
    IFD(reviver);    
    return ret;
}

Val* ValNewStrCount(Js* e, int count, uchar ch) {
    if(count < 0) count = 0;
    Str* s = StrNewLength(e, count);
    for(int i=0; i < count; i++)
        s->chars[i] = ch;
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s;
    return v;
}

Val* SerializeJSONProperty(Js* e, Val* key, Val* holder, Val* stack, DynStr* indent, Val* gap, Val* replacerFunction, Val* propertyList);

Val* SerializeJSONArray(Js* e, Val* value, Val* stack, DynStr* indent, Val* gap, Val* replacerFunction, Val* propertyList) {
    Val* ret = 0, *len = 0, *partial =0, *strP = 0, *member = 0, *separator =0, *index = 0;
    Str* stepback =0;
    DynStr* properties = 0, *final = 0;

    if(ListHasValue(e, stack->list, value))
        RET(ThrowTypeError(e, "Cyclical reference in JSON array",0,0));
    ListAddValue(e, stack->list, ValClone(e, value));
    stepback = StrClone(e, indent->str);
    DynStrAddStr(e, indent, gap->str);

    partial = ValNewListEmpty(e);

    Val* vlen = Get(e, value, e->strLength);
    len = ToLength(e, vlen);
    ValDel(e, vlen);
    RET_IF_AB(len);

    int totalLength = 0;
    index = ValNewNum(e, 0);

    while(index->num < len->num) {
        Val* sindex = ToString(e, index);
        strP = SerializeJSONProperty(e, sindex, value, stack, indent, gap, replacerFunction, propertyList );
        ValDel(e, sindex);
        RET_IF_AB(strP);
        if(ValIsUndef(strP))
            ListAddValue(e, partial->list, ValNewStrA(e, "\"null\""));
        else
            ListAddValue(e, partial->list, strP);
        strP = 0;
        index->num++;
    }

    if(partial->list->count == 0) {
        final = DynStrNew(e, 2);
        DynStrAddStrA(e, final, "[]");
    }
    else {
        if(gap->str->length == 0) {
            final = DynStrNew(e, totalLength + partial->list->count+2); 
            DynStrAdd(e, final, '[');
            for(Item* i=partial->list->head; i; i = i->next) {
                DynStrAddStr(e, final, i->value->str);
                if(i->next)
                    DynStrAdd(e, final, ',');
            }
            DynStrAdd(e, final, ']');
        }
        else {
            DynStr* sep = DynStrNew(e, indent->str->length + 2);
            DynStrAddStrA(e, sep, ",\n");
            DynStrAddStr(e, sep, indent->str);
            final = DynStrNew(e, totalLength + partial->list->count*sep->str->length + 2); 
            DynStrAddStrA(e, final, "[\n");
            DynStrAddStr(e, final, indent->str);
            for(Item* i=partial->list->head; i; i = i->next) {
                DynStrAddStr(e, final, i->value->str);
                if(i->next)
                    DynStrAddStr(e, final, sep->str);
            }
            DynStrAdd(e, final, '\n');
            DynStrAddStr(e, final, stepback);
            DynStrAdd(e, final, ']');
        }
    }
    ListRemoveLast(e, stack->list);
    StrDel(e, indent->str);
    indent->str = stepback;
    indent->capacity = stepback->length;
    stepback = 0;
    ret = StrFromDynStr(e, final);
    final = 0;
exit:
    IFD(separator);
    if(properties) DynStrDel(e, properties);
    IFD(member);
    if(final) DynStrDel(e, final);
    IFD(strP);
    IFD(partial);
    if(stepback) StrDel(e, stepback);
    IFD(len);
    IFD(index);
    return ret;
}

Val* QuoteJSONString(Js* e, Val* value,  Val* stack, DynStr* indent, Val* gap, Val* replacerFunction) {
    DynStr* ret = DynStrNew(e, value->str->length);
    DynStrAdd(e, ret, '"');
    for(int i=0; i < value->str->length; i++) {
        uchar c = value->str->chars[i];
        if(c == '"') 
            DynStrAddStrA(e, ret, "\\\"");
        else if(c == 0x0008)
            DynStrAddStrA(e, ret, "\\b");
        else if(c == 0x000C)
            DynStrAddStrA(e, ret, "\\f");
        else if(c == 0x000A)
            DynStrAddStrA(e, ret, "\\n");
        else if(c == 0x000D)
            DynStrAddStrA(e, ret, "\\r");    
        else if(c == 0x0009)
            DynStrAddStrA(e, ret, "\\t");    
        else if(c < 0x0020) {
            char buff[20];
            sprintf(buff, "\\u%04x", c);
            DynStrAddStrA(e, ret, buff);
        }
        else
            DynStrAdd(e, ret, c);
    }
    DynStrAdd(e, ret, '"');
    return StrFromDynStr(e, ret);
}

Val* ValStrCatADel(Js* e, Val* s, char* c) {
    int len = (int) strlen(c);
    Str* s2 = StrNewLength(e, s->str->length + len);
    int i = 0;
    for(i=0; i < s->str->length; i++)    
        s2->chars[i] = s->str->chars[i];
    while(*c)
        s2->chars[i++] = *c++;
    ValDel(e, s);
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s2;
    return v;
}

Val* ValStrCatDel(Js* e, Val* s, Val* cat) {
    int len = cat->str->length;
    Str* s2 = StrNewLength(e, s->str->length + len);
    int i = 0;
    for(i=0; i < s->str->length; i++)    
        s2->chars[i] = s->str->chars[i];
    for(int j = 0; j < cat->str->length; j++)
        s2->chars[i++] = cat->str->chars[j];
    ValDel(e, s);
    Val* v = ValNew(e);
    v->type = TYPE_STR;
    v->str = s2;
    return v;
}


Val* SerializeJSONObject(Js* e, Val* value,  Val* stack, DynStr* indent, Val* gap, Val* replacerFunction, Val* propertyList) {
    Val* ret = 0, *K = 0, *partial =0, *strP = 0, *member = 0, *separator =0;
    Str* stepback =0;
    DynStr* properties = 0, *final = 0;

    if(ListHasValue(e, stack->list, value))
        RET(ThrowTypeError(e, "Cyclical reference in JSON object",0,0));
    ListAddValue(e, stack->list, ValClone(e, value));
    stepback = StrClone(e, indent->str);
    DynStrAddStr(e, indent, gap->str);
    if(!ValIsUndef(propertyList))
        K = ValClone(e, propertyList);
    else
        K = EnumerableOwnNames(e, value);
    partial = ValNewListEmpty(e);
    int totalLength = 0;
    for(Item* i=K->list->head; i; i = i->next) {
        strP = SerializeJSONProperty(e, i->value, value, stack, indent, gap, replacerFunction, propertyList);
        RET_IF_AB(strP);
        if(!ValIsUndef(strP)) {
            member = QuoteJSONString(e, i->value, stack, indent, gap, replacerFunction);
            if(gap->str->length > 0)
                member = ValStrCatADel(e, member, ": ");
            else
                member = ValStrCatADel(e, member, ":");
            member = ValStrCatDel(e, member, strP);
            ListAddValue(e, partial->list, member);
            totalLength += member->str->length;
            member = 0;
        }
    }
    if(partial->list->count == 0) {
        final = DynStrNew(e, 2);
        DynStrAddStrA(e, final, "{}");
    }
    else {
        if(gap->str->length == 0) {
            final = DynStrNew(e, totalLength + partial->list->count+2); 
            DynStrAdd(e, final, '{');
            for(Item* i=partial->list->head; i; i = i->next) {
                DynStrAddStr(e, final, i->value->str);
                if(i->next)
                    DynStrAdd(e, final, ',');
            }
            DynStrAdd(e, final, '}');
        }
        else {
            DynStr* sep = DynStrNew(e, indent->str->length + 2);
            DynStrAddStrA(e, sep, ",\n");
            DynStrAddStr(e, sep, indent->str);
            final = DynStrNew(e, totalLength + partial->list->count*sep->str->length + 2); 
            DynStrAddStrA(e, final, "{\n");
            DynStrAddStr(e, final, indent->str);
            for(Item* i=partial->list->head; i; i = i->next) {
                DynStrAddStr(e, final, i->value->str);
                if(i->next)
                    DynStrAddStr(e, final, sep->str);
            }
            DynStrAdd(e, final, '\n');
            DynStrAddStr(e, final, stepback);
            DynStrAdd(e, final, '}');
        }
    }
    ListRemoveLast(e, stack->list);
    StrDel(e, indent->str);
    indent->str = stepback;
    indent->capacity = stepback->length;
    stepback = 0;
    ret = StrFromDynStr(e, final);
    final = 0;
exit:
    IFD(separator);
    if(properties) DynStrDel(e, properties);
    IFD(member);
    if(final) DynStrDel(e, final);
    IFD(strP);
    IFD(partial);
    if(stepback) StrDel(e, stepback);
    IFD(K);
    return ret;
}

Val* SerializeJSONProperty(Js* e, Val* key, Val* holder, Val* stack, DynStr* indent, Val* gap, Val* replacerFunction, Val* propertyList) {
    Val* value = 0, *toJSON = 0, *ret =0;
    value = Get(e, holder, key);
    RET_IF_AB(value);
    if(value->type == TYPE_OBJ) {
        toJSON = GetA(e, value, "toJSON");
        RET_IF_AB(toJSON);
        if(ValIsTrueDel(e, IsCallable(e, toJSON))) {
            Val* temp = Call1(e, toJSON, value, key);
            ValDel(e, value);
            value = temp;
            RET_IF_AB(value);
        }
    }
    if(!ValIsUndef(replacerFunction)) {
        Val* temp = Call2(e, replacerFunction, holder, key, value);
        ValDel(e, value);
        value = temp;
        RET_IF_AB(value);        
    }

    if(ValIsObject(value)) {
        if(ObjectGetSlotRef(e, value->obj, _NumberData_)) {
            Val* temp = ToNumber(e, value);
            ValDel(e, value);
            value = temp;
            RET_IF_AB(value);
        }
        else if(ObjectGetSlotRef(e, value->obj, _StringData_)) {
            Val* temp = ToString(e, value);
            ValDel(e, value);
            value = temp;
            RET_IF_AB(value);
        }
        else if(ObjectGetSlotRef(e, value->obj, _BooleanData_)) {
            Val* temp = ValClone(e, ObjectGetSlot(e, value->obj, _BooleanData_));
            ValDel(e, value);
            value = temp;
        }
    }
    if(value->type == TYPE_NULL)
        RET(ValNewStrA(e, "null"));
    if(value->type == TYPE_BOOL && value->b)
        RET(ValNewStrA(e, "true"));
    if(value->type == TYPE_BOOL && value->b == FALSE)
        RET(ValNewStrA(e, "false"));
    if(value->type == TYPE_STR)
        RET(QuoteJSONString(e, value, stack, indent, gap, replacerFunction));
    if(value->type == TYPE_NUM) {
        if(!isinf(value->num))
            RET(ToString(e, value));
        RET(ValNewStrA(e, "null"));
    }
    if(value->type == TYPE_OBJ && !ValIsTrueDel(e, IsCallable(e, value))) {
        bool_t isArray = IsArray(e, value);
        if(isArray) {
            RET(SerializeJSONArray(e, value, stack, indent, gap, replacerFunction, propertyList));
        }
        else {
            RET(SerializeJSONObject(e, value, stack, indent, gap, replacerFunction, propertyList));
        }
    }
    RET(ValNew(e));

exit:
    IFD(value);
    IFD(toJSON);    
    return ret;
}

Val* JSON_stringify(Js* e, Val* o, Val* othis, Val* args, Val* nt) {
    Val* value = GetArg(e, args, 0), *replacer = GetArg(e, args, 1), *space = GetArg(e, args, 2);
    Val* ret = 0, *stack = 0, *propertyList = 0, *replacerFunction = 0;
    Val* k = 0, *v = 0, *len = 0, *pk = 0, *item = 0, *gap = 0;
    Val* wrapper = 0, *status = 0;
    Val* empty = ValNewStrA(e, "");
    DynStr* indent = 0;
    bool_t isArray = FALSE;

    indent = DynStrNew(e, 10);
    stack = ValNewListEmpty(e);
    if(ValIsObject(replacer)) {
        if(ValIsTrueDel(e, IsCallable(e, replacer)))
            replacerFunction = ValClone(e, replacer);
        else {
            isArray = IsArray(e, replacer);
            if(isArray) {
                propertyList = ValNewListEmpty(e);
                Val* vl = Get(e, replacer, e->strLength);
                len = ToLength(e, vl);
                ValDel(e, vl);
                RET_IF_AB(len);
                k = ValNewNum(e, 0);
                item = 0;
                while(k->num < len->num) {
                    pk = ToString(e, k);
                    v = Get(e, replacer, pk);
                    RET_IF_AB(v);
                    if(v->type == TYPE_STR)
                        item = ValClone(e, v);
                    else if(v->type == TYPE_NUM)
                        item = ToString(e, v);
                    else if(v->type == TYPE_OBJ) {
                        if(ObjectGetSlotRef(e, v->obj, _StringData_) || ObjectGetSlotRef(e, v->obj, _NumberData_)) {
                            item = ToString(e, v);
                            RET_IF_AB(item);
                        }
                    }
                    if(!ValIsUndef(item) && !ListHasValue(e, propertyList->list, item))
                        ListAddValue(e, propertyList->list, item);
                    item = 0;
                    k->num++;                    
                }
            }
        }
    }
    if(space->type == TYPE_OBJ) {
        if(ObjectGetSlotRef(e, space->obj, _NumberData_)) {
            Val* temp = ToNumber(e, space);
            ValDel(e, space);
            space = temp;
            RET_IF_AB(space);
        }
        else if(ObjectGetSlotRef(e, space->obj, _StringData_)) {
            Val* temp = ToString(e, space);
            ValDel(e, space);
            space = temp;
            RET_IF_AB(space);
        }
    }
    if(space->type == TYPE_NUM) {
        space->num = min(10, (int) space->num);
        gap = ValNewStrCount(e, space->num, ' ');
    }
    else if(space->type == TYPE_STR) {
        if(space->str->length <= 10)
            gap = ValClone(e, space);
        else
            gap = SubstringFromToExcluding(e, space, 0, 10);
    }
    else {
        gap = ValNewStrA(e, "");
    }
    wrapper = ObjectCreate(e, 0, 0);
    status = CreateDataProp(e, wrapper, empty, value);
    RET(SerializeJSONProperty(e, empty, wrapper, stack, indent, gap, replacerFunction, propertyList));


exit:
    IFD(empty);
    IFD(status);
    IFD(wrapper);
    IFD(gap);
    IFD(item);
    IFD(pk);
    IFD(k);
    IFD(len);
    IFD(v);
    IFD(value);
    IFD(replacer);
    IFD(space);
    IFD(stack);
    IFD(propertyList);
    IFD(replacerFunction);
    if(indent) DynStrDel(e, indent);    
    return ret;
}

NativeMethod Json_methods[] = {
    { "parse", JSON_parse, 2},
    { "stringify", JSON_stringify, 3},

};

void InitJsonCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NJS) return;
    Val* json = ObjectCreate(e, realm->objectPrototype, NULL);
    DefineGlobalProperty(e, global, "JSON", ValClone(e, json));
    Val* s = ValNewStrA(e, "JSON");
    ValDel(e, Put(e, json, e->toStringTag, s, TRUE));
    ValDel(e, s);
    InitMethods(e, realm, json, Json_methods, METHCOUNT(Json_methods));
    ValDel(e, json);
}

Val* Console_log(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* ret = 0, *text = 0, *st = 0;
    text = GetArg(e, args, 0);
    st = ToString(e, text);
    RET_IF_AB(st);
    int q = e->options.quiet;
    e->options.quiet = FALSE;
    StrPrintLn(e, st->str);
    e->options.quiet = q;
    RET(ValClone(e, st));
exit:
    IFD(text);
    IFD(st);
    return ret;
}

NativeMethod Console_methods[] = {
    { "log", Console_log, 1},
};

void InitConsoleCons(Js* e, Val* global, Realm* realm) {
    Val* console = ObjectCreate(e, realm->objectPrototype, NULL);
    DefineGlobalProperty(e, global, "console", ValClone(e, console));
    InitMethods(e, realm, console, Console_methods, METHCOUNT(Console_methods));
    ValDel(e, console);
}

void InitOtherCons(Js* e, Val* global, Realm* realm) {
    if(e->noInit & NGF) return;
    DefineGlobalProperty(e, global, "Infinity", ValNewNum(e, INFINITY));
    DefineGlobalProperty(e, global, "NaN", ValNewNum(e, NAN));
    DefineGlobalProperty(e, global, "undefined", ValNew(e));
    DefineGlobalProperty(e, global, "isFinite", CreateBuiltinFunction(e, realm, isFinite));
    DefineGlobalProperty(e, global, "eval", CreateBuiltinFunction(e, realm, eval));
    DefineGlobalProperty(e, global, "parseFloat", CreateBuiltinFunction(e, realm, parseFloat));
    DefineGlobalProperty(e, global, "parseInt", CreateBuiltinFunction(e, realm, parseInt));
    DefineGlobalProperty(e, global, "isNaN", CreateBuiltinFunction(e, realm, Number_isNaN));
    DefineGlobalProperty(e, global, "decodeURI", CreateBuiltinFunction(e, realm, decodeURI));
    DefineGlobalProperty(e, global, "decodeURIComponent", CreateBuiltinFunction(e, realm, decodeURIComponent));
    DefineGlobalProperty(e, global, "encodeURI", CreateBuiltinFunction(e, realm, encodeURI));
    DefineGlobalProperty(e, global, "encodeURIComponent", CreateBuiltinFunction(e, realm, encodeURIComponent));    
    DefineGlobalProperty(e, global, "escape", CreateBuiltinFunction(e, realm, encodeURIComponent));
    DefineGlobalProperty(e, global, "unescape", CreateBuiltinFunction(e, realm, decodeURIComponent));

    DefineGlobalProperty(e, global, "require", CreateBuiltinFunction(e, realm, require));    
}


void InitGlobalObject(Js* e, Val* global, Realm* realm) {
    InitObjectCons(e, global, realm);
    // Set the prototype of the global object to be objectPrototype once it's initialized
    ValDel(e, DoSetPrototypeOf(e, global, realm->objectPrototype));
    InitFunctionCons(e, global, realm);
    InitBooleanCons(e, global, realm);
    InitSymbolCons(e, global, realm);
    InitErrorsCons(e, global, realm);
    InitNumberCons(e, global, realm);
    InitMathCons(e, global, realm);
    InitDateCons(e, global, realm);
    InitOtherCons(e, global, realm);
    InitStringCons(e, global, realm);
    InitRegExpCons(e, global, realm);
    InitArrayCons(e, global, realm);
    InitTypedArrayCons(e, global, realm);
    InitArrayBufferCons(e, global, realm);
    InitJsonCons(e, global, realm);
    InitConsoleCons(e, global, realm);


}

Val* GlobalDeclarationInstantiation(Parser* p, Node* body, Val* env, bool_t deletableBindings) {
    PtrList* lexNames = LexicallyDeclaredNames(p, body), *varNames = VarDeclaredNames(p, body);
    PtrList* varDeclarations = NULL, *functionsToInitialize = NULL;
    List* declaredFunctionNames = NULL, *declaredVarNames = NULL;
    PtrList* lexDeclarations = NULL;
    PtrList* boundNames = NULL;
    Val* fn = NULL, *vn = NULL, *fo = NULL, *status = NULL;
    Val* ret = NULL;
    Js* e = p->e;
    uint32 flags = 0;

    // @todo: from the root determine default strict flag status
    if(IsStrict(p, p->root))
        flags |= PSTRICT;

    Env* er = env->lex->envRec;

    for(PtrItem* li=lexNames->head; li; li = li->next) {
        Val* name = StringValue(p, li->value);
        Val* result = er->vtable->hasVarDecl(e, er, name);
        if(ValIsTrueDel(e, result))
            RET(ThrowSyntaxError(e, 0, name, " already declared"));
        result = er->vtable->hasLexDecl(e, er, name);
        if(ValIsTrueDel(e, result))
            RET(ThrowSyntaxError(e, 0, name, " already declared"));
        IFZ(name);
    }

    for(PtrItem* vi = varNames->head; vi; vi = vi->next) {
        Val* name = StringValue(p, vi->value);
        Val* result = er->vtable->hasLexDecl(e, er, name);
        if(ValIsTrueDel(e, result))
            RET(ThrowSyntaxError(e, 0, name, " already declared"));
        IFZ(name);
    }
    varDeclarations = VarScopedDeclarations(p, body);
    functionsToInitialize = PtrListNew(e);
    declaredFunctionNames = ListNew(e);
    for(int count=PtrListCount(e, varDeclarations), i=count-1; i >= 0; i--) {
        Node* d = PtrListGet(e, varDeclarations, i);     // @todo: Very slow!!!
        if(!NodeHasFlag(p, d, VariableDeclaration) && !NodeHasFlag(p, d, ForBinding)) {
            assert(NodeHasFlag(p, d, FunctionDeclaration) || NodeHasFlag(p, d, GeneratorDeclaration));
            fn = GetBoundName(p, d);
            if(!ListHasValue(e, declaredFunctionNames, fn)) {
                Val* fnDefinable = er->vtable->canDeclGlobalFunc(e, er, fn);
                if(!ValIsTrueDel(e, fnDefinable))
                    RET(ThrowTypeError(e, "could not define ", fn, 0));
                ListAddValue(e, declaredFunctionNames, fn);
                PtrListPrepend(e, functionsToInitialize, d);
            }
            else
                IFZ(fn);
        }
    }
    declaredVarNames = ListNew(e);
    for(PtrItem* vi=varDeclarations->head; vi; vi = vi->next) {
        Node* d = vi->value;
        boundNames = BoundNames(p, d);
        if(NodeHasFlag(p, d, VariableStatement) || NodeHasFlag(p, d, ForBinding)) {
            for(PtrItem* bi=boundNames->head; bi; bi = bi->next) {
                vn = StringValue(p, bi->value);
                if(!ListHasValue(e, declaredFunctionNames, vn)) {
                    Val* vnDefinable = er->vtable->canDeclGlobalVar(e, er, vn);
                    if(!ValIsTrueDel(e, vnDefinable)) 
                        RET(ThrowTypeError(e, "failed to define ", vn, 0));
                    if(!ListHasValue(e, declaredVarNames, vn))
                        ListAddValue(e, declaredVarNames, vn);
                    else
                        IFZ(vn);
                }
            }
        }
        PtrListDel(e, boundNames);
        boundNames = NULL;
    }

    for(PtrItem* fi=functionsToInitialize->head; fi; fi=fi->next) {
        Node* f = fi->value;
        fn = GetBoundName(p, f);
        fo = InstantiateFunctionObject(p, f, env, flags);
        status = er->vtable->createGlobalFuncBinding(e, er, fn, fo, deletableBindings);
        RET_IF_AB(status);
        IFZ(status);
        IFZ(fn);
        IFZ(fo);
    }

    for(Item* vi=declaredVarNames->head; vi; vi=vi->next) {
        status = er->vtable->createGlobalVarBinding(e, er, vi->value, deletableBindings);
        RET_IF_AB(status);
        IFZ(status);
    }

    lexDeclarations = LexicallyScopedDeclarations(p, body);
    for(PtrItem* li=lexDeclarations->head; li; li=li->next) {
        Node* d = li->value;
        boundNames = BoundNames(p, d);
        for(PtrItem* bi=boundNames->head; bi; bi=bi->next) {
            Val* dn = StringValue(p, bi->value);
            if(NodeHasFlag(p, d, Constant)) 
                status = er->vtable->createImmutableBinding(e, er, dn);
            else 
                status = er->vtable->createMutableBinding(e, er, dn, FALSE);
            IFZ(status);
            IFZ(dn);
        }
        if(NodeHasFlag(p, d, GeneratorDeclaration)) {
            fn = GetBoundName(p, d);
            fo = InstantiateFunctionObject(p, d, env, flags);
            status = er->vtable->setMutableBinding(e, er, fn, fo, FALSE);
            IFZ(fn);
            IFZ(fn);
            RET_IF_AB(status);
            IFZ(status);
        }
        PtrListDel(e, boundNames);
        boundNames = NULL;
    }
    RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
exit:  
    IFD(vn);
    IFD(fn);
    IFD(fo);
    IFD(status);
    if(lexDeclarations) PtrListDel(e, lexDeclarations);
    if(boundNames) PtrListDel(e, boundNames);
    if(declaredVarNames) ListDel(e, declaredVarNames);
    if(declaredFunctionNames) ListDel(e, declaredFunctionNames);
    if(functionsToInitialize) PtrListDel(e, functionsToInitialize);
    if(varDeclarations) PtrListDel(e, varDeclarations);
    PtrListDel(e, lexNames);     // @todo: cache against body?
    PtrListDel(e, varNames);
    return ret;
}

void ErrorFromObj(Parser* p, Val* v) {
    Val* s = NULL;
    Js* e = p->e;
    if(v->completion->type == TYPE_STR)
        s = ValClone(e, v->completion->value);
    else if(ValIsObject(v->completion->value))
        s = Invoke0(e, v->completion->value, "toString");
    
    Str* st = 0;
    if(s && s->type == TYPE_COMP && s->completion->value->type == TYPE_STR)
        st = s->completion->value->str;
    
    if(s && s->type == TYPE_STR)
        st = s->str;
    
    if(st) {
        int i = 0;
        for(i=0; i < (MAX_PARSE_ERROR-1) && i < st->length; i++)
            p->error[i] = (char) st->chars[i];
        p->error[i] = 0;
    }
    ValDel(e, s);
}

////// 15.1.7 Script Evaluation
Val* ScriptEval(Parser* p, Realm* realm, bool_t deletableBindings, uint32 flags, globalInit init) {
    if(!realm) realm = CurrentRealm(p->e);
    Context* progCtx = ContextNew(p->e, realm, NULL, TRUE); // This will complete realm if needed
    progCtx->vars = ValClone(p->e, realm->globalEnv);
    progCtx->lex = ValClone(p->e, realm->globalEnv);

    if(init)
        init(p->e, realm->globalThis, realm);
    Val* status = GlobalDeclarationInstantiation(p, p->root, realm->globalEnv, deletableBindings);
    if(ValIsAbrupt(p->e, status))
        return status;
    ValDel(p->e, status);

    p->next = 0;
    if(IsStrict(p, p->root))
        flags |= PSTRICT;
    status = Eval(p, p->root, flags);
    Val* v = status;
    Js* e = p->e;
    if(ValIsAbrupt(e, v)) {
        ErrorFromObj(p, v);
    }
    ContextDelete(p->e, progCtx);
    return status;
}

void WatcherLine(Parser* p, Node* n, Val* value) {
    if(!n || !value) return;

    int tok = n->token;
    if(tok == TOK_NOT_FOUND) {
        n = n->left;
    }
    tok = n->token;
    if(tok == TOK_NOT_FOUND)
        return;

    // If the value is a return, then strip the return bit
    // so that assigning won't throw
    if(value->type == TYPE_COMP && value->completion->type == COMP_RETURN) {
        value = value->completion->value;
    }
    if(value->type == TYPE_REF)
        value = value->Ref->base;

    if(value->type == TYPE_COMP && !ValIsAbrupt(p->e, value))
        value = value->completion->value;

    if(ValIsUndef(value))
        return;

    int line = TkGetTokLine(p->e, p->tk, tok);
    char buffer[20];
    sprintf(buffer, "line%d", line+1);
    Val* varName = ValNewStrA(p->e, buffer);
    Val* ref = GetIdentifierRef(p->e, CurrentRealm(p->e)->globalEnv, varName, FALSE);
    Val* result = PutValue(p->e, ref, value);
    ValDel(p->e, result);
    ValDel(p->e, ref);
    ValDel(p->e, varName);
}

List* TemplateStrings(Parser* p, Node* n, bool_t raw) {
    List* l = ListNew(p->e);
    Val * v;

    while(TRUE) {
        if(raw) 
            v = ValNewStr(p->e, TkGetTokRawStr(p->e, p->tk, n->token));
        else
            v = ValNewStr(p->e, TkGetTokStr(p->e, p->tk, n->token));
        ListAddValue(p->e, l, v);
        int t = NodeType(p, n);        
        if(t == TOK_TEMPLIT || t == TOK_TEMPTAIL)
            break;
        n = n->right;
        if(!n)
            break;
    }
    return l;
}

void DefineOwn(Js* e, Val* o, Val* key, Val* v, bool_t w, bool_t en, bool_t c) {
    Val* newDesc = ValNewDesc(e);
    PropSetConfigurable(e, newDesc->desc, c);
    PropSetWritable(e, newDesc->desc, w);
    PropSetEnumerable(e, newDesc->desc, en);
    PropSetValue(e, newDesc->desc, v);
    Val* res = DoDefineOwnProperty(e, o, key, newDesc);
    ValDel(e, newDesc);
    ValDel(e, res);    
}

Val* GetTemplateCallSite(Parser* p, Node* templateLiteral) {
    Js* e = p->e;
    if(templateLiteral->extra)      // @todo: could other nodes hit this?
        return ValClone(p->e, templateLiteral->extra);

    List* cookedStrings = TemplateStrings(p, templateLiteral, FALSE);
    List* rawStrings = TemplateStrings(p, templateLiteral, TRUE);
    Val* count = ValNewNum(e, cookedStrings->count);
    Val* siteObj = ArrayCreate(e, count, NULL);
    Val* rawObj = ArrayCreate(e, count, NULL);
    Val* index = ValNewNum(e, 0);
    Item* cookedValue = cookedStrings->head;
    Item* rawValue = rawStrings->head;
    while(index->num < count->num) {
        Val* prop = ToString(e, index);
        DefineOwn(e, siteObj, prop, cookedValue->value, FALSE, TRUE, FALSE);
        DefineOwn(e, rawObj, prop, rawValue->value, FALSE, TRUE, FALSE);
        cookedValue = cookedValue->next;
        rawValue = rawValue->next;
        ValDel(e, prop);
        index->num++;
    }
    ValDel(e, index);
    ValDel(e, count);
    Val* si = SetIntegrityLevel(e, rawObj, e->strFrozen);
    ValDel(e, si);
    Val* strRaw = ValNewStrA(e, "raw");
    DefineOwn(p->e, siteObj, strRaw, rawObj, FALSE, FALSE, FALSE);
    ValDel(e, strRaw);
    ValDel(e, rawObj);
    si = SetIntegrityLevel(e, siteObj, e->strFrozen);
    ValDel(e, si);
    templateLiteral->extra = siteObj;
    ListDel(e, cookedStrings);
    ListDel(e, rawStrings);
    return ValClone(e, siteObj);
}

Val* ArgumentListEvaluationTemplate(Parser* p, Node* n, uint32 flags) {
    List* l = ListNew(p->e);
    Val* siteObj = GetTemplateCallSite(p, n);
    ListAddValue(p->e, l, siteObj);

    while(TRUE) {
        int t =  NodeType(p, n);
        if(t == TOK_TEMPLIT || t == TOK_TEMPTAIL) 
            break;
        assert(t == TOK_TEMPHEAD || t == TOK_TEMPMID);
        Val* v = Eval(p, n->left, flags);
        if(ValIsAbrupt(p->e, v)) {
            ListDel(p->e, l);
            return v;
        }
        ListAddValue(p->e, l, v);
        n = n->right;
        if(!n)
            break;
    }
    return ValNewList(p->e, l);
}

Val* EvalTemplateLiteral(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    DynStr* ds = DynStrNew(e, 100);

    while(n) {
        int t = NodeType(p, n);
        Str* s = TkGetTokStr(e, p->tk, n->token);
        DynStrAddStr(e, ds, s);
        if(t == TOK_TEMPLIT || t == TOK_TEMPTAIL)
            break;
        Val* r = Eval(p, n->left, flags);
        if(ValIsAbrupt(e, r)) {
            DynStrDel(e, ds);
            return r;
        }
        Val* sv = ToString(e, r);
        ValDel(e, r);
        if(ValIsAbrupt(e, sv)) {
            DynStrDel(e, ds);
            return sv;
        }
        DynStrAddStr(e, ds, sv->str);
        ValDel(e, sv);
        n = n->right;
    }
    Val* ret = ValNewStr(e, DynStrGet(e, ds));
    DynStrDel(e, ds);
    return ret;
}

Val* Eval(Parser* p, Node* n, uint32 flags) {
    Js* e = p->e;
    Val* ret = NULL;

    if(e->debugLevel == DEBUG_LEVEL_PARSE)
        RET(ValNew(e));

    // For runtime errors, set p->next to node's token index 
    p->next = n->token;
    int type = NodeType(p, n);
    switch(type) {
        case TOK_TEMPLIT:
        case TOK_TEMPHEAD:
            // if(n->flags & NODE_TEMPLATE_CALL)
            if(NodeHasFlag(p, n, EvalTemplateLiteralCall))
                RET(EvalTemplateLiteralCall(p, n, flags));
            RET(EvalTemplateLiteral(p, n, flags));
        case TOK_REGEX:
        {
            Token* t = VectorGet(e, p->tk->tokens, n->token);
            int flagOffset = t->flag_offset;
            Str* rex = TkGetTokStr(e, p->tk, n->token);
            DynStr* body = DynStrNew(e, rex->length);
            for(int i=1; i < flagOffset; i++)       // Skip leading slash
                DynStrAdd(e, body, rex->chars[i]);
            DynStr* flags = DynStrNew(e, rex->length);
            for(int i=flagOffset+1; i < rex->length; i++)
                DynStrAdd(e, flags, rex->chars[i]);
            Val* vBody = ValNewStr(e, body->str);
            Val* vFlags = ValNewStr(e, flags->str);
            ret = RegExpCreate(e, vBody, vFlags);
            ValDel(e, vBody);
            ValDel(e, vFlags);
            DynStrDel(e, body);
            DynStrDel(e, flags);
            goto exit;
        }
        break;
        case TOK_NUMLIT:
            RET(ValNewNum(p->e, TkGetTokNumVal(p->e, p->tk, n->token)));
        case TOK_STRLIT:
            RET(ValNewStr(p->e, TkGetTokStr(p->e, p->tk, n->token)));    
        case TOK_IDENTIFIER:
        {
            Val* name = ValNewStrId(e, p->tk, n->token);
            ret = ResolveBinding(p->e, name, FALSE);
            ValDel(e, name);
            goto exit;
        }
    }
    if(n->token != TOK_NOT_FOUND) {
        RET(EvalExpression(p, n, flags));            
    }    

    RET(EvalStatementList(p, n, flags));
exit:
   // if(p->e->options.watcher)
   //     WatcherLine(p, n, ret);
    return ret;
}

////////////// Parser

// Call parse function and set is / isNot flags if supplied
// Short-circuit if the token is proven isNot
Node* P(ParseFunc fn, Parser* p, int start, uint32 flags, uint32 isNot) {
    if(p->stop)
        return NULL;
    if(TkIsTokFlag(p->e, p->tk, start, isNot))
        return NULL;
    Node* n = fn(p, start, flags);
    if(n) 
        NodeSetFlag(p, n, fn);
    else 
        p->next = start;
    
    return n;
}

Node* Expression(Parser* p, int start, uint32 flags);
Node* AssignmentExpression(Parser* p, int start, uint32 flags);


Node* SyntaxError(Parser* p, char* e) {
    if(p->error[0])
        return NULL;
    int line = TkGetTokLine(p->e, p->tk, p->next)+1;
    if(p->fileName[0])
        sprintf(p->error, "%s:%d SyntaxError: %s", p->fileName, line, e);
    else 
        sprintf(p->error, ":%d SyntaxError: %s", line, e);
    
#if 0
    printf("%s\n", p->error);
#endif

    return NULL;
}

void RuntimeError(Parser* p, char* err) {
    if(p->error[0])
        return;
    int line = TkGetTokLine(p->e, p->tk, p->next);

    if(line == TOK_NO_LINE) {
        for(int t = p->next-1; t >=0; t--) {
            line = TkGetTokLine(p->e, p->tk, t);
            if(line != TOK_NO_LINE)
                break;
        }
    }
    
    line++;
    if(p->fileName[0])
        sprintf(p->error, "%s:%d runtime error %s", p->fileName, line, err);
    else 
        sprintf(p->error, ":%d runtime error %s", line, err);    
}
Node* StatementListParse(Parser* p, int start, uint32 flags);
Node* NodeError(Parser* p, Node* n, int start, char* err);
Node* ScriptBody(Parser* p, int start, uint32 flags) {
    Node* n = StatementListParse(p,0, flags);
    if(!n)
        return n;
    if(p->next < TkGetCount(p->e, p->tk) - 1) {
        char buff[255];
        sprintf(buff, "unexpected parse stop at line: %d of %d",  TkGetTokLine(p->e, p->tk, p->next),
            TkGetLineCount(p->e, p->tk));
        return NodeError(p, n, start, buff);
    }
    return n;
}

Node* Script(Parser* p, uint32 flags) {
    return P(ScriptBody, p, 0, flags,0);
}

bool_t CheckSemiNewLine(Parser* p);
Node* NodeStop(Parser* p, Node* n, int start, char* err);
Node* StatementListItem(Parser* p, int start, uint32 flags) {
    // @todo - we handle declaration before statements so that let declarations
    // do not get stumpted by ExpressionStatements causing let to be interpreted
    // as an identifier and the token converted... We should probably NOT convert
    // the token in place and find another way to deal with this
    Node* n = P(Declaration, p, start, flags, 0);

    // Special handling for var statement since we cheat and use declaration
    // parsing for it
    if(n && NodeKeyword(p, n) == id_var) {
        NodeSetFlag(p,n, VariableStatement);

        // Ensure that the nodes on the right all have VariableDeclaration
        // on them to support *DeclarationInstantiation routines
        for(Node* nr = n->right; nr; nr = nr->right) {
            NodeSetFlag(p, nr, VariableDeclaration);
        }

        NodeSetFlag(p,n, Statement);
        NodeClearFlag(p, n, Declaration);
    }
    if(n)
        return n;
    
    // If it is a declaration but there is an error, we should exit
    // This switching of Declarations and statement per commment above
    // is causing uninitialized constants to be interpreted as statements
    // and supressing errors #405
    return P(Statement, p, start, flags, 0);
}


// @todo: it would be much more efficient if while we parse the body of a functiojn
//        we tag it with ContainsSuper
bool_t ContainsKeyword(Parser* p, Node* n, int key, uint32 flags) {
    if(!n)
        return FALSE;

    if(NodeHasFlag(p, n, FunctionDeclaration)) {
        if(ContainsKeyword(p, n->right, key, flags))
            return TRUE;
        if(ContainsKeyword(p, n->left->right, key, flags))
            return TRUE;
        return FALSE;
    }
    if(NodeHasFlag(p, n, FunctionExpression)) {
        if(ContainsKeyword(p, n->right, key, flags))
            return TRUE;
        if(ContainsKeyword(p, n->left->right, key, flags))
            return TRUE;
        return FALSE;
    }

    if(NodeHasFlag(p, n, FormalParameters)) {
        for(Node* a=n; a; a = a->right) {
            if(ContainsKeyword(p, a->left, key, flags))
                return TRUE;
        }
        return FALSE;
    }

    if(NodeHasFlag(p, n, BindingElement)) {
        if(NodeKeyword(p, n) == id_eq) {
            return ContainsKeyword(p, n->right, key, flags);
        }
        else {
            if(flags & PSTRICT)
                return FALSE;       // super not allowed as identifier?
            Val* s = TkGetTokStrVal(p->e, p->tk, n->token);
            if(ValIsStrADel(p->e, s, "super"))
                return TRUE;
            return FALSE;
        } 
    }
    if(NodeHasFlag(p, n, FunctionBody)) {
        for(Node* c=n->right; c; c = c->right) {
            if(ContainsKeyword(p, c->left, key, flags))
                return TRUE;
        }
        return FALSE;
    }
    if(NodeHasFlag(p, n, Statement)) {

    }
    if(NodeHasFlag(p, n, BindingIdentifier)) {
        Val* s = TkGetTokStrVal(p->e, p->tk, n->token);
        if(ValIsStrADel(p->e, s, "super"))
            return TRUE;
        return FALSE;
    }
    return FALSE;

}

bool_t ReferencesSuper(Parser* p, Node* n) {
    return FALSE;
}

bool_t IsStrict(Parser* p, Node* n) {
    if(!n || !n->left)
        return FALSE;
    Node* l = n->left;
    if(l && NodeType(p, l) == TOK_STRLIT) {
        if(StrEqChars(p->e, TkGetTokStr(p->e, p->tk, l->token), "use strict")) {
            return TRUE;
        }
    }
    return FALSE;
}

void AppendNameToChars(char* buffer, char* text, int size, Val* name);

// 15.1.1 StatementList early errors
void StatementList_EarlyErrors(Parser* p, Node* root, char* buffer, int size) {
    buffer[0] = 0;      // Clear errors

    // if(HasDuplicates(LexicallyDeclaredNames(p, root))) @todo: check already handled

    PtrList* lexNames = TopLevelLexicallyDeclaredNames(p, root);
    PtrList* varNames = TopLevelVarDeclaredNames(p, root);
    if(lexNames) {
        for(PtrItem* lexItem = lexNames->head; lexItem; lexItem = lexItem->next) {
            Val* name = StringValue(p, lexItem->value);
            if(PtrListHasStr(p, varNames, name, 0)) {
                AppendNameToChars(buffer, "duplicate entry: ", size, name);
                ValDel(p->e, name);
                goto exit;
            }
            ValDel(p->e, name);
        }
    }

    // @todo implement rest of 15.1.1 rules
exit:
    PtrListDel(p->e, lexNames);    
    PtrListDel(p->e, varNames);
}

void SkipNewLines(Parser* p);


Node* StatementList(Parser* p, int start, uint32 flags) {
    // If we have no more tokens (or especially in the case of an empty source)
    // return a special null node
    if(start >= TkGetCount(p->e, p->tk)) {
        return NodeNew(p);
    }
    while(NextType(p, FALSE) == TOK_LINETERM) {
        p->next++;
        start++;
    }

    Node* l = StatementListItem(p, start, flags);
    if(!l) {        
        return NodeError(p, NULL, start, "Statement expected");
    }

    // If the statement is an expression statement and string literal 
    // and 'use strict' then we turn on strict mode for the rest
    // of the statement list
    if(l && NodeType(p, l) == TOK_STRLIT) {
        if(StrEqChars(p->e, TkGetTokStr(p->e, p->tk, l->token), "use strict")) {
            flags |= PSTRICT;
        }
    }

    p->error[0] = 0;
    Node* root = NodeNew(p);
    Node* n = root;
    n->left = l;
    while(p->next < p->tk->tokens->count) {
//        while(NextType(p, FALSE) == TOK_LINETERM) p->next++;
        SkipNewLines(p);
        l = StatementListItem(p, p->next, flags);
        if(!l) break;
        p->error[0] = 0;        // @todo: handle sub-expression errors
        Node* r = NodeNew(p);
        r->left = l;
        n->right = r;
        n = r;
    }
    return root;
}

Node* StatementListParse(Parser* p, int start, uint32 flags) {
    Node* n = P(StatementList,p, start, flags, 0);
    if(!n)
        return n;

    char buffer[255];
    StatementList_EarlyErrors(p, n, buffer, sizeof(buffer));
    if(buffer[0]) 
        return NodeStop(p, n, start, buffer);
    return n;
}


Node* NodeNewAdvance(Parser* p, Node* left, Node* right) {
    Node* n = NodeNew(p);
    n->token = p->next;
    p->next++;
    n->left = left;
    n->right = right;
    return n;
}

Node* NodeError(Parser* p, Node* n, int start, char* err) {
    p->next = start;
    NodeDel(p, n);
    return SyntaxError(p, err);
}
Node* NodeStop(Parser* p, Node* n, int start, char* err) {
    Node* ret = NodeError(p, n, start, err);
    p->stop = 1;
    return ret;
}

Node* Literal(Parser* p, int start, uint32 flags) {
    int type =  NextType(p, TRUE); 
    if(type == TOK_NUMLIT || type == TOK_STRLIT) 
        return NodeNewAdvance(p, NULL, NULL);
    int k = NextKeyword(p, TRUE); 
    if(k == id_true || k == id_false || k == id_null)
        return NodeNewAdvance(p, NULL, NULL);
    return NULL;
}


// Return a token node if the keyword is allowed as an identifier
Node* KeywordAsIdentifier(Parser* p, int start, char* id, uint32 flags) {
    if(flags & PSTRICT) {
        // char buffer[255];
        // sprintf(buffer, "identified %s not allowed in strict mode", id);
        // return SyntaxError(p, buffer);
        return NULL;
    }

    // try to return as a keyword and handle in StringValue later
    return NodeNewAdvance(p, NULL, NULL);
}

Node* IdentifierName(Parser* p, int start, uint32 flags) {
    int type = NextType(p, TRUE);

    if(type == TOK_IDENTIFIER) 
        return NodeNewAdvance(p, NULL, NULL);

    if(type != TOK_KEYWORD || TkIsPunctuator(p->e, p->tk, p->next))
        return NULL;    

        // return NodeNewAdvance(p, NULL, NULL);
    int k = NextKeyword(p, TRUE);    
    for(int i=0; i < sizeof(keywords)/sizeof(KeyDef); i++) {
        KeyDef* kd = &keywords[i];
        if(kd->kid == k)
            return KeywordAsIdentifier(p, start, (char*) kd->text, flags);
    }
    
    return NULL;
}

// @todo:
// If strict syntax error on: 
//      "implements", "interface", "let", "package", "private", "protected", 
//      "public", "static", or "yield"
//
//  Syntax error if reserved word except for yield
//
Node* Identifier(Parser* p, int start, uint32 flags) {
    int type = NextType(p, TRUE);

    if(type == TOK_IDENTIFIER) {
        return NodeNewAdvance(p, NULL, NULL);
    }
    if(type != TOK_KEYWORD)
        return NULL;

    int key = NextKeyword(p, TRUE);

    // Handle [~Yield]
    if(key == id_yield) {
        if(flags & PNOYIELD || flags & PSTRICT) 
            return SyntaxError(p, "identifier yield not allowed");
        else 
            return KeywordAsIdentifier(p, start, "yield", 0);
    }

    if(key == id_let) {
        if(flags & PNOLET || flags & PSTRICT) 
            return SyntaxError(p, "identifier let not allowed");
        else 
            return KeywordAsIdentifier(p, start, "let", 0);
    }

    // Handle [+Default]
    if(flags & PDEFAULT && key == id_default) {
        return KeywordAsIdentifier(p, start, "default", 0);
    }

    switch(key) {
        case id_implements:
            return KeywordAsIdentifier(p, start, "implements", flags);
        case id_interface:
            return KeywordAsIdentifier(p, start, "interface", flags);
        case id_let:
            return KeywordAsIdentifier(p, start, "let", flags);
        case id_package:
            return KeywordAsIdentifier(p, start, "package", flags);
        case id_private:
            return KeywordAsIdentifier(p, start, "private", flags);
        case id_protected:
            return KeywordAsIdentifier(p, start, "protected", flags);
        case id_public:
            return KeywordAsIdentifier(p, start, "public", flags);
        case id_static: 
            return KeywordAsIdentifier(p, start, "static", flags);
        case id_yield:
            return KeywordAsIdentifier(p, start, "yield", flags);
        case id_module:
            return KeywordAsIdentifier(p, start, "module", flags);
//        case id_get:
//            return KeywordAsIdentifier(p, start, "get", flags);            
//        case id_set:
//            return KeywordAsIdentifier(p, start, "set", flags);                        
    }
    return NULL;
}

Val* TkGetTokStrVal(Js* e, Tokenizer* tk, int token);
Node* BindingIdentifier(Parser* p, int start, uint32 flags) {
    if(flags & PSTRICT) {
        if(NextType(p, TRUE) == TOK_IDENTIFIER) {
            Val* s = TkGetTokStrVal(p->e, p->tk, p->next);
            if(ValEqStrA(p->e, s, "arguments") || ValEqStrA(p->e, s, "eval")) {
                ValDel(p->e, s);
                return SyntaxError(p, "'arguments' or 'eval' not allowed in strict mode as identifier");
            }
            ValDel(p->e, s);
        }
    }
    Node* n = P(Identifier, p, start, flags, 0);
    if(!n)
        return n;

    // #404 - The spec does not show that we need to fail this ... But the ES6 book does
    //        I have added this since it adds more type safety to JSE and can easily
    //        be removed
    if(ValIsStrADel(p->e, StringValue(p, n), "undefined")) {
        return NodeError(p, n, start, "let does not allow settig undefined");
    }
    return n;
}

Val* GeneratorYield(Js* e, Val* obj) {
    return NULL;    // @todo: implement
}

Val* EvalComprehensionIf(Parser* p, Node* n, Val* accumulator, Node* tail, uint32 flags);

Val* EvalComprehensionTail(Parser* p, Node* expr, Val* accumulator, uint32 flags) {
    Js* e = p->e;
    Val* valueRef = NULL, *value = NULL, *ret = NULL, *len = NULL, *putStatus = NULL;
    Val* yieldStatus = NULL;

    if(TkGetTokKeyword(e, p->tk, expr->token) == id_if) 
        return EvalComprehensionIf(p, expr, accumulator, expr->right, flags);

    // @todo: support nested ComprehensionFor sequences

    valueRef = Eval(p, expr, flags);
    value = GetValue(e, valueRef);
    RET_IF_AB(value);
    if(!ValIsUndef(accumulator)) {
        len = Get(e, accumulator, p->e->strLength);
        if(len->num >= (number) 0xffffffff)
            RET(ThrowRangeError(e, "invalid length",0,0));
        Val* strLen = ToString(e, len);
        putStatus = Put(e, accumulator,strLen, value, TRUE);
        ValDel(e, strLen);
        RET_IF_AB(putStatus);
        len->num++;
        ValDel(e, putStatus);
        putStatus = Put(e, accumulator, e->strLength, len, TRUE);
        RET_IF_AB(putStatus);
        RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
    }
    Val* vf = ValNewBool(e, FALSE);
    yieldStatus = GeneratorYield(e, CreateResultObject(e, value, vf));
    ValDel(e, vf);
    RET_IF_AB(yieldStatus);
    RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
exit:
    IFD(yieldStatus);
    IFD(len);
    IFD(putStatus);
    IFD(valueRef);
    IFD(value);
    return ret;    
}

Node* ObjectBindingPattern(Parser* p, int start, uint32 flags);
Node* SingleNameBinding(Parser* p, int start, uint32 flags);
Node* PropertyName(Parser* p, int start, uint32 flags);
Node* ArrayBindingPattern(Parser* p, int start, uint32 flags);
Node* BindingRestElement(Parser* p, int start, uint32 flags);

Val* KeyedBindingInitialization(Parser* p, Node* node, Val* obj, Val* env, Val* propertyName, uint32 flags) {
    Val* v = NULL, *ret= NULL, *defaultValue = NULL, *hasNameProperty = NULL;
    Js* e = p->e;

    if(NodeHasFlag(p, node, BindingPattern) || 
        ((NodeKeyword(p, node) == id_eq) && NodeHasFlag(p, node->left, BindingPattern))) {
        Node* initializer = NULL;
        Node* pattern = node;
        if(NodeKeyword(p, node) == id_eq) {
            initializer = node->right;
            pattern = node->left;
        }
        v = Get(e, obj, propertyName);
        RET_IF_AB(v);
        if(initializer && ValIsUndef(v)) {
            ValDel(e, v);
            defaultValue = Eval(p, initializer, flags);
            v = GetValue(e, defaultValue);
            RET_IF_AB(v);
        }
        if(v->type != TYPE_OBJ)
            RET(ThrowTypeError(e, "not an object",0,0));
        RET(BindingInitialization(p, pattern, v, env, flags));
    }
    
    if(NodeHasFlag(p, node, BindingIdentifier) ||
        ((NodeKeyword(p, node) == id_eq) && NodeHasFlag(p, node->left, BindingIdentifier))) {
        Node* initializer = NULL;
        Node* identifier = node;
        if(NodeKeyword(p, node) == id_eq) {
            initializer = node->right;
            identifier = node->left;
        }
        v = Get(e, obj, propertyName);
        RET_IF_AB(v);
        if(initializer && ValIsUndef(v)) {
            ValDel(e, v);
            defaultValue = Eval(p, initializer, flags);
            v = GetValue(e, defaultValue);
            RET_IF_AB(v);
            if(IsAnonymousFunctionDefinition(p, initializer)) {
                hasNameProperty = HasOwnProp(e, v, e->strName);
                RET_IF_AB(hasNameProperty);
                if(!ValIsTrue(e, hasNameProperty)) {
                    Val* sv = StringValue(p, identifier);
                    Val* res = SetFunctionName(e, v, sv, NULL);
                    ValDel(e, sv);
                    ValDel(e, res);
                }
            }
        }
        RET(BindingInitialization(p, identifier, v, env, flags));
    }


exit:
    IFD(v);
    IFD(defaultValue);
    IFD(hasNameProperty);
    return ret;    
}

Val* IteratorBindingInitialization(Parser* p, Node* node, Val* iterator, Val* env, uint32 flags) {
    Js* e = p->e;
    Val* ret = NULL, *status = NULL, *v = NULL, *defaultValue = NULL, *next= NULL;
    Val* hasNameProperty = NULL, *name = NULL, *A = NULL, *n = NULL, *sn = NULL;
    Val* defineStatus = NULL, *nextValue = NULL, *pres = NULL;

    if(NodeHasFlag(p, node, FormalParameters)) {
        if(!node)
            RET(ValNew(e));
        for(Node* param=node; param; param=param->right) {
            pres = IteratorBindingInitialization(p, param->left, iterator, env, flags);
            RET_IF_AB(pres);
            if(!param->right)
                RET_VAL(pres);
            ValDel(e, pres);
        }
    }

    if(NodeHasFlag(p, node, ArrayBindingPattern)) {
        if(!node->right) 
            RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));

        for(Node* el=node->right; el; el=el->right) {
            if(!el->left)  {    // Elision
                status = IteratorStep(e, iterator);
                RET_IF_AB(status);
                // status = IteratorDestructuringAssignmentEvaluation(p, node, iterator, flags);
            }
            else 
                status = IteratorBindingInitialization(p, el->left, iterator, env, flags);            
            RET_IF_AB(status);
            if(!el->right)
                break;
            IFZ(status);
        }
        return status;
    }

    if(NodeHasFlag(p, node, SingleNameBinding)) {
        Node* initializer = NULL;
        Node* identifier = node;
        if(NodeKeyword(p, node) == id_eq) {
            initializer = node->right;
            identifier = node->left;            
        }
        next = IteratorStep(e, iterator);
        RET_IF_AB(next);
        if(next->type == TYPE_BOOL && !next->b)
            v = ValNew(e);
        else {
            v = IteratorValue(e, next);
            RET_IF_AB(v);
        }

        if(initializer && ValIsUndef(v)) {
            IFZ(v);
            defaultValue = Eval(p, initializer, flags);
            v = GetValue(e, defaultValue);
            RET_IF_AB(v);
            if(IsAnonymousFunctionDefinition(p, initializer)) {
                hasNameProperty = HasOwnProp(e, v, e->strName);
                RET_IF_AB(hasNameProperty);
                if(!ValIsTrue(e, hasNameProperty)) {
                    name = StringValue(p, identifier);
                    status = SetFunctionName(e, v, name, NULL);                    
                }
            }
        }
        RET(BindingInitialization(p, identifier, v, env, flags));
    }

    if(NodeHasFlag(p, node, BindingRestElement)) {
        A = ArrayCreate(e, 0, NULL);
        n = ValNewNum(e, 0);
        while(TRUE) {
            next = IteratorStep(e, iterator);
            RET_IF_AB(next);
            if(next->type == TYPE_BOOL && !next->b) 
                RET(BindingInitialization(p, node->left, A, env, flags));
            nextValue = IteratorValue(e, next);
            RET_IF_AB(nextValue);
            sn = ToString(e, n);
            defineStatus = CreateDataPropOrThrow(e, A, sn, nextValue);
            RET_IF_AB(defineStatus);
            IFZ(sn);
            IFZ(defineStatus);
            IFZ(next);
            IFZ(nextValue);
            n->num++;
        }
    }
    if(NodeHasFlag(p, node, BindingPattern) || 
        (node && NodeKeyword(p, node) == id_eq && NodeHasFlag(p, node->left, BindingPattern))) {
        Node* initializer = NULL;
        Node* pattern = node;
        if(NodeKeyword(p, node) == id_eq) {
            initializer = node->right;
            pattern = node->left;            
        }
        next = IteratorStep(e, iterator);
        RET_IF_AB(next);
        if(next->type == TYPE_BOOL && !next->b) 
            v = ValNew(e);
        else {
            v = IteratorValue(e, next);
            RET_IF_AB(v);
        }
        if(initializer && ValIsUndef(v)) {
            ValDel(e, v);
            defaultValue = Eval(p, initializer, flags);
            v = GetValue(e, defaultValue);
            RET_IF_AB(v);
        }
        if(v->type != TYPE_OBJ)
            RET(ThrowTypeError(e, "not an object",0,0));
        RET(BindingInitialization(p, pattern, v, env, flags));
    }
    RET(ValNew(e));
exit:
    IFD(name);
    IFD(pres);
    IFD(defineStatus);
    IFD(nextValue);
    IFD(sn);
    IFD(n);
    IFD(A);
    IFD(v);
    IFD(defaultValue);
    IFD(next);
    IFD(hasNameProperty);
    IFD(status);
    return ret;
}

Node* BindingProperty(Parser* p, int start, uint32 flags);
Node* CatchParameter(Parser* p, int start, uint32 flags);
Val* BindingInitialization(Parser* p, Node* node, Val* value, Val* env, uint32 flags) {
    Js* e = p->e;

    W(p,node, value);
    
    if(NodeHasFlag(p, node, CatchParameter) && NodeHasFlag(p, node, BindingPattern)) {
        if(value->type != TYPE_OBJ)
            return ThrowTypeError(e, "not an object",0,0);
        // Otherwise go below which will handle ObjectBindingPattern or ArrayBindingPattern
    }

    if(NodeHasFlag(p, node, ForDeclaration)) {
        PtrList* bn = BoundNames(p, node->right);
        bool_t isConst = IsConstantDeclaration(p, node);
        Env* ev = env->lex->envRec;
        for(PtrItem* pi = bn->head; pi; pi = pi->next) {
            Val* name = StringValue(p, pi->value);
            if(isConst) 
                ValDel(e, ev->vtable->createImmutableBinding(e, ev, name));
            else
                ValDel(e, ev->vtable->createMutableBinding(e, ev, name, TRUE));
            ValDel(e, name);
        }
        PtrListDel(e, bn);
        return BindingInitialization(p, node->right, value, env, flags);
    }

    if(NodeHasFlag(p, node, ObjectBindingPattern)) {
        assert(value->type == TYPE_OBJ);
        for(Node* pb=node->right; pb; pb=pb->right) {
            Val* status = BindingInitialization(p, pb, value, env, flags);
            if(ValIsAbrupt(e, status)) {
                return status;
            }
            ValDel(e, status);
        }
        return ValNew(e);
    }

    if(NodeHasFlag(p, node, ArrayBindingPattern)) {
        assert(value->type == TYPE_OBJ);
        Val* iterator = GetIterator(e, value, NULL);
        if(ValIsAbrupt(e, iterator))
            return iterator;
        Val* status = IteratorBindingInitialization(p, node, iterator, env, flags);
        ValDel(e, iterator);
        return status;
    }


    if(NodeHasFlag(p, node, BindingProperty) && NodeHasFlag(p, node->left, SingleNameBinding)) {
        PtrList* bn = BoundNames(p, node->left);
        assert(bn->count == 1);
        Val* name = StringValue(p, (Node*) bn->head->value);
        Val* result = KeyedBindingInitialization(p, node->left, value, env, name, flags);
        ValDel(e, name);
        PtrListDel(e, bn);
        return result;
    }

    if(NodeHasFlag(p, node, SingleNameBinding)) {
        PtrList* bn = BoundNames(p, node);
        assert(bn->count == 1);
        Val* name = StringValue(p, (Node*) bn->head->value);
        Val* result =  InitializeBoundName(e, name, value, env, flags & PSTRICT);
        ValDel(e, name);
        PtrListDel(e, bn);
        return result;
    }
    
    if(NodeKeyword(p, node) == id_colon && NodeHasFlag(p, node->left, PropertyName)) {
        Val* P = Eval(p, node->left, flags);
        if(ValIsAbrupt(e, P)) {
            return P;
        }
        Val* result = KeyedBindingInitialization(p, node->right, value, env, P, flags);
        ValDel(e, P);
        return result;
    }

    Val* name = StringValue(p, node);
    Val* ret = InitializeBoundName(p->e, name, value, env, (flags & PSTRICT));
    ValDel(p->e, name);
    return ret;
}

Val* EvalComprehensionFor(Parser* p, Node* n, Val* accumulator, Node* tail, uint32 flags) {
    Val* exprRef = NULL, *exprValue = NULL, *obj = NULL, *keys = NULL;
    Val* oldEnv = NULL, *nextResult = NULL, *nextValue = NULL;
    Val* forEnv = NULL, *status = NULL, *cont = NULL, *ret = NULL;
    Js* e = p->e;

    exprRef = Eval(p, n->right, flags);
    exprValue = GetValue(e, exprRef);
    RET_IF_AB(exprValue);
    if(ValIsNull(exprValue) || ValIsUndef(exprValue))
        RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));
    obj = ToObject(e, exprValue);
    RET_IF_AB(obj);
    keys = GetIterator(e, obj, NULL);
    RET_IF_AB(keys);
    oldEnv = e->currentContext->lex;
    while(TRUE) {
        IFD(nextResult);
        nextResult = IteratorStep(e, keys);
        RET_IF_AB(nextResult);
        if(nextResult->type == TYPE_BOOL && nextResult->b == FALSE)
            RET(ValNewCompU(e, COMP_NORMAL, NULL, NULL));

        nextValue = IteratorValue(e, nextResult);
        ValDel(e, nextResult);
        nextResult = NULL;
        RET_IF_AB(nextValue);
        forEnv = NewDeclEnv(e, oldEnv);
        Env* env = forEnv->lex->envRec;
        Node* boundNames = n->left;
        if(n->token != TOK_NOT_FOUND) {     // single value
            Val* name = ValNewStrId(e, p->tk, boundNames->token);
            Val* res =  env->vtable->createMutableBinding(e, env, name, TRUE);
            ValDel(e, res);
            ValDel(e, name);
            status = BindingInitialization(p, boundNames, nextValue, forEnv, flags);
            RET_IF_AB(status);
        }
        else {                              // list of bound values
            for(Node* i = boundNames; i; i = i->right) {
                Val* name = ValNewStrId(e, p->tk, i->left->token);
                Val* ret = forEnv->env->vtable->createMutableBinding(e, forEnv->env, name, TRUE);
                ValDel(e, ret);
                ValDel(e, name);
                status = BindingInitialization(p, i, nextValue, forEnv, flags);
                RET_IF_AB(status);
            }
        }
        e->currentContext->lex = forEnv;
        cont = EvalComprehensionTail(p, tail, accumulator, flags);
        e->currentContext->lex = oldEnv;
        ValDel(e, forEnv);
        forEnv = NULL;
        RET_IF_AB(cont);
        ValDel(e, cont);
        cont = NULL;
        ValDel(e, status);
        status = NULL;
        ValDel(e, nextValue);
        nextValue = NULL;
    }

exit:
    IFD(exprRef);
    IFD(exprValue);
    IFD(obj);
    IFD(keys);
    IFD(nextResult);
    IFD(nextValue);
    IFD(forEnv);
    IFD(status);
    IFD(cont);
    return ret;
}

Val* EvalComprehensionIf(Parser* p, Node* n, Val* accumulator, Node* tail, uint32 flags) {
    Val* valueRef = NULL, *value = NULL, *boolValue = NULL, *ret = NULL;
    Js* e = p->e;
    valueRef = Eval(p, n->left, flags);
    value = GetValue(e, valueRef);
    RET_IF_AB(value);
    boolValue = ToBoolean(e, value);
    if(ValIsTrue(e, boolValue)) 
        RET(EvalComprehensionTail(p, n->right, accumulator, flags));
    RET(ValNewCompU(e, COMP_NORMAL,NULL,NULL));
exit:
    IFD(valueRef);
    IFD(value);
    IFD(boolValue);
    return ret;
}


Node* IdentifierReference(Parser* p, int start, uint32 flags) {
    return Identifier(p, start, flags);
}

Node* LabelIdentifier(Parser* p, int start, uint32 flags) {
    return Identifier(p, start, flags);
}

Node* ParenthesizedExpression(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lpar)
        return NULL;
    p->next++;
    Node* n = Expression(p, p->next, flags);
    if(!n) {
        p->next = start;
        return NULL;
    }
    if(NextKeyword(p, TRUE) != id_rpar) {
        return NodeError(p, n, start, ") exprected");
    }
    p->next++;
    return n;
}

Node* SpreadElement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_dotdotdot)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = AssignmentExpression(p, p->next, flags);
    return n;
}

Node* Element(Parser* p, int start, uint32 flags) {
    Node* n = AssignmentExpression(p, start, flags);
    if(n) return n;
    return SpreadElement(p, start, flags);
}

Node* ArrayLiteral(Parser* p, int start, uint32 flags) {
    if(TkGetTokKeyword(p->e, p->tk, start) != id_lbracket)              // id_lbracket
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    Node* r = n;
    while(TRUE) {
        int key = NextKeyword(p, TRUE);
        if(key == id_rbracket)
            break;
        r->right = NodeNew(p);
        r->right->left = Element(p, p->next, flags);
        r = r->right;
        key = NextKeyword(p, TRUE);
        if(key != id_comma)
            break;
        p->next++;
        // Handle trailing elision
        if(NextKeyword(p, TRUE) == id_rbracket) {
            r->right = NodeNew(p);
            break;
        }
    }

    if(NextKeyword(p, TRUE) != id_rbracket) {
        return NodeError(p, n, start, "] Expected");
    }
    p->next++;
    return n;
}

Node* ComprehensionIf(Parser* p, int start, uint32 flags) {
    if(TkGetTokKeyword(p->e, p->tk, start) != id_if)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");

    p->next++;
    n->left = AssignmentExpression(p, p->next, flags);
    if(!n->left)
        return NodeError(p, n, start, "AssignmentExpression expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;
    return n;
}  




Node* BindingRestElement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_dotdotdot)
        return NULL;
    
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = P(BindingIdentifier,p, p->next, flags,0);
    if(!n->left)
        return NodeError(p, n, start, "BindingIdentifier expected");

    Node* n2 = NodeNew(p);
    NodeSetFlag(p, n, BindingRestElement);
    n2->left = n;
    return n2;
}

Node* BindingElisionElement(Parser* p, int start, uint32 flags) {
    int k = NextKeyword(p, TRUE);
    if(k == id_comma) 
        return NodeNew(p);
    if(k == id_dotdotdot) 
        return P(BindingRestElement,p, start, flags,0);

    Node* n = P(BindingElement,p, start, flags,0);
    if(!n)
        return n;
    Node* n2 = NodeNew(p);
    NodeSetFlag(p, n2, BindingElement);
    n2->left = n;
    return n2;
}

Node* BindingElementList(Parser* p, int start, uint32 flags) {
    Node* n = P(BindingElisionElement,p, start, flags,0);
    if(NodeKeyword(p, n) == id_dotdotdot)
        return n;
    if(!n)
        return NULL;

    Node* root = n;
    while(NextKeyword(p, TRUE) == id_comma) {
        p->next++;
        n->right = P(BindingElisionElement,p, p->next, flags,0);
        if(!n->right) 
            return NodeError(p, root, start, "BindingElisionElement expected");
        n = n->right;
        if(NodeKeyword(p, n) == id_dotdotdot)
            break;
    }
    return root;
}

Node* ArrayBindingPattern(Parser* p, int start, uint32 flags) { 
    if(NextKeyword(p, FALSE) != id_lbracket)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->right = P(BindingElementList,p, p->next, flags,0);
    if(NextKeyword(p, TRUE) != id_rbracket)
        return NodeError(p, n, start, "] expected");
    p->next++;
    return n;
}


Node* SingleNameBinding(Parser* p, int start, uint32 flags) {
    Node* n = P(BindingIdentifier,p, start, flags,0);
    if(NextKeyword(p, TRUE) != id_eq)
        return n;
    Node* n2 = NodeNewAdvance(p, n, NULL);
    n2->right = P(AssignmentExpression,p, p->next, flags,0);
    if(!n2->right)
        return NodeError(p, n2, start, "AssignmentExpression expected");
    return n2;
}

Node* BindingElement(Parser* p, int start, uint32 flags) {
    Node* n = P(SingleNameBinding,p, start, flags,0);
    if(n)
        return n;
    n = P(BindingPattern,p, start, flags,0);
    if(!n)
        return NULL;
    if(NextKeyword(p, TRUE) != id_eq)
        return n;

    Node* n2 = NodeNewAdvance(p, n, NULL);
    n2->right = P(AssignmentExpression,p, p->next, flags,0);
    if(!n2->right)
        return NodeError(p, n2, start, "AssignmentExpression expected");
    return n2;
}

Node* PropertyName(Parser* p, int start, uint32 flags);

Node* BindingProperty(Parser* p, int start, uint32 flags) {
    Node* n = P(SingleNameBinding,p, start, flags,0);
    if(n) {
        Node* n2 = NodeNew(p);
        n2->left = n;
        return n2;
    }
    n = P(PropertyName,p, start, flags,0);
    if(!n)
        return NULL;
    if(NextKeyword(p, TRUE) != id_colon) 
        return NodeError(p, n, start, ": expected");
    Node* n2 = NodeNewAdvance(p, n, NULL);
    n2->right = P(BindingElement,p, p->next, flags,0);
    if(!n2->right)
        return NodeError(p, n2, start, "BindingElement expected");
    Node* n3 = NodeNew(p);
    n3->left = n2;
    return n3;
}

Node* BindingPropertyList(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) == id_rbrace)
        return NULL;
    Node* n = P(BindingProperty,p, start, flags,0);
    if(!n)
        return NULL;
    Node* root = n;
    while(NextKeyword(p, TRUE) == id_comma) {
        p->next++;
        n->right = P(BindingProperty,p, p->next, flags,0);
        if(!n->right)
            return NodeError(p, root, start, "BindingProperty expected");
        n = n->right;
    }
    return root;
}

Node* ObjectBindingPattern(Parser* p, int start, uint32 flags) { 
    if(NextKeyword(p, FALSE) != id_lbrace)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->right = P(BindingPropertyList,p, p->next, flags,0);
    if(NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, n, start, "} expected");
    p->next++;
    return n;
}

Node* BindingPattern(Parser* p, int start, uint32 flags) { 
    Node* n = P(ObjectBindingPattern,p, start, flags,0);
    if(n)
        return n;

    return P(ArrayBindingPattern,p, start, flags,0);
}

Node* ValidateForBindingIdentifier(Parser* p, int start, Node* n) {
    if(!n)
        return NULL;
    if(TokIsId(p->e, p->tk, n, "let"))
        return NodeError(p, n, start, "let not allowed");
    return n;
}

Node* ForBinding(Parser* p, int start, uint32 flags) {
    Node *n = P(BindingIdentifier,p, start, flags,0);
    if(n)
        return ValidateForBindingIdentifier(p, start, n);

    // @todo: Validate binding identifiers in pattern for "let" and repeats
    return BindingPattern(p, start, flags);
}

Node* ComprehensionFor(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_for) 
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");

    p->next++;
    n->left = P(ForBinding,p, p->next, flags,0);
    if(!n->left)
        return NodeError(p, n, start, "ForBinding expected");
    if(NextKeyword(p, TRUE) != id_of)
        return NodeError(p, n, start, "of expected");
    p->next++;
    n->right = AssignmentExpression(p, p->next, flags);
    if(!n->right)
        return NodeError(p, n, start, "AssignmentExpression expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;
    return n;
}

Node* ComprehensionTail(Parser* p, int start, uint32 flags) {
    Node* n = AssignmentExpression(p, start, flags);
    if(n) 
        return n;
    n = ComprehensionFor(p, start, flags);
    if(n) {
        n->right = ComprehensionTail(p, p->next, flags);
        return n;
    }
    n = ComprehensionIf(p, start, flags);
    if(!n)
        return NULL;
    n->right = ComprehensionTail(p, p->next, flags);
    return n;
}

Node* ArrayComprehension(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lbracket)              // id_lbracket
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = ComprehensionFor(p, p->next, flags);
    if(!n->left) 
        return NodeError(p, n, start, "ComprehensionFor expected");
    n->right = ComprehensionTail(p, p->next, flags);
    if(!n->right) 
        return NodeError(p, n, start, "ComprehensionTail expected");

    if(NextKeyword(p, TRUE) != id_rbracket)
        return NodeError(p, n, start, "] expected");
    p->next++;
    return n;
}

Node* ArrayInitializer(Parser* p, int start, uint32 flags) {
    Node* n = ArrayLiteral(p, start, flags);
    if(n) return n;
    p->error[0] = 0;
    return ArrayComprehension(p, start, flags);
}

Node* StrictFormalParameters(Parser* p, int start, uint32 flags) {
    return P(FormalParameters,p, start, flags | PSTRICT,0);
}

Node* PropertySetParameterList(Parser* p, int start, uint32 flags) {
    return P(FormalParameters, p, start, flags, 0);
}



bool_t MethodDefinition_EarlyErrors(Parser* p, Node* node) {
    int k = NodeKeyword(p, node);
    PtrList* paramNames = BoundNames(p, node->right->right);
    if(k == id_set) {
        if(NameListHasDuplicates(p, paramNames)) {
            PtrListDel(p->e, paramNames);
            return TRUE;
        }                
    }

    if(k == id_lpar || k == id_set) {
        PtrList* funcBodyLex = LexicallyDeclaredNames(p, node->right->left);
        bool_t ret = FALSE;

        for(PtrItem* bi=paramNames->head; bi; bi = bi->next) {
            Val* vn = StringValue(p, bi->value);
            if(PtrListHasStr(p, funcBodyLex, vn,0)) {
                ValDel(p->e, vn);
                ret = TRUE;
                break;
            }
            ValDel(p->e, vn);
        }

        PtrListDel(p->e, paramNames);
        PtrListDel(p->e, funcBodyLex);
        return ret;
    }   
    PtrListDel(p->e, paramNames);
    return FALSE;
}


Val* DefineMethod(Parser* p, Node* n, uint32 flags, Val* object, Val* funcProto) {
    Js* e = p->e;
    Val* ret = NULL, *closure = NULL, *propKey = NULL;
    propKey = StringValue(p, n->left); // Eval(p, n->left, flags);??
    RET_IF_AB(propKey);

    bool_t strict = (IsStrict(p, n->right->left)) ? TRUE : FALSE;
    Val* scope = e->currentContext->lex;
    int kind = (funcProto) ? FUNC_NORMAL : FUNC_METHOD;
    closure = FunctionCreate(e, kind, n->right->right, n->right->left, scope, strict, funcProto, p, n);
    ValDel(e, MakeMethod(e, closure, propKey, object));
    ret = ValNewObject(e);
    PutA(e, ret, "[[key]]", propKey, FALSE);
    PutA(e, ret, "[[closure]]", closure, FALSE);

exit:
    IFD(propKey);
    IFD(closure);
    return ret;
}

Val* PropertyDefinitionEvaluation(Parser* p, Node* n, uint32 flags, Val* object, bool_t enumerable) {
    Val* ret = NULL, *methodDef = NULL, *desc = NULL, *key = NULL, *closure = NULL, * propKey = NULL;
    Val* prefix = NULL;
    Js* e = p->e;

    int k = NodeKeyword(p, n);
    if(k == id_lpar) {
        methodDef = DefineMethod(p, n, flags, object, NULL);
        RET_IF_AB(methodDef);
        key = GetA(e, methodDef, "[[key]]");
        closure = GetA(e, methodDef, "[[closure]]");
        ValDel(e, SetFunctionName(e, closure, key, NULL));
        desc = ValNewDesc(e);
        PropSetValue(e, desc->desc, closure);        
        PropSetConfigurable(e, desc->desc, TRUE);
        PropSetWritable(e, desc->desc, TRUE);
        PropSetEnumerable(e, desc->desc, enumerable);
        RET(DefinePropOrThrow(e, object, key, desc));
    }
    else if(k == id_get) {
        propKey = StringValue(p, n->left); // Eval???
        RET_IF_AB(propKey);
        bool_t strict = IsStrict(p, n->right); 
        Val* scope = e->currentContext->lex;
        closure = FunctionCreate(e, FUNC_METHOD, NULL, n->right, scope, strict, NULL, p, n);
        ValDel(e, MakeMethod(e, closure, NULL, object));
        prefix = ValNewStrA(e, "get");
        ValDel(e, SetFunctionName(e, closure, propKey, prefix));
        desc = ValNewDesc(e);
        desc->desc->get = ValClone(e, closure);
        PropSetConfigurable(e, desc->desc, TRUE);
        PropSetEnumerable(e, desc->desc, enumerable);
        RET(DefinePropOrThrow(e, object, propKey, desc));
    }
    else if(k == id_set) {
        propKey = StringValue(p, n->left); // Eval???
        RET_IF_AB(propKey);
        bool_t strict = IsStrict(p, n->right->left);
        Val* scope = e->currentContext->lex;
        closure = FunctionCreate(e, FUNC_METHOD, n->right->right, n->right, scope, strict, NULL, p, n);
        ValDel(e, MakeMethod(e, closure, NULL, object));
        prefix = ValNewStrA(e, "set");
        ValDel(e, SetFunctionName(e, closure, propKey, prefix));
        desc = ValNewDesc(e);
        desc->desc->set = ValClone(e, closure);
        PropSetConfigurable(e, desc->desc, TRUE);
        PropSetEnumerable(e, desc->desc, enumerable);
        RET(DefinePropOrThrow(e, object, propKey, desc));
    }

exit:
    IFD(prefix);
    IFD(propKey);
    IFD(desc);
    IFD(key);
    IFD(closure);
    IFD(methodDef);
    return ret;    
}

Node* MethodDefinition(Parser* p, int start, uint32 flags) {

    // Handle id_get and id_set before propName since the parser
    // will return a valid node for get and set assuming they
    // are identifiers
    if(NextKeyword(p, TRUE) == id_get) {
        Node* n = NodeNewAdvance(p, NULL, NULL);
        n->left = P(PropertyName, p, p->next, flags, 0);
        if(!n->left) {
            return NodeError(p, n, start, "PropertyName expected");
        }
        if(NextKeyword(p, TRUE) != id_lpar) {
            return NodeError(p, n, start, "( expected");
        }
        p->next++;
        if(NextKeyword(p, TRUE) != id_rpar) {
            return NodeError(p, n, start, ") expected");
        }
        p->next++;
        if(NextKeyword(p, TRUE) != id_lbrace) {
            return NodeError(p, n, start, "{ expected");            
        }        
        p->next++;
        n->right = P(FunctionBody, p, p->next, flags, 0 );
        if(!n->right) {
            return NodeError(p, n, start, "FunctionBody expected");
        }

        if(NextKeyword(p, TRUE) != id_rbrace) {
            return NodeError(p, n, start, "} expected");
        }
        p->next++;
        return n;        
    }

    if(NextKeyword(p, TRUE) == id_set) {
        Node* n = NodeNewAdvance(p, NULL, NULL);
        n->left = P(PropertyName, p, p->next, flags, 0);
        if(!n->left) {
            return NodeError(p, n, start, "PropertyName expected");
        }
        if(NextKeyword(p, TRUE) != id_lpar) {
            return NodeError(p, n, start, "( expected");
        }
        p->next++;
        n->right = NodeNew(p);
        n->right->right = P(PropertySetParameterList, p, p->next, flags, 0);
        if(!n->right->right) {
            return NodeError(p, n, start, "PropertySetParameterList expected");
        }
        if(NextKeyword(p, TRUE) != id_rpar) {
            return NodeError(p, n, start, ") expected");
        }
        p->next++;
        if(NextKeyword(p, TRUE) != id_lbrace) {
            return NodeError(p, n, start, "{ expected");            
        }        
        p->next++;
        n->right->left = P(FunctionBody, p, p->next, flags, 0 );
        if(!n->right->left) {
            return NodeError(p, n, start, "FunctionBody expected");
        }

        if(NextKeyword(p, TRUE) != id_rbrace) {
            return NodeError(p, n, start, "} expected");
        }
        p->next++;
        if(MethodDefinition_EarlyErrors(p, n)) {
            return NodeError(p, n, start, "MethodDefinition_EarlyErrors");
        }

        return n;        
    }

    Node* propName = P(PropertyName, p, p->next, flags, 0);
    if(propName) {
        int k = NextKeyword(p, TRUE);
        if(k != id_lpar) {
            return NodeError(p, propName, start, "( expected");
        }
        Node* n = NodeNewAdvance(p, propName, NULL);
        n->right = NodeNew(p);

        n->right->right = P(StrictFormalParameters, p, p->next, flags,0 );
        // It's ok for this to be NULL
//        if(!n->right->right) {
//            return NodeError(p, n, start, "Strict formal parameters expected");
//        }

        if(NextKeyword(p, TRUE) != id_rpar) {
            return NodeError(p, n, start, ") expected");
        }
        p->next++;
        if(NextKeyword(p, TRUE) != id_lbrace) {
            return NodeError(p, n, start, "{ expected");            
        }        
        p->next++;
        n->right->left = P(FunctionBody, p, p->next, flags, 0 );
        if(!n->right->left) {
            return NodeError(p, n, start, "FunctionBody expected");
        }

        if(NextKeyword(p, TRUE) != id_rbrace) {
            return NodeError(p, n, start, "} expected");
        }
        p->next++;
        if(MethodDefinition_EarlyErrors(p, n)) {
            return NodeError(p, n, start, "MethodDefinition_EarlyErrors");
        }
        return n;
    }


    return NULL;
}


bool_t ComputedPropertyContains(Parser* p, Node* n, Val* symbol) {
    if(NodeHasFlag(p, n, MethodDefinition)) {
        // All method definitions have propertyName left->left
        return ComputedPropertyContains(p, n->left, symbol);
    }

    return FALSE;
}


bool_t HasComputedPropertyKey(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, MethodDefinition)) {
        return HasComputedPropertyKey(p, n->left);
    }
    return FALSE;
}

bool_t ContainsSuperCall(Parser* p, Node* n) {
    return ContainsKeyword(p, n, id_super, 0);
}

bool_t HasDirectSuper(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, MethodDefinition)) {
        int k = NodeKeyword(p, n);
        if(k == id_lpar || k == id_set) {
            if(ContainsSuperCall(p, n->right->right)) {
                return TRUE;
            }

            if(ContainsSuperCall(p, n->right->left)) {
                return TRUE;
            }
        }

        return ContainsSuperCall(p, n->right);
    }
    return FALSE;
}

Val* PropName(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, MethodDefinition)) {
        return PropName(p, n->left);
    }

    return ValNew(p->e); // @todo: implement
}

bool_t SpecialMethod(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, MethodDefinition)) {
        int k = NodeKeyword(p, n);
        if(k == id_lpar) {
            return FALSE;
        }
        return TRUE;
    }

    return FALSE;
}


void CtagsCheckAssignmentFunc(Parser* p, Node* n, int lastCall);


Node* PropertyDefinition(Parser* p, int start, uint32 flags) {
    int t = NextType(p, TRUE);
    if(t == TOK_STRLIT || t == TOK_NUMLIT) {
        Node* n = NodeNewAdvance(p, NULL, NULL);
        if(NextKeyword(p, TRUE) != id_colon)
            return NodeError(p, n, start, ", expected");
        Node* x = NodeNewAdvance(p, n, NULL);
        x->right = AssignmentExpression(p, p->next, flags);
        if(!x->right)
            return NodeError(p, x, start, "AssignmentExpression expected");
        return x;
    }

    // Identifier is amiguous since it can be used with <TdentifierRef> = <AssignmentExpression>
    if(
        (t == TOK_IDENTIFIER 
            || t == TOK_KEYWORD
        )

        && TkGetTokKeyword(p->e, p->tk, p->next+1) == id_colon) {
        Node* l = NodeNewAdvance(p, NULL, NULL);
        Node* x = NodeNewAdvance(p, l, NULL);
        int lastCall = 0;
        if(p->calls)
            lastCall = p->calls->list->count;
        x->right = AssignmentExpression(p, p->next, flags);
        if(!x->right)
            return NodeError(p, x, start, "AssignmentExpression expected");
        CtagsCheckAssignmentFunc(p, x, lastCall);
        return x;
    }

    Node* n = IdentifierReference(p, start, flags);
    if(n) {
        int k = NextKeyword(p, TRUE);
         // Need to check for lpar to allow for method def below
        if(k != id_eq && k != id_lpar)
            return n;
        
        if(k != id_lpar) {
            Node* x = NodeNewAdvance(p, n, NULL);
            x->right = AssignmentExpression(p, p->next, flags);
            if(!x->right)
                return NodeError(p, x, start, "AssignmentExpression expected");
            return x;
        }
        NodeDel(p, n);
        p->next = start;
    }

    if(NextKeyword(p, TRUE) == id_lbracket) {
        Node* n = NodeNewAdvance(p, NULL, NULL);
        n->left = AssignmentExpression(p, p->next, flags);
        if(!n->left)
            return NodeError(p, n, start, "AssignmentExpression expected");
        if(NextKeyword(p, TRUE) != id_rbracket)
            return NodeError(p, n, start, "] expected");
        p->next++;
        if(NextKeyword(p, TRUE) != id_colon)
            return NodeError(p, n, start, ": expected");
        Node* x = NodeNewAdvance(p, n, NULL);
        x->right = AssignmentExpression(p, p->next, flags);
        if(!x->right)
            return NodeError(p, x, start, "AssignmentExpression expected");
        return x;
    }
    return MethodDefinition(p, start, flags);
}

Node* PropertyDefinitionList(Parser* p, int start, uint32 flags) {
    Node* n = NodeNew(p);
    Node* root = n;
    while(TRUE) {
        n->left = PropertyDefinition(p, p->next, flags);
        if(NextKeyword(p, TRUE) != id_comma)
            break;
        Node* r = NodeNew(p);
        n->right = r;
        n = n->right;
        p->next++;
    }
    return root;
}

Node* ValidateNoPropDuplicates(Parser* p, Node* n, uint32 flags) {
    // @todo: ensure [:]->left is not duplicate other than method definitions
    return n;
}

Node* ObjectLiteral(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lbrace)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->right = PropertyDefinitionList(p, p->next, flags);
    if(NextKeyword(p, TRUE) != id_rbrace) 
        return NodeError(p, n, start, "} expected");
    p->next++;

    if(! (flags & PSTRICT))
        return ValidateNoPropDuplicates(p, n, flags);

    return n;
}

Node* FunctionRestParameter(Parser* p, int start, uint32 flags) {
    return P(BindingRestElement, p, p->next, flags, 0);
}

Node* FormalParameter(Parser* p, int start, uint32 flags) {
    return P(BindingElement, p, p->next, flags, 0);
}

Node* FormalsList(Parser* p, int start, uint32 flags) {
    Node* root = NULL;
    Node* last = NULL;
    while(TRUE) {
        Node* n = P(FormalParameter, p, p->next, flags, 0);
        if(n) {
            Node* a = NodeNew(p);
            a->left = n;
            n = a;
        }
        else if(NextKeyword(p, TRUE) == id_dotdotdot) {
            // #416 we should not advance since FunctionRestParameter calls
            //      BindingRestParameter which expects the current position to
            //      be at the '...' token
            // n = NodeNewAdvance(p, NULL, NULL);
//            n = NodeNew(p);
            n = P(FunctionRestParameter, p, p->next, flags, 0);
            if(last)
                last->right = n;
            else
                root = n;
            return root;
        }
        if(!n)
            return root;

        if(!root)
            root = n;
        if(last)
            last->right = n;
        last = n;
        if(NextKeyword(p, TRUE) != id_comma)
            return root;
        p->next++;
    }
}

Node* FormalParameterList(Parser* p, int start, uint32 flags) {
    Node* n = P(FunctionRestParameter, p, start, flags, 0);
    if(n)
        return n;
    return P(FormalsList, p, start, flags, 0);
}

Node* FormalParameters(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) == id_rpar)
        return NULL;

    return P(FormalParameterList, p, start, flags, 0);
}

Node* FunctionStatementList(Parser* p, int start, uint32 flags) {
    return StatementListParse(p, start, flags);
}

Node* FunctionBody(Parser* p, int start, uint32 flags) {
    return P(FunctionStatementList, p, start, flags, 0);
}

Val* NodeGetCallStr(Parser* p, Node* n) {
    Js* e = p->e;
    if(TkGetTokKeyword(e, p->tk, n->token) == id_dot) {
        Val* l = NodeGetCallStr(p, n->left);
        l = ValStrCatADel(e, l, ".");
        Val* r = ValNewStrId(e, p->tk, n->right->token);
        l = ValStrCatDel(e, l, r);
        ValDel(e, r);
        return l;
    }   
    else if(TkGetTokKeyword(e, p->tk, n->token) == id_lpar) {
        Val* l = NodeGetCallStr(p, n->left);
        return ValStrCatADel(e, l, "()");
    }
    else {
        return ValNewStrId(e, p->tk, n->token);
    }
}


Node* FunctionExpression(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_function)
        return NULL;

    int funcLine = TkGetTokLine(p->e, p->tk, p->next)+1;
    FuncDef* fd = FuncDefNew(p);
    fd->line = funcLine;
    fd->startToken = start;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    
    // We need to flag the function as strict if it is in a strict
    // context
    if(flags & PSTRICT)
        NodeSetFlag(p, n, IsStrict);
    
    n->left = NodeNew(p);
    n->left->left = P(BindingIdentifier, p, p->next, flags, 0);
    // For function expressions, it's ok for the name to be anonymous
    if(n->left->left) {
        fd->name = NodeGetCallStr(p, n->left->left);
        // fd->name = StringValue(p, n->left->left);
    }

    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;            
    p->error[0] = 0;
    n->right = P(FormalParameters, p, p->next, flags, 0);
    if(!n->right && p->error[0])
        return NodeError(p, n, start, "function FormalParameters expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;

    if(NextKeyword(p, TRUE) != id_lbrace)
        return NodeError(p, n, start, "{ expected");

    BlockDef* bd = BlockDefNew(p);
    fd->block = bd;
    bd->start = TkGetTokLine(p->e, p->tk, p->next)+1;
    p->next++;
    n->left->right = P(FunctionBody, p, p->next, flags, 0);
    if(!n->left->right && NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, n, start, "FunctionBody expected");
    if(NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, n, start, "} expected");
    bd->end = TkGetTokLine(p->e, p->tk, p->next);
    fd->endToken = p->next;
    p->currentBlock = p->currentBlock->parent;
    p->next++;
    p->currentFunc = p->currentFunc->parent;
    return n;
}

Node* ClassExpression(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* GeneratorExpression(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* Comprehension(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* GeneratorComprehension(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* RegularExpressionLiteral(Parser* p, int start, uint32 flags) {
    if(NextType(p, TRUE) != TOK_REGEX) 
        return NULL;

    // @todo: Parse the regex body

    // Ensure flags are g, i, m, u, y and don't repeat
    Str* rex = TkGetTokStr(p->e, p->tk, start);
    if(!rex)
        return NULL;
    assert(rex);
    Token* tk = VectorGet(p->e, p->tk->tokens, start);
    int flagOffset = tk->flag_offset;
    bool_t has_i = FALSE, has_m = FALSE, has_g = FALSE;
    bool_t has_u = FALSE, has_y = FALSE;

    Node* n = NodeNewAdvance(p, NULL, NULL);

    for(int i = flagOffset+1; i < rex->length; i++) {
        uchar c = rex->chars[i];
        if(c == 'i') {
            if(has_i)
                return NodeError(p, n, start, "'i' cannot be specified multiple times in RegExp flags");
            has_i = TRUE;
        }
        else if(c == 'g') {
            if(has_g)
                return NodeError(p, n, start, "'g' cannot be specified multiple times in RegExp flags");
            has_g = TRUE;
        }
        else if(c == 'm') {
            if(has_m)
                return NodeError(p, n, start, "'m' cannot be specified multiple times in RegExp flags");
            has_m = TRUE;
        }
        else if(c == 'u') {
            if(has_u)
                return NodeError(p, n, start, "'u' cannot be specified multiple times in RegExp flags");
            has_u = TRUE;
        }
        else if(c == 'y') {
            if(has_y)
                return NodeError(p, n, start, "'u' cannot be specified multiple times in RegExp flags");
            has_y = TRUE;
        }
        else 
            return NodeError(p, n, start, "Invalid RegExp flag character");
    }

    return n;
}

Node* TemplateLiteral(Parser* p, int start, uint32 flags) {
    if(NextType(p, TRUE) == TOK_TEMPLIT)
        return NodeNewAdvance(p, NULL, NULL);

    if(NextType(p, TRUE) != TOK_TEMPHEAD)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = Expression(p, p->next, flags);
    if(!n->left)
        return NodeError(p, n, start, "Expression expected");
    Node* root = n;
    while(n) {
        if(NextType(p, TRUE) == TOK_TEMPTAIL) {
            n->right = NodeNewAdvance(p, NULL, NULL);
            break;
        }
        if(NextType(p, TRUE) != TOK_TEMPMID) // Allow TEMPHEAD + Expression with no tail
            return root;

        n->right = NodeNewAdvance(p, NULL, NULL);
        n = n->right;
        n->left = Expression(p, p->next, flags);
        if(!n->left)
            return NodeError(p, root, start, "Expression expected");
    }
    return root;
}

Node* CoverParenthesizedExpressionAndArrowParameterList(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lpar)
        return NULL;
    p->next++;

    if(NextKeyword(p, TRUE) == id_rpar) 
        return NodeError(p, NULL, start, "Expression expected");

    if(NextKeyword(p, TRUE) == id_dotdotdot) {
        Node* n = NodeNewAdvance(p, NULL, NULL);
        n->right = P(BindingIdentifier,p, p->next, flags,0);
        if(!n->right) {
            return NodeError(p, n, start, "Binding identifier expected");
        }
        if(NextKeyword(p, TRUE) != id_rpar) {
            return NodeError(p, n, start, ") exprected");
        }
        p->next++;
        return n;
    }
    Node* n = Expression(p, p->next, flags);
    if(!n) {
        p->next = start;
        return NULL;
    }

    if(NextKeyword(p, TRUE) == id_comma) {
        p->next++;
        if(NextKeyword(p, TRUE) != id_dotdotdot) {
            return NodeError(p, n, start, "... expected");
        }
        Node* n2 = NodeNewAdvance(p, n,NULL);
        n2->right = P(BindingIdentifier,p, p->next, flags,0);
        if(!n2->right) 
            return NodeError(p, n2, start, "Binding identifier expected");
        n = n2;
    }

    if(NextKeyword(p, TRUE) != id_rpar) {
        return NodeError(p, n, start, ") exprected");
    }
    p->next++;
    return n;    
}

Node* PrimaryExpression(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) == id_this) {
        return NodeNewAdvance(p, NULL, NULL);
    }

    Node* n = IdentifierReference(p, start, flags);
    if(n) return n;
    n = P(Literal, p, start, flags, 0);
    if(n) return n;
    n = P(ArrayInitializer, p, start, flags, 0);
    if(n) return n;
    n = P(ObjectLiteral, p, start, flags, 0);
    if(n) return n;
    n = P(FunctionExpression, p, start, flags, 0);
    if(n) return n;
    n = P(ClassExpression,p, start, flags, 0);
    if(n) return n;
    n = P(GeneratorExpression, p, start, flags, 0);
    if(n) return n;
    n = P(GeneratorComprehension,p, start, flags, 0);
    if(n) return n;
    n = P(RegularExpressionLiteral, p, start, flags, 0);
    if(n) return n;
    n = P(TemplateLiteral, p, start, flags, 0);
    if(n) return n;
    n = P(CoverParenthesizedExpressionAndArrowParameterList,p, start, flags, 0);
    if(n) return n;
    // @todo: remove this below since it's covered by above
    n = P(ParenthesizedExpression, p, start, flags, 0);
    return n;
}

Node* MemberExpression(Parser* p, int start, uint32 flags);
Node* Arguments(Parser* p, int start, uint32 flags);

Node* SuperMemberExpression(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_super) 
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    int k = NextKeyword(p, TRUE);
    if(k != id_dot && k != id_lbracket) {
        return NodeError(p, n, start, "super. or super[ expected");
    }
    Node* n2 = NodeNewAdvance(p, n, NULL);
    if(k == id_dot) 
        n2->right = IdentifierReference(p, p->next, flags);
    else if(k == id_lbracket) 
        n2->right = Expression(p, p->next, flags);
    if(!n2->right)
        return NodeError(p, n2, start, "Identifier or Expression expected");
    return n2;
}

Node* NewMemberExpression(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_new)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) == id_super) 
        n->left = NodeNewAdvance(p, NULL, NULL);        
    else 
        n->left = MemberExpression(p, p->next, flags);
    if(!n->left)
        return NodeError(p, n, start, "new super or new MemberExpression expected");
    if(NextKeyword(p, TRUE) == id_lpar) {
        // return NodeError(p, n, start, "( expected");
        p->next++;
        n->right = Arguments(p, p->next, flags);

        // It's OK for arguments to be empty
        // if(!n->right)
        //     return NodeError(p, n, start, "Arguments expected");
        if(NextKeyword(p, TRUE) != id_rpar) 
            return NodeError(p, n, start, ") expected");
        p->next++;
    }
    return n;
}

Node* MetaProperty(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_new)
        return NULL;

    Node* n2 = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, FALSE) == id_dot) {
        Node* n = NodeNewAdvance(p, n2, NULL);
        n->right = IdentifierName(p, p->next, flags);
        if(!n->right)
            return NodeError(p, n, start, "new.target expected");
        Val* name = StringValue(p, n->right);
        bool_t isTarget = ValEqStrA(p->e, name, "target");
        ValDel(p->e, name);
        if(!isTarget) {
            return NodeError(p, n, start, "new.target expected");
        }
        return n;
    }
    return NULL;
}

// This will enforce [no LineTerminator here] rules
void SkipNewLines(Parser* p) {
    int t1, k1, t2, k2;
    t1 = NextType(p, 0);
    k1 = NextKeyword(p, 0);
    p->next++;
    t2 = NextType(p, 0);
    k2 = NextKeyword(p, 0);
    p->next--;

    if( (k2 == id_plusplus || k2 == id_minusminus) && t1 == TOK_LINETERM)
        return;
    if( (k1 == id_continue || k1 == id_break || k1 == id_return || k1 == id_throw || k1 == id_yield)
        && t2 == TOK_LINETERM && k2 != id_semi)
        return;
    while(NextType(p, FALSE) == TOK_LINETERM) p->next++;    // #433
}

Node* MemberExpression(Parser* p, int start, uint32 flags) {
    Node* n =  P(PrimaryExpression,p, start, flags,0);
    if(!n) 
        n = P(SuperMemberExpression,p, start, flags,0);
    
    if(!n)
        n = P(NewMemberExpression,p, start, flags,0);

    if(!n)
        n = P(MetaProperty,p, start, flags,0);

    if(!n)
        return NULL;

    while(TRUE) {
        // while(NextType(p, FALSE) == TOK_LINETERM) p->next++;    // #433
        SkipNewLines(p);

        int k = NextKeyword(p, FALSE);
        int t = NextType(p, FALSE);

        if(k == id_dot) {
            Node* n2 = NodeNewAdvance(p, n, NULL);
            n2->right = IdentifierName(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "Identifier expected");
            n = n2;
        }
        else if(k == id_lbracket) {
            Node* n2 = NodeNewAdvance(p, n, NULL);
            n2->right = Expression(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "[Expression] expected");
            if(NextKeyword(p, TRUE) != id_rbracket)
                return NodeError(p, n2, start, "] expected");
            p->next++;
            n = n2;
        }
        else if(t == TOK_TEMPLIT || t == TOK_TEMPHEAD) {
            Node* n2 = NodeNewAdvance(p, n, NULL);
            // GO back one on p->next so we can make n2->right = TemplateLiteral
            // also mark the node flags to be a template literal call
            // n2->flags |= NODE_TEMPLATE_CALL;
            NodeSetFlag(p, n2, EvalTemplateLiteralCall);
            p->next--;
            n2->right = TemplateLiteral(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "TemplateLiteral expected");
            n = n2;
        }
        else {
            break;
        }
    }
    return n;
}

Node* Arguments(Parser* p, int start, uint32 flags) {
    Node* n2 = NULL, *root = NULL;
    while(TRUE) {
        Node* n;
        if(NextKeyword(p, TRUE) == id_dotdotdot) {
            n = NodeNewAdvance(p, NULL, NULL);
            n->left = AssignmentExpression(p, p->next, flags);
            if(!n->left) {
                return NodeError(p, n, start, "AssignmentExpression exprected");
            }
        }
        else {
            Node* l = AssignmentExpression(p, p->next, flags);
            if(!l)
                return root;

            n = NodeNew(p);
            n->left = l;
        }
        if(!root) {
            root = n;
            n2 = n;
        }
        else {
            n2->right = n;
            n2 = n;
        }

        if(NextKeyword(p, TRUE) != id_comma)
            return root;
        p->next++;
    }
    return NULL;
}


#define GLOBAL_CALLER       "**global**"

void CallDefNew(Parser* p, Node* n) {
    Js* e = p->e;
    if(!e->options.callGraph)
        return;
    if(!p->calls)
        p->calls = ValNewListEmpty(e);
    Val* cd = ValNewObject(e);
    if(p->currentFunc && p->currentFunc->name)
        PutA(e, cd, "source", p->currentFunc->name, FALSE);
    else
        PutA(e, cd, "source", ValNewStrA(e, GLOBAL_CALLER), TRUE);
    if(n->left && n->left->token) {
        Val* uid = NodeGetCallStr(p, n->left);
        PutA(e, cd, "target", uid, FALSE);
    }
    if(n->right) {
        Val* ar = 0;
        for(Node* a = n->right; a; a = a->right) {
            Val* as = NodeGetCallStr(p, a->left);
            if(!ar)
                ar = as;
            else  {
                ar = ValStrCatADel(e, ar, ",");
                ar = ValStrCatDel(e, ar, as);
            }
        }
        PutA(e, cd, "args", ar, FALSE);
    }
    PutA(e, cd, "line", ValNewNum(e, TkGetTokLine(e, p->tk, n->token)), TRUE);
    ListAddValue(e, p->calls->list, cd);
}

Node* CallExpression(Parser* p, int start, uint32 flags) {
    Node* n = NULL;

    if(NextKeyword(p, TRUE) == id_super) 
        n = NodeNewAdvance(p, NULL, NULL);
    
    if(!n)
        n = MemberExpression(p, start, flags);

    if(!n) 
        return NULL;
    
    while(TRUE) {
        SkipNewLines(p) ; // while(NextType(p, FALSE) == TOK_LINETERM) p->next++;    // #433

        int k = NextKeyword(p, FALSE);
        int t = NextType(p, FALSE);
        Node* n2 = NULL;
        if(k == id_lpar) {
            n2 = NodeNewAdvance(p, n, NULL);
            if(NextKeyword(p, TRUE) == id_rpar) {
                p->next++;
                n = n2;
                CallDefNew(p, n);
                continue;
            }
            n2->right = Arguments(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "Arguments expected");
            if(NextKeyword(p, TRUE) != id_rpar) 
                return NodeError(p, n2, start, ") expected");
            p->next++;            
            n = n2;
            CallDefNew(p, n);
            continue;
        }
        if(k == id_lbracket) {
            n2 = NodeNewAdvance(p, n, NULL);
            n2->right = Expression(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "Expression expected");
            if(NextKeyword(p, TRUE) != id_rbracket) 
                return NodeError(p, n2, start, "] expected");
            p->next++;
            n = n2;
            continue;            
        }
        if(k == id_dot) {
            n2 = NodeNewAdvance(p, n, NULL);
            n2->right = IdentifierReference(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "Identifier expected");
            n = n2;
            continue;            
        }
        if(t == TOK_TEMPHEAD || t == TOK_TEMPLIT) {        
            n2 = NodeNewAdvance(p, n, NULL); 
            n2->right = TemplateLiteral(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "TemplateLiteral expected");
            n = n2;
            continue;            
        }
        break;
    }
    return n;
}


Node* NewExpression(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) == id_new) {
        Node* n = NodeNewAdvance(p, NULL, NULL);
        if(NextKeyword(p, TRUE) == id_super) {
            n->right = NodeNewAdvance(p, NULL, NULL);
            return n;
        }
        n->right = MemberExpression(p, p->next, flags);
        if(!n->right) {
            return NodeError(p, n, start, "Member expression expected");
        }
        return n;
    }
    return MemberExpression(p, start, flags);
}

Node* LeftHandSideExpression(Parser* p, int start, uint32 flags) {
    Node* n = CallExpression(p, start, flags);
    if(n)
        return n;
    return NewExpression(p, start, flags);
}

Node* PostfixExpression(Parser* p, int start, uint32 flags) {
    Node* n = LeftHandSideExpression(p, start, flags);
    if(!n) return NULL;
    int k =  NextKeyword(p, FALSE);

    // Note we don't need to worry about [NoLineTermHere] between LHS and ++ 
    // since TkGetTokKeyword() will return id_none for TOK_LINETERM
    if( k == id_plusplus || k == id_minusminus) 
        return NodeNewAdvance(p, n, NULL);
    return n;
}


Node* UnaryExpression(Parser* p, int start, uint32 flags) {
    Node* n = PostfixExpression(p, start, flags);
    if(n)
        return n;

    int k = NextKeyword(p, TRUE);

    switch(k) {
        case id_delete:
        case id_void:
        case id_typeof:
        case id_plusplus:
        case id_minusminus:
        case id_plus:
        case id_minus:
        case id_tilde:
        case id_not: 
            n = NodeNewAdvance(p, NULL, n);
            n->right = UnaryExpression(p, p->next, flags);
            if(!n->right)
                    return NodeError(p, n, start, "UnaryExpression expected");
            return n;
    }
    return NULL;
}


Node* LeftRecursiveExpression(Parser* p, int start, ParseFunc inner, OpsFunc ops, uint32 flags) {
    Node* u1 = inner(p, start, flags);
    if(!u1) return NULL;
    Node* op = u1;
    int k =  NextKeyword(p, FALSE);
    while(ops(k)) {
        op = NodeNew(p);
        op->token = p->next;
        p->next++;
        Node* u2 = inner(p, p->next, flags);
        if(u2 == NULL) {
            NodeDel(p, u1);
            NodeDel(p, u2);
            return NodeError(p, op, start, "UnaryExpression expected");
        }
        k =  NextKeyword(p, TRUE);
        op->left = u1;
        op->right = u2;
        u1 = op;
    }

    return op;    
}

bool_t MultOps(int k) {
    return (k == id_mult || k == id_div || k == id_mod);
}
Node* MultiplicativeExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, UnaryExpression, MultOps, flags);
}

bool_t AddOps(int k) {
    return (k == id_plus || k == id_minus);
}

Node* AdditiveExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, MultiplicativeExpression, AddOps, flags);
}

bool_t ShiftOps(int k) {
    return ( k == id_lshift || k == id_rshift || k == id_rshifta);    
}

Node* ShiftExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, AdditiveExpression, ShiftOps, flags);
}

bool_t RelOps(int k) {
    return ( k == id_lt || k == id_lte || k == id_gt || k == id_gte || k == id_instanceof || k == id_in);
}

Node* RelationalExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, ShiftExpression, RelOps, flags);
}

bool_t EqOps(int k) {
    return ( k == id_eqeq || k == id_neqeq || k == id_eqeqeq || k == id_ne);
}
Node* EqualityExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, RelationalExpression, EqOps, flags);
}

bool_t BitAndOps(int k) {
   return (k == id_and); 
}
Node* BitwiseAndExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, EqualityExpression, BitAndOps, flags);
}

bool_t BitXorOps(int k) {
    return (k == id_caret);
}

Node* BitwiseXorExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, BitwiseAndExpression, BitXorOps, flags);
}

bool_t BitOrOps(int k) {
    return (k == id_or);
}

Node* BitwiseOrExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, BitwiseXorExpression, BitOrOps, flags);
}

bool_t LogAndOps(int k) {
    return (k == id_andand);
}
Node* LogicalAndExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, BitwiseOrExpression, LogAndOps, flags);
}

bool_t LogOrOps(int k) {
    return (k == id_oror);
}

Node* LogicalOrExpression(Parser* p, int start, uint32 flags) {
    return LeftRecursiveExpression(p, start, LogicalAndExpression, LogOrOps, flags);
}

Node* ConditionalExpression(Parser* p, int start, uint32 flags) {
    Node* n = LogicalOrExpression(p, start, flags);
    if(!n)
        return NULL;

    if(NextKeyword(p, TRUE) == id_question) {
        Node* n2 = NodeNewAdvance(p, n, NULL);
        Node* texpr = AssignmentExpression(p, p->next, flags);
        if(!texpr) {
            NodeDel(p, texpr);
            return NodeError(p, n2, start, "AssignmentExpression expected");
        }
        if(NextKeyword(p, TRUE) != id_colon) {
            NodeDel(p, texpr);
            return NodeError(p, n2, start, ": expected");
        }
        n2->right = NodeNewAdvance(p, texpr, NULL);
        n2->right->right = AssignmentExpression(p, p->next, flags);
        if(!n2->right->right) {
            return NodeError(p, n2, start, "AssignmentExpression expected");
        }
        return n2;
    }
    else
        return n;
}

Node* DestructuringAssignmentTarget(Parser* p, int start, uint32 flags) {
    return LeftHandSideExpression(p, start, flags);
}


Node* PropertyName(Parser* p, int start, uint32 flags) {
    return IdentifierName(p, start, flags);    // @todo: Need to validate this
}

Node* AssignmentElement(Parser* p, int start, uint32 flags) {
    Node* n = DestructuringAssignmentTarget(p, start, flags);
    if(!n)
        return NULL;
    if(NextKeyword(p, TRUE) == id_eq) {
        Node* n2 = NodeNewAdvance(p, n, NULL);
        n2->right = AssignmentExpression(p, p->next, flags);
        if(!n2->right)
            return NodeError(p, n2, start, "AssignmentExpression expected");
        return n2;
    }
    return n;
}

Node* ArrayAssignmentPattern(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lbracket)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    Node* root = n;

    while(NextKeyword(p, TRUE) != id_rbrace) {
        n->right = NodeNew(p);
        n = n->right;
        
        if(NextKeyword(p, TRUE) == id_comma) {
            p->next++;
            continue;
        }

        if(NextKeyword(p, TRUE) == id_dotdotdot) {
            n->left = NodeNewAdvance(p, NULL, NULL);
            n->left->left = DestructuringAssignmentTarget(p, p->next, flags);
            if(!n->left->left)
                return NodeError(p, root, start, "DestructuringAssignmentTarget expected");
            break;
        }

        n->left = AssignmentElement(p, p->next, flags);
        if(!n->left)
            return NodeError(p, root, start, "AssignmentPattern expected");
        if(NextKeyword(p, TRUE) != id_comma)
            break;
    }

    if(NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, root, start, "] expected");
    p->next++;
    return root;
}

Node* AssignmentProperty(Parser* p, int start, uint32 flags) {
    Node* n = IdentifierReference(p, start, flags);
    if(n) {
        int k = NextKeyword(p, TRUE);
        if(k == id_eq) {
            Node* n2 = NodeNewAdvance(p, n, NULL);
            n2->right = AssignmentExpression(p, p->next, flags);
            if(!n2->right)
                return NodeError(p, n2, start, "AssignmentExpression expected");
            return n2;
        }
        if(k == id_comma || k == id_rbrace)  // Handle IdentifierRefernce no Initializer
            return n; 
        NodeDel(p, n);  // Dropdown to check for PropertyName : ....
        p->next = start;
    }
    n = PropertyName(p, start, flags);
    if(!n)
        return n;
    if(NextKeyword(p, TRUE) != id_colon)
        return NodeError(p, n, start, ": expected");
    Node* n2 = NodeNewAdvance(p, n, NULL);
    n2->right = AssignmentElement(p, p->next, flags);
    if(!n2->right)
        return NodeError(p, n2, start, "AssignmentElement expected");
    return n2;
}


Node* ObjectAssignmentPattern(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lbrace)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    Node* root = n;
    while(NextKeyword(p, TRUE) != id_rbrace) {
        n->right = NodeNew(p);
        n = n->right;
        n->left = AssignmentProperty(p, p->next, flags);
        if(!n->left) 
            return NodeError(p, root, start, "AssignmentProperty expected");
        
        if(NextKeyword(p, TRUE) == id_comma) {
            p->next++;
            continue;
        }
    }

    if(NextKeyword(p, TRUE) != id_rbrace) {
        return NodeError(p, root, start, "} expected");
    }
    p->next++;
    return root;
}

Node* AssignmentPattern(Parser* p, int start, uint32 flags) {
    Node* n = ObjectAssignmentPattern(p, start, flags);
    if(n)
        return n;
    return ArrayAssignmentPattern(p, start, flags);
}

Node* DestructuringAssignment(Parser* p, int start, uint32 flags) {
    Node* n = P(AssignmentPattern, p, start, flags, 0);
    if(!n)
        return NULL;
    if(NextKeyword(p, TRUE) != id_eq)  {
        p->next = start;
        NodeDel(p, n);
        return NULL;
    }
    
    Node* n2 = NodeNewAdvance(p, n, NULL);
    n2->right = AssignmentExpression(p, p->next, flags);
    if(!n2->right)
        return NodeError(p, n2, start, "AssignmentExpression expected");
    return n2;
}

// Patch all calls made after a certain index to a new function name
// this is needed for expr = function() { call();}
// At the time the statement list is parsed, the function name
// is not determined yet so the call will be assumed to be 
// global
void PatchCalls(Parser* p, Val* name, int startIndex) {
    if(!p->calls)
        return;

    Js* e = p->e;
    int ii = 0;
    for(Item* i = p->calls->list->head; i; i = i->next, ii++) {
        if(ii < startIndex)
            continue;
        Val* call = i->value;
        Val* source = GetA(e, call, "source");
        if(ValEqStrA(e, source, GLOBAL_CALLER)) {
            PutA(e, call, "source", ValClone(e, name), TRUE);
        }
        ValDel(e, source);
    }
}

// Check for following
//          (=)
//         /    \
//      <id>    function
void CtagsCheckAssignmentFunc(Parser* p, Node* n, int lastCall) {
    Js* e = p->e;
    Tokenizer* tk = p->tk;

    if(TkGetTokKeyword(e, tk, n->right->token) == id_function) {
        Node* name = NULL;

        if( TkGetTokType(e, tk, n->left->token) == TOK_IDENTIFIER)
            name = n->left;
        else if(TkGetTokKeyword(e, tk, n->left->token) == id_dot) 
            name = n->left->right;

        if(e->options.genTags)
            CtagsAddFunction(e, p, n->left->token, n->right->token);
        FuncDef* fd = FuncDefFind(p, TkGetTokLine(p->e, p->tk, n->right->token)+1);
        if(fd && !fd->name) {
            fd->name = NodeGetCallStr(p, n->left);
            if(e->options.callGraph)
                PatchCalls(p, fd->name, lastCall);

            // fd->name = StringValue(p, name);
#if 0
            ValPrintLn(e, "function ", fd->name, 0);
#endif            
        }
    }
}



// AssignmentExpression:
//      YieldExpression @todo
//      LeftHandSideExpression = AssignmentExpression
//      LeftHandSideExpression AssignmentOperator AssignmentExpression @todo
Node* AssignmentExpression(Parser* p, int start, uint32 flags) {
    Node* n = DestructuringAssignment(p, start, flags);
    if(n)
        return n;

    // ArrowFunction goes here
    if(!n)
        n = ConditionalExpression(p, start, flags);
    if(!n)
        n = LeftHandSideExpression(p, start, flags);
    if(!n) return NULL;  
    int k = NextKeyword(p, FALSE);  // Why not true?

    switch(k) {
        case id_eq: 
        case id_multeq:
        case id_diveq:
        case id_modeq:
        case id_pluseq:
        case id_minuseq:
        case id_lshifteq:
        case id_rshifteq:
        case id_rshiftaeq:
        case id_andeq:
        case id_oreq:
        case id_careteq:
        {
            Node* n2 = NodeNewAdvance(p, n, NULL);

            // We need to remember the count of calls before we evaluate the body
            // since we might need to patch all new added calls with **global** 
            // to the function about to be defined
            int lastCall = 0;
            if(p->calls)
                lastCall = p->calls->list->count;

            n2->right = AssignmentExpression(p, p->next, flags);
            if(!n2->right) 
                return NodeError(p, n2, start, "AssignmentExpression expected");
            if(k == id_eq) {
                CtagsCheckAssignmentFunc(p, n2, lastCall);
            }
            return n2;
        }
    }
    return n;

}

bool_t IsComma(Parser* p) {
    if(NextKeyword(p, FALSE) != id_comma) 
        return FALSE;

    if(TkGetTokKeyword(p->e, p->tk, p->next+1) == id_dotdotdot)
        return FALSE;

    return TRUE;
}
// Expression: 
//      AssignmentExpression
//      Expression, AssignmentExpression    
Node* Expression(Parser* p, int start, uint32 flags) {
    Node* n = AssignmentExpression(p, start, flags);
    if(!n) return NULL;

    if(!IsComma(p))
        return n;

    Node* root = NodeNewAdvance(p, n, NULL);
    Node* n2 = root;
    while(TRUE) {
        n = AssignmentExpression(p, p->next, flags);
        if(!n)
            break;
        if(IsComma(p)) {
            Node* nr = NodeNewAdvance(p, n, NULL);
            n2->right = nr;
            n2 = nr;
            continue;
        }
        n2->right = n;
        n2 = n;
    }
    return root;
}

bool_t CheckSemiNewLine(Parser* p) {
    if(p->next >= TkGetCount(p->e, p->tk))
        return TRUE;

    // Special case for LINETERM, look for previous token
    // as LINETERM to allow the parser to advance past NEWLINE
    // while it parses
    if(p->next > 0 && TkGetTokType(p->e, p->tk, p->next-1) == TOK_LINETERM)
        return TRUE;

    // 433 check for semi before evaluating previous brace
    if(NextKeyword(p, FALSE) == id_semi) {
        p->next++;
        return TRUE;
    }
    
    // Special case for previous '}'
    if(p->next > 0 && TkGetTokKeyword(p->e, p->tk, p->next-1) == id_rbrace)
        return TRUE;

    // Offending token is a LINETERM
    if(NextType(p, FALSE) == TOK_LINETERM) {
        p->next++;
        return TRUE;
    }

    // Offending token is }
    if(NextKeyword(p, FALSE) == id_rbrace) {
        // p->next++; @note - we do not advance since the right brace might be part of block close
        return TRUE;
    }

    return FALSE;
}


Node* BlockStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lbrace)
        return NULL;

    // Handle empty block
    int temp = p->next;
    p->next = start+1;
    if(NextKeyword(p, TRUE) == id_rbrace) {
        return NodeNewAdvance(p, NULL, NULL);
    }
    p->next = temp;
    

    int blkStart = TkGetTokLine(p->e, p->tk, p->next)+1;
    BlockDef* bd = BlockDefNew(p);
    bd->start = blkStart;

    p->next++;      // start + 1 is wrong since it puts the left brace back in play
    Node* n = StatementListParse(p, p->next, flags);
    if(NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, n, start, "} expected");
    int end = TkGetTokLine(p->e, p->tk, p->next)+1;
    bd->end = end;
    p->currentBlock = p->currentBlock->parent;
    return NodeNewAdvance(p, NULL, n);
}

Node* VariableStatement(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* VariableDeclaration(Parser* p, int start, uint32 flags) {
    return NULL;
}


Node* EmptyStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) == id_semi)
        return NodeNewAdvance(p, NULL, NULL);
    return NULL;
}

Node* ExpressionStatement(Parser* p, int start, uint32 flags) {
    int key = NextKeyword(p, TRUE);

    // Special handling for DestructuringAssignment
    if(key == id_lbrace) {
       // #408 this is wrong according to the spec return DestructuringAssignment(p, start, flags);
        return NULL;
    }

    if(key == id_function || key == id_class)
        return NULL;
    if(key == id_let) {
        key = NextKeyword(p, TRUE);
        if(key == id_lbracket)
            return NULL;
    }
    Node* n = Expression(p, start, flags);
    if(!n) return NULL;

    // Special handling for colon so that we treat as labelled statement 
    // not expression
    if(NextKeyword(p, TRUE) == id_colon) {
        NodeDel(p, n);
        return NULL;
    }

    if(n && NodeType(p, n) == TOK_STRLIT) {
        if(StrEqChars(p->e, TkGetTokStr(p->e, p->tk, n->token), "use watcher")) {
            p->e->options.watcher = TRUE;
        }
    }
    return n;
}

Node* IfStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_if)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar)
        return NodeError(p, n, start, "( expected");

    p->next++;
    n->left = Expression(p, p->next, flags);
    if(!n->left)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;

    Node* t = P(Statement,p, p->next, flags,0);
    if(!t) 
        return NodeError(p, n, start, "Statement expected");
    if(NextKeyword(p, TRUE) == id_else) {
        n->right = NodeNewAdvance(p, t, NULL);
        n->right->right = P(Statement,p, p->next, flags,0);
        if(!n->right->right)
            return NodeError(p, n, start, "Statement expected");
    }
    else {
        n->right = t;
    }
    return n;
}

Node* DoStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_do)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = P(Statement,p, p->next, flags,0);
    if(!n->left)
        return NodeError(p, n, start, "Statement expected");
    if(NextKeyword(p, TRUE) != id_while)
        return NodeError(p, n, start, "while expected");
    p->next++;
    if(NextKeyword(p, TRUE) != id_lpar)
        return NodeError(p, n, start, "( expected");
    p->next++;
    n->right = P(Expression,p, p->next, flags,0);
    if(!n->right)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;
    return n;
}

Node* WhileStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_while) return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar)
        return NodeError(p, n, start, "( expected");
    p->next++;
    n->left = P(Expression,p, p->next, flags,0);
    if(!n->left)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right)
        return NodeError(p, n, start, "Statement expected");
    return n;
}

Node* ForEEE(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");

    p->next++;
    if(NextKeyword(p, TRUE) == id_semi) {
        n->left = NodeNew(p);
    }
    else {
        n->left = NodeNew(p);
        n->left->left = P(Expression,p, p->next, flags | PNOLET,0);
        if(NextKeyword(p, TRUE) != id_semi)
            return NodeError(p, n, start, "for( Expression ; expected");
        p->next++;
    }

    if(NextKeyword(p, TRUE) == id_semi) {
        n->left->right = NodeNew(p);
    }
    else {
        n->left->right = NodeNew(p);
        n->left->right->left = P(Expression,p, p->next, flags,0);
        if(NextKeyword(p, TRUE) != id_semi)
            return NodeError(p, n, start, "for( Expression ; expected");
        p->next++;                
    }

    if(NextKeyword(p, TRUE) == id_semi) {
        n->left->right->right = NodeNew(p);
    }
    else {
        n->left->right->right = NodeNew(p);
        n->left->right->right->left = P(Expression,p, p->next, flags,0);
    }

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;
}

Node* BindingList(Parser* p, int start, uint32 flags, bool_t mustInit);
Node* VarDeclarationList(Parser* p, int start, uint32 flags) {
    return BindingList(p, start, flags, FALSE); // @todo: Use dedicted parser
}

Node* ForVEE(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");

    p->next++;
    if(NextKeyword(p, TRUE) != id_var)  {
        NodeDel(p, n);
        return NULL;
    }
    n->left = NodeNew(p);
    
    n->left->left = NodeNewAdvance(p, NULL, NULL);
    n->left->left->right = P(VarDeclarationList,p, p->next, flags,0);  
    if(!n->left->left->right)
        return NodeError(p, n, start, "VarDeclarationList expected");
    if(NextKeyword(p, TRUE) != id_semi)
        return NodeError(p, n, start, "for( var VarDeclarationList ; expected");
    p->next++;                

    if(NextKeyword(p, TRUE) == id_semi) {
        n->left->right = NodeNew(p);
    }
    else {
        n->left->right = NodeNew(p);
        n->left->right->left = P(Expression,p, p->next, flags,0);
        if(NextKeyword(p, TRUE) != id_semi)
            return NodeError(p, n, start, "for( Expression ; expected");
        p->next++;                
    }


    if(NextKeyword(p, TRUE) == id_semi) {
        n->left->right->right = NodeNew(p);
    }
    else {
        n->left->right->right = NodeNew(p);
        n->left->right->right->left = P(Expression,p, p->next, flags,0);
    }

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;    
}

Node* LexicalDeclaration(Parser* p, int start, uint32 flags);
Node* ForLEE(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");

    p->next++;
    Node* ld = P(LexicalDeclaration,p, p->next, flags,0);
    if(!ld) {
        NodeDel(p, n);
        return NULL;
    }
    n->left = NodeNew(p);
    n->left->left = NodeNew(p);
    n->left->left->left = ld;

    if(NextKeyword(p, TRUE) == id_semi) {
        p->next++;
    }
    else {
        Node* ex = P(Expression,p, p->next, flags,0);
        if(ex) 
            n->left->left->right = ex;
        if(NextKeyword(p, TRUE) == id_semi)
            p->next++;
    }

    if(NextKeyword(p, TRUE) == id_rpar) {
        n->left->right = NodeNew(p);
    }
    else {
        n->left->right = NodeNew(p);
        n->left->right->left = P(Expression,p, p->next, flags,0);
    }    

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;    
}

Node* ForLIE(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;

    int k = NextKeyword(p, TRUE);
    if(k == id_let || k == id_lbracket) {
        NodeDel(p, n);
        return NULL;
    }

    Node* lhs = P(LeftHandSideExpression,p, p->next, flags,0);
    if(!lhs) {
        NodeDel(p, n);
        p->next = start;
        return NULL;
    }

    if(NextKeyword(p, TRUE) != id_in) {
        NodeDel(p, n);
        NodeDel(p, lhs);
        p->next = start;
        return NULL;
    }
    n->left = NodeNewAdvance(p, lhs, NULL);
    n->left->right = P(Expression,p, p->next, flags,0);
    if(!n->left->right)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right)
        return NodeError(p, n, start, "Statement expected");
    return n;
}


Node* ForVIE(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    if(NextKeyword(p, TRUE) != id_var) {
        p->next = start;
        NodeDel(p, n);
        return NULL;
    }    

    Node* v = NodeNewAdvance(p, NULL, NULL);
    v->right = P(ForBinding,p, p->next, flags,0);
    if(!v->right) {
        p->next = start;
        NodeDel(p, n);
        NodeDel(p, v);
        return NULL;
    }
    
    if(NextKeyword(p, TRUE) != id_in) {
        p->next = start;
        NodeDel(p, n);
        NodeDel(p, v);
        return NULL;
    }

    n->left = NodeNewAdvance(p, v, NULL);
    n->left->right = P(Expression,p, p->next, flags,0);
    if(!n->left->right) 
        return NodeError(p, n, start, "Expression expected");

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;        
}

Node* ForDeclaration(Parser* p, int start, uint32 flags) {
    int k = NextKeyword(p, TRUE);
    if(k != id_let && k != id_const)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->right = P(ForBinding,p, p->next, flags,0);
    if(!n->right) {
        NodeDel(p, n);
        return NULL;
    }
    return n;
}

Node* ForFIE(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    Node* fd = P(ForDeclaration,p, p->next, flags,0);
    if(!fd) {
        NodeDel(p, n);
        return NULL;
    }
    if(NextKeyword(p, TRUE) != id_in) {
        NodeDel(p, n);
        NodeDel(p, fd);
        return NULL;
    }
    n->left = NodeNewAdvance(p, fd, NULL);
    n->left->right = P(Expression,p, p->next, flags,0);
    if(!n->left->right) 
        return NodeError(p, n, start, "Expression expected");

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;            
}

Node* ForLOA(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;

    int k = NextKeyword(p, TRUE);
    if(k == id_let) {
        NodeDel(p, n);
        return NULL;
    }

    Node* lhs = P(LeftHandSideExpression,p, p->next, flags,0);
    if(!lhs) {
        NodeDel(p, n);
        p->next = start;
        return NULL;
    }

    if(NextKeyword(p, TRUE) != id_of) {
        NodeDel(p, n);
        NodeDel(p, lhs);
        return NULL;
    }
    n->left = NodeNewAdvance(p, lhs, NULL);
    n->left->right = P(AssignmentExpression, p, p->next, flags, 0);
    if(!n->left->right) {
        return NodeError(p, n, start, "AssignmentExpression expected");
    }

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;                
}

Node* ForVOA(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    if(NextKeyword(p, TRUE) != id_var) {
        p->next = start;
        NodeDel(p, n);
        return NULL;
    }    

    Node* v = NodeNewAdvance(p, NULL, NULL);
    v->right = P(ForBinding,p, p->next, flags,0);
    if(!v->right) {
        p->next = start;
        NodeDel(p, n);
        NodeDel(p, v);
        return NULL;
    }
    
    if(NextKeyword(p, TRUE) != id_of) {
        p->next = start;
        NodeDel(p, n);
        NodeDel(p, v);
        return NULL;
    }

    n->left = NodeNewAdvance(p, v, NULL);
    n->left->right = P(AssignmentExpression,p, p->next, flags,0);
    if(!n->left->right) 
        return NodeError(p, n, start, "AssignmentExpression expected");

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;    
}

Node* ForFOA(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_for)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    Node* fd = P(ForDeclaration,p, p->next, flags,0);
    if(!fd) {
        NodeDel(p, n);
        return NULL;
    }
    if(NextKeyword(p, TRUE) != id_of) {
        NodeDel(p, n);
        NodeDel(p, fd);
        return NULL;
    }
    n->left = NodeNewAdvance(p, fd, NULL);
    n->left->right = P(AssignmentExpression,p, p->next, flags,0);
    if(!n->left->right) 
        return NodeError(p, n, start, "AssignmentExpression expected");

    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(Statement,p, p->next, flags,0);
    if(!n->right) 
        return NodeError(p, n, start, "Statement expected");
    return n;  
}


Node* IterationStatement(Parser* p, int start, uint32 flags) {
    Node* n = P(DoStatement, p, start, flags, 0);
    if(n) return n;
    n = P(WhileStatement, p, start, flags, 0);
    if(n) return n;
    n = P(ForEEE, p, start, flags, 0);
    if(n) return n;
    n = P(ForVEE, p, start, flags, 0);
    if(n) return n;
    n = P(ForLEE, p, start, flags | PSTRICT, 0);
    if(n) return n;
    n = P(ForLIE, p, start, flags, 0);
    if(n) return n;
    n = P(ForVIE, p, start, flags, 0);
    if(n) return n;
    n = P(ForFIE, p, start, flags, 0);
    if(n) return n;
    n = P(ForLOA, p, start, flags, 0);
    if(n) return n;
    n = P(ForVOA, p, start, flags, 0);
    if(n) return n;    
    return P(ForFOA, p, start, flags, 0);
}

Node* CaseClause(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_case)
        return NULL;

    Node* n = NodeNew(p);

    n->left = NodeNewAdvance(p, NULL, NULL);
    n->left->left = P(Expression, p, p->next, flags,0);
    if(!n->left->left)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_colon)
        return NodeError(p, n, start, ": expected");
    p->next++;
    n->left->right = StatementListParse(p, p->next, flags);
    return n;
}

Node* DefaultClause(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_default)
        return NULL;

    Node* n = NodeNew(p);
    n->left = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_colon)
        return NodeError(p, n, start, ": expected");
    p->next++;
    n->left->right = StatementListParse(p, p->next, flags);
    return n;
}

Node* CaseOrDefaultClause(Parser* p, int start, uint32 flags, bool_t *hasDefault) {
    Node* n = P(CaseClause,p, start, flags,0);
    if(n)
        return n;
    n = P(DefaultClause,p, start, flags,0);

    if(!n) 
        return SyntaxError(p, "case or default expected");

    if(*hasDefault)
        return NodeError(p, n, start, "only one default allowed in a switch statement");
    
    *hasDefault = TRUE;
    return n;
}

Node* CaseBlock(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_lbrace) 
        return SyntaxError(p, "{ expected");
    p->next++;

    if(NextKeyword(p, TRUE) == id_rbrace) {
        p->next++;
        return NULL;
    }

    bool_t hasDefault = FALSE;
    Node* n = CaseOrDefaultClause(p, p->next, flags, &hasDefault);
    if(!n) 
        return SyntaxError(p, "case or default expected");

    Node* root = n;
    while(NextKeyword(p, TRUE) != id_rbrace) {
        n->right = CaseOrDefaultClause(p, p->next, flags, &hasDefault);
        if(!n->right)
            return NodeError(p, root, start, "case or default expected");
        n = n->right;
    }
    
    // #433 advance past the right brace
    p->next++;
    return root;
}

Node* SwitchStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_switch)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    n->left = Expression(p, p->next, flags);
    if(!n->left)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->right = P(CaseBlock, p, p->next, flags,0);
    if(!n->right)
        return NodeError(p, n, start, "CaseBlock expected");
    return n;
}

Node* BreakableStatement(Parser* p, int start, uint32 flags) {
    Node* n = P(IterationStatement,p, start, flags,0);
    if(n) return n;
    return P(SwitchStatement,p, start, flags,0);
}


bool_t NextLineTerm(Parser* p) {
    return (p->next > 0 && TkGetTokType(p->e, p->tk, p->next) == TOK_LINETERM);
}

Node* ContinueStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_continue)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextLineTerm(p))
        return n;

    if(NextKeyword(p, FALSE) == id_semi)
        return n;

    n->right = LabelIdentifier(p, p->next, flags);
    return n;
}

Node* BreakStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_break)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextLineTerm(p))
        return n;

    if(NextKeyword(p, FALSE) == id_semi)
        return n;

    n->right = LabelIdentifier(p, p->next, flags);
    return n;
}

Node* ReturnStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_return)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    if(NextLineTerm(p))
        return n;

    if(NextKeyword(p, FALSE) == id_semi)
        return n;

    n->right = P(Expression,p, p->next, flags,0);
    return n;
}

Node* WithStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_with)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);

    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    n->left = P(Expression, p, p->next, flags, 0);
    if(!n->left)
        return NodeError(p, n, start, "Expression expected");
    if(NextKeyword(p, TRUE) != id_rpar) 
        return NodeError(p, n, start, ") expected");    
    p->next++;
    n->right = P(Statement, p, p->next, flags, 0);
    if(!n->right)
        return NodeError(p, n, start, "Statement expected");
    return n;
}


Node* FunctionDeclaration(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_function)
        return NULL;

    int funcLine = TkGetTokLine(p->e, p->tk, p->next)+1;
    FuncDef* fd = FuncDefNew(p);
    fd->startToken = start;
    fd->line = funcLine;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = NodeNew(p);
    n->left->left = P(BindingIdentifier, p, p->next, flags, 0);
    if(!n->left->left)
        return NodeError(p, n, start, "function BindingIdentifier expected");    
    Node* funcNameNode = n->left->left;
    fd->name = StringValue(p, funcNameNode);
    CtagsAddFunction(p->e, p, funcNameNode->token, funcNameNode->token);

    if(NextKeyword(p, TRUE) != id_lpar) 
        return NodeError(p, n, start, "( expected");
    p->next++;
    p->error[0] = 0;
    n->right = P(FormalParameters, p, p->next, flags, 0);
    if(!n->right && p->error[0])
        return NodeError(p, n, start, "function FormalParameters expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;

    if(NextKeyword(p, TRUE) != id_lbrace)
        return NodeError(p, n, start, "{ expected");
    BlockDef* bd = BlockDefNew(p);
    fd->block = bd;
    bd->start = TkGetTokLine(p->e, p->tk, p->next)+1;

    p->next++;
    n->left->right = P(FunctionBody, p, p->next, flags, 0);
    if(!n->left->right && NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, n, start, "FunctionBody expected");
    if(NextKeyword(p, TRUE) != id_rbrace)
        return NodeError(p, n, start, "} expected");
    bd->end = TkGetTokLine(p->e, p->tk, p->next) + 1;
    fd->endToken = p->next;
    p->currentBlock = p->currentBlock->parent;
    p->next++;
    p->currentFunc = p->currentFunc->parent;
    return n;
}




Node* LabelledItem(Parser* p, int start, uint32 flags) {
    Node* n = P(Statement, p, start, flags, 0);
    if(n)
        return n;
    return P(FunctionDeclaration, p, start, flags, 0);
}

Node* LabelledStatement(Parser* p, int start, uint32 flags) {
    Node* l = P(LabelIdentifier,p, start, flags,0);
    if(!l)
        return NULL;

    if(NextKeyword(p, TRUE) != id_colon) {
        NodeDel(p, l);
        return NULL;
    }

    Node* n = NodeNewAdvance(p, l, NULL);
    n->right = P(LabelledItem, p, p->next, flags, 0);
    if(!n->right)
        return NodeError(p, n, start, "Statement expected");
    return n;
}

Node* ThrowStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_throw)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = Expression(p, p->next, flags);
    if(!n->left)
        return NodeError(p, n, start, "Expression expected");

    return n;
}

Node* Finally(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_finally)
        return NULL;
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = P(BlockStatement, p, p->next, flags, 0);
    if(!n->left)
        return NodeError(p, n, start, "BlockStatement expected");
    return n;
}


Node* CatchParameter(Parser* p, int start, uint32 flags) {
    Node* n = P(BindingIdentifier, p, start, flags, 0);
    if(n) return n;
    return P(BindingPattern, p, start, flags, 0);
}

Node* Catch(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, TRUE) != id_catch)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);

    if(NextKeyword(p, TRUE) != id_lpar)
        return NodeError(p, n, start, "( expected");
    p->next++;

    n->left = NodeNew(p);
    n->left->left = P(CatchParameter,p, p->next, flags,0);
    if(!n->left->left)
        return NodeError(p, n, start, "CatchParameter expected");
    if(NextKeyword(p, TRUE) != id_rpar)
        return NodeError(p, n, start, ") expected");
    p->next++;
    n->left->right = P(BlockStatement, p, p->next, flags, 0);
    if(!n->left->right)
        return NodeError(p, n, start, "BlockStatement expected");

    return n;
}

Node* TryStatement(Parser* p, int start, uint32 flags) {
    if(NextKeyword(p, FALSE) != id_try)
        return NULL;

    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->left = P(BlockStatement,p, p->next, flags,0);
    if(!n->left) 
        return NodeError(p, n, start, "BlockStatement expected");
    n->right = P(Catch,p, p->next, flags,0);
    if(p->error[0]) {
        NodeDel(p, n);
        return NULL;
    }

    if(!n->right)
        n->right = NodeNew(p);

    n->right->right = P(Finally,p, p->next, flags,0);
    if(p->error[0]) {
        NodeDel(p, n);
        return NULL;
    }
    return n;
}

Node* DebuggerStatement(Parser* p, int start, uint32 flags) {
    int key = NextKeyword(p, TRUE);
    if(key == id_debugger) {        
        p->next++;
        Node* n = NodeNew(p);
        n->token = start;
        if(NextType(p, TRUE) == TOK_STRLIT) {
            n->left = NodeNew(p);
            n->left->token = p->next;
            p->next++;
        }
        return n;
    }
    return NULL;
}


Node* Statement(Parser* p, int start, uint32 flags) {
    // Skip leading LINETERM to allow for if() LINETERM statement
    while(TkGetTokType(p->e, p->tk, p->next) == TOK_LINETERM)
        p->next++;

    start = p->next;

    Node* n = P(BlockStatement,p, start, flags,0);
    if(n) return n;
    n = P(VariableStatement,p, start, flags,0);
    if(n) goto checkSemi;
    n = P(EmptyStatement,p, start, flags,0);
    if(n) return n;
    n = P(ExpressionStatement,p, start, flags,0);
    if(n)  goto checkSemi;
    n = P(IfStatement,p, start, flags,0);
    if(n) return n;
    n = P(BreakableStatement,p, start, flags,0);
    if(n) return n;
    n = P(ContinueStatement,p, start, flags,0);
    if(n) goto checkSemi;
    n = P(BreakStatement,p, start, flags,0);
    if(n)  goto checkSemi;
    n = P(ReturnStatement,p, start, flags,0);
    if(n)  goto checkSemi;
    n = P(WithStatement,p, start, flags,0);
    if(n) return n;
    n = P(LabelledStatement,p, start, flags,0);
    if(n) return n;
    n = P(ThrowStatement,p, start, flags,0);
    if(n)  goto checkSemi;
    n = P(TryStatement,p, start, flags,0);
    if(n) return n;
    n = P(DebuggerStatement,p, start, flags,0);
    if(n)  goto checkSemi;
    return NULL;

checkSemi:
    if(!CheckSemiNewLine(p)) 
        return NodeError(p,n, start, "';' expected");    
    return n;
}



Node* GeneratorDeclaration(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* ClassDeclaration(Parser* p, int start, uint32 flags) {
    return NULL;
}

Node* LexicalBinding(Parser* p, int start, uint32 flags, bool_t mustInit) {
    Node* n = P(BindingIdentifier,p, start, flags,0);
    if(!n)
        n = P(BindingPattern,p, start, flags, 0);
    if(!n)
        return n;
    if(NextKeyword(p, TRUE) == id_eq) {
        Node* n2 = NodeNewAdvance(p, n, NULL);
        n2->right = AssignmentExpression(p, p->next, flags);
        if(!n2->right)
            return NodeError(p, n2, start, "AssignmentExpression expected");
        return n2;
    }
    if(mustInit)
        return NodeStop(p, n, start, "Initialization required for constant");
    return n;
}

Node* BindingList(Parser* p, int start, uint32 flags, bool_t mustInit) {
    Node* n = LexicalBinding(p, start, flags, mustInit);

    if(!n)
        return n;
    Node* root = NodeNew(p);
    root->left = n;
    n = root;
    while(TRUE) {
        if(NextKeyword(p, TRUE) != id_comma)
            break;
        p->next++;
        n->right = NodeNew(p);
        n->right->left = LexicalBinding(p, p->next, flags, mustInit);        
        if(!n->right->left)
            return NodeError(p, root, start, "LexicalBinding expected");
        n = n->right;
    }
    return root;
}
Node* Constant(Parser* p, int start, uint32 flags) {
    return NULL;        // @tnote this is used for flags only
}


void AppendNameToChars(char* buffer, char* text, int size, Val* name) {
    sprintf(buffer, "%s", text);
    int i = (int) strlen(buffer);
    for(int j = 0; j < name->str->length && (j + i) < size; i++, j++) {
        buffer[i] = name->str->chars[j];
    }
    buffer[i] = 0;
}

Node* LexicalDeclaration(Parser* p, int start, uint32 flags) {
    int k = NextKeyword(p, FALSE);
    bool_t mustInit = FALSE;
    if(k != id_const && k != id_let && k != id_var)
        return NULL;

    if(k == id_const) 
        mustInit = (flags & PMUSTINIT);
    Node* n = NodeNewAdvance(p, NULL, NULL);
    n->right = BindingList(p, p->next, flags, mustInit);
    if(!n->right) 
        return NodeError(p, n, start, "BindingList expected");

    if(mustInit)
        NodeSetFlag(p, n, Constant);

    if(!CheckSemiNewLine(p))
        return NodeError(p,n, start, "';' expected");    

    if(k == id_var)
        NodeSetFlag(p, n->right, VariableStatement);
    else {
        // #403
        // not var, means let or const => check for duplicate entries
        PtrList* bn = BoundNames(p, n->right);
        for(PtrItem* bni=bn->head; bni; bni = bni->next) {
            Val* dn = StringValue(p, bni->value);
            if(PtrListHasStr(p, bn, dn, bni)) {
                PtrListDel(p->e, bn);
                char buffer[255];
                AppendNameToChars(buffer, "- duplicate entry: ", sizeof(buffer), dn);
                ValDel(p->e, dn);
                return NodeError(p, n, start, buffer);
            }
            ValDel(p->e, dn);
        }
        PtrListDel(p->e, bn);
    }
    return n;
}

Node* Declaration(Parser* p, int start, uint32 flags) {
    Node* n = P(FunctionDeclaration, p, start, flags, 0);
    if(n)
        return n;
    n = P(GeneratorDeclaration,p, start, flags,0);
    if(n) return n;
    n = P(ClassDeclaration, p, start, flags, 0);
    if(n) return n;
    n = P(LexicalDeclaration,p, start, flags | PMUSTINIT , 0);
    if(n) return n;
    return NULL;
}


int NumberOfParameters(Js* e, Node* list) {
    return 0;   // @todo: Implement
}

bool_t HasInitializer(Parser* p, Node* n);

int ExpectedArgCount(Parser* p, Node* args) {
    if(NodeHasFlag(p, args, PropertySetParameterList)) {
        if(HasInitializer(p, args)) {
            return 0;
        }
        return 1;
    }

    int count = 0;
    while(args) {
        Node* arg = args->left;
        if(NodeKeyword(p, arg) == id_dotdotdot)
            return count;
        if(HasInitializer(p, arg))
            return count;
        count++;
        args = args->right;
    }
    return count;
}


PtrList* BoundNames(Parser* p, Node* d) {
    Js* e = p->e;
    Node* x = d;
    PtrList* ret = PtrListNew(e);

    if(!d) 
        return ret;
    
    if(NodeHasFlag(p, d, FunctionDeclaration))
        return PtrListCat(e, ret, BoundNames(p, d->left->left), TRUE);

    if(NodeHasFlag(p, d, ForDeclaration)) 
        return PtrListCat(e, ret, BoundNames(p, d->right), TRUE);

    if(NodeHasFlag(p, d, BindingIdentifier)) 
        return PtrListAdd(e, ret, d);

    if(NodeHasFlag(p, d, StatementListItem)) {
        if(NodeHasFlag(p, d, FunctionDeclaration))
            return NULL;
        if(NodeHasFlag(p, d, GeneratorDeclaration))
            return NULL;
    }

    if(NodeHasFlag(p, d, BindingProperty))
        return PtrListCat(e, ret, BoundNames(p, d->left), TRUE);

    if(NodeHasFlag(p, d, BindingRestElement))
        return PtrListCat(e, ret, BoundNames(p, d->left), TRUE);

    if(NodeHasFlag(p, d, SingleNameBinding) && NodeKeyword(p, d) == id_eq) 
        return PtrListCat(e, ret, BoundNames(p, d->left), TRUE);

    if(NodeHasFlag(p, d->left, PropertyName) && NodeKeyword(p, d) == id_colon)
        return PtrListCat(e, ret, BoundNames(p, d->right), TRUE);

    if(NodeHasFlag(p, d, ObjectBindingPattern)) {
        for(Node* bp=d->right; bp; bp=bp->right)
            PtrListCat(e, ret, BoundNames(p, bp), TRUE);        
        return ret;
    }

    if(NodeHasFlag(p, d, ArrayBindingPattern)) {
        // BindingElement when used in a BindingElementList looks a bit different
        // then when used within a BindingProperty... It has a null node with the actual
        // element on the left (see BindingPattern diagram)
        for(Node* be=d->right; be; be=be->right) 
            PtrListCat(e, ret, BoundNames(p, be->left), TRUE);
        return ret;
    }

    if(NodeHasFlag(p, d, VariableStatement)) {
        for(Node* be=d; be; be=be->right) {
            x = be->left;
            if(NodeKeyword(p, x) == id_eq) {
                x = x->left;
            }
            if(NodeHasFlag(p, x, BindingIdentifier))
                PtrListAdd(e, ret, x);
            else if(NodeHasFlag(p, x, BindingPattern))
                PtrListCat(e, ret, BoundNames(p, x), TRUE);
        }
        return ret;
    }

    if(NodeHasFlag(p, d, Declaration))
        d = d->right;

    while(d) {
        Node* x = d->left;
        if(d->left && NodeKeyword(p, d->left) == id_eq) 
            x = d->left->left;
        
        // #416 handle FormalParameters with spread
        if(x && NodeKeyword(p, x) == id_dotdotdot)
            x = x->left;
        if(NodeHasFlag(p, x, BindingIdentifier))
            PtrListAdd(e, ret, x);
        else if(NodeHasFlag(p, x, BindingPattern))
            PtrListCat(e, ret, BoundNames(p, x), TRUE);
        d = d->right;
        if(!d)
            break;
    }

    return ret;    
}

bool_t IsComputedPropertyKey(Parser* p, Node* n) {
    return FALSE;   // @todo: implement
}

bool_t ContainsExpression(Parser* p, Node* n) {
    if(NodeHasFlag(p, n, SingleNameBinding)) {
        if(NodeKeyword(p, n) == id_eq)
            return TRUE;
        return FALSE;
    }

    if(NodeHasFlag(p, n, FormalsList)) {
        bool_t ret = FALSE;
        while(n) {
            if(NodeKeyword(p, n) == id_dotdotdot)
                return ret;
            ret = ContainsExpression(p, n->left);
            if(ret)
                return ret;
            n = n->right;
        }
        return FALSE;
    }

    if(NodeHasFlag(p, n, BindingProperty)) {
        if(NodeKeyword(p, n->left) == id_colon) {
            bool_t has = IsComputedPropertyKey(p, n->left->left);
            if(has)
                return has;
            return ContainsExpression(p, n->left->right);
        }
        return ContainsExpression(p, n->left);
    }

    if(NodeHasFlag(p, n, BindingElement)) 
        return ContainsExpression(p, n->left);

    if(NodeHasFlag(p, n, BindingPattern)) {
        for(Node* r=n->right; r; r = r->right) {
            bool_t has = ContainsExpression(p, r);
            if(has)
                return TRUE;
        }
        return FALSE;
    }

    return FALSE;
}

bool_t HasInitializer(Parser* p, Node* n) {
    // PropertyBinding
    if(NodeHasFlag(p, n, BindingElement) && NodeKeyword(p, n) == id_eq) 
        return TRUE;

    // ElementBinding
    if(NodeHasFlag(p, n, BindingElement) && n->left && NodeKeyword(p, n->left) == id_eq)
        return TRUE;

    return FALSE;
}

bool_t IsSimpleParameterList(Parser* p, Node* n) {

    if(!n)
        return TRUE;
    
    if(NodeHasFlag(p, n, FormalParameterList)) {
        while(n) {
            if(!IsSimpleParameterList(p, n->left))
                return FALSE;
            n = n->right;
        }
        return TRUE;
    }

    if(NodeHasFlag(p, n, SingleNameBinding)) {
        if(NodeHasFlag(p, n, BindingIdentifier))
            return TRUE;
        if(n->left && NodeHasFlag(p, n->left, BindingIdentifier))
            return TRUE;
    }
    return FALSE;
}
    

bool_t IsConstantDeclaration(Parser* p, Node* n) {
    if(NodeKeyword(p, n) == id_const)
        return TRUE;
    return FALSE;
}

bool_t IsGeneratorDeclaration(Parser* p, Node* n) {
    return NodeHasFlag(p, n, GeneratorDeclaration) != NULL;
}


bool_t IsBindingIdentifier(Parser* p, Node* param) {
    return NodeHasFlag(p, param, BindingIdentifier) != NULL;
}

/////// Data 6.2.6
Data* DataCreate(Js* e, uint32 size) {
    Data* db = halloc(e->memory[DX].data);
    db->data = (uint8*) _hallocsize(e->memory[XX].data, size, __LINE__);
    memset(db->data, 0, size);
    db->size = size;
    db->refs = 1;
    return db;
}

Val* CreateByteDataBlock(Js* e, Val* size) {
    Data* d = DataCreate(e, (uint32) size->num);
    if(!d)
        return ThrowTypeError(e, "memory error",0,0);

    Val* v = ValNew(e);
    v->type = TYPE_BLOCK;
    v->block = d;
    return v;
}

Val* CreateByteDataSize(Js* e, int size) {
    Val s;
    ValInitNum(&s, size);
    return CreateByteDataBlock(e, &s);
}

Val* DataCopyBytes(Js* e, Data* to_block, int to_index, Data* from_block, int from_index, int count) {
    assert(to_block != from_block);
    assert(to_index >= 0);
    assert(from_index >= 0);
    assert(count >= 0);
    uint32 from_size = from_block->size;
    assert(from_index + count <= from_size);
    uint32 to_size = to_block->size;
    assert(to_index + count <= to_size);
    while(count > 0) {
        to_block->data[to_index] = from_block->data[from_index];
        from_index++;
        to_index++;
        count--;
    }
    return ValNew(e);
}

void DataDel(Js* e, Data* db) {
    hfree(e->memory[XX].data, db->data);
    hfree(e->memory[DX].data, db);
}

///////// Simple JSON parsing
void EnsureContext(Js* e) {
    if(!e->currentContext)
        e->currentContext = ContextNew(e, NULL, NULL, FALSE);
}

void EndContext(Js* e) {
    // To avoid memory test failure, we must _free up the context
    ContextDelete(e, e->currentContext);
    e->currentContext = NULL;
}

#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>

bool_t DebugIsIdentifier(Js* e, Tokenizer* tk, int t, char* value) {
    if(TkGetTokType(e, tk, t) != TOK_IDENTIFIER)
        return FALSE;
    Val* uid = ValNewStrId(e, tk, t);
    bool_t ret = ValEqStrA(e, uid, value);
    ValDel(e, uid);
    return ret;
}

int DebugGetContentLength(Js* e, Tokenizer* tk) {
    if(!DebugIsIdentifier(e, tk, 0, "Content"))
        return 0;
    if(TkGetTokKeyword(e, tk, 1) != id_minus)
        return 0;
    if(!DebugIsIdentifier(e, tk, 2, "Length"))
        return 0;
    if(TkGetTokKeyword(e, tk, 3) != id_colon)
        return 0;
    if(TkGetTokType(e, tk, 4) != TOK_NUMLIT)
        return 0;
    return (int) TkGetTokNumVal(e, tk, 4);
}

int JsonSkipLineTerm(Js* e, Tokenizer* tk, int start) {
    while(TkGetTokType(e, tk, start) == TOK_LINETERM)
        start++;

    return start;
}

Property* ArrayGetLenProp(Js* e, Val* A) {
    for(Property* p = A->obj->properties; p; p = p->next) {
        if(p->name && StringCompare(e, p->name->str, e->strLength->str)==0)
            return p;
    }
    return NULL;
}

void ArrayFastAdd(Js* e, Val* A, int idx, Val* v, Property* len) {
    char buff[200];
    sprintf(buff, "%d", idx);
    Val* name = ValNewStrA(e, buff);
    Property* np = PropNew(e);
    np->name = name;
    np->ownName = TRUE;
    np->flags = PROP_WRITEABLE | PROP_CONFIGURABLE | PROP_NOT_ENUMERABLE;
    PropSetValue(e, np, v);
    ObjInsertProp(e, A->obj, np);
    if(v->type != TYPE_NUM)
        ObjectClearFlag(e, A->obj, OBJ_ALLNUM);
    if(idx != len->value->num)
        ObjectClearFlag(e, A->obj, OBJ_CONT);
    len->value->num++;

}

Val* JsonParseValue(Js* e, Tokenizer* tk, int* next) {
    int start = 0;
    Val* v = NULL;
    if(next) start = *next;
    Val* ret = NULL;

    start = JsonSkipLineTerm(e, tk, start);
    int type = TkGetTokType(e, tk, start);
    // #517 handle negative number values
    if(type == TOK_KEYWORD && TkGetTokKeyword(e, tk, start) == id_minus) {
        start++;
        start = JsonSkipLineTerm(e, tk, start);
        type = TkGetTokType(e, tk, start);
        if(type == TOK_NUMLIT) {
            ret = ValNewNum(e, -1 * TkGetTokNumVal(e, tk, start++));
        }
    }
    else if(type == TOK_NUMLIT) {
        ret = ValNewNum(e, TkGetTokNumVal(e, tk, start++));
    }
    else if(type == TOK_STRLIT) {
        ret = ValNewStr(e, TkGetTokStr(e, tk, start++));
    }
    else if(type == TOK_KEYWORD) {
        int key = TkGetTokKeyword(e, tk, start);
        if(key == id_true) {
            ret = ValNewBool(e, TRUE);
            start++;
        }
        else if(key == id_false) {
            ret = ValNewBool(e, FALSE);
            start++;
        }
        else if(key == id_lbrace) {
            ret = JsonParse(e, tk, &start);
            // if(ValIsUndef(ret))
            //     RET_VAL(ret);
        }
        else if(key == id_lbracket) {
            start++;
            ret = ArrayCreate(e, NULL, NULL);
            // @opt declare the object as a numeric array unless fast add proves wrong
            ObjectSetFlag(e, ret->obj, OBJ_ARRAY | OBJ_CONT | OBJ_ALLNUM);
            Property* plen = ArrayGetLenProp(e, ret);
            assert(plen);
            int index = 0;
            while(TkGetTokKeyword(e,tk, start) != id_rbracket) {
                IFD(v);
                v = JsonParseValue(e, tk, &start);
                if(ValIsUndef(v))
                    RET(ValNew(e));
                ArrayFastAdd(e, ret, index++, v, plen);

                start = JsonSkipLineTerm(e, tk, start);
                int key = TkGetTokKeyword(e, tk, start);
                if(key == id_rbracket) 
                    break;
                if(key != id_comma)
                    RET(ThrowSyntaxError(e, "] expected",0,0));
                start++;
            }
            start = JsonSkipLineTerm(e, tk, start);
            if(TkGetTokKeyword(e, tk, start) != id_rbracket)
                RET(ThrowSyntaxError(e, "] expected", 0,0));
            start++;
        }
        else
            RET(ThrowSyntaxError(e, "unexpected token",0,0));
    }   

    start = JsonSkipLineTerm(e, tk, start);

    if(!ret)
        RET(ThrowSyntaxError(e, "JSON parse error",0,0));
    
    // After we parse a value we must see either a comma or end of input
    // or it is a syntax error
    int key = TkGetTokKeyword(e, tk, start);

    if(!ValIsException(e, ret) && start < tk->tokens->count) {
        if(key != id_comma && key != id_rbracket && key != id_rbrace)
            RET(ThrowSyntaxError(e, "unexpected value",0,0));
    }

    if(next) *next = start;

exit:

    IFD(v);
    return ret;
}

Val* JsonParse(Js* e, Tokenizer* tk, int *next) {
    int start = 0;
    if(next)
        start = *next;
    Val* propName = NULL;
    Val* propVal = NULL;
    Val* ret = NULL;
    Val* obj = NULL;
    
    if(tk->error[0])
        RET(ThrowSyntaxError(e, tk->error, 0,0));

    start = JsonSkipLineTerm(e, tk, start);

    if(TkGetTokKeyword(e, tk, start) != id_lbrace) {
        RET(JsonParseValue(e, tk, &start));
    }

    start++;
    obj = ObjectCreate(e, 0,0);
    if(TkGetTokKeyword(e, tk, start) == id_rbrace) {
        if(next) *next = start+1;
        RET_VAL(obj);
    }
    while(1) {
        start = JsonSkipLineTerm(e, tk, start);
        IFD(propName);
        propName = NULL;
        IFD(propVal);
        propVal = NULL;

        if(TkGetTokType(e, tk, start) != TOK_STRLIT)
            RET(ValNew(e));
        start = JsonSkipLineTerm(e, tk, start);
        propName = ValNewStr(e, TkGetTokStr(e, tk, start++));
        if(TkGetTokKeyword(e, tk, start++) != id_colon)
            RET(ValNew(e));

        start = JsonSkipLineTerm(e, tk, start);
        propVal = JsonParseValue(e, tk, &start);
        if(ValIsUndef(propVal))
            RET(ValNew(e));
        
        start = JsonSkipLineTerm(e, tk, start);
        int type = TkGetTokType(e, tk, start);
        if(type != TOK_KEYWORD) 
            RET(ValNew(e));

        Val* res = Put(e, obj, propName, propVal, FALSE);
        ValDel(e, res);
        
        IFZ(propName);
        IFZ(propVal);
        start = JsonSkipLineTerm(e, tk, start);
        int key = TkGetTokKeyword(e, tk, start++);
        if(key == id_rbrace) 
            break;
        if(key != id_comma)
            RET(ThrowSyntaxError(e, "} expected",0,0));
    }
    if(next)
        *next = start;
    RET_VAL(obj);
exit:
    IFD(propName);
    IFD(propVal);
    IFD(obj);
    return ret;
}

void JsonStringifyCore(Js* e, Val* v, DynStr* ds) {
    switch(v->type) {
        case TYPE_NUM:
            if(ValIsNan(v)) {
                DynStrAddStrA(e, ds, "\"NaN\"");    
                break;
            }            
            if(isinf(v->num)) {
                if(v->num < 0) 
                    DynStrAddStrA(e, ds, "\"-Infinity\"");    
                else    
                    DynStrAddStrA(e, ds, "\"Infinity\"");    
                break;

            }
        case TYPE_BOOL:
        {
            Val* s = ToString(e, v);
            DynStrAddStr(e, ds, s->str);
            ValDel(e, s);
            break;
        }

        case TYPE_STR:
            DynStrAdd(e, ds, '"');
            DynStrAddStr(e, ds, v->str);
            DynStrAdd(e, ds, '"');
            break;

        case TYPE_OBJ:
            if(IsArray(e, v)) {
                DynStrAdd(e, ds, (uchar) '[');
                Val* len = GetA(e, v, "length");
                int ilen = (int) len->num;
                char buff[255];
                for(int i=0; i < ilen; i++) {
                    if(i > 0)
                        DynStrAdd(e, ds, ',');
                    sprintf(buff, "%d", i);
                    Val* element = GetA(e, v, buff);
                    JsonStringifyCore(e, element, ds);
                    ValDel(e, element);
                }
                DynStrAdd(e, ds, (uchar) ']');
                ValDel(e, len);
            }
            else {
                DynStrAdd(e, ds, (uchar) '{');
                int index = 0;
                for(Property* p = v->obj->properties; p ; p = p->next) {
                    if(index > 0) 
                        DynStrAdd(e, ds, (uchar) ',');
                    index++;
                    DynStrAdd(e, ds, (uchar) '"');
                    DynStrAddStr(e, ds, p->name->str);
                    DynStrAdd(e, ds, (uchar) '"');
                    DynStrAdd(e, ds, (uchar) ':');
                    JsonStringifyCore(e, p->value, ds);
                }
                DynStrAdd(e, ds, (uchar) '}');
            }
            break;

    }
}

Val* JsonStringify(Js* e, Val* v) {
    assert(ValIsObject(v));
    DynStr* ds = DynStrNew(e, 2048);
    JsonStringifyCore(e, v, ds);
    Val* ret = ValNewStr(e, DynStrGet(e, ds));
    DynStrDel(e, ds);
    return ret;
}

char* FileReadA(Js* e, const char* name) {
    FILE* fp = fopen(name, "r");
    if(!fp)
        return NULL;
    
    fseek(fp,0L, SEEK_END);
    long length = ftell(fp);
    fseek(fp,0L,SEEK_SET);
    char* buff = _hallocsize(e->memory[ST].data, (int) length+1, __LINE__);
    long read = fread(buff, 1, length, fp);
    if(read != length) {
        hfree(e->memory[ST].data, buff);
        return NULL;
    }
    fclose(fp);
    buff[length] = 0;
    return buff;
}

Context* RetainedContext(Js* e, Realm* r) {
    // This will become the current context
    Context* ctx = ContextNew(e, r, NULL, TRUE);
    ctx->vars = ValClone(e, r->globalEnv);
    ctx->lex = ValClone(e, r->globalEnv);
    return ctx;
}

void PrintError(Parser* p, bool_t done) {
    char* f = p->fileName;
    char* last = "";
    
    if(f[0]) {
        last = strstr(f, "/");
        while(last) {
            f = last + 1;
            last = strstr(f, "/");
        }
    }
    
    if(p->error[0]) {
        int line = TkGetTokLine(p->e, p->tk, p->next);
        
        if(line == TOK_NO_LINE) {
            for(int t = p->next-1; t >=0; t--) {
                line = TkGetTokLine(p->e, p->tk, t);
                if(line != TOK_NO_LINE)
                    break;
            }
        }
        
        line++;
        jprintf(p->e,0,"%s:%d %s%s%s\n", f, line, p->e->colors.red, p->error, p->e->colors.normal);
    }
    else if(TkHasError(p->e, p->tk))
        jprintf(p->e,0,"%d %s%s%s\n", TkGetErrorLine(p->e, p->tk), p->e->colors.red, p->tk->error, p->e->colors.normal);
    if(done)
        exit(-1);
}

#endif // JSE_IMPL
/////////////////////////////////////////////////////////////////////////////////

///////////////////// DEBUGGER /////////////////

#ifdef JSE_DEBUG

///////// Get a request object from a socket
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <signal.h>

void signal_handler(int signum){
    printf("\n<<< socket error, disconnecting\n");
    exit(-1);
}

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa) {
    if (sa->sa_family == AF_INET) {
        return &(((struct sockaddr_in*)sa)->sin_addr);
    }
    return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

// void d0(Js* e, DebugContext* dc, const char * format, ... ) {
// }

void d1(Js* e, DebugContext* dc, const char * format, ... ) {
    if(!e->options.debugLog)
        return;
    char buffer[2048];
    va_list args;
    va_start (args, format);
    vsprintf (buffer,format, args);

    if(dc) {
        dc->print(e, 0, "jse debug: %s", buffer);
        return;
    }
    jprintf(e, 0, "jse debug: %s", buffer);
}

#define d0      d1

int DebugSocketError(DebugContext* dc) {
    dc->shouldExit = TRUE;
    d1(dc->p->e, dc, "<<< socket error, disconnecting\n");
    exit(-1);
    return TRUE;
}

int DebugWrite(DebugContext* dc, char* data, int len);

void DebugQuickCommand(DebugContext* dc, Str* sb, int n, char* output) {
    Js* e = dc->p->e;
    dc->quickMode = TRUE;
    char* ch = StrDecode(e, sb);
    if(strncmp(ch, "c", 1) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"continue\"}", dc->autoSeq++);
    }
    else if(strncmp(ch, "s", 1) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"continue\", \"arguments\": { \"stepaction\": \"in\"}}",
                 dc->autoSeq++);
    }
    else if(strncmp(ch, "n", 1) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"continue\", \"arguments\": { \"stepaction\": \"next\"}}",
                 dc->autoSeq++);
    }    
    else if(strncmp(ch, "o", 1) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"continue\", \"arguments\": { \"stepaction\": \"out\"}}",
                 dc->autoSeq++);
    }        
    else if(strncmp(ch, "q", 1) == 0) {
        if(atoi(ch+1) > 0) 
            sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"disconnect\", \"arguments\": { \"exit\": true }}", dc->autoSeq++);
        else    
            sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"disconnect\"}", dc->autoSeq++);
    }    
    else if(strncmp(ch, "p ", 2) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"evaluate\", \"arguments\": { \"expression\": \"%s\"}}"
                , dc->autoSeq++, 
                ch + 2);
    }   
    else if(*ch == 'b' || *ch == 'B') {
        char* enabled = "true";
        if(*ch == 'B')
            enabled = "false";
        int len = (int) strlen(ch);
        int line = 0;
        char file[1024];
        file[0] = 0;
        if(len > 2) {
            char cc = ch[2];
            if(cc >= '0' && cc <= '9') {
                line = atoi(ch+2);
            }
            else {
                char* fp = file;
                char* cp;
                for(cp = ch+2; *cp && *cp !=' '; cp++)
                    *fp++ = *cp;
                *fp = 0;
                line = atoi(cp+1);
            }
        }
        if(*file) {
            sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"setbreakpoint\", \"arguments\": { \"type\": \"script\", \"target\": \"%s\", \"line\": %d, \"enabled\":%s}}"
                    , dc->autoSeq++,
                    file,
                    line-1, enabled);
        }
        else {
            sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"setbreakpoint\", \"arguments\": { \"type\": \"script\", \"line\": %d, \"enabled\":%s}}"
                    , dc->autoSeq++,
                    line-1, enabled);
        }
    }

   else if(strncmp(ch, "x", 1) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"clearbreakpoint\", \"arguments\": { \"breakpoint\": \"%d\"}}"
                , dc->autoSeq++, 
                atoi(ch + 2)-1);
    }   
    else if(strncmp(ch, "h", 1) == 0) {
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"help\"}", dc->autoSeq++);
    }
    else if(strncmp(ch, "l", 1) == 0) {
        int start = -1;
        int end = -1;
        if(strlen(ch) >= 3)
            start = atoi(ch+2);
        if(strstr(ch+2, ",") != 0)
            end = atoi(strstr(ch+2, ",")+1);
        sprintf(output, "{\"seq\": %d, \"type\":\"request\", \"command\": \"list\", \"arguments\": { \"start\": %d, \"end\": %d}}", dc->autoSeq++, start, end);
    }

    hfree(e->memory[ST].data, ch);   

    int len = (int) strlen(output);
    DebugWrite(dc, dc->p->e->colors.yellow, (int) strlen(dc->p->e->colors.yellow));
    DebugWrite(dc, output, len);
    DebugWrite(dc, dc->p->e->colors.normal, (int) strlen(dc->p->e->colors.normal));
    DebugWrite(dc, "\r\n",2);
   
}


int DebugReadAll(DebugContext* dc, DynStr* buffer) {
    int n;
    Js* e = dc->p->e;

    char buff[255];
    while(TRUE) {
        n = dc->read(e, dc->sock, buff, 254);
        if(n < 0 || errno )
            return DebugSocketError(dc);
        if(n == 0) 
            return buffer->str->length;
        buff[n] = 0;
        DynStrAddStrA(e, buffer, buff);
    }
}

int DebugRead(DebugContext* dc, int count, DynStr* buffer) {
    int n;
    Js* e = dc->p->e;
    char buff[255];
    int total = 0;
    int limit = 254;

    if(count < limit)
        limit = count;
    while(TRUE) {
        n = dc->read(e, dc->sock, buff, limit);
        if(n < 0)
            return DebugSocketError(dc);
        if(n == 0)
            return total;
        total += n;
        buff[n] = 0;
        DynStrAddStrA(e, buffer, buff);
        if(total == count)
            return total;
    }    
}

// Read a line from buffer (skip leading line terminators)
// Returns TRUE if there is more data, FALSE if there is none
bool_t DebugReadLine(DebugContext* dc, DynStr* buffer) {
    Js* e = dc->p->e;
    char ch;
    int n;
    bool_t leading = TRUE;
    while(TRUE) {
        n = dc->read(e, dc->sock, &ch, 1);
        if(n < 0) 
            return DebugSocketError(dc);

        if(n < 1)
            break;

        if(TkIsLineTerm(ch) ) {                 // Skip leading line terminators
            if(leading)
                continue;
            break;
        }

        leading = FALSE;
        DynStrAdd(e, buffer, (uchar) ch);
    }

    // done with buffer?
    if(n == 0)
        return FALSE;
    return TRUE;
}


bool_t DebugSkipSpaces(Str* s, int index, int* next) {
    int i;
    for(i=index; i < s->length; i++) {
        char ch = (char) s->chars[i];
        if(ch == ' ')
            continue;
        break;
    }
    if(i >= s->length)
        return FALSE;
    *next = i;
    return TRUE;
}
bool_t StrStartsWithA(Js* e, Str* s, char* match, bool_t ignoreCase, bool_t skipPrefixSpace);

int DebugContentLengthFromStr(Js* e, Str* str, int *next) {
    if(!StrStartsWithA(e, str, "content-length", TRUE, TRUE))
        return -1;

    int i = 14;
    if(!DebugSkipSpaces(str, i, &i))
        return -1;
    char ch = (char) str->chars[i];
    if(ch != ':')
        return -1;

    i++;
    if(!DebugSkipSpaces(str, i, &i))
        return -1;
    char buffer[200];
    int j;
    for(j=0; j < 200; j++) {
        char cd = (char) str->chars[i];
        if(cd < '0' || cd > '9')
            break;
        buffer[j] = cd;
        i++;
        if(i > str->length) break;
    }

    buffer[j] = 0;
    int len = atoi(buffer);
    if(next) *next = i;
    return len;
}


int DebugReadContentLength(DebugContext* dc, DynStr** buffer) {
    Js* e = dc->p->e;
    DynStr* ds = DynStrNew(e, 1000);
    DebugReadLine(dc, ds);
    Str* str = ds->str;
    int ret = DebugContentLengthFromStr(e, str, NULL);
    if(buffer)
        *buffer = ds;
    else
        DynStrDel(e, ds);

    // if we have a return, we must seek past the \n\r\n
    // we have already eaten the first \r
    if(ret) {
        char buff[200];
        dc->read(e, dc->sock, buff, 3);
    }
    return ret;
}

bool_t isQuickPrefix(char c) {
    switch(c) {
        case 'p':
        case 'h':
        case 'b':
        case 'B':
        case 'x':
        case 'l':
        case 'q':
        case 'c':
        case 's':
        case 'n':
        case 'o':            
            return TRUE;
    }
    return FALSE;
}

//
Val* DebugParseRequest(DebugContext* dc, Tokenizer* tk) {
    Js* e = dc->p->e;
    DynStr* buffer;
    int contLen = DebugReadContentLength(dc, &buffer);
    int count = 0;
    // No content length, keep reading the rest into the buffer
    if(contLen > 0) {
        DynStrClear(e, buffer);
        count = DebugRead(dc, contLen, buffer);
    }
    else if(contLen < 0) {
        // We already read the buffer
        count = buffer->str->length;
    }
    else {
        count = DebugReadAll(dc, buffer);
    }

    d0(e, dc, "<<< Content-Length: %d bytes\n", count);
    if(count == 0) {
        DynStrDel(e, buffer);
        return NULL;
    } 

    Str* sb = StrClone(e, buffer->str);
    DynStrDel(e, buffer);
    if(sb->length && isQuickPrefix(sb->chars[0])) {
        char output[4096];
        DebugQuickCommand(dc, sb, count, output);
        StrDel(e, sb);
        sb = StrNewChars(e, output);
    }

    TkTokenizeS(e, tk, sb,0,0);
    return JsonParse(e, tk, NULL);
}



int DebugListenSocket(Js* e, DebugContext* dc) {
    int sockfd = (int) dc->init(e, dc);  
    if(sockfd < 0) {
        dc->print(e, 1, "jse debug: error debugger init\n");
    }
    else if (dc->listen(e, (void*) (long) sockfd, 5) == -1) {
        dc->print(e, 1, "jse debug: error listen\n");
    }

    d1(e,dc, "<<< waiting for connections...\n");    
    return sockfd;
}


Val* DebugResponseObject(Js* e, Val* seq, int response_seq, Val* command) {
    Val* res = ValNewObject(e);
    int seqNum = 0;
    if(seq && seq->type == TYPE_NUM) 
        seqNum = (int) seq->num;

    PutA(e, res, "seq", ValNewNum(e, response_seq), TRUE);
    PutA(e, res, "type", ValNewStrA(e, "response"), TRUE);
    PutA(e, res, "request_seq", ValNewNum(e, seqNum), TRUE);
    if(command) PutA(e, res, "command", command, FALSE);
    PutA(e, res, "success", ValNewBool(e, TRUE), TRUE);
    PutA(e, res, "running", ValNewBool(e, TRUE), TRUE);
    return res;
}

Val* DebugResponseError(Js* e, Val* seq, int response_seq, Val* command, char* message) {    
    Val* res = DebugResponseObject(e, seq, response_seq, command);
    PutA(e, res, "message", ValNewStrA(e, message), TRUE);
    PutA(e, res, "success", ValNewBool(e, FALSE), TRUE);
    PutA(e, res, "running", ValNewBool(e, FALSE), TRUE);
    return res;
}   

bool_t DebugValidateRequest(DebugContext* dc, Val* seq, Val* type, Val* command) {
    Js* e = dc->p->e;
    if(seq->type != TYPE_NUM) {
        d1(e, dc, "<<< seq not a number\n");
        return FALSE;
    }
    if(!ValEqStrA(e, type, "request")) {
        d1(e,dc, "<<< type not 'request'\n");
        return FALSE;
    }
    if(command->type != TYPE_STR){
        d1(e,dc,"<<< command not a string\n");
        return FALSE;
    }
    return TRUE;
}




void* SocketInit(Js* e, void* d) {
    DebugContext* dc = (DebugContext*)d;
    int sockfd;  
    struct addrinfo hints, *servinfo, *p;
    int yes=1;
    int rv;
    void* bad = (void*)(long) -1;

    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, e->options.port, &hints, &servinfo)) != 0) {
        jprintf(e, 0, "getaddrinfo: %s\n", gai_strerror(rv));
        return bad;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p->ai_next) {
        if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
            d1(e, 0, "<<< error socket\n");
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
            d1(e, dc, "<<< error setsockopt\n");
            exit(1);
        }

        if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
            dc->close(e, (void*)(long) sockfd);
            dc->print(e, 1, "<<< error bind\n");
            continue;
        }

        break;
    }

    if (p == NULL)  {
        freeaddrinfo(servinfo); // all done with this structure
        dc->print(e,1, "<<< error failed to bind\n");
        return bad;
    }

    freeaddrinfo(servinfo); // all done with this structure
    return (void*)(long)sockfd;
}

int SocketListen(Js* e, void* fd, int count) {
    return listen((int) fd, count);
}

int SocketRead(Js* e, void* socket, char* buffer, int count) {
    return (int) read((int) socket, (void*) buffer, count);
}

int SocketWrite(Js* e, void* socket, char* buffer, int count) {
    int res =  (int) write((int) socket, (void*) buffer, count);
    return res;
}

#define BAD ((void*)(long)(-1))

void* SocketAccept(Js* e, int handle) {
    void* new_fd;  // listen on sock_fd, new connection on new_fd
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    char s[INET6_ADDRSTRLEN];

    sin_size = sizeof their_addr;
    new_fd = (void*)(long) accept(handle, (struct sockaddr *)&their_addr, &sin_size);
    if (new_fd < 0) {
        d1(e,0,"<<< error accept");
        return BAD;
    }

    inet_ntop(their_addr.ss_family, get_in_addr((struct sockaddr *)&their_addr), s, sizeof s);
    d1(e,0,"<<< connection from %s\n", s);   
    return new_fd; 
}

void SocketClose(Js* e, void* socket) {
    close((int) socket);
}


Debugger* DebuggerNew(Js* e, DebugContext* dc) {
    Debugger* dbg = (Debugger*) halloc(e->memory[DG].data);
    dbg->context = dc;
    dbg->state = DEBUG_BREAK;
    dbg->targetLine = DEBUG_NOLINE;
    dbg->targetContext = NULL;
    dbg->Breakpts = VectorNew(e, 5, sizeof(Breakpt), 1.4);
    e->debugger = dbg;
    return dbg;
}

void DebuggerDel(Js* e, Debugger* dbg) {
    if(!dbg) return;
    VectorDel(e, dbg->Breakpts);
    e->debugger = NULL;
    hfree(e->memory[DG].data, dbg);
}

int DebuggerFindBreakpt(Js* e, int file, int line) {
    Debugger* dbg = e->debugger;
    if(!dbg) return DEBUG_NOTFOUND;
    Vector* bps = dbg->Breakpts;
    int count =  VectorCount(e, bps);
    for(int c=0; c < count; c++) {
        Breakpt* bp = VectorGet(e, bps, c);
        if(bp->file == file && bp->line == line)
            return c;
    }
    return DEBUG_NOTFOUND;
}


int DebuggerAddBreakpt(Js* e, int file, int line) {
    Debugger* dbg = e->debugger;
    if(!dbg) return DEBUG_NOTFOUND;    
    int index = DebuggerFindBreakpt(e, file, line);
    if(index != DEBUG_NOTFOUND)
        return index;

    Vector* bps = dbg->Breakpts;
    int count =  VectorCount(e, bps);
    Breakpt bp;
    bp.file = file;
    bp.line = line;
    bp.enabled = TRUE;
    bp.condition[0] = '\0';
    VectorInsert(e, dbg->Breakpts, &bp, 0);
    return count;
}

void DebuggerRemoveBreakpt(Js* e, int index) {
    Debugger* dbg = e->debugger;
    if(!dbg) return;
    Vector* bps = dbg->Breakpts;
    VectorRemove(e, bps, index);    
}

void DebuggerEnableBreakpt(Js* e, int index) {
    Debugger* dbg = e->debugger;
    if(!dbg) return;
    Vector* bps = dbg->Breakpts;
    Breakpt* bp = VectorGet(e, bps, index);
    bp->enabled = TRUE;
}

void DebuggerDisableBreakpt(Js* e, int index) {
    Debugger* dbg = e->debugger;
    if(!dbg) return;
    Vector* bps = dbg->Breakpts;
    Breakpt* bp = VectorGet(e, bps, index);
    bp->enabled = FALSE;
}

bool_t DebuggerBreakptEnabled(Js* e, int index) {
    Debugger* dbg = e->debugger;
    if(!dbg) return FALSE;
    Vector* bps = dbg->Breakpts;
    Breakpt* bp = VectorGet(e, bps, index);
    return bp->enabled;
}

bool_t DebuggerCheckBreakpt(Js* e, int file, int line) {
    Debugger* dbg = e->debugger;
    if(!dbg) return FALSE;    
    int index = DebuggerFindBreakpt(e, file, line);
    if(index == DEBUG_NOTFOUND)
        return FALSE;
    return DebuggerBreakptEnabled(e, index);
}

void DebuggerClearAllBreakpts(Js* e) {
    Debugger* dbg = e->debugger;
    if(!dbg) return;    
    VectorReset(e, dbg->Breakpts);    
}

bool_t DebugExec(DebugContext* dc);
bool_t DebugSendBreak(Js* e);
Val* DebugExceptionResponse(Js* e, Val* ex);

///// Called before every statement execution
///// Returns true to continue execution, otherwise causes a throw
bool_t shouldStepIn(Debugger* dbg, Context* cc, int line) {
    if( (line != dbg->targetLine) && (cc == dbg->targetContext))
        return TRUE;
    if(cc->prev == dbg->targetContext)
        return TRUE;
    return FALSE;
}



bool_t DebuggerTick(Parser* p) {
    Js* e = p->e;

    Debugger* dbg = e->debugger;
    if(!dbg)
        return TRUE;

    Context* cc = e->currentContext;
    DebugContext* dc = dbg->context;
    // Parser* p = dc->p;
    dc->p = p;
    Tokenizer* tk = p->tk;
    int file = p->fileIndex;           

    int line = TkGetTokLine(e, tk, p->next);

    switch(dbg->state) {
        case DEBUG_CONTINUE:
            if(DebuggerCheckBreakpt(e, file, line )) {
                d1(e, NULL, "!!! breakpoint hit line: %d\n", line);
                dbg->state = DEBUG_BREAK;
                break;
            }
            return TRUE;

        case DEBUG_STOP:
            d1(e, NULL, "!!! stop\n");
            return FALSE;

        case DEBUG_IN:
            if( shouldStepIn(dbg, cc, line)) {
                dbg->state = DEBUG_BREAK;
                d1(e, NULL, "!!! step in break line: %d\n", line);
                break;
            }
            return TRUE;
        case DEBUG_OUT:
            if(cc == dbg->targetContext) {
                dbg->state = DEBUG_BREAK;
                d1(e, NULL, "!!! step out break line: %d\n", line);
                break;
            }
            return TRUE;

        case DEBUG_OVER:
            if(line != dbg->targetLine && cc->prev != dbg->targetContext) {
                dbg->state = DEBUG_BREAK;
                d1(e, NULL, "!!! step over break line: %d\n", line);
                break;
            }
            return TRUE;
    }

    DebugSendBreak(e);
    while(dbg->state == DEBUG_BREAK) {
        dbg->targetLine = line;
        dbg->targetContext = cc->prev;
        bool_t er = DebugExec(dbg->context);
        if(!er)
            break;
    }

    return TRUE;
}

DebugContext* DebugContextNew(Js* e) {
    DebugContext* dc = (DebugContext*) halloc(e->memory[DC].data);
    dc->tk = TkNew(e);
    dc->r = RealmNew(e);
    RealmRetain(e, dc->r); 
    dc->p = ParserNew(e);    
    dc->req = NULL;
    dc->seq = NULL;
    dc->running = FALSE;
    dc->command = NULL;
    dc->arguments = NULL;
    dc->type = NULL;
    dc->rs = 0;    
    dc->sentConnected = FALSE;
    dc->listen = SocketListen;
    dc->accept = SocketAccept;
    dc->read = SocketRead;
    dc->write = SocketWrite;
    dc->close = SocketClose;
    dc->init = SocketInit;
    dc->print = jprintf;
    dc->sock = NULL;
    dc->vprint = ValPrintLn;
    dc->refs = ArrayCreate(e, NULL, NULL);
    dc->shouldExit = FALSE;
    if(e->options.ni)
        dc->appendCR = FALSE;
    else
        dc->appendCR = TRUE;
    dc->evalInit = NULL;
    dc->autoSeq = 1;
    dc->mainEnd = FALSE;
    dc->quickMode = FALSE;
    dc->appendResponse = 0;
    dc->lastLine = 1;
    signal(SIGPIPE, signal_handler);    
    dc->files = ListNew(e);
    return dc;
}

void DebugContextResetParser(DebugContext* dc) {
    Js* e = dc->p->e;
    ParserDel(dc->p);
    TkDel(e, dc->tk);
    dc->tk = TkNew(e);
    dc->p = ParserNew(e);
    dc->running = FALSE;
}

void DebugContextResetComnand(DebugContext* dc) {
    Js* e = dc->p->e;
    IFZ(dc->req);
    IFZ(dc->seq);
    IFZ(dc->command);
    IFZ(dc->arguments);
    IFZ(dc->type);
}

void DebugContextResetSession(DebugContext* dc) {
    Js* e = dc->p->e;
    IFZ(dc->refs);
}

void DebugContextDel(DebugContext* dc) {
    if(!dc) return;
    Js* e = dc->p->e;
    DebugContextResetComnand(dc);
    DebugContextResetSession(dc);
    if(dc->tk) TkDel(e, dc->tk);
    if(dc->p) ParserDel(dc->p);
    if(dc->r) RealmRelease(e, dc->r);
    ListDel(e, dc->files);
    hfree(e->memory[DC].data, dc);
}


Val* DebugResEnd(Js* e);
void DebugSendObject(Js* e, DebugContext* dc, Val* res);

Val* DebugRun(DebugContext* dc, bool_t breakNow) {
    Js* e = dc->p->e;
    dc->running = TRUE;

    if(breakNow) 
        e->debugger->state = DEBUG_BREAK;
    else 
        e->debugger->state = DEBUG_CONTINUE;

    d1(e, dc, "!!! running\n");
    // Always send continue response 
    DebugSendObject(e, dc, DebugResponseObject(e, dc->seq, dc->rs, dc->command));
    Val* v = ScriptEval(dc->p, dc->r, FALSE,0, dc->evalInit);
    if(ValIsAbrupt(e, v)) {
        Val* res = DebugExceptionResponse(e, v);
        ValDel(e, v);
        return res;
    }
    ValDel(e, v);
    return DebugResEnd(e);
}

Val* DebugStep(Js* e, DebugContext* dc) {
    if(!dc->running) 
        return DebugRun(dc, TRUE);

    Val* action = GetA(e, dc->arguments, "stepaction");
    Val* res = NULL;
    Debugger* dbg = e->debugger;
    Parser* p = dc->p;
    Tokenizer* tk = p->tk;
    int line = TkGetTokLine(e, tk, p->next);

    if(ValEqStrA(e, action, "in")) {
        dbg->state = DEBUG_IN;
        dbg->targetLine = line;
        dbg->targetContext = e->currentContext;
        res = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    }
    else if(ValEqStrA(e, action, "out")) {
        dbg->state = DEBUG_OUT;
        dbg->targetLine = line;
        dbg->targetContext = e->currentContext->prev;
        res = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    }
    else if(ValEqStrA(e, action, "next")) {
        dbg->state = DEBUG_OVER;
        dbg->targetLine = line;
        dbg->targetContext = e->currentContext;
        res = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    }
    else {
        res = DebugResponseError(e, dc->seq, dc->rs, dc->command, "Unknown stepaction");
    }
    ValDel(e, action);
    return res;
}

bool_t DebugIsStep(Js* e, DebugContext* dc) {
    Val* stepAction = GetA(e, dc->arguments, "stepaction");
    if(!stepAction || ValIsUndef(stepAction) || ValIsAbrupt(e, stepAction)) {
        ValDel(e, stepAction);
        return FALSE;
    }
    return TRUE;
}




Val* DebugContinue(Js* e, DebugContext* dc) {
    if(dc->p->error[0]) {
        return DebugResponseError(e, dc->seq, dc->rs, dc->command, dc->p->error);
    }                        
    else {
        if(DebugIsStep(e, dc))
            return DebugStep(e, dc);

        if(dc->running && e->debugger) {
            e->debugger->state = DEBUG_CONTINUE;
            e->debugger->targetLine = DEBUG_NOLINE;
            e->debugger->targetContext = NULL;
            // We do not respond here until the debugger breaks
            return DebugResponseObject(e, dc->seq, dc->rs, dc->command);
        }
        return DebugRun(dc, FALSE);        
    }
}

Val* DebugDisconnect(Js* e, DebugContext* dc) {
    dc->shouldExit = TRUE;
    Val* res = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    PutA(e, res, "running", ValNewBool(e, FALSE), TRUE);
    Val* args = dc->arguments;
    if(args && ValIsTrueDel(e, GetA(e, args, "exit")))
        exit(0);

    return res;        
}

// @todo: Cleanup the whole reference and lookup system for debugging
Val* DbgSerializeVal(DebugContext* dc, Val* v);
Val* DbgSerializeObj(DebugContext* dc, Val* v);

Val* DbgAddRef(DebugContext* dc, Val* data) {
    Js* e = dc->p->e;
    Val* len = GetA(e, dc->refs, "length");
    if(len->num > 20)
        return NULL;
    char slen[20];
    sprintf(slen, "%d", (int) len->num);
    PutA(e, dc->refs, slen, data, FALSE);
    PutA(e, data, "handle", len, FALSE);
    return len;
}



Val* DbgSerializeVal(DebugContext* dc, Val* v) {
    Js* e = dc->p->e;
    if(v->type == TYPE_REF)
        v = v->Ref->base;
    if(v->type == TYPE_COMP)
        v = v->completion->value;
    if(v->type == TYPE_OBJ)
        return DbgSerializeObj(dc, v);
    Val* data = ValNewObject(e);
    char* type = "unknown";
    if(v->type == TYPE_STR) {
        type = "string";
        PutA(e, data, "length", ValNewNum(e, v->str->length), TRUE);
    }
    else if(v->type == TYPE_NUM) type = "number";
    else if(v->type == TYPE_UNDEF) type = "undefined";
    else if(v->type == TYPE_NULL) type = "null";
    else if(v->type == TYPE_SYMA) type = "symbol";
    else if(v->type == TYPE_BOOL) type = "boolean";

    PutA(e, data, "type", ValNewStrA(e, type), TRUE);
    if(v->type != TYPE_UNDEF && v->type != TYPE_NULL)
        PutA(e, data, "value", v, FALSE);
    return data;
}

void ArrayPush(Js* e, Val* arr, Val* v, bool_t del) {
    Val* len = GetA(e, arr, "length");
    Val* slen = ToString(e, len);
    Val* res = Put(e, arr, slen, v, TRUE);
    ValDel(e, res);
    ValDel(e, len);
    ValDel(e, slen);
    if(del) ValDel(e, v);
}
bool_t IsArray(Js* e, Val* a);

Val* DbgSerializeObj(DebugContext* dc, Val* v) {
    Js* e = dc->p->e;
    Val* data = ValNewObject(e);
    if(IsArray(e, v)) 
        PutA(e, data, "className", ValNewStrA(e, "Array"), TRUE);
    else
        PutA(e, data, "className", ValNewStrA(e, "Object"), TRUE);
    PutA(e, data, "type", ValNewStrA(e, "object"), TRUE);
    Val* properties = ArrayCreate(e, NULL, NULL);
    PutA(e, data, "properties", properties, FALSE);
    Val* keys = DoOwnPropertyKeys(e, v);    
    while(TRUE) {
        Val* result = IteratorNext(e, keys, NULL);
        Val* done = IteratorComplete(e, result);
        if(!ValIsTrueDel(e, done)) {
            Val* ref = ValNewObject(e);
            Val* name = IteratorValue(e, result);
            Val* value = DoGet(e, v, name, NULL);
            Val* propData = DbgSerializeVal(dc, value);
            Val* propHandle = DbgAddRef(dc, propData);
            ValDel(e, propData);

            // Apply the limit in reference data
            if(!propHandle) {
                ValDel(e, value);
                ValDel(e, result);
                break;
            }
            PutA(e, ref, "ref", propHandle, TRUE);
            PutA(e, ref, "name", name, TRUE);
            ValDel(e, result);            
            ValDel(e, value);
            ArrayPush(e, properties, ref, TRUE);
        }
        else {
            ValDel(e, result);            
            break;
        }
    }
    ValDel(e, properties);
    ValDel(e, keys);
    return data;
}

int DebugFileIndex(DebugContext* dc, Val* file) {
    Js* e = dc->p->e;

    // No file means always 0 is the current file
    if(ValIsUndef(file))
        return 0;

    // If the file is found exactly, then use that index
    int index = ListValueIndex(e, dc->files, file);
    if(index >= 0)
        return index;

    // File not found ==> Try to find it ignoring leading path
    Val* shortFile = ValStripPath(e, file);
    index = 0;
    for(Item* i = dc->files->head; i; i = i->next) {
        Val* shortItem = ValStripPath(e, i->value);
        Val* sv = SameValue(e, shortItem, shortFile);
        if(ValIsTrueDel(e, sv)) {
            ValDel(e, shortFile);
            ValDel(e, shortItem);
            return index;
        }
        ValDel(e, shortItem);
        index++;
    }
    ValDel(e, shortFile);

    // We now add this file
    index = dc->files->count;
    ListAddValue(e, dc->files, ValClone(e, file));
    return index;

}

///// Create new breakpoint
// {"seq":117,"type":"request","command":"setbreakpoint","arguments":{"type":"function,"target":"f"}}
// {"seq":118,"type":"request","command":"setbreakpoint","arguments":{type:"script","target":"test.js","line":100}}
// {"seq":119,"type":"request","command":"setbreakpoint","arguments":{"type":"function,"target":"f","condition":"i > 7"}}
Val* DebugSetBreakpoint(Js* e, DebugContext* dc) {
    Val* type = NULL, *target = NULL, *line = NULL, *enabled = NULL;
    Val* ret = NULL, *body = NULL, *locations = NULL, *location = NULL;

    if(!ValIsObject(dc->arguments))
        RET(DebugResponseError(e, dc->seq, dc->rs, dc->command, "Invalid request arguments"));

    Val* args = dc->arguments;
    type = GetA(e, args, "type");

    if(!ValEqStrA(e, type, "script"))
        RET(DebugResponseError(e, dc->seq, dc->rs, dc->command, "Invalid request arguments.type"));

    target = GetA(e, args, "target");
    int targetIndex = DebugFileIndex(dc, target);
    // @todo: we only support a single file for now

    line = GetA(e, args, "line");
    int index = DebuggerAddBreakpt(e, targetIndex, (int) line->num);
    enabled = GetA(e, args, "enabled");
    if(ValIsUndef(enabled) || ValIsTrue(e, enabled))
        DebuggerEnableBreakpt(e, index);
    else
        DebuggerDisableBreakpt(e, index);

    d0(e, dc, "<<< setbreakpoint %d line: %d %s\n", index, (int) line->num, (enabled) ? "enabled" : "disabled");
    ret = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    body = ValNewObject(e);
    PutA(e, body, "type", type, FALSE);
    PutA(e, body, "breakpoint", ValNewNum(e, index), TRUE);
    PutA(e, ret, "body", body, FALSE);
    locations = ArrayCreate(e, NULL, 0);
    location = ValNewObject(e);
    PutA(e, location, "line", line, FALSE);
    PutA(e, location, "column", ValNewNum(e, 0), TRUE);
    PutA(e, locations, "0", location, FALSE);
    PutA(e, body, "actual_locations", locations, FALSE);

exit:
    IFD(type);
    IFD(target);
    IFD(line);
    IFD(enabled);
    IFD(body);
    IFD(location);
    IFD(locations);
    return ret;
}

Val* DebugClearBreakpoint(Js* e, DebugContext* dc) {
    Val* breakpoint = NULL, *ret = NULL;
    if(!ValIsObject(dc->arguments))
        return DebugResponseError(e, dc->seq, dc->rs, dc->command, "Invalid request arguments");

    Val* args = dc->arguments;
    breakpoint = GetA(e, args, "breakpoint");   
    d0(e, dc, "<<< clearbreakpoint: %d\n", (int) breakpoint->num);
    DebuggerRemoveBreakpt(e, (int) breakpoint->num);
    ret = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    Val* body = ValNewObject(e);
    PutA(e, body, "type", ValNewStrA(e, "script"), TRUE); // @todo: other types
    PutA(e, body, "breakpoint", breakpoint, TRUE);
    PutA(e, ret, "body", body, TRUE);
    return ret;
}

Val* DebugHelp(Js* e, DebugContext* dc) {
    char* hs = "\n\
    c          continue\n\
    q          disconnect\n\
    p <expr>   print\n\
    b <line>   setbreakpoint\n\
    B <line>   disable breakpoint\n\
    x <line>   clearbreakpoint\n\
    h          help\n\
    l <s>[,#]  list start, count\
    ";
    return ValNewStrA(e, hs);
}

int GetNumVal(Js* e, Val* obj, char* p, int def) {
    Val* v = GetA(e, obj, p);
    if(ValIsUndef(v)) {
        ValDel(e, v);
        return def;
    }
    int ret = v->num;
    ValDel(e, v);
    return ret;
}

void stradd(char* buff, const char * format, ... ) {    
    va_list args;
    char* buffer = strstr(buff, "\0");
    va_start (args, format);
    vsprintf (buffer,format, args);
}

bool_t HasBreakpoint(Js* e, DebugContext* dc, int line) {
    return DebuggerCheckBreakpt(e, 0, line);
}

#define DEBUG_LIST_LIMIT        10

Val* DebugListCore(Js* e, DebugContext* dc, int start, int end) {
    char buff[32767];
    Tokenizer* tk = dc->p->tk;
    int lines = TkGetLineCount(e, tk);
    int limit = DEBUG_LIST_LIMIT;

    if(start < 0) start = dc->lastLine;
    end = start + end;
    if(end < start) end = start + limit;
    if(end >= lines) end = lines-1;
    char* b = buff;
    char* lineColor = e->colors.blue;
    char* textColor = e->colors.green;
    char* normalColor = e->colors.normal;
    int lc = (int) strlen(lineColor);
    int tc = (int) strlen(textColor);
    int nc = (int) strlen(normalColor);

    for(int l = start; l < end; l++) {
        sprintf(b, "%s", lineColor); b += lc;
        sprintf(b,"%04d%s ", l+1, (HasBreakpoint(e, dc, l)) ? "*" : " ");
        b += 6;
        sprintf(b, "%s", textColor); b += tc;
        int t = TkGetLineStartTok(e, tk, l);
        int o = TkGetTokOffset(e, tk, t);
        for(uchar c = tk->input[o]; c != 0; ) {
            if(c == '\r' || c == '\n') { 
                *b++ = '\r';
                *b++ = '\n';
                break;
            }
            *b++ = c;
            c = tk->input[++o];
        }
    }
    sprintf(b, "%s", normalColor); b += nc;
    *b = 0;
    return ValNewStrA(e, buff);
}

Val* DebugList(Js* e, DebugContext* dc) {
    int limit = DEBUG_LIST_LIMIT;
    int start = GetNumVal(e, dc->arguments, "start", dc->lastLine) - 1;
    int end = GetNumVal(e, dc->arguments, "end", start + limit);
    return DebugListCore(e, dc, start, end);
}


int ArrayGetIntLen(Js* e, Val* arr);

Val* DebugEvaluate(Js* e, DebugContext* dc) {
    ValDel(e, dc->refs);
    dc->refs = ArrayCreate(e, 0, 0);
    if(!ValIsObject(dc->arguments))
        return DebugResponseError(e, dc->seq, dc->rs, dc->command, "Invalid request arguments");
    if(dc->p->error[0]) 
        return DebugResponseError(e, dc->seq, dc->rs, dc->command, dc->p->error);
    
    Val* expression = GetA(e, dc->arguments, "expression");
    if(expression->type != TYPE_STR) {
        ValDel(e, expression);
        return DebugResponseError(e, dc->seq, dc->rs, dc->command, "Invalid arguments.expression");
    }

    Val* vIgnoreExceptions = GetA(e, dc->req, "ignoreExceptions");
    bool_t ignoreExceptions = ValIsTrueDel(e, vIgnoreExceptions);

    Parser* p = ParserNew(e);
    Val* v = Parse(p, expression->str, FALSE, 0);
    ValDel(e, v);
    // Temporarily disable watcher so we don't mess up existing line values
    bool_t w = e->options.watcher;
    e->options.watcher = FALSE;
    // Temporarily disable the debugger to avoid nasty re-entry issues here
    Debugger* tempDebugger = e->debugger;
    e->debugger = NULL;
    // #509 We can't use ScriptEval here since it will  not honor the current
    //      execution context and all local / vars state
    //
    // Correction - if the program has already terminated, we should use a ScriptEval
    //              to focrce looking for values in the realm (globals) since the
    //              context is already gone
    if(dc->mainEnd)
         v = ScriptEval(p, dc->r, FALSE,0, 0);
    else
        v = Eval(p, p->root, 0);

    e->debugger = tempDebugger;
    // Re-enable the debugger
    e->options.watcher = w;

    Val* res = DebugResponseObject(e, dc->seq, dc->rs, dc->command);
    if(ignoreExceptions && ValIsAbrupt(e, v)) {
        ValDel(e, v);
        v = ValNew(e);
    }

    Val* vs = NULL;
    if(ValIsAbrupt(e, v)) {
        dc->print(e, 0, "debug: evaluate exception\n" );                                    
        PutA(e, res, "success", ValNewBool(e, FALSE), TRUE);
        PutA(e, res, "message", ValNewStrA(e, "exception"), TRUE);
    }
    else {
        if(ValIsPrimitive(v)) {
            vs = DbgSerializeVal(dc, v);
        }
        else if(ValIsObject(v)) {
            vs = DbgSerializeObj(dc, v);
        }
        else {
            d1(e,  dc, "*** unknown type *** %x", v->type);
            // assert(0);
        }
        ValDel(e, v);
        // Always give the root value a handle to the end of the array
        PutA(e, vs, "handle", ValNewNum(e, ArrayGetIntLen(e, dc->refs)), TRUE);
        PutA(e, res, "refs", dc->refs, FALSE);
        PutA(e, res, "body", vs, TRUE);
    }
    ParserDel(p);
    ValDel(e, expression);
    PutA(e, res, "ignoreExceptions", ValNewBool(e, ignoreExceptions), TRUE);
    return res;
}

Val* DebugLookup(Js* e, DebugContext* dc) {
    return NULL;
}

Val* DebugCommand(Js* e, DebugContext* dc) {
    dc->rs++;
    if(ValEqStrA(e, dc->command, "continue")) 
        return DebugContinue(e, dc);

    else if(ValEqStrA(e, dc->command, "evaluate")) 
        return DebugEvaluate(e, dc);
    else if(ValEqStrA(e, dc->command, "disconnect")) 
        return DebugDisconnect(e, dc);    
    else if(ValEqStrA(e, dc->command, "lookup"))
        return DebugLookup(e, dc);
    else if(ValEqStrA(e, dc->command, "setbreakpoint"))
        return DebugSetBreakpoint(e, dc);
    else if(ValEqStrA(e, dc->command, "clearbreakpoint"))
        return DebugClearBreakpoint(e, dc);
    else if(ValEqStrA(e, dc->command, "list"))
        return DebugList(e, dc);
    else if(ValEqStrA(e, dc->command, "help"))
        return DebugHelp(e, dc);

    return  DebugResponseError(e, dc->seq, dc->rs, dc->command, "Not implemented");
}

void DebugGetCommand(Js* e, DebugContext* dc) {
    dc->command = GetA(e, dc->req, "command");
    dc->seq = GetA(e, dc->req, "seq");
    dc->type = GetA(e, dc->req, "type");
    dc->arguments = GetA(e, dc->req, "arguments");    
}

void DebugSendConnected(DebugContext* dc) {
    Js* e = dc->p->e;
    dc->sentConnected = TRUE;
    char jseVer[255];
    sprintf(jseVer, "jse-Version %d.%d.%d.%d\n", 
            JSE_VERSION_MAJOR, JSE_VERSION_MINOR, JSE_BUILD_NUMBER, JSE_BUILD_INC);

    char s[2048];
    sprintf(s, "Type: connect\n%s\nProtocol-Version: 1\nEmbedding-Host: node v0.10.25\nContent-Length: 0%s", jseVer, (dc->appendCR) ? "" : "\r\n\r\n");
    int len = (int) strlen(s);

    d1(e, dc, ">>> sending connected buffer\n");
    dc->write(dc->p->e, dc->sock, s, len);
}

int DebugWrite(DebugContext* dc, char* data, int len) {
    Js* e = dc->p->e;
    d0(e, dc, ">>> writing %d bytes\n", len);

    if(e->options.verbose)
        d0(e, dc, ">>> sending: %s\n", data);
    if(dc->appendCR) 
        return dc->write(dc->p->e, dc->sock, data, len);
    
    if(!dc->quickMode) {
    char buffer[255];
        sprintf(buffer, "Content-Length: %d\r\n\r\n", len);
        int lb = (int) strlen(buffer);
        int i = dc->write(dc->p->e, dc->sock, buffer, lb);
        if(i < 0)
            return i;
    }
    return dc->write(dc->p->e, dc->sock, data, len);
}

void DebugLogObj(DebugContext* dc,char* prefix, Val* obj);

void DebugSendObject(Js* e, DebugContext* dc, Val* res) {
    DebugLogObj(dc, ">>>", res);
    Val* str = 0;
    char* ch = 0;
    if(res->type == TYPE_STR) {
        str = ValClone(e, res);
        ch = StrDecodeNoEscape(e, str->str);
    }
    else {
        str = JsonStringify(e, res);         
        ch = StrDecode(e, str->str);
    }

    ValDel(e, res);
    int len = (int) strlen(ch);
    int n = DebugWrite(dc, ch, len);
    if (n < 0) 
        jprintf(e,1,"jse debug: error: writing to socket");
    hfree(e->memory[ST].data, ch);   


    if(dc->quickMode)  {
        if(dc->appendResponse) {
            DebugWrite(dc, "\r\n", 2);
            ch = StrDecodeNoEscape(e, dc->appendResponse->str);
            DebugWrite(dc, ch, dc->appendResponse->str->length);
            hfree(e->memory[ST].data, ch);   
            ValDel(e, dc->appendResponse);
            dc->appendResponse = 0;
        }
        DebugWrite(dc, "\r\n~ ", 4);
    }
    ValDel(e, str); 
}

void DebugLogObj(DebugContext* dc,char* prefix, Val* obj) {
    Js* e = dc->p->e;
    Val* r = obj;
    Val* type = GetA(e, r, "type");
    char* tag = "";
    bool_t isReqRes = FALSE;
    Val* command;
    if(ValEqStrA(e, type, "request")) {
        command = GetA(e, r, "command");
        tag = "request";
        isReqRes = TRUE;
    }
    else if(ValEqStrA(e, type, "response")) {
        command = GetA(e, r, "command");
        tag = "response";
        isReqRes = TRUE;
    }
    if(isReqRes) {
        Val* action = NULL, *args = NULL;
        if(ValEqStrA(e, command, "continue")) {   
            args = GetA(e, r, "arguments");         
            action = GetA(e, args, "stepaction");
        }
        else if(ValEqStrA(e, command, "evaluate")) {
            args = GetA(e, r, "arguments");         
            action = GetA(e, args, "expression");
        }
        else if(ValEqStrA(e, command, "setbreakpoint")) {
            args = GetA(e, r, "arguments");
            action = GetA(e, args, "line");
            Val* temp = ToString(e, action);
            ValDel(e, action);
            action = temp;
        }
        ValDel(e, args);
        char* act = NULL;
        if(action && !ValIsUndef(action) && !ValIsAbrupt(e, action))
            act = StrDecode(e, action->str);
        if(command && command->type == TYPE_STR) {
            char* cmd = StrDecode(e, command->str);
            d1(e, dc, "%s %s.command:%s.%s\n", prefix, tag, cmd, (act) ? act : "");
            hfree(e->memory[ST].data, cmd);
        }
        if(act) hfree(e->memory[ST].data, act);
        ValDel(e, action);
        ValDel(e, type);
        ValDel(e, command);
    }
    else if(ValEqStrA(e, type, "event")) {
        Val* event = GetA(e, r, "event");
        Val* body = GetA(e, r, "body");
        Val* sline = GetA(e, body, "sourceLine");

        assert(event->type == TYPE_STR);
        char* chars = StrDecode(e, event->str);
        d1(e, dc, "%s event.event:%s line: %d\n", prefix, chars, (int) sline->num);
        ValDel(e, body);
        ValDel(e, sline);
        hfree(e->memory[ST].data, chars);
        ValDel(e, type);
        ValDel(e, event);
    }
    else {
        ValDel(e, type);
        d1(e, dc, "%s unknown\n", prefix);
    }
}


void DebugAppendCR(DebugContext* dc);
// Wait for and handle an incoming command, returns NULL if no response
// is generated
bool_t DebugExec(DebugContext* dc) {
    Js* e = dc->p->e;
    DebugAppendCR(dc);
    dc->req = DebugParseRequest(dc, dc->tk);    // Request JSON
    if(!dc->req) {
        d1(e, dc, "<<< error failed to parse request");        
        return FALSE;
    }

    DebugLogObj(dc, "<<<", dc->req);

    if(!dc->sentConnected) 
        DebugSendConnected(dc);

    Val* res = NULL;
    if(!ValIsObject(dc->req)) 
        res = DebugResponseError(e, NULL, dc->rs++, NULL, "Invalid request object");
    else {
        DebugGetCommand(e, dc);
        if(!DebugValidateRequest(dc, dc->seq, dc->type, dc->command)) {
             res = DebugResponseError(e, dc->seq, dc->rs++, dc->command, "Invalid request properties");       
        }
        else
            res = DebugCommand(e, dc);
    }

    DebugContextResetComnand(dc);
    DebugSendObject(e, dc, res);
    return TRUE;
}



Val* DebugResEnd(Js* e) {
    Debugger* dbg = e->debugger;
    if(!dbg)
        return NULL;
    DebugContext* dc = dbg->context;
    char* path = e->options.file;
    dc->mainEnd = TRUE;
    DebugAppendCR(dc);
    Val* res = ValNewObject(e);
    PutA(e, res, "seq", ValNewNum(e, dc->rs++), TRUE);
    PutA(e, res, "type", ValNewStrA(e, "event"), TRUE);
    PutA(e, res, "event", ValNewStrA(e, "break"), TRUE);
    PutA(e, res, "running", ValNewBool(e, FALSE), TRUE);
    Val* body = ValNewObject(e);
    PutA(e, res, "body", body, FALSE);
    PutA(e, body, "sourceLine", ValNewNum(e, -1), TRUE);
    PutA(e, body, "sourceColumn", ValNewNum(e, 0), TRUE);
    Val* script = ValNewObject(e);
    if(dc->p->fileName[0]) PutA(e, script, "name", ValNewStrA(e, dc->p->fileName), TRUE);
    PutA(e, body, "script", script, FALSE);
    PutA(e, script, "name", ValNewStrA(e, path), TRUE);
    ValDel(e, script);
    ValDel(e, body);
    return res;
}

bool_t DebugSendBreak(Js* e) {
    Debugger* dbg = e->debugger;
    DebugContext* dc = dbg->context;
    Parser* p = dc->p;
    Tokenizer* tk = p->tk;
    int line = TkGetTokLine(e, tk, p->next);
//    char* path = e->options.file;

    DebugAppendCR(dc);
    Val* res = ValNewObject(e);
    PutA(e, res, "seq", ValNewNum(e, dc->rs++), TRUE);
    PutA(e, res, "type", ValNewStrA(e, "event"), TRUE);
    PutA(e, res, "event", ValNewStrA(e, "break"), TRUE);
    Val* body = ValNewObject(e);
    PutA(e, res, "body", body, FALSE);
    PutA(e, body, "sourceLine", ValNewNum(e, line), TRUE);
    PutA(e, body, "sourceColumn", ValNewNum(e, 0), TRUE);
    Val* script = ValNewObject(e);
    PutA(e, body, "script", script, FALSE);
    if(dc->p->fileName[0]) PutA(e, script, "name", ValNewStrA(e, dc->p->fileName), TRUE);
    ValDel(e, script);
    ValDel(e, body);
    if(dc->quickMode) {
        Val* s = DebugListCore(e, dc, line, 1);
        dc->lastLine = line;
        dc->appendResponse = s;
    }    
    DebugSendObject(e, dc, res);


    return TRUE;
}

Val* DebugExceptionResponse(Js* e, Val* ex) {
    Debugger* dbg = e->debugger;
    DebugContext* dc = dbg->context;
    Parser* p = dc->p;
    Tokenizer* tk = p->tk;
    int line = TkGetTokLine(e, tk, p->next);
    char* path = e->options.file;

    DebugAppendCR(dc);
    Val* res = ValNewObject(e);
    PutA(e, res, "seq", ValNewNum(e, dc->rs++), TRUE);
    PutA(e, res, "type", ValNewStrA(e, "event"), TRUE);
    PutA(e, res, "event", ValNewStrA(e, "exception"), TRUE);
    Val* body = ValNewObject(e);
    PutA(e, res, "body", body, FALSE);
    PutA(e, body, "sourceLine", ValNewNum(e, line), TRUE);
    PutA(e, body, "sourceColumn", ValNewNum(e, 0), TRUE);
    // @todo: need a string for the exception
    char buffer[255];
    if(dc->p->fileName[0])
        sprintf(buffer, "%s:%d runtime error %s", dc->p->fileName, line, dc->p->error);
    else 
        sprintf(buffer, ":%d runtime error %s", line, dc->p->error);
        
    
    PutA(e, body, "exception", ValNewStrA(e, buffer), TRUE);
    Val* script = ValNewObject(e);
    PutA(e, body, "script", script, FALSE);
    PutA(e, script, "name", ValNewStrA(e, path), TRUE);
    ValDel(e, script);
    ValDel(e, body);
    return res;
}

char* DebugFileName(const char* full) {
    char* lastSlash = NULL;
    char* original = (char*) full;
    while(*full) {
        if(!*full) break;
        if(*full == '/')
            lastSlash = (char*) full;
        full++;
    }
    if(!lastSlash)
        return original;
    return lastSlash+1;
}
void DebugAppendCR(DebugContext* dc) {
    if(dc->appendCR) 
        dc->write(dc->p->e, dc->sock, "\r\n\r\n", 4);
}

void EnsureContext(Js* e);
void EndContext(Js* e);



void LoadConfig(Js* e) {
    char* home = getenv("HOME");
    char path[1024];
    sprintf(path, "%s/.jserc", home);

    FILE *fp = fopen(path, "r");
    if(!fp)
        return;

    while(!feof(fp)) {
        char buff[1024];
        fgets(buff, 1024, fp);
        char* cmd = buff;
        int v = 0;
        char* sval = strstr(buff, "=");
        if(sval) {
            *sval = 0;
            sval++;

            if(strcmp(cmd, "script_path") == 0) {
                char* sp = e->options.script_path;
                if(*sval == '~') {
                    sprintf(sp, "%s", home);                    
                    sp += strlen(sp);
                    sval++;
                }
                sprintf(sp, "%s", sval);
                int len = strlen(e->options.script_path) -1;
                if(e->options.script_path[len] == '\n')
                    e->options.script_path[len] = 0;
                // jprintf(e, 0, "script_path: %s hello\n", e->options.script_path);
                continue;
            }
            else {
                v = atoi(sval);
            }
        }


        if(strcmp(cmd, "colors") == 0)
            e->options.colors = v;

        if(strcmp(cmd, "margin") == 0)
            e->options.margin = v;

        if(strcmp(cmd, "watcher") == 0)
            e->options.watcher = v;

    }
    fclose(fp);
}

void CmdArgsParse(Js* e, int argc, const char* argv[]) {
    LoadConfig(e);
    char* nonOption1 = NULL, *nonOption2 = NULL;        // Get command and file
    for(int i=1; i < argc; i++) {
        char* arg = (char*) argv[i];


        if(arg[0] != '-') {
            if(nonOption1 == NULL) {
                nonOption1 = arg;
            }
            else if(nonOption2 == NULL) {
                nonOption2 = arg;
            }
        }

        if(0 == strcmp(arg, "--quiet") || 0 == strcmp(arg, "-q"))
            e->options.quiet = TRUE;

        if(0 == strcmp(arg, "--verbose") || 0 == strcmp(arg, "-v"))
            e->options.verbose = TRUE; 

        if(0 == strcmp(arg, "-R"))
            e->options.recursive = TRUE; 

        if(0 == strcmp(arg, "--runtime") || 0 == strcmp(arg, "-r"))
            e->options.runtime = TRUE; 

        if(0 == strcmp(arg, "--watcher") || 0 == strcmp(arg, "-w"))
            e->options.watcher = TRUE;                    

        if(0 == strcmp(arg, "--colors") || 0 == strcmp(arg, "-c"))
            e->options.colors = TRUE;                            
        
        if(0 == strcmp(arg, "--debugLog") || 0 == strcmp(arg, "-dl"))
            e->options.debugLog = TRUE;                            

        if(0 == strcmp(arg, "--functions") || 0 == strcmp(arg, "-fn"))
            e->options.functions = 1;                            

        if(0 == strcmp(arg, "--nocolors") || 0 == strcmp(arg, "-nc"))
            e->options.colors = 0;                            

        if(getenv("TERM") && !strstr(getenv("TERM"), "color"))
            e->options.colors = FALSE;

        if(0 == strcmp(arg, "--lines") || 0 == strcmp(arg, "-l"))
            e->options.lines = TRUE;                            

        if(0 == strcmp(arg, "--opml")) 
            e->options.opml = TRUE;

        if(0 == strcmp(arg, "--opmlUseLR")) 
            e->options.opmlUseLR = TRUE;

        if(0 == strcmp(arg, "--calls") || 0 == strcmp(arg, "-cg"))
            e->options.callGraph = TRUE;

        if(0 == strcmp(arg, "--noHeader")) 
            e->options.noHeader = TRUE;

        if(0 == strcmp(arg, "--github")) 
            e->options.github = TRUE;

        if(0 == strcmp(arg, "--ni")) 
            e->options.ni = TRUE;

        if(0 == strcmp(arg, "--memory") || 0 == strcmp(arg, "-m"))
            e->options.memory = TRUE;      

        if(strncmp(arg, "--start=",8) == 0) {
            e->options.start = atoi(arg + 8);
        }
        if(strncmp(arg, "-s=", 3) == 0) {
            e->options.start = atoi(arg+3);
        }

        if(strncmp(arg, "--num=",6) == 0) {
            e->options.num = atoi(arg + 6);
        }
        if(strncmp(arg, "-n=", 3) == 0) {
            e->options.num = atoi(arg+3);
        }

        if(strncmp(arg, "--margin=",9) == 0) {
            e->options.margin = atoi(arg + 6);
        }
        if(strncmp(arg, "-m=", 3) == 0) {
            e->options.margin = atoi(arg+3);
        }
        if(strncmp(arg, "--port=",7) == 0) {
            e->options.port = arg + 7;
        }
        if(strncmp(arg, "-p=", 3) == 0) {
            e->options.port = arg+3;
        }
        if(strncmp(arg, "--output=",9) == 0) {
            e->options.outputFile = arg + 9;
        }
        if(strncmp(arg, "-o=", 3) == 0) {
            e->options.outputFile = arg+3;
        }
    }


    if(nonOption1 && nonOption2) {
        e->options.command = nonOption1;
        e->options.file = nonOption2;
    }
    if(!nonOption1) {
        e->options.command = "repl";
        e->options.file = "";
    }
    else if(nonOption2 != NULL) {
        e->options.command = nonOption1;
        e->options.file = nonOption2;
    }
    else if(0 == strcmp(nonOption1, "test")) {
        e->options.command = "test";
        e->options.file = "";
    }
    else if(0 == strcmp(nonOption1, "help")) {
        e->options.command = "help";
        e->options.file = "";
    }
    else if(0 == strcmp(nonOption1, "debug")) {
        e->options.command = "debug";
    }
    else {
        e->options.command = "run";
        e->options.file = nonOption1;
    }
}



///////////////////// DEBUGGER /////////////////
#endif // JSE_DEBUG

/////////////////////////////////////////////////////////////////////////////////
//
// Main entry point use #define JSE_MAIN to activate
//
#ifdef JSE_MAIN
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

////////// Option


// Print about string to console
void MainAbout(Js* e) {
    if(e->options.noHeader)
        return;
    jprintf(e,0,"jse %d.%d.%d.%d\n", JSE_VERSION_MAJOR, JSE_VERSION_MINOR, JSE_BUILD_NUMBER, JSE_BUILD_INC);
}

void PrintError(Parser* p, bool_t done);

void SetGlobal(Js* e, char* name, Val* value) {
    Val* varName = ValNewStrA(e, name);
    Val* ref = GetIdentifierRef(e, CurrentRealm(e)->globalEnv, varName, FALSE);
    Val* result = PutValue(e, ref, value);
    ValDel(e, result);
    ValDel(e, ref);
    ValDel(e, varName);
}

Val* TryRunScript(Js* e, Realm* realm, char* line) {
    Parser* p = NULL;
    Val* ret = NULL, *source = NULL, *v = NULL;
    char* buff = NULL;

    char fullPath[MAX_PATH];
    char script[MAX_PATH];

    char* w = line;
    char* d = script;
    while(*w != 0 && *w != ' ')
        *d++ = *w++;
    *d = 0;
    w++;

    sprintf(fullPath, "%s/%s", e->options.script_path, script);
    char* name = fullPath;

    buff = FileReadA(e, fullPath);
    p = ParserNew(e);
    if(!buff) {
        strcat(fullPath, ".js");
        buff = FileReadA(e, fullPath);    
    }

    if(!buff) {
        RET(ValNewCompA(e, COMP_THROW, NULL, name));
    }

    source = Utf8Decode(e, (uint8*) buff);
    v = Parse(p, source->str, TRUE, 0);
    source->type = TYPE_UNDEF;
    RET_IF_AB(v);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    jprintf(e, 0, "[script] %s\n", name);
    RET_VAL(v);

exit:
    if(p) ParserDel(p);
    IFD(source);
    IFD(v);
    if(buff) hfree(e->memory[ST].data, buff);
    return ret;
}


void MainReplResult(Js* e, Realm* realm, Val* gv, bool_t verbose) {
    Context* ctx = ContextNew(e, realm, 0, 0);
    SetGlobal(e, "_", gv);
    if(ValIsObject(gv)) {
        Val* s = Invoke0(e, gv, "toString");
        ValPrint(e, s, verbose,-1);
        jprintf(e, 0,  "\n");
        // ValPrintLn(e, "", s, verbose);
        ValDel(e, s);
    }
    else  {
        ValPrint(e, gv, verbose,-1);
        jprintf(e, 0,  "\n");
        // ValPrintLn(e, "", gv, verbose);
    }
    ContextDelete(e, ctx);
}

int MainRepl(Js* e) {
    char *prompt = "_ ";
    char hist_file[4096];
    sprintf(hist_file, "%s/.jse_hist", getenv("HOME"));

    bool_t verbose = e->options.verbose;
    Realm* realm = RealmNew(e);
    RealmRetain(e, realm);

#ifdef LINENOISE
    linenoiseHistoryLoad(hist_file);
#endif    

    while(TRUE) {
        bool_t run = TRUE;

#ifdef LINENOISE
        char* line = linenoise(prompt);
        if(line == NULL) 
            break;
        linenoiseHistoryAdd(line);
        linenoiseHistorySave(hist_file);
#else        
        char line[2048];
        jprintf(e,0,prompt);
        fgets(line, sizeof(line), stdin); 

#endif
        if(*line == 0 || *line == '\n') {
#ifdef LINENOISE
            free(line);
#endif            
            continue;
        }       

        Parser* p = ParserNew(e);
        Val* v = ParseA(p, line, 0);
        if(ValIsAbrupt(e, v)) {
            run = FALSE;
            Val* tv = TryRunScript(e, realm, line);
            if(ValIsAbrupt(e, tv)) {
                PrintError(p, 0);
            }
            else {
                MainReplResult(e, realm, tv, verbose);    
            }
            ValDel(e, tv);
        }
        ValDel(e, v);
        if(run) {
            v = ScriptEval(p, realm, FALSE, 0, 0);      
            Val* gv = GetValue(e, v);  
            if(ValIsAbrupt(e, gv))  {
                Val* tv = TryRunScript(e, realm, line);
                if(ValIsAbrupt(e, tv)) {
                    PrintError(p, 0);
                }
                else {
                    MainReplResult(e, realm, tv, verbose);    
                }
                ValDel(e, tv);
            }
            else  {
                MainReplResult(e, realm, gv, verbose);
            }
            ValDel(e, gv);
            ValDel(e, v);
        }
        ParserDel(p);        
#ifdef LINENOISE
        free(line);
#endif                
    }
    RealmRelease(e, realm);
    return 0;
}

int MainCat(Js* e) {
    const char* name = e->options.file;
    if(!name) {
        jprintf(e,0,"\nerror - expected jse cat file\n");
        exit(-1);
    }
    char* buff = FileReadA(e, name);
    if(!buff) {
        jprintf(e,0,"\n%serror - unable to open file %s\n", e->colors.red, name);
        exit(-1);
    }
    Tokenizer* lex = TkNew(e);
    // can't use tokenizea() since this frees the source
    Str* ubuff = StrNewChars(e, buff);
    bool_t colorizer = 1;
    bool_t verbose = e->options.verbose;
    if(e->options.runtime) {
        colorizer = 0;
        verbose = TRUE;
    }
    TkTokenize(e, lex, ubuff->chars,-1,0,colorizer);
    if(TkHasError(e, lex)) {
        jprintf(e,0,"\n%serror - %s in file %s\n", e->colors.red, TkGetError(e, lex), name);
    }
    else {
        TkPrint(e, lex, NULL, 0, verbose);
    }
    TkDel(e, lex);
    StrDel(e, ubuff);
    hfree(e->memory[ST].data, buff);
    return 0;
}


#include <stdio.h>
#include <dirent.h>
#include <sys/types.h> 
#include <regex.h>


int match(const char *string, char *pattern) {
    int    status;
    regex_t    re;

    if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB) != 0) {
        return(0);      /* Report error. */
    }
    status = regexec(&re, string, (size_t) 0, NULL, 0);
    regfree(&re);
    if (status != 0) {
        return(0);      /* Report error. */
    }
    return(1);
}

void foo() {
    DIR *dp;

    dp = opendir(".");
    if (dp) {
        struct dirent *entry;

      for(entry = readdir(dp); entry; entry = readdir(dp)) {
            if(match(entry->d_name, ".js"))
                printf(" my match %s\n", entry->d_name);
        }
        closedir(dp);
    }
}

void CoreTag(Js* e, const char* name) {
    char* buff = FileReadA(e, name);
    if(!buff) {
        jprintf(e,0,"%sskipping file %s\n", e->colors.red, name);
        return;
    }
    jprintf(e,0,"%stagging file %s\n", e->colors.red, name);
    Parser* p = ParserNew(e);
    ParserSetFileName(p, (char*) name);
    e->options.genTags = TRUE;
    Val* v = ParseA(p, buff, 0);
    ValDel(e, v);
    hfree(e->memory[ST].data, buff);
    ParserDel(p);    
}

bool_t isDir(const char* spec) {
    bool_t r = FALSE;
    DIR *dp = opendir(spec);
    if(dp) {
        r = TRUE;
        closedir(dp);
    }
    return r;
}

bool_t isFile(const char* spec) {
    bool_t r = FALSE;
    FILE* fp = fopen(spec, "r");
    if(fp) {
        r = TRUE;
        fclose(fp);
    }
    return r;
}


struct fileIterTag {
    char* name;
    struct fileIterTag* next;
};


typedef struct fileIterTag fileIter;
fileIter* fileIterGetTail(fileIter* item) {
    if(!item) return item;
    if(item->next == NULL) return item;
    return fileIterGetTail(item->next);    
}

fileIter* fileIterAdd(fileIter* list, char* dir, char* file) {
    char buff[2048];
    sprintf(buff, "%s/%s", dir, file);
    fileIter* i = _malloc(sizeof(fileIter));
    i->name = _malloc(strlen(buff) + 1);
    i->next = NULL;
    strcpy(i->name, buff);
    fileIter* tail = fileIterGetTail(list);
    if(!tail)
        return i;
    tail->next = i;
    return list;
}

// Get list of file names based on a spec. If the spec is a directory
// then all files in the directory are returned
fileIter* filesFromSpec(fileIter* parent, char* dir, char* files, bool_t recursive) {
    fileIter* list = parent;
    DIR *dp = opendir(dir);
    if(!dp)
        return parent;
    struct dirent *entry;
    for(entry = readdir(dp); entry; entry = readdir(dp)) {
        char* name = entry->d_name;

        if(entry->d_type == DT_REG) {   // Regular file
            if(!files || !*files)
                list = fileIterAdd(list, dir, name);
            else if(match(entry->d_name, files))
                list = fileIterAdd(list, dir, name);
        }

        if(entry->d_type == DT_DIR) {   // Directory
            if(!recursive || name[0] == '.')
                continue;
            char path[2048];
            sprintf(path, "%s/%s", dir, name);
            list = filesFromSpec(list, path, files, recursive);
        }
    }
    closedir(dp);        
    return list;
}

void fileIterDel(fileIter* list) {
    for(fileIter* i = list; i;) {
        fileIter* next = i->next;
        _free(i->name);
        _free(i);
        i = next;
    }
}

void fileIterPrint(fileIter* list) {
    for(fileIter* i = list; i ; i = i->next) 
        printf("%s\n", i->name);
}

// Split a spec into a base directory and associated file specs
void splitSpec(char* spec, char* dir, char* files) {
    char* p = strstr(spec, "/*");
    if(p) {
        size_t len = p - spec;
        strncpy(dir, spec, len);
        dir[len] = 0;
        strcpy(files, p+2);
        return;
    }

    p = strstr(spec, "/");
    if(p) {
        char* p2 = strstr(p+1, "/");
        while(p2) {
            p = p2;
            p2 = strstr(p+1, "/");
        }
        size_t len = p - spec;
        strncpy(dir, spec, len);
        dir[len] = 0;
        strcpy(files, p + 1);
        return;
    }

    if(isDir(spec)) {
        *files = 0;
        strcpy(dir, spec);
        return;
    }
    strcpy(dir, ".");
    if(spec[0] == '*')
        strcpy(files, spec+1);
    else
        strcpy(files, spec);
}

int MainTags(Js* e) {
    const char* name = e->options.file;
    if(!name) {
        jprintf(e,0,"\nerror - expected jse tags file\n");
        exit(-1);
    }
    char dir[1024], files[1024];
    splitSpec((char*) name, dir, files);
    fileIter* list = filesFromSpec(NULL, dir, files, e->options.recursive);
    for(fileIter* i = list; i; i = i->next) 
        CoreTag(e, i->name);
    fileIterDel(list);


    FILE* out = stdout;
    if(e->options.outputFile) {
        out = fopen(e->options.outputFile, "w");
        e->options.outputFile = NULL;               // so that jprintf() works as usual
    }

    CtagsPrint(e, out);
    if(out != stdout)
        fclose(out);
    return 0;  
}

int MainSyn(Js* e) {
    const char* expr = e->options.file;
    if(!expr) {
        jprintf(e,0,"\nerror - jse syn {expression}\n");
        return -1;
    }

    Parser* p = ParserNew(e);
    Val* v = ParseA(p, (char*) expr, 0);
    if(ValIsAbrupt(e, v)) {
        ValPrintLn(e, "", v, TRUE);
        return -1;
    }
    ValDel(e, v);
    if(e->options.opml) 
        NodePrintOpml(p, p->root, 0, "");
    else
        NodePrint(p, p->root,0);
    ParserDel(p);
    return 0;
}

int MainEval(Js* e) {
    const char* expr = e->options.file;
    if(!expr) {
        jprintf(e,0,"\nerror - jse eval {expression}\n");
        return -1;
    }

    Parser* p = ParserNew(e);
    Realm* r = RealmNew(e);
    RealmRetain(e, r);
    Val* v = ParseA(p, (char*) expr, 0);
    ValDel(e, v);
    v = ScriptEval(p, r, FALSE,0, 0);
    ValPrintLn(e, "", v, e->options.verbose);
    ValDel(e, v);
    ParserDel(p);
    RealmRelease(e, r);
    return 0;
}





Context* RetainedContext(Js* e, Realm* r);


int MainRun(Js* e) {
    const char* name = e->options.file;
    if(!name) {
        jprintf(e,0,"\nerror - expected jse run file\n");
        exit(-1);
    }
    char* buff = FileReadA(e, name);
    if(!buff) {
        jprintf(e,0,"\n%serror - unable to open file %s\n", e->colors.red, name);
        exit(-1);
    }

    Realm* realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0


    Context* retained = NULL;

    // If we have watcher we will need to get a retained context so that we can
    // eval after the script evaluation is complete 
    if(e->options.watcher)
        retained = RetainedContext(e, realm);

    Parser* p = ParserNew(e);
    ParserSetFileName(p, (char*) name);
    Val* source = Utf8Decode(e, (uint8*) buff);
    //  Val* v = ParseA(p, buff, 0);
    Val* v = Parse(p, source->str, TRUE, 0);
    source->type = TYPE_UNDEF;
    ValDel(e, source);          // Parser will take care of the source
    if(ValIsAbrupt(e, v)) {
        // ValPrintLn(e, "", v, TRUE);
        PrintError(p, 1);
        exit(-1);
    }        
    ValDel(e, v);

    if(e->options.opml) {
        NodePrintOpml(p, p->root, 0, name);
        exit(0);
    }

    if(e->options.functions) {
        printf("Function list\n");
        for(FuncDef* fn = p->functions; fn; fn = fn->next) {
            ValPrintLn(e, "", fn->name, 0);
            if(e->options.callGraph && p->calls) {
                for(Item* i = p->calls->list->head; i; i = i->next) {
                    Val* cd = i->value;
                    Val* source = GetA(e, cd, "source");
                    if(ValIsTrueDel(e, SameValue(e, source, fn->name))) {
                        Val* t = GetA(e, cd, "target");
                        Val* a = GetA(e, cd, "args");
                        t = ValStrCatADel(e, t, "(");
                        if(!ValIsUndef(a)) {
                            t = ValStrCatDel(e, t, a);
                        }
                        t = ValStrCatADel(e, t, ")");
                        t = ValStrCatADel(e, t, " line:");
                        Val* l = GetA(e, cd, "line");
                        Val* ls = ToString(e, l);
                        ValDel(e, l);
                        t = ValStrCatDel(e, t, ls);
                        ValDel(e, ls);
                        ValPrintLn(e, "      +-> ", t, 0);
                        ValDel(e, t);
                    }
                    ValDel(e, source);
                }
            }
        }
        exit(0);
    }

    v = ScriptEval(p, realm, FALSE,0, 0);
    if(ValIsAbrupt(e, v)) {
        PrintError(p, 1);
    }

    if(e->options.lines) {
        ValDel(e, v);
        int lines = TkGetLineCount(e, p->tk);
        List* extra = ListNew(e);
        for(int line = 0; line < lines; line++) {
            char buff[20];
            sprintf(buff, "line%d", line+1);
            Val* varName = ValNewStrA(e, buff);
            v = GetIdentifierRef(e, realm->globalEnv, varName, FALSE);
            Val* value = GetValue(e, v);
            
            if(ValIsAbrupt(e, value)) {
                ListAddValue(e, extra, ValNew(e));
                ValDel(e, value);
            }
            else
                ListAddValue(e, extra, value);
            ValDel(e,v);
            ValDel(e, varName);
        }
        Str* ubuff = StrNewChars(e, buff);
        Tokenizer* lex = TkNew(e);
        TkTokenizeS(e, lex, ubuff,0,1);
        TkPrint(e, lex, extra, e->options.margin, FALSE);
        TkDel(e, lex);
        ListDel(e, extra);
    }
    else {
        vpl(e, v);
        ValDel(e, v);
    }
    
    ContextDelete(e, retained);
    // tokenizer will delete buffer    StrDel(e, ubuff);
    hfree(e->memory[ST].data, buff);
    ParserDel(p);        
    RealmRelease(e, realm);            
    return 0;    
}

#define BAD ((void*)(long)(-1))

int MainDebug(Js* e) {
    const char* name = e->options.file;
    d1(e,0,"debugging %s on port: %s\n", DebugFileName(name), e->options.port);

    if(!name) {
        jprintf(e,1,"\njse debug: error expected jse run file\n");
    }
    char* buff = FileReadA(e, name);
    if(!buff) {
        jprintf(e,1,"\n%sjse debug: error unable to open file %s\n", e->colors.red, name);
    }

    // Creating a new context will cause attempt to access ArrayPrototype
    // To do this, we must ensure that the environment has the "orphan" outer
    // context used independent of any runtime contexts used
    EnsureContext(e);
    DebugContext* dc = DebugContextNew(e);
    Debugger* dbg = DebuggerNew(e, dc);
    ParserSetFileName(dc->p, (char*) name);
    Val* v = ParseA(dc->p, buff, 0);
    if(ValIsAbrupt(e, v)) {         // @todo: handle parse errors
        ValPrintLn(e, "", v, TRUE);
    }        
    ValDel(e, v);

    int sockfd = DebugListenSocket(e, dc);
    while(1) {  
        void* new_fd = dc->accept(e, sockfd);
        if (new_fd == BAD)
            continue;
        
        dc->sock = new_fd;

        while(1) {
            bool_t rb = DebugExec(dc);
            if(!rb) continue;
            if(dc->shouldExit)
                break;
        }

        if(dc->appendCR) dc->write(e, (void*)(long)new_fd, "\r\n\r\n", 4);
        d1(e,dc,"disconnecting\n");
        dc->close(e, (void*)(long) new_fd);  // parent doesn't need this
        if(dc->shouldExit)
            break;
    }

    DebugContextDel(dc);
    EndContext(e);
    DebuggerDel(e, dbg);
    hfree(e->memory[ST].data, buff);
    d1(e,0,"exiting\n");
    return 0;
}

int MainHelp(Js* e) {
    char* G = ""; // e->colors.green;
    char* N = ""; // e->colors.normal;
    char* M = ""; // e->colors.magenta;
    jprintf(e,0,"Option\n");
    jprintf(e,0,"  jse %srun%s <file>           run file\n", G, N);
    jprintf(e,0,"  jse %sdebug%s <file>         debug file\n", G, N);
    jprintf(e,0,"  jse %scat%s <file>           tokenize and list file\n", G, N);
    jprintf(e,0,"  jse %seval%s <expr>          evaluate expression\n", G, N);
    jprintf(e,0,"  jse %ssyn%s <expr>           parse and print parse tree of expression\n", G, N);  
    jprintf(e,0,"  jse %stags%s <spec>          parse and generate tags\n", G, N);
    jprintf(e,0,"  jse                      interactive mode\n");
    jprintf(e,0,"  --%squiet%s (-q)             supress banners\n", M, N);
    jprintf(e,0,"  --%sfunctions%s (-fn)        list functions\n", M, N);
    jprintf(e,0,"  --%sverbose%s (-v)           detailed information\n", M, N);
    jprintf(e,0,"  --%swatcher%s (-w)           enable exec watcher\n", M, N);
    jprintf(e,0,"  --%scolors%s (-c)            ANSI term colors\n", M, N);
    jprintf(e,0,"  --%snocolors%s (-nc)         Disable ANSI term colors\n", M, N);    
    jprintf(e,0,"  --%slines%s (-l)             show lines in cat and run\n", M, N);
    jprintf(e,0,"  --%smemory%s (-m)            display detailed allocations on exit\n", M, N);      
    jprintf(e,0,"  --%sopmlUseLR%s              Use L/R parent nodes in OPML export\n", M, N);        
    jprintf(e,0,"  --%snoHeader%s               Don't display jse version header\n", M, N);      
    jprintf(e,0,"  --%sgithub%s                 Produce github ```javascript tags\n", M, N);            
    jprintf(e,0,"  --%sni%s                     Non-interactive mode for hosts\n", M, N);            
    jprintf(e,0,"  --%sopml %s                  use opml for syntax output\n", M, N);    
    jprintf(e,0,"  --%sstart%s=<n> (-s=<n>)     cat start line\n", M, N);
    jprintf(e,0,"  --%snum%s=<n> (-n=<n>)       cat number of lines\n", M, N);
    jprintf(e,0,"  --%smargin%s=<n> (-m=<n>     margin for watcher output\n", M, N);
    jprintf(e,0,"  --%sport%s=<n> (-p=<n>       port used for debugging\n", M, N);
    jprintf(e,0,"  --%sruntime%s (-r)           jse cat prints verbose runtime tokens\n", M, N); 
    jprintf(e,0,"  --%soutput%s=<file> (-o=<f>  redirect output to file\n", M, N);
    return 0;
}


int main(int argc, const char * argv[]) {
    Js e;
    JsInit(&e, FALSE);
    CmdArgsParse(&e, argc, argv);   

    int ret = 0;

    if(e.options.colors) {
        JsColors(&e, TRUE);
    }

    if(e.options.github) 
        jprintf(&e, 0, "```javascript\n");
    if(!e.options.quiet && !e.options.opml)
        MainAbout(&e);

    if(0 == strcmp(e.options.command, "repl")) {
        ret = MainRepl(&e);
    }
    else if(0 == strcmp(e.options.command, "cat")) {
        ret = MainCat(&e);
    }
    else if(0 == strcmp(e.options.command, "tags")) {
        ret = MainTags(&e);
    }
    else if(0 == strcmp(e.options.command, "syn")) {
        ret = MainSyn(&e);
    }    
    else if(0 == strcmp(e.options.command, "help")) {
        ret = MainHelp(&e);
    }
    else if(0 == strcmp(e.options.command, "test")) {
        ret = MainTest(&e);
    }
    else if(0 == strcmp(e.options.command, "eval")) {
        ret = MainEval(&e);
    }
    else if(0 == strcmp(e.options.command, "debug")) {
        ret = MainDebug(&e);
    }    
    else if(0 == strcmp(e.options.command, "run")) {
        ret = MainRun(&e);
    }
    if(e.options.github) 
        jprintf(&e, 0, "```\n");    

    JsClear(&e);


    return ret;
}
#endif // JSE_MAIN
/////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////
// Test infrastructure
#ifdef JSE_TEST

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

///////////// memory debugging md_



typedef struct {
    uint32 passed;
    uint32 failed;
    Js* js;
    bool_t verbose;
} test;

void test_init(Js* e, test* test) {
    test->passed = 0;
    test->failed = 0;
    test->js = e;
}


bool_t _ok(test* test, bool_t condition, char* desc, int line) {
    if(condition) {
        test->passed++;
    }
    else {
        test->failed++;
    }
    
    if(!test->verbose && condition)
        return condition;
    
    if(condition)
        jprintf(test->js,0,"%s%-62s %s%s\n", test->js->colors.normal, desc, test->js->colors.green,"  pass");
    else
        jprintf(test->js,0,"jse.c:%d %s%-50s %s%s\n", line, test->js->colors.normal, desc, test->js->colors.red, "  fail");

    return condition;
}

bool_t fail(test* test, char* desc) {
    return ok(test, FALSE, desc);
}

void CodePointTest(test* t) {
    uchar data1[] = { 0xA0 };
    uint32 cp;
    
    cp = GetUtf16CodePoint(data1);
    ok(t, cp == 0xA0, "6.1.4 GetUtf16CodePoint");
    
    uchar data2[] = { 0xD7FF, 0xE000, 0xFFFF };
    cp = GetUtf16CodePoint(data2);
    ok(t, cp == 0xD7FF, "6.1.4 GetUtf16CodePoint");
    cp = GetUtf16CodePoint(data2+1);
    ok(t, cp == 0xE000, "6.1.4 GetUtf16CodePoint");
    cp = GetUtf16CodePoint(data2+2);
    ok(t, cp == 0xFFFF, "6.1.4 GetUtf16CodePoint");
    uchar data3[] = { 0xD8FF, 0xDC7F };
    cp = GetUtf16CodePoint(data3);
    uint32 expected = (0xD8FF-0xD800) * 0x400 + (0xDC7F-0xDC00) + 0x10000;
    ok(t, cp == expected, "6.1.4 GetUtf16CodePoint");
}

void ValTest(test* t) {
    Val v;
    
    Js* e = t->js;
    
    int allocs = e->memory[VA].data->allocs;
    ValInit(&v);
    ok(t, v.type == TYPE_UNDEF, "Val.init");
    ValInitNum(&v, 3.14);
    ok(t, v.type == TYPE_NUM, "Val.init_num");
    ok(t, v.num == 3.14, "Val.all");
    ValInitNull(&v);
    ok(t, v.type == TYPE_NULL, "Val.init_null");
    ValInitBool(&v, TRUE);
    ok(t, v.b == TRUE, "Val.init_bool");
    ValInitStrA(t->js, &v, "hello");
    ok(t, v.type == TYPE_STR, "Val.init_stra");
    ok(t, StrEqChars(e, v.str, "hello"), "Val.init_stra");
    ValClear(t->js, &v);
    ok(t, v.type == TYPE_UNDEF, "Val.clear");
    
    Val* vp = ValNew(e);
    ok(t, vp->type == TYPE_UNDEF, "Val.new");
    ValDel(e, vp);
    ok(t, e->memory[VA].data->allocs==allocs, "Val._free");
    vp = ValNewNull(e);
    ok(t, vp->type == TYPE_NULL, "Val.new_null");
    ValDel(e, vp);
    vp = ValNewStrA(e, "hello");
    ok(t, StrEqChars(e, vp->str, "hello"), "Val.new_stra");
    ValDel(e, vp);
    ok(t, e->memory[VA].data->allocs==allocs, "Val._free");
    vp = ValNewBool(e, FALSE);
    ok(t, vp->b == FALSE, "Val.new_bool");
    ValDel(e, vp);
    
    // test assignment
    Val src, dest;
    ValInit(&src);
    ValInit(&dest);
    ValSet(e, &dest, &src);
    ok(t, dest.type == TYPE_UNDEF, "Val.set");
    ValInitBool(&src, FALSE);
    ValSet(e, &dest, &src);
    ok(t, dest.type == TYPE_BOOL, "Val.set");
    ok(t, dest.b == FALSE, "Val.set");
    ValInitNull(&src);
    ValSet(e, &dest, &src);
    ok(t, dest.type == TYPE_NULL, "Val.set");
    ValInitNum(&src, 3.14);
    ValSet(e, &dest, &src);
    ok(t, dest.type == TYPE_NUM, "Val.set");
    ok(t, dest.num == 3.14, "Val.set");
    ValInitStrA(e, &src, "string");
    ValSet(e, &dest, &src);
    ok(t, dest.type == TYPE_STR, "Val.set");
    ok(t, StrEqChars(e, dest.str, "string"), "Val.set");
    ValClear(e, &src);
    
    ValInitSymbol(e, &src, "symbol");
    ValSet(e, &dest, &src);
    ok(t, dest.type == TYPE_SYMA, "Val.set");
    ok(t, ValEqStrA(e, &dest, "symbol"), "Val.set");
    ValClear(e, &src);
    ValClear(e, &dest);
    ValClear(e, &v);
    
    vp = ValNewObject(e);
    ok(t, vp->type == TYPE_OBJ, "Val.init_obj");
    ValDel(e, vp);
    
    Val* v1 = ValNewNum(e, 2.34);
    Val* v2 = ValClone(e, v1);
    ok(t, v2->type == TYPE_NUM, "Val.clone0");
    ok(t, v2->num == 2.34, "Val.clone1");
    ValDel(e, v1);
    ValDel(e, v2);
}

void StrMapTest(test* t) {
    Js* e = t->js;
    Strmap* sm = StrmapNew(e, 1024, 3, sizeof(int), 2.0);
    if(sm == NULL) {
        ok(t, FALSE, "Strmap");
        return;
    }
    
    int Val = 1;
    StrmapPutA(e, sm, "Shark", &Val);
    Val = 2;
    StrmapPutA(e, sm, "Dolphin", &Val);
    Val = 3;
    StrmapPutA(e, sm, "Cuda", &Val);
    
    int* i = StrmapGetA(e, sm, "foo");
    if(i) goto err;
        
    i = StrmapGetA(e, sm, "Dolphin");
    if(!i) goto err;
    if(*i != 2) goto err;
    
    i = StrmapGetA(e, sm, "Shark");
    if(*i != 1)  goto err;
    
    StrmapDel(e, sm);
    ok(t, TRUE, "Strmap.all");
    return;
    
err:
    StrmapDel(e, sm);
    ok(t, FALSE, "Strmap.all");
}



void TkTest(test* t) {
    Js* e = t->js;
    Tokenizer* lex = TkNew(e);
    if(!lex) {
        ok(t, FALSE, "tk.create");
        return;
    }
    
    TkTokenizeA(e, lex, "...", 0, 0, 1);
    ok(t, TkGetTokKeyword(e, lex, 0) == id_dotdotdot, "tk.id_dotdotdot");

    TkTokenizeA(e, lex, "var x=20.1;", 0, 0, 1);
    ok(t, *((int*)StrmapGetA(e, e->keywords, "for")) == id_for, "tk.for_keyword");
    ok(t, *((int*)StrmapGetA(e, e->keywords, "var")) == id_var, "tk.var_keyword");
    ok(t, *((int*)StrmapGetA(e, e->keywords, "function")) == id_function, "tk.function_keyword");
    ok(t, TkGetLineCount(e, lex) == 1, "tk.get_line_count");
    ok(t, TkGetTokType(e, lex, 0) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokKeyword(e, lex, 0) == id_var, "tk.get_tok_keyword");
    ok(t, TkGetTokOffset(e, lex, 1) == 4, "tk.get_tok_offset");
    ok(t, TkGetTokLen(e, lex, 1) == 1, "tk.get_tok_len");
    ok(t, TkGetTokKeyword(e, lex, 2) == id_eq, "tk.get_tok_keyword");
    ok(t, TkGetTokNumVal(e, lex, 3) == 20.1, "tk.get_tok_numval");
    ok(t, TkGetTokKeyword(e, lex, 4) == id_semi, "tk.get_tok_keyword");


    //                   123456789012
    TkTokenizeA(e, lex, "hello='world",0,0,0);
    ok(t, TkHasError(e, lex), "tk.HasError");
    ok(t, TkGetErrorLine(e, lex) == 0, "tk.GetErrorLine");
    ok(t, TkGetErrorCol(e, lex) == 13, "tk.GetErrorLine");


    TkTokenizeA(e, lex, "s='hello world'; z='hello world'",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.TOK_IDENTIFIER");
    ok(t, TkGetTokKeyword(e, lex, 1) == id_eq, "tk.id_eq");
    ok(t, TkGetTokType(e, lex, 2) == TOK_STRLIT, "tk.TOK_STRLIT");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 2), "hello world"), "tk.get_tok_str");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 6), "hello world"), "tk.get_tok_str");
    

    TkTokenizeA(e, lex, "i=-2.4;",0,0,1);
    ok(t, TkGetTokNumVal(e, lex, 2) == -2.4, "tk.negative_num_const");

    TkTokenizeA(e, lex, "i=-0.6e-6;",0,0,1);
    ok(t, TkGetTokNumVal(e, lex, 2) == -0.6e-6, "tk.Num(-0.6e-6)");

                            //   01234 56789 0123
    TkTokenizeA(e, lex, "a=1;\nb=2;\nc=3;",0,0,0);
    ok(t, TkGetLineCount(e, lex) == 3, "tk.multi_line_count");
    ok(t, TkGetLineStartTok(e, lex, 0) == 0, "tk.get_line_start_tok");
    ok(t, TkGetLineEndTok(e, lex, 0) == 4, "tk.get_line_end_tok");
    ok(t, TkGetLineStartTok(e, lex, 1) == 5, "tk.get_line_start_tok");
    ok(t, TkGetLineEndTok(e, lex, 1) == 9, "tk.get_line_end_tok");
    ok(t, TkGetLineStartTok(e, lex, 2) == 10, "tk.get_line_start_tok");
    ok(t, TkGetLineEndTok(e, lex, 2) == 14, "tk.get_line_end_tok");
    
    //                    01234 56789012 34 5 6789
    TkTokenizeA(e, lex, "a=1;\n   b=2;\n \n\nc=3;",0,0,1);
    ok(t, TkGetLineCount(e, lex) == 5, "tk.get_line_offset");
    ok(t, TkGetLineOffset(e, lex, 0) == 0, "tk.get_line_offset");
    ok(t, TkGetLineLen(e, lex, 0) == 5, "tk.get_line_len");
    ok(t, TkGetLineOffset(e, lex, 1) == 5, "tk.get_line_offset");
    ok(t, TkGetLineLen(e, lex, 1) == 8, "tk.get_line_len");
    ok(t, TkGetLineOffset(e, lex, 2) == 13, "tk.get_line_offset");
    ok(t, TkGetLineLen(e, lex, 2) == 2, "tk.get_line_len");
    ok(t, TkGetLineOffset(e, lex, 3) == 15, "tk.get_line_offset");
    ok(t, TkGetLineLen(e, lex, 3) == 1, "tk.get_line_len");
    ok(t, TkGetLineOffset(e, lex, 4) == 16, "tk.get_line_offset");
    ok(t, TkGetLineLen(e, lex, 4) == 4, "tk.get_line_len");

    TkTokenizeA(e, lex, "hello; Myhello; helo; myword",0,0,1);
    Vector* matches = TkMatchA(e, lex, 0, "hello",0);
    Str* match = VectorNextStr(e, matches, NULL);
    ok(t, StrEqChars(e, match, "hello"), "tk.matcha");
    match = VectorNextStr(e, matches, match);
    ok(t, StrEqChars(e, match, "Myhello"), "tk.next_str");
    match = VectorNextStr(e, matches, match);
    ok(t, match == NULL, "tk.next_str");
    
    matches = TkMatchA(e, lex, 0, "he",0);
    match = VectorNextStr(e, matches, NULL);
    ok(t, StrEqChars(e, match, "hello") , "tk.next_str");
    match = VectorNextStr(e, matches, match);
    ok(t, StrEqChars(e, match, "helo") , "tk.next_str");
    match = VectorNextStr(e, matches, match);
    ok(t, StrEqChars(e, match, "Myhello") , "tk.next_str");
    match = VectorNextStr(e, matches, match);
    ok(t, match == NULL, "tk.all");
    
    // @note - for some reason, the matches are coming in
    // reversed for MATCH_NO_CASE
    TkTokenizeA(e, lex, "HeLlo; MyhellO; helo; myWord",0,0,1);
    matches = TkMatchA(e, lex, 0, "hello",MATCH_NO_CASE);
    match = VectorNextStr(e, matches, NULL);
    ok(t, StrEqChars(e, match, "MyhellO"), "tk.next_str(NO_CASE)");
    match = VectorNextStr(e, matches, match);
    ok(t, StrEqChars(e, match, "HeLlo"), "tk.matcha(NO_CASE)");     


    //                    01234 56789012 34 5 6789
    TkTokenizeA(e, lex, "a=1;\n   b=2;\n \n\nc=3;",0,0,1);
    int tok = TkGetTokFromOffset(e, lex, 5);
    ok(t, tok == TOK_NOT_FOUND, "tk.TOK_NOT_FOUND");
    tok = TkGetTokFromOffset(e, lex, 19);
    ok(t, TkGetTokKeyword(e, lex, tok) == id_semi, "tk.get_tok_from_offset");
    
    //                01234 56789 0123
    TkTokenizeA(e, lex, "a=1;\nb=2;\nc=3;",0,0,0);
    ok(t, TkGetPrevTok(e, lex,0,1) == TOK_NOT_FOUND, "tk.get_prev_tok");
    ok(t, TkGetPrevTok(e, lex,1,1) == 0, "tk.get_prev_tok");
    ok(t, TkGetPrevTok(e, lex,5,1) == 3, "tk.get_prev_tok");
    ok(t, TkGetPrevTok(e, lex,5,0) == 4, "tk.get_prev_tok");
    ok(t, TkGetNextTok(e, lex,8,1) == 10, "tk.get_prev_tok");
    ok(t, TkGetNextTok(e, lex,8,1) == 10, "tk.get_prev_tok");
    ok(t, TkGetNextTok(e, lex,13,0) == 14, "tk.get_prev_tok");
    ok(t, TkGetNextTok(e, lex,13,1) == TOK_NOT_FOUND, "tk.get_prev_tok");
        
    // Test empty string
    TkTokenizeA(e, lex, "",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 1, "tk.empty_string");
    
    //  Get_tokCount test
    TkTokenizeA(e, lex, "a=1;\n   b=2;\n \n\nc=3;",0,0,0);
    ok(t, TkGetTokCount(e, lex, 0) == 5, "tk.get_tok_count");
    ok(t, TkGetTokCount(e, lex, 1) == 5, "tk.get_tok_count");
    ok(t, TkGetTokCount(e, lex, 2) == 1, "tk.get_tok_count");
    ok(t, TkGetTokCount(e, lex, 3) == 1, "tk.get_tok_count");
    ok(t, TkGetTokCount(e, lex, 4) == 5, "tk.get_tok_count");

    // TKGetNextFunc_tok test
                //               012345678       9012        3   45678
    int next=0;
    TkTokenizeA(e, lex, "a=1;x.y=function();function test;{m:function()}",0,0,1);
    ok(t, TkGetNextFuncTok(e, lex, 0,&next) == 6, "tk.get_next_func_tok");
    ok(t, TkGetNextFuncTok(e, lex, next,&next) == 13, "tk.get_next_func_tok");
    ok(t, TkGetNextFuncTok(e, lex, next,&next) == 16, "tk.get_next_func_tok");
    ok(t, TkGetNextFuncTok(e, lex, next,&next) == TOK_NOT_FOUND, "tk.get_next_func_tok");

    //  TkTokenizeOutline test1
    TkTokenizeOutlineA(e, lex, "A0\nB0\n C1\n  D2\nE0\n F1\n    G4",0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.outlinea1");
    ok(t, TkGetTokType(e, lex, 2) == TOK_IDENTIFIER, "tk.outlinea1");
    ok(t, TkGetTokType(e, lex, 4) == TOK_KEYWORD, "tk.outlinea1");
    ok(t, TkGetTokType(e, lex, 6) == TOK_NUMLIT, "tk.outlinea1");
    ok(t, TkGetTokType(e, lex, 8) == TOK_IDENTIFIER, "tk.outlinea1");
    ok(t, TkGetTokType(e, lex, 10) == TOK_KEYWORD, "tk.outlinea1");
    ok(t, TkGetTokType(e, lex, 12) == TOK_COMMENT, "tk.outlinea1");

    //  TkTokenizeOutline test2
    TkTokenizeOutlineA(e, lex, "0\n B",0,1);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.outlinea20");
    ok(t, TkGetTokType(e, lex, 2) == TOK_KEYWORD, "tk.outlinea21");
    ok(t, TkGetTokCount(e, lex, 1) != 4, "tk.outlinea22");
    ok(t, TkGetLineCount(e, lex) == 2, "tk.outlinea23");

    //                           0123456  78
    TkTokenizeA(e, lex, "a(b(),'c');",0,0,0);
    ok(t, TkGetTokCount(e, lex, 0) == 10, "tk.all");
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.get_tok_count");
    ok(t, TkGetTokType(e, lex, 1) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokType(e, lex, 2) == TOK_IDENTIFIER, "tk.get_tok_type");
    ok(t, TkGetTokType(e, lex, 3) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokType(e, lex, 4) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokLen(e, lex, 4) == 1, "tk.get_tok_len");
    ok(t, TkGetTokType(e, lex, 5) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokLen(e, lex, 5) == 1, "tk.get_tok_len");
    ok(t, TkGetTokType(e, lex, 6) == TOK_STRLIT, "tk.get_tok_type");
    ok(t, TkGetTokLen(e, lex, 6) == 3, "tk.get_tok_len");
    ok(t, TkGetTokType(e, lex, 7) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokKeyword(e, lex, 7) == id_rpar, "tk.get_tok_keyword");
    ok(t, TkGetTokType(e, lex, 8) == TOK_KEYWORD, "tk.get_tok_type");
    ok(t, TkGetTokKeyword(e, lex, 8) == id_semi, "tk.get_tok_keyword");
    
                            //   0123456789012345678901
    TkTokenizeA(e, lex, "// word1 word2,word3\n",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 6, "tk.tokenize_comment_word_count");
    ok(t, TkGetTokType(e, lex, 0) == TOK_COMMENT, "tk.tokenize_comment_word0_type");
    ok(t, TkGetTokOffset(e, lex, 0) == 0, "tk.tokenize_comment_word0_offset");
    ok(t, TkGetTokLen(e, lex, 0) == 2, "tk.tokenize_comment_word0_len");
    ok(t, TkGetTokType(e, lex, 1) == TOK_COMMENT, "tk.tokenize_comment_word1_type");
    ok(t, TkGetTokOffset(e, lex, 1) == 3, "tk.tokenize_comment_word1_offset");
    ok(t, TkGetTokLen(e, lex, 1) == 5, "tk.tokenize_comment_word1_len");
    ok(t, TkGetTokType(e, lex, 2) == TOK_COMMENT, "tk.tokenize_comment_word2_type");
    ok(t, TkGetTokOffset(e, lex, 2) == 9, "tk.tokenize_comment_word2_offset");
    ok(t, TkGetTokLen(e, lex, 2) == 5, "tk.tokenize_comment_word2_len");
    ok(t, TkGetTokType(e, lex, 3) == TOK_COMMENT, "tk.tokenize_comment_word3_type");
    ok(t, TkGetTokOffset(e, lex, 3) == 14, "tk.tokenize_comment_word3_offset");
    ok(t, TkGetTokLen(e, lex, 3) == 1, "tk.tokenize_comment_word3_len");
    ok(t, TkGetTokType(e, lex, 4) == TOK_COMMENT, "tk.tokenize_comment_word4_type");
    ok(t, TkGetTokOffset(e, lex, 4) == 15, "tk.tokenize_comment_word4_offset");
    ok(t, TkGetTokLen(e, lex, 4) == 5, "tk.tokenize_comment_word4_len");
    ok(t, TkGetTokType(e, lex, 5) == TOK_LINETERM, "tk.tokenize_comment_word5_type");
    ok(t, TkGetTokOffset(e, lex, 5) == 20, "tk.tokenize_comment_word5_offset");
    ok(t, TkGetTokLen(e, lex, 5) == 1, "tk.tokenize_comment_word5_len");

                     //   0123456789012345 678901
    TkTokenizeA(e, lex, "/* word1, word2\nhello*/",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 5, "tk.tokenize_mcomment_line0_count");
    // Tokenizer will add a lineterm token at the end of the file
    ok(t, TkGetTokCount(e, lex, 1) == 3, "tk.tokenize_mcomment_line1_count");
    ok(t, TkGetTokType(e, lex, 0) == TOK_COMMENT, "tk.tokenize_mcomment_word0_type");
    ok(t, TkGetTokOffset(e, lex, 0) == 0, "tk.tokenize_mcomment_word0_offset");
    ok(t, TkGetTokLen(e, lex, 0) == 2, "tk.tokenize_mcomment_word0_len");
    ok(t, TkGetTokType(e, lex, 1) == TOK_COMMENT, "tk.tokenize_mcomment_word1_type");
    ok(t, TkGetTokOffset(e, lex, 1) == 3, "tk.tokenize_mcomment_word1_offset");
    ok(t, TkGetTokLen(e, lex, 1) == 5, "tk.tokenize_mcomment_word1_len");
    ok(t, TkGetTokType(e, lex, 2) == TOK_COMMENT, "tk.tokenize_mcomment_word2_type");
    ok(t, TkGetTokOffset(e, lex, 2) == 8, "tk.tokenize_mcomment_word2_offset");
    ok(t, TkGetTokLen(e, lex, 2) == 1, "tk.tokenize_mcomment_word2_len");
    ok(t, TkGetTokType(e, lex, 3) == TOK_COMMENT, "tk.tokenize_mcomment_word3_type");
    ok(t, TkGetTokOffset(e, lex, 3) == 10, "tk.tokenize_mcomment_word3_offset");
    ok(t, TkGetTokLen(e, lex, 3) == 5, "tk.tokenize_mcomment_word3_len");
    ok(t, TkGetTokType(e, lex, 4) == TOK_LINETERM, "tk.tokenize_mcomment_word4_type");
    ok(t, TkGetTokOffset(e, lex, 4) == 15, "tk.tokenize_mcomment_word4_offset");
    ok(t, TkGetTokLen(e, lex, 4) == 1, "tk.tokenize_mcomment_word4_len");
    ok(t, TkGetTokType(e, lex, 5) == TOK_COMMENT, "tk.tokenize_mcomment_word5_type");
    ok(t, TkGetTokOffset(e, lex, 5) == 16, "tk.tokenize_mcomment_word5_offset");
    ok(t, TkGetTokLen(e, lex, 5) == 5, "tk.tokenize_mcomment_word5_len");
    ok(t, TkGetTokType(e, lex, 6) == TOK_COMMENT, "tk.tokenize_mcomment_word6_type");
    ok(t, TkGetTokOffset(e, lex, 6) == 21, "tk.tokenize_mcomment_word6_offset");
    ok(t, TkGetTokLen(e, lex, 6) == 2, "tk.tokenize_mcomment_word6_len");

                    //    0123456789012345
    TkTokenizeA(e, lex, "// hello 123,456",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 6, "tk.tokenize_comment_num_count");
    ok(t, TkGetTokType(e, lex, 0) == TOK_COMMENT, "tk.tokenize_comment_num0_type");
    ok(t, TkGetTokOffset(e, lex, 0) == 0, "tk.tokenize_comment_num0_offset");
    ok(t, TkGetTokLen(e, lex, 0) == 2, "tk.tokenize_comment_num0_len");
    ok(t, TkGetTokType(e, lex, 1) == TOK_COMMENT, "tk.tokenize_comment_num1_type");
    ok(t, TkGetTokOffset(e, lex, 1) == 3, "tk.tokenize_comment_num1_offset");
    ok(t, TkGetTokLen(e, lex, 1) == 5, "tk.tokenize_comment_num1_len");
    ok(t, TkGetTokType(e, lex, 2) == TOK_COMMENT, "tk.tokenize_comment_num2_type");
    ok(t, TkGetTokOffset(e, lex, 2) == 9, "tk.tokenize_comment_num2_offset");
    ok(t, TkGetTokLen(e, lex, 2) == 3, "tk.tokenize_comment_num2_len");
    ok(t, TkGetTokType(e, lex, 3) == TOK_COMMENT, "tk.tokenize_comment_num3_type");
    ok(t, TkGetTokOffset(e, lex, 3) == 12, "tk.tokenize_comment_num3_offset");
    ok(t, TkGetTokLen(e, lex, 3) == 1, "tk.tokenize_comment_num3_len");
    ok(t, TkGetTokType(e, lex, 4) == TOK_COMMENT, "tk.tokenize_comment_num2_type");
    ok(t, TkGetTokOffset(e, lex, 4) == 13, "tk.tokenize_comment_num2_offset");
    ok(t, TkGetTokLen(e, lex, 4) == 3, "tk.tokenize_comment_num2_len");


                    //    0123456789012345
    TkTokenizeA(e, lex, "a='word1, word2'",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 8, "tk.tokenize_str_color_count");
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.tokenize_str_color0_type");
    ok(t, TkGetTokType(e, lex, 1) == TOK_KEYWORD, "tk.tokenize_str_color1_type");
    ok(t, TkGetTokType(e, lex, 2) == TOK_STRLIT, "tk.tokenize_str_color2_type");
    ok(t, TkGetTokOffset(e, lex, 2) == 2, "tk.tokenize_str_color2_offset");
    ok(t, TkGetTokLen(e, lex, 2) == 1, "tk.tokenzie_str_color2_len");

                    //    01234567890 12345
    TkTokenizeA(e, lex, "a='word1, \\'word2'",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 9, "tk.tokenize_str_esc_color_count");
    ok(t, TkGetTokType(e, lex, 5) == TOK_STRLIT, "tk.tokenize_str_esc_color5_type");
    ok(t, TkGetTokOffset(e, lex, 5) == 10, "tk.tokenize_str_esc_color5_offset");
    ok(t, TkGetTokLen(e, lex, 5) == 2, "tk.tokenzie_str_esc_color5_len");

                    //    0123456789012345678901234567890123 4567890123456789012
    TkTokenizeA(e, lex, "#pragma clang diagnostic ignored \"-Wshorten-64-to-32\"",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 16, "tk.tokenize_str_cpp_color_count");


    TkTokenizeA(e, lex, "// abcdef",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 3, "tk.tokenize_simple_count");
    ok(t, TkGetTokType(e, lex, 0) == TOK_COMMENT, "tk.tokenize_simple0_type");
    ok(t, TkGetTokOffset(e, lex, 0) == 0, "tk.tokenize_simple0_offset");
    ok(t, TkGetTokLen(e, lex, 0) == 2, "tk.tokenzie_str_simple0_len");
    ok(t, TkGetTokType(e, lex, 1) == TOK_COMMENT, "tk.tokenize_simple1_type");
    ok(t, TkGetTokOffset(e, lex, 1) == 3, "tk.tokenize_simple1_offset");
    ok(t, TkGetTokLen(e, lex, 1) == 6, "tk.tokenzie_str_simple1_len");
    // ok(t, TkGetTokType(e, lex, 2) == TOK_LINETERM, "tk.tokenize_simple2_type");

    TkTokenizeA(e, lex, "{ x = 20; }",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 7, "tk.get_matching_tok_count");
    ok(t, TkGetMatchingTok(e, lex, 1) == 5, "tk.get_matching_tok_not_keyword");
    ok(t, TkGetMatchingTok(e, lex, 0) == 5, "tk.get_matching_tok_forward");
    ok(t, TkGetMatchingTok(e, lex, 5) == 0, "tk.get_matching_tok_back");

    TkTokenizeA(e, lex, " x[1,[2,3]]",0,0,1);
    ok(t, TkGetTokCount(e, lex, 0) == 11, "tk.get_matching_nested_tok_count");
    ok(t, TkGetMatchingTok(e, lex, 1) == 9, "tk.get_matching_nested_tok_forward1");
    ok(t, TkGetMatchingTok(e, lex, 9) == 1, "tk.get_matching_nested_tok_back1");
    ok(t, TkGetMatchingTok(e, lex, 4) == 8, "tk.get_matching_nested_tok_forward2");
    ok(t, TkGetMatchingTok(e, lex, 8) == 4, "tk.get_matching_nested_tok_back2");

    TkTokenizeA(e, lex, "x.func().foo()",0,0,1);
    ok(t, TkGetNextKeyword(e, lex, 0, id_dot) == 1, "tk.get_next_keyword0");
    ok(t, TkGetNextKeyword(e, lex, 1, id_dot) == 5, "tk.get_next_keyword1");
    ok(t, TkGetNextKeyword(e, lex, 5, id_dot) == TOK_NOT_FOUND, "tk.get_next_keyword2");
    ok(t, TkGetPrevKeyword(e, lex, 1, id_dot) == TOK_NOT_FOUND, "tk.get_prev_keyword0");
    ok(t, TkGetPrevKeyword(e, lex, 5, id_dot) == 1, "tk.get_prev_keyword1");
    ok(t, TkGetPrevKeyword(e, lex, 8, id_dot) == 5, "tk.get_prev_keyword2");

    TkTokenizeA(e, lex, "x.func().foo()",0,0,1);
    ok(t, TkGetNextDot(e, lex, 0) == 1, "tk.get_next_dot0");
    ok(t, TkGetNextDot(e, lex, 1) == 5, "tk.get_next_dot1");
    ok(t, TkGetNextDot(e, lex, 5) == TOK_NOT_FOUND, "tk.get_next_dot2");
    ok(t, TkGetPrevDot(e, lex, 1) == TOK_NOT_FOUND, "tk.get_prev_dot0");
    ok(t, TkGetPrevDot(e, lex, 5) == 1, "tk.get_prev_dot1");
    ok(t, TkGetPrevDot(e, lex, 8) == 5, "tk.get_prev_dot2");

    TkTokenizeA(e, lex, "/**\n*  call 'make' in the \n*/",0,0,1);
    ok(t, TkGetTokType(e, lex, 0) == TOK_COMMENT, "tk./**");
    
    TkTokenizeA(e, lex, "x = 0;\ny",0,0,1);
    ok(t, TkGetTokCol(e, lex, 0) == 0, "tk.get_tok_col");
    ok(t, TkGetTokCol(e, lex, 1) == 2, "tk.get_tok_col");
    ok(t, TkGetTokCol(e, lex, 2) == 4, "tk.get_tok_col");
    ok(t, TkGetTokCol(e, lex, 4) == 6, "tk.get_tok_col");
    ok(t, TkGetTokCol(e, lex, 5) == 0, "tk.get_tok_col");
    

    TkTokenizeA(e, lex, "//!!!!",0,0,1);
    ok(t, TkGetTokCol(e, lex, 1) == 2, "tk.get_tok_col");

    TkTokenizeA(e, lex, "z = { x = 20; } m (  { hello ) z",0,0,1);
    ok(t, TkGetMatchingTok(e, lex, 0) == 7, "tk.get_matching_tok_not_keyword");
    ok(t, TkGetMatchingTok(e, lex, 2) == 7, "tk.get_matching_tok_not_open");
    ok(t, TkGetMatchingTok(e, lex, 8) == 12, "tk.get_matching_tok_skip");

    TkTokenizeA(e, lex, "x = 30",0,0,1);
    ok(t, TkGetTokCount(e, lex, -1) == 0, "tk.get_tok_count(bad_line)");
    ok(t, TkGetTokIndex(e, lex, -1, 0) == TOK_NOT_FOUND, "tk.get_tok_index(bad_line");
    ok(t, TkGetTokIndex(e, lex, 0, -1) == TOK_NOT_FOUND, "tk.get_tok_index(bad_tok");
    ok(t, TkGetTokLine(e, lex, -1) == TOK_NOT_FOUND, "tk.get_tok_line(bad_tok)");
    ok(t, TkGetTokOffset(e, lex, -1) == TOK_NOT_FOUND, "tk.get_tok_offset(bad_tok)");
    ok(t, TkGetTokLen(e, lex, -1) ==TOK_NOT_FOUND, "tk.get_tok_len(bad_tok)");
    ok(t, TkGetTokType(e, lex, -1) == TOK_NOT_FOUND, "tk.get_tok_type(bad_tok)");
    ok(t, TkGetTokKeyword(e, lex, -1) == TOK_NOT_FOUND, "tk.get_tok_keyword(bad_tok)");
    ok(t, TkGetTokCol(e, lex, -1) == TOK_NOT_FOUND, "tk.get_tok_col(bad_tok)");
    ok(t, TkGetTokNumVal(e, lex, -1) == 0, "tk.get_tok_numval(bad_tok)");
    ok(t, TkGetTokStr(e, lex, -1) == NULL, "tk.get_tok_str(bad_tok)");
    ok(t, TkGetPrevTok(e, lex, -1, 0) == TOK_NOT_FOUND, "tk.get_prev_tok(bad_tok)");
    ok(t, TkGetNextTok(e, lex, -1, 0) == TOK_NOT_FOUND, "tk.get_next_tok(bad_tok)");
    ok(t, TkGetMatchingTok(e, lex, -1) == TOK_NOT_FOUND, "tk.get_matching_tok(bad_tok)");
    ok(t, TkGetPrevKeyword(e,lex, -1, 0) == TOK_NOT_FOUND, "tk.get_prev_keyword(bad_tok)");
    ok(t, TkGetNextKeyword(e, lex, -1, 0) == TOK_NOT_FOUND, "tk.get_next_keyword(bad_tok)");
    ok(t, TkIsPunctuator(e, lex, -1) == FALSE, "tk.is_puncuator(bad_tok)");
    ok(t, TkIsDivPunctuator(e, lex, -1) == FALSE, "tk.is_div_puncuator(bad_tok)");
    ok(t, TkIsRightBracePunctuator(e, lex, -1) == FALSE, "tk.is_brace_puncuator(bad_tok)");
    ok(t, TkIsPunctuator(e, lex, -1) == FALSE, "tk.is_any_puncuator(bad_tok)");


    TkTokenizeA(e, lex, "x = 30",0,0,1);
    int tt = TkGetLineStartTok(e, lex, 0);
    ok(t, tt == 0, "tk.get_line_start_tok(0)");
    ok(t, TkGetTokLine(e, lex, tt) == 0, "tk.get_tok_line(0)");

    TkTokenizeA(e, lex, "( word )",0,0,1);
    ok(t, TkGetMatchingTok(e, lex, 1) == 2, "tk.get_matching_tok('(word), 1)");

    TkTokenizeA(e, lex, "( word ) word",0,0,1);
    ok(t, TkGetMatchingTok(e, lex, 3) == TOK_NOT_FOUND, "tk.get_matching_tok('(word) word, 3)");

    ok(t, TkIsSpace(lex, TOK_BOM), "tk.TkIsSpace(BOM)");

    TkTokenizeA(e, lex, "\"",0,0,1);
    ok(t, TkGetTokType(e, lex, 0) == TOK_STRLIT, "tk.tokenize('\"').Type0");
    // ok(t, TkGetTokType(e, lex, 1) == TOK_LINETERM, "tk.tokenize('\"').Type1");
    ok(t, TkGetTokCount(e, lex, 0) == 2, "tk.tokenize('\"').Count");

    TkTokenizeA(e, lex, "/*",0,0,1);
    ok(t, TkGetTokType(e, lex, 0) == TOK_COMMENT, "tk.tokenize('/*').Type0");
    // ok(t, TkGetTokType(e, lex, 1) == TOK_LINETERM, "tk.tokenize('/*').Type1");    
    ok(t, TkGetTokCount(e, lex, 0) == 2, "tk.tokenize('/*').Count");

    Str* s = StrNewLength(e, 2);
    s->chars[0] = 'x';
    s->chars[1] = TOK_ZWJ;
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.tokenize('xZWJ') identifier");

    s = StrNewLength(e,2);  // tokenizer will delete old string
    s->chars[0] = 'y';
    s->chars[1] = TOK_ZWNJ;
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.tokenize('yZWNJ') identifier");

    s = StrNewLength(e,2);  // tokenizer will delete old string
    s->chars[0] = '1';
    s->chars[1] = 'X';
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_NUMLIT, "tk.tokenize('1X') number");
    ok(t, TkGetTokType(e, lex, 1) == TOK_IDENTIFIER, "tk.tokenize('1X') identifier");

    ok(t, TkIsLineTerm(0x2028), "tk.LineTerm(0x2028)");
    ok(t, !TkIsLineTerm(TOK_BOM), "tk.LineTerm(0x2028)");
    ok(t, TkIsSpace(lex, 0x3000), "tk.Space(0x3000)");

    s = StrNewLength(e,2);  // tokenizer will delete old string
    s->chars[0] = 0x0A;
    s->chars[1] = 'X';
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_LINETERM, "tk.tokenize('\\rX') LineTerm");
    ok(t, TkGetTokType(e, lex, 1) == TOK_IDENTIFIER, "tk.tokenize('\\rX') identifier");
    ok(t, TkGetTokType(e, lex, 2) == TOK_LINETERM, "tk.tokenize('\\rX') LineTerm");

    s = StrNewLength(e,3);  // tokenizer will delete old string
    s->chars[0] = 0x0A;
    s->chars[1] = 0x0D;
    s->chars[2] = 'X';
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_LINETERM, "tk.tokenize('\\r\\nX') lineterm");
    ok(t, TkGetTokType(e, lex, 1) == TOK_IDENTIFIER, "tk.tokenize('\\r\\nX') identifier");    

    TkTokenizeA(e, lex, "x=2;//hello\ny=3;",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.SingleLineCommentAsLineTerm0");
    ok(t, TkGetTokType(e, lex, 4) == TOK_LINETERM, "tk.SingleLineCommentAsLineTerm4");
    ok(t, TkGetTokCount(e, lex, 5) == TOK_IDENTIFIER, "tk.SingleLineCommentAsLineTerm5");

    TkTokenizeA(e, lex, "x=2;//hello\r\ny=3;",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.SingleLineCommentAsLineTermCRLF0");
    ok(t, TkGetTokType(e, lex, 4) == TOK_LINETERM, "tk.SingleLineCommentAsLineTermCRLF4");
    ok(t, TkGetTokCount(e, lex, 5) == TOK_IDENTIFIER, "tk.SingleLineCommentAsLineTermCRLF5");

    TkTokenizeA(e, lex, "x=2;/*hello*/y=3;",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.MultiLineCommentNoLineTerm0");
    ok(t, TkGetTokCount(e, lex, 4) == TOK_IDENTIFIER, "tk.MultiLineCommentNoLineTerm4");

    TkTokenizeA(e, lex, "x=2;/*hello\n*/y=3;",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.MultiLineCommentOneLineTerm0");
    ok(t, TkGetTokType(e, lex, 4) == TOK_LINETERM, "tk.MultiLineCommentOneLineTerm4");
    ok(t, TkGetTokCount(e, lex, 5) == TOK_IDENTIFIER, "tk.MultiLineCommentOneLineTerm5");

    TkTokenizeA(e, lex, "x=2;/*hello\nworld\nyes\n*/y=3;",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.MultiLineCommentMultiLineTerm0");
    ok(t, TkGetTokType(e, lex, 4) == TOK_LINETERM, "tk.MultiLineCommentMultiLineTerm4");
    ok(t, TkGetTokCount(e, lex, 5) == TOK_IDENTIFIER, "tk.MultiLineCommentMultiLineTerm5");

    TkTokenizeA(e, lex, "$=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier($)");
    TkTokenizeA(e, lex, "_=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(_)");
    TkTokenizeA(e, lex, "$x=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier($x)");
    TkTokenizeA(e, lex, "_x=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(_x)");
    TkTokenizeA(e, lex, "$1=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier($1)");
    TkTokenizeA(e, lex, "_1=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(_1)");
    TkTokenizeA(e, lex, "x$=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(x$)");
    TkTokenizeA(e, lex, "x_=1", 0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(x_)");

    s = StrNewLength(e,1); 
    s->chars[0] = TOK_ZWNJ;
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) != TOK_IDENTIFIER, "tk.Identifier(ZWNJ)");
    s = StrNewLength(e,1);  // tokenizer will delete old string
    s->chars[0] = TOK_ZWJ;
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) != TOK_IDENTIFIER, "tk.Identifier(ZWJ)");

    s = StrNewLength(e,2); 
    s->chars[0] = 'x';
    s->chars[1] = TOK_ZWNJ;
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(xZWNJ)");
    s = StrNewLength(e,2); 
    s->chars[0] = 'x';
    s->chars[1] = TOK_ZWJ;
    TkTokenizeS(e, lex, s, 0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.Identifier(xZWJ)");

    TkTokenizeA(e, lex, "x\\uhello",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.IdentifierUnicodeHex4Invalid");
    ok(t, TkHasError(e, lex), "tk.IdentifierUnicodeHex4Invalid");

    TkTokenizeA(e, lex, "x\\u0065",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.IdentifierUnicodeHex4Valid");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 0), "xe"), "tk.IdentifierUnicodeHex4Valid");
    ok(t, !TkHasError(e, lex), "tk.IdentifierUnicodeHex4Valid");

    TkTokenizeA(e, lex, "x\\u0065z",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.IdentifierUnicodeHex4Valid");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 0), "xez"), "tk.IdentifierUnicodeHex4Valid");
    ok(t, !TkHasError(e, lex), "tk.IdentifierUnicodeHex4Valid");

    TkTokenizeA(e, lex, "x\\u{65}",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.IdentifierUnicodeHexValid");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 0), "xe"), "tk.IdentifierUnicodeHexValid");
    ok(t, !TkHasError(e, lex), "tk.IdentifierUnicodeHex4Valid");

    TkTokenizeA(e, lex, "\\u0065z",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.IdentifierUnicodeHex4StartValid");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 0), "ez"), "tk.IdentifierUnicodeHex4StartValid");
    ok(t, !TkHasError(e, lex), "tk.IdentifierUnicodeHex4StartValid");    
    
    TkTokenizeA(e, lex, "0b1010",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_NUMLIT, "tk.BinaryIntegerLiteral.Parse");
    ok(t, TkGetTokNumVal(e, lex,0) == 10, "tk.BinaryIntegerLiteral.Value");

    TkTokenizeA(e, lex, "0o710",0,0,0);
    ok(t, TkGetTokType(e, lex, 0) == TOK_NUMLIT, "tk.OctalIntegerLiteral.Parse");
    ok(t, TkGetTokNumVal(e, lex,0) == 456, "tk.OctalIntegerLiteral.Value");


    TkTokenizeA(e, lex, "x='x\\0y'",0,0,0);
    ok(t, TkGetTokStr(e, lex,2)->chars[0] == 'x', "tk.StringLiteralEscape0");
    ok(t, TkGetTokStr(e, lex,2)->chars[1] == 0, "tk.StringLiteralEscape1");    
    ok(t, TkGetTokStr(e, lex,2)->chars[2] == 'y', "tk.StringLiteralEscape2");        

    TkTokenizeA(e, lex, "x='x\\u{65}y'",0,0,0);
    ok(t, TkGetTokStr(e, lex,2)->chars[0] == 'x', "tk.StringLiteralHexEscape0");
    ok(t, TkGetTokStr(e, lex,2)->chars[1] == 'e', "tk.StringLiteralHexEscape1");    
    ok(t, TkGetTokStr(e, lex,2)->chars[2] == 'y', "tk.StringLiteralHexEscape2");  

    TkTokenizeA(e, lex, "x='hel\\\no\\\n\r2'",0,0,0);
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 2), "helo2"), "tk.StringLiteralLineContinuation");

    TkTokenizeA(e, lex, "x=/something/i;",0,0,0);
    ok(t, TkGetTokType(e,lex,2) == TOK_REGEX, "tk.RegExp.0");

    TkTokenizeA(e, lex, "x=/something/ig;",0,0,0);
    ok(t, TkGetTokType(e,lex,2) == TOK_REGEX, "tk.RegExp.0");    

    TkTokenizeA(e, lex, "x=/(?:)/", 0,0,0);
    ok(t, TkGetTokType(e,lex,2) == TOK_REGEX, "tk.RegExp.1");

    // Begin tests from Craig
    TkTokenizeA(e, lex, "\n", 0,0,1);
    ok(t, TkGetLineCount(e,lex) == 2, "tk.LinefeedLineCount");
    ok(t, TkGetLineFromOffset(e,lex,0) == 0, "tk.LinefeedLineFromOffset");
    ok(t, TkGetLineOffset(e,lex,0) == 0, "tk.LinefeedLastLineOffset");
   
    TkTokenizeA(e, lex, "", 0,0,0);
    ok(t, TkGetLineCount(e,lex) == 0, "tk.EmptyFileLineCount");
    ok(t, TkGetLineFromOffset(e,lex,0) == TOK_NO_LINE, "tk.SpacelineLineFromOffset");
    ok(t, TkGetLineOffset(e,lex,0) == -1, "tk.SpaceLineOffset");
   
    TkTokenizeA(e, lex, " ", 0,0,1);
    ok(t, TkGetLineCount(e,lex) == 1, "tk.SpacelineLineCount");
    ok(t, TkGetLineFromOffset(e,lex,0) == 0, "tk.SpacelineLineFromOffset");
    ok(t, TkGetLineOffset(e,lex,0) == 0, "tk.SpaceLineOffset");
   // End tests from Craig

    TkTokenizeA(e, lex, "reallyLongWordToTestWith", 0,0,0);

    // Colorizer breaks the words inside the template literal
    TkTokenizeA(e, lex, "x=`hello`;",0,0,1);    
    ok(t, TkGetTokType(e,lex,2) == TOK_STRLIT, "tk.TemplateLiteralColorizer.Type0");
    ok(t, TkGetTokType(e,lex,3) == TOK_STRLIT, "tk.TemplateLiteralColorizer.Type1");
    ok(t, TkGetTokType(e,lex,4) == TOK_STRLIT, "tk.TemplateLiteralColorizer.Type2");  

    //                   012345678 9012345
    TkTokenizeA(e, lex, "x=`hello\nworld`;",0,0,0);    
    ok(t, TkGetTokType(e,lex,2) == TOK_TEMPLIT, "tk.TemplateLiteralNoSubstitutions.Type");    
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 2), "hello\nworld"), "tk.TemplateLiteralNoSubstitutions.Value");
    ok(t, StrEqChars(e, TkGetTokRawStr(e, lex, 2), "hello\nworld"), "tk.TemplateLiteralNoSubstitutions.Value");
    ok(t, TkGetTokCount(e, lex,0) == 2, "tk.TemplateLiteralNoSubstitutions.Count0");
    ok(t, TkGetTokCount(e, lex,1) == 3, "tk.TemplateLiteralNoSubstitutions.Count1");
    s = TkGetTokStr(e, lex, 2);
    ok(t, StrLen(e,s) == 11, "tk.TemplateLiteralNoSubstitutions.Length");

    TkTokenizeA(e, lex, "x=`hell\\x65 world`;",0,0,0);    
    ok(t, TkGetTokType(e,lex,2) == TOK_TEMPLIT, "tk.TemplateLiteralNoSubstitutions.Type");    
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 2), "helle world"), "tk.TemplateLiteralNoSubUniEscape.String");
    ok(t, StrEqChars(e, TkGetTokRawStr(e, lex, 2), "hell\\x65 world"), "tk.TemplateLiteralNoSubUniEscape.Raw");

    TkTokenizeA(e, lex, "x=`hel\\\no\\\n\r2`",0,0,0);
    ok(t, StrEqChars(e, TkGetTokStr(e, lex, 2), "helo2"), "tk.TemplateLiteralContinuation");


    TkTokenizeA(e, lex, "`x=${y+z}`",0,0,0);
    ok(t, TkGetTokType(e, lex,0) == TOK_TEMPHEAD, "tk.TemplateLiteralSub.Head");
    ok(t, TkGetTokType(e, lex,1) == TOK_IDENTIFIER, "tk.TemplateLiteralSub.Sub0");
    ok(t, TkGetTokType(e, lex,2) == TOK_KEYWORD, "tk.TemplateLiteralSub.Sub1");
    ok(t, TkGetTokType(e, lex,3) == TOK_IDENTIFIER, "tk.TemplateLiteralSub.Sub2");
    ok(t, VectorCount(e, lex->tokens) == 5, "tk.TemplateLiteralSub.Count");

    TkTokenizeA(e, lex, "`Hello${3+4}World`",0,0,0);
    ok(t, TkGetTokType(e, lex,0) == TOK_TEMPHEAD, "tk.TemplateLiteralSub.Head");
    ok(t, TkGetTokType(e, lex,1) == TOK_NUMLIT, "tk.TemplateLiteralSub.Sub0");
    ok(t, TkGetTokType(e, lex,2) == TOK_KEYWORD, "tk.TemplateLiteralSub.Sub1");
    ok(t, TkGetTokType(e, lex,3) == TOK_NUMLIT, "tk.TemplateLiteralSub.Sub2");
    ok(t, TkGetTokType(e, lex,4) == TOK_TEMPTAIL, "tk.TemplateLiteralSub.Tail");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex,0), "Hello"), "tk.TemplateLiteralSub.Head.Value");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex,4), "World"), "tk.TemplateLiteralSub.Tail.Value");
    ok(t, VectorCount(e, lex->tokens) == 6, "tk.TemplateLiteralSub.Count");


    TkTokenizeA(e, lex, "`Hello${A}World${B}Yes`",0,0,0);
    ok(t, TkGetTokType(e, lex,0) == TOK_TEMPHEAD, "tk.TemplateLiteralSub2.Head");
    ok(t, TkGetTokType(e, lex,1) == TOK_IDENTIFIER, "tk.TemplateLiteralSub2.Sub0");
    ok(t, TkGetTokType(e, lex,2) == TOK_TEMPMID, "tk.TemplateLiteralSub2.Mid");
    ok(t, TkGetTokType(e, lex,3) == TOK_IDENTIFIER, "tk.TemplateLiteralSub2.Sub3");
    ok(t, TkGetTokType(e, lex,4) == TOK_TEMPTAIL, "tk.TemplateLiteralSub2.Tail");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex,0), "Hello"), "tk.TemplateLiteralSub2.Head.Value");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex,2), "World"), "tk.TemplateLiteralSub2.Mid.Value");
    ok(t, StrEqChars(e, TkGetTokStr(e, lex,4), "Yes"), "tk.TemplateLiteralSub2.Tail.Value");
    ok(t, VectorCount(e, lex->tokens) == 6, "tk.TemplateLiteralSub.Count");


    TkTokenizeA(e, lex, "break\nlabel",0,0,0);
    ok(t, TkGetTokKeyword(e, lex,0) == id_break, "tk.AutoSemiBreak0");
    ok(t, TkGetTokKeyword(e, lex,1) == id_semi, "tk.AutoSemiBreak1");
    ok(t, TkGetTokType(e, lex,2) == TOK_LINETERM, "tk.AutoSemiBreak2");

    TkTokenizeA(e, lex, "break\nlabel",0,0,1);
    ok(t, TkGetTokKeyword(e, lex,0) == id_break, "tk.AutoSemiBreak0");
    ok(t, TkGetTokType(e, lex,1) == TOK_LINETERM, "tk.AutoSemiBreak2");

    TkTokenizeA(e, lex, "GB=1",0,0,1);
    ok(t, TkIsConst(e, lex, 0), "tk.isConst");
    ok(t, !TkIsConst(e, lex, 1), "tk.isConst");

    TkTokenizeA(e, lex, "Gb=1",0,0,1);
    ok(t, !TkIsConst(e, lex, 0), "tk.isConst");


    TkTokenizeA(e, lex, "var x=20.1;", 0, 0, 1);
    ok(t, TkGetTokLen(e, lex, 9) == 0, "tk.GetTokLen(invalid)==0");

    TkTokenizeA(e, lex, "x=/a/b\r", 0, 0, 1);
    ok(t, TkGetTokLen(e, lex, 2) == 4, "tk.GetTokLen(RegEx) #173");

    TkTokenizeA(e, lex, "x = (... A)", 0, 0, 1);
    ok(t, TkGetCount(e, lex) == 7, "tk.GetCount()");

    TkTokenizeA(e, lex, "1 2e4 0x3 0b01 0o4", 0, 0, 1);
    ok(t, TkGetTokFlags(e, lex, 0) == 0, "Tokenizer.NumFlags.None");
    ok(t, TkGetTokFlags(e, lex, 1) & TF_NUM_EXP, "Tokenizer.NumFlags.Exp");
    ok(t, TkGetTokFlags(e, lex, 2) & TF_NUM_HEX, "Tokenizer.NumFlags.Hex");    
    ok(t, TkGetTokFlags(e, lex, 3) & TF_NUM_BIN, "Tokenizer.NumFlags.Bin");    
    ok(t, TkGetTokFlags(e, lex, 4) & TF_NUM_OCT, "Tokenizer.NumFlags.Oct");    

    TkTokenizeA(e, lex, "x = '123'", 0, 0, 1);
    ok(t, TkGetWidestToken(e, lex) == 3, "tk.TkGetWidestToken()");    

    s = StrNewLength(e, 3);
    s->chars[0] = 'x';
    s->chars[1] = 0x3000;
    s->chars[2] = 'y';
    TkTokenizeS(e, lex, s, 0,1);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.tokenize('x0x3000y').x");
    ok(t, TkGetTokType(e, lex, 1) == TOK_SPC_RALIGN, "tk.tokenize('x0x3000y').0x3000");    
    ok(t, TkGetTokType(e, lex, 2) == TOK_IDENTIFIER, "tk.tokenize('x0x3000y').y");

// Craig
    s = StrNewLength(e, 7);
    s->chars[0] = 'x';
    s->chars[1] = ' ';
    s->chars[2] = 0x3000;
    s->chars[3] = 'y';
    s->chars[4] = ' ';
    s->chars[5] = 0x3000;
    s->chars[6] = 'z';
    TkTokenizeS(e, lex, s, 0,1);
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "tk.tokenize('x 0x3000y 0x3000z').x");
    ok(t, TkGetTokType(e, lex, 1) == TOK_SPC_RALIGN, "tk.tokenize('x 0x3000y 0x3000z').0x3000");
    ok(t, TkGetTokType(e, lex, 2) == TOK_IDENTIFIER, "tk.tokenize('x 0x3000y 0x3000z').y");
    ok(t, TkGetTokType(e, lex, 3) == TOK_SPC_RALIGN, "tk.tokenize('x 0x3000y 0x3000z').0x3000");
    ok(t, TkGetTokType(e, lex, 4) == TOK_IDENTIFIER, "tk.tokenize('x 0x3000y 0x3000z').z");
    ok(t, TkGetTokOffset(e, lex, 1) == 2, "tk.tokenize('x 0x3000y 0x3000z').2");
    ok(t, TkGetTokLen(e, lex, 1) == 1, "tk.tokenize('x 0x3000y 0x3000z').1");
    ok(t, TkGetTokOffset(e, lex, 3) == 5, "tk.tokenize('x 0x3000y 0x3000z').5");
    ok(t, TkGetTokLen(e, lex, 3) == 1, "tk.tokenize('x 0x3000y 0x3000z').1");
    
    TkTokenizeA(e, lex, "{x}=1;", 0, 0, 0);
    ok(t, TkGetTokKeyword(e, lex, 0) == id_lbrace, "tk.}=.0");
    ok(t, TkGetTokType(e, lex, 1) == TOK_IDENTIFIER, "tk.}=.1");
    ok(t, TkGetTokKeyword(e, lex, 2) == id_rbrace, "tk.}=.2");
    ok(t, TkGetTokKeyword(e, lex, 3) == id_eq, "tk.}=.3");
    ok(t, TkGetTokType(e, lex, 4) == TOK_NUMLIT, "tk.}=.4");
    ok(t, TkGetTokKeyword(e, lex, 5) == id_semi, "tk.}=.5");


    // New tests for colorizer EOF marker insertion
    TkTokenizeA(e, lex, "", 0, 0, 1);    
    ok(t, TkGetCount(e, lex) == 1, "Tokenizer.EOF.Empty.TokenCount");
    ok(t, TkGetLineCount(e, lex) == 1, "Tokenizer.EOF.Empty.LineCount");
    ok(t, TkGetTokCount(e, lex,0) == 1, "Tokenizer.EOF.Empty.TokenCount");
    ok(t, TkGetTokType(e, lex, 0) == TOK_EOF, "Tokenizer.EOF.Empty.TokenType");

    TkTokenizeA(e, lex, "x=1", 0, 0, 1);    
    ok(t, TkGetCount(e, lex) == 4, "Tokenizer.EOF.OneLine.TokenCount");
    ok(t, TkGetLineCount(e, lex) == 1, "Tokenizer.EOF.OneLine.LineCount");
    ok(t, TkGetTokCount(e, lex,0) == 4, "Tokenizer.EOF.OneLine.TokenCount");
    ok(t, TkGetTokType(e, lex, 3) == TOK_EOF, "Tokenizer.EOF.OneLine.TokenType");    


    TkTokenizeA(e, lex, "x=1\ny=2", 0, 0, 1);    
    ok(t, TkGetCount(e, lex) == 8, "Tokenizer.EOF.MultiLine.TokenCount");
    ok(t, TkGetLineCount(e, lex) == 2, "Tokenizer.EOF.MultiLine.LineCount");
    ok(t, TkGetTokCount(e, lex,0) == 4, "Tokenizer.EOF.MultiLine.TokenCount.0");
    ok(t, TkGetTokCount(e, lex,1) == 4, "Tokenizer.EOF.MultiLine.TokenCount.1");
    ok(t, TkGetTokType(e, lex, 7) == TOK_EOF, "Tokenizer.EOF.MultiLine.TokenType");    


    TkTokenizeA(e, lex, "a\t\tb", 0, 0, 1);    
    ok(t, TkGetCount(e, lex) == 5, "Tokenizer.TAB.TokenCount");
    ok(t, TkGetTokType(e, lex, 0) == TOK_IDENTIFIER, "Tokenizer.TAB.Type.0");    
    ok(t, TkGetTokType(e, lex, 1) == TOK_TAB, "Tokenizer.TAB.Type.1");  
    ok(t, TkGetTokLen(e, lex, 1) == 1, "Tokenizer.TAB.Len.1");    
    ok(t, TkGetTokOffset(e, lex, 1) == 1, "Tokenizer.TAB.Offset.1");    
    ok(t, TkGetTokType(e, lex, 2) == TOK_TAB, "Tokenizer.TAB.Type.2");  
    ok(t, TkGetTokLen(e, lex, 2) == 1, "Tokenizer.TAB.Len.2");    
    ok(t, TkGetTokOffset(e, lex, 2) == 2, "Tokenizer.TAB.Offset.2");        
    ok(t, TkGetTokType(e, lex, 3) == TOK_IDENTIFIER, "Tokenizer.TAB.Type.3");    

    TkTokenizeA(e, lex, "a\n\tb", 0, 0, 1);    
    ok(t, TkGetTokCol(e, lex, 2) == 0, "Tokenizer.TAB.Column.#458");    

    TkDel(e, lex);
}

void TkTest2(test* t) {
    Js* e = t->js;
    Tokenizer* lex = TkNew(e);
    char s[1024];
    
    //***************************************************************************
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '2'; s[ 7] = '\n';
    /* Line 2 */ s[ 8] = 'c'; s[ 9] = '='; s[10] = '3'; s[11] = '\0';
    TkTokenizeA(e, lex, s, 0, 0, 1);
    ok(t, TkGetCount(e, lex) == 12, "Tokenizer.Range.None.Count");
    ok(t, TkGetLineCount(e, lex) == 3, "Tokenizer.Range.None.LineCount");
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '2'; s[ 7] = '\n';
    /* Line 2 */ s[ 8] = 'c'; s[ 9] = '='; s[10] = '3'; s[11] = '\0';
    TkReplaceA(e, lex, 6,7, 6,7, s, 2);
    ok(t, TkGetLineCount(e, lex) == 3, "Tokenizer.Range.OneChar.LineCount");
    ok(t, lex->tempLineCount == 3, "Tokenizer.Range.OneChar.tempLineCount");
    ok(t, lex->tempEndToken == 7, "Tokenizer.Range.OneChar.tempEndToken");
    ok(t, TkValidateToken(e, lex, 8) == TRUE, "Tokenizer.Range.OneChar.Owned.TkValidateToken");
    ok(t, lex->tempLineCount < 0, "Tokenizer.Range.OneChar.Owned.PostValidate.tempLineCount");
    ok(t, lex->tempEndToken < 0, "Tokenizer.Range.OneChar.Owned.PostValidate.tempEndToken"); 
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '\n';
    /* Line 2 */ s[ 7] = 'c'; s[ 8] = '='; s[ 9] = '3'; s[10] = '\0';
    TkReplaceA(e, lex, 6,6, 6,5, s, 2);
    ok(t, TkGetLineCount(e, lex) == 3, "Tokenizer.Range.OneChar.Del.LineCount");
    ok(t, lex->tempLineCount == 3, "Tokenizer.Range.OneChar.Del.tempLineCount");
    ok(t, lex->tempEndToken == 6, "Tokenizer.Range.OneChar.Del.tempEndToken");
    //***************************************************************************
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '2'; s[ 7] = '\n';
    /* Line 2 */ s[ 8] = 'c'; s[ 9] = '='; s[10] = '3'; s[11] = '\n';
    /* Line 3 */ s[12] = 'd'; s[13] = '='; s[14] = '4'; s[15] = '\n';
    /* Line 4 */ s[16] = 'e'; s[17] = '='; s[18] = '5'; s[19] = '\0';
    TkTokenizeA(e, lex, s, 0, 0, 1);
    ok(t, TkGetLineCount(e, lex) == 5, "Tokenizer.Range.AddLine.Original.LineCount");
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '2'; s[ 7] = '\n';
    /* Line 2 */ s[ 8] = 'c'; s[ 9] = '='; s[10] = '3'; s[11] = '\n';
    /* Line 3 */ s[12] = 'k'; s[13] = '='; s[14] = '0'; s[15] = '\n';    
    /* Line 4 */ s[16] = 'd'; s[17] = '='; s[18] = '4'; s[19] = '\n';
    /* Line 5 */ s[20] = 'e'; s[21] = '='; s[22] = '5'; s[23] = '\0';
    TkReplaceA(e, lex, 12,12, 12, 16, s, 3);
    ok(t, TkGetLineCount(e, lex) == 6, "Tokenizer.Range.AddLine.LineCount");
    //***************************************************************************
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '2'; s[ 7] = '\n';
    /* Line 2 */ s[ 8] = 'c'; s[ 9] = '='; s[10] = '3'; s[11] = '\n';
    /* Line 3 */ s[12] = 'd'; s[13] = '='; s[14] = '4'; s[15] = '\n';
    /* Line 4 */ s[16] = 'e'; s[17] = '='; s[18] = '5'; s[19] = '\0';
    TkTokenizeA(e, lex, s, 0, 0, 1);
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'c'; s[ 5] = '='; s[ 6] = '3'; s[ 7] = '\n';
    /* Line 3 */ s[ 8] = 'd'; s[ 9] = '='; s[10] = '4'; s[11] = '\n';
    /* Line 4 */ s[12] = 'e'; s[13] = '='; s[14] = '5'; s[15] = '\0';
    TkReplaceA(e, lex, 4,7, 4,3, s, 3);
    ok(t, TkGetLineCount(e, lex) == 4, "Tokenizer.Range.RemoveLine.LineCount");
    //***************************************************************************
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = 'b'; s[ 2] = '\0';
    TkTokenizeA(e, lex, s, 0, 0, 1);
    ok(t, TkGetLineCount(e, lex) == 1, "Tokenizer.EndInsert.LineCount");
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = 'b'; s[ 2] = 'c'; s[ 3] = '\0';
    TkReplaceA(e, lex, 2,2, 2,3, s, 7);
    ok(t, lex->tempEndToken == -1, "Tokenizer.EndInsert.EndToken");
    ok(t, TkGetLineCount(e, lex) == 1, "Tokenizer.Replace.EndInsert.LineCount");
    //***************************************************************************   
    /* Line 0 */ s[ 0] = '1'; s[ 1] = '2'; s[ 2] = '3'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = '4'; s[ 5] = '5'; s[ 6] = '\n'; 
    /* Line 2 */ s[ 7] = '6'; s[ 8] = '\0'; 
    TkTokenizeA(e, lex, s, 0, 0, 1);
    ok(t, TkGetLineLen(e, lex, 2) == 1, "Tokenizer.Full.EndLength");
    /* Line 0 */ s[ 0] = '1'; s[ 1] = '2'; s[ 2] = '3'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = '4'; s[ 5] = '5'; s[ 6] = 'k'; s[ 7] = '\n'; 
    /* Line 2 */ s[ 8] = '6'; s[ 9] = '\0'; 
    TkReplaceA(e, lex, 6,6, 6,7, s, 9);
    ok(t, TkGetLineLen(e, lex, 2) != 8, "Tokenizer.Replace.EndLength");
    //***************************************************************************  
    Str* z = StrNewLength(e, 12);
    uchar* x = z->chars;
    x[0] = 'a'; x[1] = '='; x[2]='4'; x[3]=' ';x[4]='/'; x[5]='*';x[6]=' ';
    x[7] = 'z'; x[8] = 0; x[9] = 'm'; x[10] ='*'; x[11] = '/';
    TkTokenizeS(e, lex, z, 0,1);
    //***************************************************************************
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '2'; s[ 7] = '\n';
    /* Line 2 */ s[ 8] = 'c'; s[ 9] = '='; s[10] = '3'; s[11] = '\n';
    /* Line 3 */ s[12] = 'd'; s[13] = '='; s[14] = '4'; s[15] = '\n';
    /* Line 4 */ s[16] = 'e'; s[17] = '='; s[18] = '5'; s[19] = '\0';
    TkTokenizeA(e, lex, s, 0, 0, 1);
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'b'; s[ 5] = '='; s[ 6] = '3'; s[ 7] = '\n';
    /* Line 3 */ s[ 8] = 'm'; s[ 9] = '='; s[10] = '4'; s[11] = '\n';
    /* Line 4 */ s[12] = 'e'; s[13] = '='; s[14] = '5'; s[15] = '\0';
    TkReplaceA(e, lex, 9,10, 9,10, s, 2);
    ok(t, !TkNeedFull(e, lex), "Tokenizer.Replace.CountMinusView.Low");
    /* Line 0 */ s[ 0] = 'a'; s[ 1] = '='; s[ 2] = '1'; s[ 3] = '\n';
    /* Line 1 */ s[ 4] = 'k'; s[ 5] = '='; s[ 6] = '3'; s[ 7] = '\n';
    /* Line 3 */ s[ 8] = 'm'; s[ 9] = '='; s[10] = '4'; s[11] = '\n';
    /* Line 4 */ s[12] = 'e'; s[13] = '='; s[14] = '5'; s[15] = '\0';
    TkReplaceA(e, lex, 0,1, 0,1, s, 2);
    // int zz = TkGetLineFromOffset(e, lex, 1);
    ok(t, !TkNeedFull(e, lex), "Tokenizer.Replace.CountMinusView.High");


    TkTokenizeA(e, lex, "x = 0.19999999999999996;", 0, 0, 1);
    ok(t, TkGetTokNumVal(e, lex, 2) == 0.19999999999999996, "Tokenizer.NumLit.Long");
    

    TkTokenizeA(e, lex, "a\n b\n c\n d\n\na\n\n b\n\n c\n\n d\n", 0, 0, 1);
#if 0    
    TkPrint(e, lex, 0, 0, 1);
    ok(t, TkGetTokCol(e, lex, 0) == 0, "#490.0");
    ok(t, TkGetTokCol(e, lex, 1) == 1, "#490.1");
    ok(t, TkGetTokCol(e, lex, 2) == 2, "#490.2");
    ok(t, TkGetTokCol(e, lex, 3) == 3, "#490.3");
    ok(t, TkGetTokCol(e, lex, 4) == 0, "#490.4");
    ok(t, TkGetTokCol(e, lex, 5) == 0, "#490.5");
    ok(t, TkGetTokCol(e, lex, 6) == 0, "#490.6");
    ok(t, TkGetTokCol(e, lex, 7) == 1, "#490.7");
    ok(t, TkGetTokCol(e, lex, 8) == 0, "#490.8");
    ok(t, TkGetTokCol(e, lex, 9) == 2, "#490.9");
    ok(t, TkGetTokCol(e, lex, 10) == 0, "#490.10");
    ok(t, TkGetTokCol(e, lex, 11) == 3, "#490.11");
    ok(t, TkGetTokCol(e, lex, 12) == 0, "#490.12");
#endif

    TkTokenizeA(e, lex, "get = 1;",0,0,1);
    ok(t, TkGetTokKeyword(e, lex, 0) == id_get, "Tokenizer.keyword.get");

    TkTokenizeA(e, lex, "o = { get : 1 };",0,0,1);
    ok(t, TkGetTokKeyword(e, lex, 3) == id_get, "Tokenizer.object.get");


    TkDel(e, lex);
}


void EngineTest(test* t) {
    Js* e = t->js;
    ok(t, ValEqStrA(e, e->hasInstance, "Symbol.hasInstance"), "Symbol.hasInstance");
    ok(t, ValEqStrA(e, e->isConcatSpreadable, "Symbol.isConcatSpreadable"), "Symbol.isConcatSpreadable");
    ok(t, ValEqStrA(e, e->isRegExp, "Symbol.isRegExp"), "Symbol.isRegExp");
    ok(t, ValEqStrA(e, e->iterator, "Symbol.iterator"), "Symbol.iterator");
    ok(t, ValEqStrA(e, e->toPrimitive, "Symbol.toPrimitive"), "Symbol.toPrimitive");
    ok(t, ValEqStrA(e, e->toStringTag, "Symbol.toStringTag"), "Symbol.toStringTag");
    ok(t, ValEqStrA(e, e->unscopables, "Symbol.unscopables"), "Symbol.unscopables");
    ok(t, ValEqStrA(e, e->prototype, "prototype"), "prototype");
}


// ScriptEval deletes the context after done which is a problem for situations like REPL and Watcher:  
// currentContext == NULL.  RetainedContext(Realm) before or after ScriptEval to be able to access 
// the realms global environment




void PropTest(test* t) {
    Js* e = t->js;
    Property* p = PropNew(e);
    ok(t, p != NULL, "Property.create");
    ok(t, p->value == NULL, "Property.init");
    ok(t, p->set == NULL, "Property.init");
    ok(t, p->get == NULL, "Property.init");
    ok(t, p->next == NULL, "Property.init");
    ok(t, p->flags == 0, "Property.init");
    
    
    Val* owned = ValNewStrA(e, "ownedPropKey");
    int32 a2 = e->memory[ST].data->allocs;
    PropSetName(e, p, owned, TRUE);
    ok(t, StrEqChars(e, p->name->str, "ownedPropKey"), "Property.set_owned_name");
    PropClear(e, p);
    ok(t, p->name == NULL, "Property.clear");
    ok(t, e->memory[ST].data->allocs == a2, "Property.set_owned_name");
    
    Val* shared = ValNewStrA(e, "sharedPropKey");
    PropSetName(e, p, shared, FALSE);
    ok(t, StrEqChars(e, p->name->str, "sharedPropKey"), "Property.set_shared_name");
    Val v;
    ValInit(&v);
    ValInitNum(&v, 3.14);
    PropSetValue(e, p, &v);
    ok(t, p->value != NULL, "Property.set_value");
    ok(t, p->value->type == TYPE_NUM, "Property.set_value");
    ok(t, p->value->num == 3.14, "Property.set_value");
    PropClear(e, p);
    
    
    ValDel(e, owned);
    ValDel(e, shared);
    PropDel(e, p);
    
    ok(t, IsAccessorDesc(e, NULL) == FALSE, "Property.is_accessor(NULL)");
    
    p = PropNew(e);
    p->set = ValNewObject(e);
    p->get = ValNewObject(e);
    ok(t, IsAccessorDesc(e, p) == TRUE, "Property.is_accessor(set, Get)");
    PropDel(e, p);
    
    p = PropNew(e);
    p->get = ValNewObject(e);
    ok(t, IsAccessorDesc(e, p) == TRUE, "Property.is_accessor(Get)");
    PropDel(e, p);

    p = PropNew(e);
    p->set = ValNewObject(e);
    ok(t, IsAccessorDesc(e, p) == TRUE, "Property.is_accessor(set)");
    PropDel(e, p);

    p = PropNew(e);
    p->value = ValNew(e);
    ok(t, IsAccessorDesc(e, p) == FALSE, "Property.is_accessor(data)");
    PropDel(e, p);
    

    ok(t, PropIsData(e, NULL) == FALSE, "Property.is_data(NULL)");
    
    p = PropNew(e);
    p->value = ValNew(e);
    PropSetWritable(e, p, TRUE);
    ok(t, PropIsData(e, p) == TRUE, "Property.is_data(value, writable)");
    PropDel(e, p);

    p = PropNew(e);
    p->value = ValNew(e);
    ok(t, PropIsData(e, p) == TRUE, "Property.is_data(value, no_writeable)");
    PropDel(e, p);
    
    p = PropNew(e);
    ok(t, PropIsData(e, p) == FALSE, "Property.is_data(no_value, no_writeable)");
    PropDel(e, p);


    ok(t, PropIsGeneric(e, NULL) == FALSE, "Property.is_generic(NULL)");
    
    p = PropNew(e);
    p->value = ValNew(e);
    ok(t, PropIsGeneric(e, p) == FALSE, "Property.is_generic(data)");
    PropDel(e, p);

    p = PropNew(e);
    p->set = ValNew(e);
    ok(t, PropIsGeneric(e, p) == FALSE, "Property.is_generic(accessor)");
    PropDel(e, p);
    
    p = PropNew(e);
    ok(t, PropIsGeneric(e, p) == TRUE, "Property.is_generic(neither)");
    PropDel(e, p);


    Val* desc = ValNewDesc(e);
    p = desc->desc;
    PropSetWritable(e, p, TRUE);
    PropSetEnumerable(e, p, TRUE);
    PropSetConfigurable(e, p, TRUE);
    p->name = ValNewStrA(e, "X");
    p->ownName = TRUE;
    p->value = ValNewNum(e, 1.4);
    p->set = ValNewObject(e);
    p->get = ValNewObject(e);
    Val* obj = FromPropertyDesc(e, desc);
    Val *W, *C, *E, *V, *S, *G;
    W = GetA(e, obj, "writable");
    E = GetA(e, obj, "enumerable");
    C = GetA(e, obj, "configurable");
    V = GetA(e, obj, "value");
    S = GetA(e, obj, "set");
    G = GetA(e, obj, "get");
    
    ok(t, W->type == TYPE_BOOL && W->b, "obj.from_prop(writable)");
    ok(t, E->type == TYPE_BOOL && E->b, "obj.from_prop(enumerable)");
    ok(t, C->type == TYPE_BOOL && C->b, "obj.from_prop(configurable)");
    ok(t, V->type == TYPE_NUM && V->num == 1.4, "obj.from_prop(value)");
    ok(t, VallAllEq(e, S, p->set), "obj.from_prop(set)");
    ok(t, VallAllEq(e, G, p->get), "obj.from_prop(Get)");
    
    ValDel(e, W);
    ValDel(e, E);
    ValDel(e, C);
    ValDel(e, V);
    ValDel(e, S);
    ValDel(e, G);
    ValDel(e, obj);
    ValDel(e, desc);
    
    Val* P1 = ValNewDesc(e);
    P1->desc->ownName = TRUE;
    P1->desc->name = ValNewStrA(e, "HELLO");
    PropSetWritable(e, P1->desc, TRUE);
    Val* P2 = ValClone(e, P1);
    bool_t eq = VallAllEq(e, P1, P2);
    ok(t, P2->type == TYPE_DESC, "Property.ValNewDesc");
    ok(t, StrEqChars(e, P2->desc->name->str, "HELLO"), "Property.ValSet(desc)");
    ok(t, eq, "Property.VallAllEq(desc)");
    ValDel(e, P1);
    ValDel(e, P2);
    
    Val* abrupt = ValNewCompA(e, COMP_RETURN, NULL, NULL);
    P1 = ToPropertyDesc(e, abrupt);
    ok(t, P1->completion->type == COMP_RETURN, "Property.ToPropertyDesc(abrupt)");
    ValDel(e, P1);
    ValDel(e, abrupt);

    Val* N = ValNewNum(e, 1);
    P1 = ToPropertyDesc(e, N);
    ok(t, ValIsThrow(e, P1, CurrentRealm(e)->typeErrorObject), "Property.ToPropertyDesc(non_obj)");
    ValDel(e, P1);
    ValDel(e, N);

    
    Val* O = ValNewObject(e);
    abrupt = ValNewCompA(e, COMP_RETURN, NULL, NULL);
    PutA(e, O, "enumerable", abrupt, FALSE);
    P1 = ToPropertyDesc(e, O);
    ok(t, P1->completion->type == COMP_RETURN, "Property.ToPropertyDesc(abrupt_enum)");
    ValDel(e, P1);
    ValDel(e, abrupt);
    ValDel(e, O);
    
    
    O = ValNewObject(e);
    V = ValNewNum(e, 1);
    PutA(e, O, "value", V, TRUE);  // V will be deleted
    P1 = ToPropertyDesc(e, O);
    ok(t, P1->type == TYPE_DESC, "Property.ToPropertyDesc(data)");
    ok(t, P1->desc->value->num == 1, "Property.ToPropertyDesc(data)");
    ValDel(e, P1);
    ValDel(e, O);


    O = ValNewObject(e);
    V = ValNewNum(e, 1);
    PutA(e, O, "set", V, TRUE);  // V will be deleted
    P1 = ToPropertyDesc(e, O);
    ok(t, ValIsThrow(e, P1, CurrentRealm(e)->typeErrorObject), "Property.ToPropertyDesc(accessor_non_callable)");
    ValDel(e, P1);
    ValDel(e, O);

    O = ValNewObject(e);
    V = ValNewNum(e, 1);
    PutA(e, O, "set", V, FALSE);  // V will NOT be deleted
    PutA(e, O, "value", V, TRUE);  // V will be deleted
    P1 = ToPropertyDesc(e, O);
    ok(t, ValIsThrow(e, P1, CurrentRealm(e)->typeErrorObject), "Property.ToPropertyDesc(invalid)");
    ValDel(e, P1);
    ValDel(e, O);
    
    P1 = ValNewDesc(e);
    P2 = ValNewDesc(e);
    PropSetWritable(e, P2->desc, TRUE);
    PropSetEnumerable(e, P2->desc, TRUE);
    PropSetConfigurable(e, P2->desc, TRUE);
    P2->desc->value = ValNewNum(e, 1);
    ok(t, !P1->desc->value, "Property.complete(data)");
    ok(t, ! PropHasWritable(e, P1->desc), "Property.complete(data)");
    ok(t, ! PropHasConfigurable(e, P1->desc), "Property.complete(data)");
    ok(t, !PropHasEnumerable(e, P1->desc), "Property.complete(data)");
    P1 = CompletePropertyDesc(e, P1, P2);
    ok(t, P1->desc->value->num == 1, "Property.complete(data)");
    ok(t, PropIsWritable(e, P1->desc), "Property.complete(data)");
    ok(t, PropIsConfigurable(e, P1->desc), "Property.complete(data)");
    ok(t, PropIsEnumerable(e, P1->desc), "Property.complete(data)");
    ValDel(e, P2);
    ValDel(e, P1);

    P1 = ValNewDesc(e);
    // Due to an issue with 6.2.4.6, we have to convince the complete routine
    // that P1 is not generic
    P1->desc->get = ValNewBool(e, TRUE);
    P2 = ValNewDesc(e);
    P2->desc->get = ValNewBool(e, TRUE);
    P2->desc->set = ValNewBool(e, TRUE);
    PropSetConfigurable(e, P2->desc, TRUE);
    PropSetEnumerable(e, P2->desc, TRUE);
    ok(t, !P1->desc->set, "Property.complete(accessor)");
    ok(t, ! PropHasConfigurable(e,P1->desc), "Property.complete(accessor)");
    ok(t, ! PropHasEnumerable(e, P1->desc), "Property.complete(accessor)");
    P1 = CompletePropertyDesc(e, P1, P2);
    ok(t, P1->desc->set->b == TRUE, "Property.complete(accessor)");
    ok(t, PropIsConfigurable(e, P1->desc), "Property.complete(accessor)");
    ok(t, PropIsEnumerable(e, P1->desc), "Property.complete(accessor)");
    ValDel(e, P2);
    ValDel(e, P1);

}


Val* MockSetter(Js* e, Val* o, Val* othis, Val* args) {
    PutA(e, othis, "__x", ListGetValue(e, args->list, 0), TRUE);
    return ValNew(e);
}

Val* MockCallNull(Js* e, Val* o, Val* othis, Val* args) {
    return NULL;
}

void ObjectTest(test* t) {
    Js* e = t->js;
    int32 allocs = e->memory[OB].data->allocs;
    Object* o = ObjectNew(e);
    ok(t, o->properties == NULL, "obj.create");
    ObjectDelete(e, o);
    ok(t, e->memory[OB].data->allocs == allocs, "obj._free");
    
    o = ObjectNew(e);
    ObjectSetMethod(e, o, _Call_, MockCallNull, FALSE);
    void* c = ObjectGetMethod(e, o, _Call_);
    ok(t, c == MockCallNull, "Object.SetMethod(NoCheck)");
    ObjectSetMethod(e, o, _Call_, NULL, TRUE);
    c = ObjectGetMethod(e, o, _Call_);
    ok(t, c == NULL, "Object.SetMethod(Check)");
    ObjectSetSlot(e, o, "[[A]]", ValNewNum(e, 3), FALSE, TRUE);
    ObjectSetSlot(e, o, "[[B]]", ValNewNum(e, 4), FALSE, TRUE);
    ObjectSetSlot(e, o, "[[C]]", ValNewNum(e, 5), FALSE, TRUE);
    ok(t, ObjectGetSlot(e, o, "[[A]]")->num ==3, "obj.SetSlot(NoCheck1)");
    ok(t, ObjectGetSlot(e, o, "[[B]]")->num ==4, "obj.SetSlot(NoCheck2)");
    ok(t, ObjectGetSlot(e, o, "[[C]]")->num ==5, "obj.SetSlot(NoCheck3)");
    ObjectSetSlot(e, o, "[[A]]", ValNewNum(e, 6), TRUE, TRUE);
    ObjectSetSlot(e, o, "[[B]]", ValNewNum(e, 7), TRUE, TRUE);
    ObjectSetSlot(e, o, "[[C]]", ValNewNum(e, 8), TRUE, TRUE);
    ok(t, ObjectGetSlot(e, o, "[[A]]")->num ==6, "obj.SetSlot(Check1)");
    ok(t, ObjectGetSlot(e, o, "[[B]]")->num ==7, "obj.SetSlot(Check2)");
    ok(t, ObjectGetSlot(e, o, "[[C]]")->num ==8, "obj.SetSlot(Check3)");
    
    ObjectDelete(e, o);
    
    
    Val* P = ValNewObject(e);
    PutA(e, P, "X", ValNewNum(e, 3.14), TRUE);
    Val* O = ValNewObject(e);
    Val* R = DoSetPrototypeOf(e, O, P);
    ok(t, ValIsTrueDel(e, R), "obj.SetPrototypeOf");
    ValDel(e, O);
    ValDel(e, P);

    P = ValNewNull(e);
    O = ValNewObject(e);
    R = DoSetPrototypeOf(e, O, P);
    ok(t, ValIsTrueDel(e, R), "obj.SetPrototypeOf(null)");
    ValDel(e, O);
    ValDel(e, P);

    P = ValNewObject(e);
    O = ValNewObject(e);
    R = DoSetPrototypeOf(e, P, O);
    ok(t, ValIsTrueDel(e, R), "obj.SetPrototypeOf");
    R = DoSetPrototypeOf(e, O, P);
    ok(t, !ValIsTrueDel(e, R), "obj.SetPrototypeOf(own parent)");
    ValDel(e, O);
    ValDel(e, P);


    P = ValNewObject(e);
    O = ValNewObject(e);
    R = DoPreventExtensions(e, O);
    ValDel(e, R);
    R = DoSetPrototypeOf(e, O, P);
    ok(t, !ValIsTrueDel(e, R), "obj.SetPrototypeOf(non_extensible)");
    ValDel(e, O);
    ValDel(e, P);


    O = ValNewObject(e);
    R = DoIsExtensible(e, O);
    ok(t, ValIsTrueDel(e, R), "obj.IsExtensible(true)");
    R = DoPreventExtensions(e, O);
    ok(t, ValIsTrueDel(e, R), "obj.PreventExtensions()");
    R = DoIsExtensible(e, O);
    ok(t, !ValIsTrueDel(e, R), "obj.IExtensible(false)");
    ValDel(e, O);

    O = ValNewObject(e);
    PutA(e, O, "X", ValNewNum(e,2), TRUE);
    R = GetA(e, O, "X");
    ok(t, R->type == TYPE_NUM && R->num == 2, "obj.define_own(new)");
    ValDel(e, R);
    ValDel(e, O);

    O = ValNewObject(e);
    PutA(e, O, "X", ValNewNum(e,2), TRUE);
    PutA(e, O, "X", ValNewNum(e,4), TRUE);
    R = GetA(e, O, "X");
    ok(t, R->type == TYPE_NUM && R->num == 4, "obj.define_own(existing)");
    ValDel(e, R);
    ValDel(e, O);

    O = ValNewObject(e);
    PutA(e, O, "X", ValNewNum(e,2), TRUE);
    PutA(e, O, "X", ValNew(e), TRUE);
    R = GetA(e, O, "X");
    ok(t, R->type == TYPE_UNDEF, "obj.define_own(clear existing)");
    ValDel(e, R);
    ValDel(e, O);


    Val* X = ValNewStrA(e, "X");
    Val* Y = ValNewStrA(e, "Y");
    Val* Z = ValNewStrA(e, "Z");
    Val* W = ValNewStrA(e, "W");
    O = ValNewObject(e);
    P = ValNewObject(e);
    Val* P2 = ValNewObject(e);
    R = DoSetPrototypeOf(e, O, P);
    ValDel(e, R);
    R = DoSetPrototypeOf(e, P, P2);
    ValDel(e, R);
    PutA(e, O, "X", ValNewNum(e,2), TRUE);
    R = DoHasProperty(e, O, X);
    ok(t, ValIsTrueDel(e, R), "obj.has_property(exists)");
    R = DoHasProperty(e, O, Y);
    ok(t, !ValIsTrueDel(e, R), "obj.has_property(not_exists)");
    PutA(e, P, "Z", ValNewNum(e, 9), TRUE);
    R = DoHasProperty(e, O, Z);
    ok(t, ValIsTrueDel(e, R), "obj.has_property(exists_from_proto)");
    PutA(e, P2, "W", ValNewNum(e, 8), TRUE);
    R = DoHasProperty(e, O, W);
    ok(t, ValIsTrueDel(e, R), "obj.has_property(proto of proto)");
    
    ValDel(e, W);
    ValDel(e, X);
    ValDel(e, Y);
    ValDel(e, Z);
    ValDel(e, P);
    ValDel(e, O);
    ValDel(e, P2);
    
    
    X = ValNewStrA(e, "X");
    Y = ValNewStrA(e, "Y");
    Z = ValNewStrA(e, "Z");
    W = ValNewStrA(e, "W");
    O = ValNewObject(e);
    P = ValNewObject(e);
    P2 = ValNewObject(e);
    R = DoSetPrototypeOf(e, O, P);
    ValDel(e, R);
    R = DoSetPrototypeOf(e, P, P2);
    ValDel(e, R);
    PutA(e, O, "X", ValNewNum(e,1), TRUE);
    R = DoGet(e, O, X, NULL);
    ok(t, R->num == 1, "obj.Get(exists)");
    ValDel(e, R);
    R = DoGet(e, O, Y, NULL);
    ok(t, R->type == TYPE_UNDEF, "obj.Get(not_exists)");
    ValDel(e, R);
    PutA(e, P, "Z", ValNewNum(e, 2), TRUE);
    R = DoGet(e, O, Z, NULL);
    ok(t, R->num == 2, "obj.Get(exists_from_proto)");
    ValDel(e, R);
    PutA(e, P2, "W", ValNewNum(e, 3), TRUE);
    R = DoGet(e, O, W, NULL);
    ok(t, R->num == 3, "obj.Get(proto of proto)");
    ValDel(e, R);
    ValDel(e, W);
    ValDel(e, X);
    ValDel(e, Y);
    ValDel(e, Z);
    ValDel(e, P);
    ValDel(e, O);
    ValDel(e, P2);
    
    
    P = ValNewObject(e);
    O = ValNewObject(e);
    R = DoSetPrototypeOf(e, O, P);
    ValDel(e, R);
    X = ValNewDesc(e);
    Val* XS = ValNewObject(e);
    ObjectSetMethod(e, XS->obj, _Call_, MockSetter, FALSE);
    X->desc->set = ValClone(e, XS);
    Val* N = ValNewStrA(e, "X");
    R = DoDefineOwnProperty(e, P, N, X );
    ValDel(e, R);
    PutA(e, O, "X", ValNewNum(e, 3.14), TRUE);
    R = GetA(e, O, "__x");
    ok(t, R->num == 3.14, "obj.set(proto.setter)");
    ValDel(e, N);
    ValDel(e, R);
    ValDel(e, X);
    ValDel(e, XS);
    ValDel(e, O);
    ValDel(e, P);
}
void create_prop_numa(Js* e, Val* o, char* name, number n, bool_t en) {
    Val* desc = ValNewDesc(e);
    Val* nv = ValNewNum(e, n);
    PropSetValue(e, desc->desc, nv);
    ValDel(e, nv);
    PropSetEnumerable(e, desc->desc, en);
    PropSetWritable(e, desc->desc, TRUE);
    Val* uname = ValNewStrA(e, name);
    Val* r = DoDefineOwnProperty(e, o, uname, desc);
    ValDel(e, r);
    ValDel(e, uname);
    ValDel(e, desc);
}

bool_t list_has_stra(Js* e, List* l, char* name) {
    Val* v = ValNewStrA(e, name);
    bool_t ret = ListHasValue(e, l, v);
    ValDel(e, v);
    return ret;
}

void OrdinaryTest(test* t) {
    Js* e = t->js;
    Val* vo = ValNewObject(e);
//    ok(t, strcmp(vo->obj->vtable->class_name, "Object")==0, "obj.class_name");
    Val* p = ValNewObject(e);
    
    Val* r = DoSetPrototypeOf(e, vo, p);
    ValDel(e, r);
    Val* p2 = DoGetPrototypeOf(e, vo);
    ok(t,  VallAllEq(e, p2, p), "obj.SetPrototype_of");
    ok(t, ValIsTrueDel(e, DoIsExtensible(e, vo)), "obj.IsExtensible");
    ValDel(e, p2);
    ValDel(e, p);

    
    Val* key1 = ValNewStrA(e, "prop1");
    
    Val* v1 = DoGet(e, vo, key1, NULL);
    ok(t, v1->type == TYPE_UNDEF, "obj.Get");
    ValDel(e, v1);
    Val v2;
    ValInitNum(&v2, 3.14);
    Val* vs1 = DoSet(e,vo,key1, &v2,vo);
    ok(t,  vs1->b == TRUE, "obj.set");
    ValDel(e, vs1);
    Val* v3 = DoGet(e, vo, key1, NULL);
    ok(t, v3 != NULL, "obj.Get");
    ok(t, v3->type == TYPE_NUM, "obj.Get");
    ok(t, v3->num == 3.14, "obj.Get");
    ValDel(e, v3);
    
    Val* key2 = ValNewStrA(e, "prop2");
    ValClear(e, &v2);
    ValInitStrA(e, &v2, "Hello");
    Val* vs2 = DoSet(e,vo,key2, &v2,vo);
    ok(t, vs2->b == TRUE, "obj.set");
    ValDel(e, vs2);
    v3 = DoGet(e, vo, key2, NULL);
    ok(t, v3 != NULL, "obj.Get");
    ok(t, v3->type == TYPE_STR, "obj.Get");
    ok(t, StrEqChars(e, v3->str, "Hello"), "obj.Get");
    ValClear(e, &v2);
    ValDel(e, v3);
    
    Val* succ = DoDelete(e, vo, key1);
    ValDel(e, succ);
    Val* vk1 = DoGet(e,vo,key1, NULL);
    ok(t, vk1->type == TYPE_UNDEF, "obj.del");
    ValDel(e, vk1);
    Val* vk2 = DoGet(e,vo,key2, NULL);
    ok(t, vk2 != NULL, "obj.del");
    ValDel(e, vk2);
    succ = DoDelete(e, vo, key2);
    ValDel(e, succ);
    vk2 = DoGet(e,vo,key2, NULL);
    ok(t, vk2->type == TYPE_UNDEF, "obj.del");
    ValDel(e, vk2);
    
    ValDel(e, vo);
    ValDel(e, key1);
    ValDel(e, key2);
    
    // enumerate
    Val* P = ValNewObject(e);
    Val* O = ObjectCreate(e, P, NULL);
    create_prop_numa(e, P, "PX", 1, TRUE);
    create_prop_numa(e, P, "PY", 2, TRUE);
    create_prop_numa(e, P, "XZ", 3, TRUE);
    create_prop_numa(e, O, "OX", 4, TRUE);
    create_prop_numa(e, O, "OY", 5, TRUE);
    create_prop_numa(e, O, "XZ", 6, FALSE);
    Val* I = DoEnumerate(e, O);
    ok(t, I->type == TYPE_OBJ, "obj.enumerable is obj");
//    ok(t, ObjectIs(e, I, "ListIterator"), "obj.enumerate is ListIterator");
    List* L = ObjectGetSlot(e, I->obj, _IteratedList_)->list;
    ok(t, list_has_stra(e, L, "OY"), "obj.enumerate(OX)");
    ok(t, list_has_stra(e, L, "OX"), "obj.enumerate(OY)");
    ok(t, !list_has_stra(e, L, "XZ"), "obj.enumerate(XZ)");
    ok(t, list_has_stra(e, L, "PX"), "obj.enumerate(PX)");
    ok(t, list_has_stra(e, L, "PY"), "obj.enumerate(PY)");
    ValDel(e, I);
    
    I = DoOwnPropertyKeys(e, O);
    ok(t, I->type == TYPE_OBJ, "obj.OwnPropertyKeys is obj");
//    ok(t, ObjectIs(e, I, "ListIterator"), "obj.OwnPropertyKeys is ListIterator");
    L = ObjectGetSlot(e, I->obj, _IteratedList_)->list;
    ok(t, list_has_stra(e, L, "OY"), "obj.OwnPropertyKeys(OX)");
    ok(t, list_has_stra(e, L, "OX"), "obj.OwnPropertyKeys(OY)");
    ok(t, list_has_stra(e, L, "XZ"), "obj.OwnPropertyKeys(XZ)");
    ok(t, !list_has_stra(e, L, "PX"), "obj.OwnPropertyKeys(PX)");
    ok(t, !list_has_stra(e, L, "PY"), "obj.OwnPropertyKeys(PY)");

    ValDel(e, I);
    ValDel(e, O);
    ValDel(e, P);
    

    O = ObjectCreate(e, NULL, NULL);
    Object* op = CurrentRealm(e)->objectPrototype->obj;
    ok(t, O->obj->prototype->obj == op, "obj.ObjectCreate(NULL, NULL)");
    ValDel(e, O);

    P = ValNewObject(e);
    O = ObjectCreate(e, P, NULL);
    ok(t, O->obj->prototype->obj == P->obj, "obj.ObjectCreate(P, NULL)");
    ValDel(e, O);
    ValDel(e, P);
    
    L = ListNew(e);
    ListAddValue(e, L, ValNewStrA(e, "X"));
    ListAddValue(e, L, ValNewStrA(e, "Y"));
    Val* LV = ValNewList(e, L);
    O = ObjectCreate(e, NULL, LV);
    Val* N = ValNewStrA(e, "X");
    Val* R = DoHasProperty(e, O, N);
    ok(t, ValIsTrueDel(e, R), "obj.ObjectCreate(NULL, X, Y)");
    ValDel(e, N);
    N = ValNewStrA(e, "Y");
    R = DoHasProperty(e, O, N);
    ok(t, ValIsTrueDel(e, R), "obj.ObjectCreate(NULL, X, Y)");
    ValDel(e, N);
    ValDel(e, O);
    ValDel(e, LV);
    
}

void TestProto(test* t, Val* o1, Val* o2, char* desc) {
    Js* e = t->js;
    Val* proto = DoGet(e, o1, e->prototype, o1);
    ok(t, VallAllEq(e, proto, o2), desc);
    ValDel(e, proto);
}

void RealmTest(test* t) {
    Js* e = t->js;
    Realm* r = RealmNew(e);
    
    Realm* i = r;
    TestProto(t, i->arrayBufferConstructor, i->arrayBufferPrototype, "Realm.array_buffer");
    TestProto(t, i->arrayConstructor, i->arrayPrototype, "Realm.array");
    TestProto(t, i->booleanObject, i->booleanPrototype, "Realm.boolean");
    TestProto(t, i->dataViewObject, i->dataViewPrototype, "Realm.dataview");
    TestProto(t, i->dateObject, i->datePrototype, "Realm.date");
    TestProto(t, i->errorObject, i->errorPrototype, "Realm.error");
    TestProto(t, i->evalErrorObject, i->evalErrorPrototype, "Realm.eval_error");
    TestProto(t, i->functionConstructor, i->functionPrototype, "Realm.function");
    TestProto(t, i->generatorObject, i->generatorPrototype, "Realm.generator");
    TestProto(t, i->int8ArrayObject, i->int8ArrayPrototype, "Realm.int8_array");
    TestProto(t, i->mapObject, i->mapPrototype, "Realm.map");
    TestProto(t, i->numberObject, i->numberPrototype, "Realm.number");
    TestProto(t, i->objectConstructor, i->objectPrototype, "Realm.object");
    TestProto(t, i->rangeErrorObject, i->rangeErrorPrototype, "Realm.range_error");
    TestProto(t, i->referenceErrorObject, i->referenceErrorPrototype, "Realm.reference_error");
    TestProto(t, i->regExpConstructor, i->regExpPrototype, "Realm.regexp");
    TestProto(t, i->setObject, i->setPrototype, "Realm.set");
    TestProto(t, i->stringConstructor, i->stringPrototype, "Realm.string");
    TestProto(t, i->typeErrorObject, i->typeErrorPrototype, "Realm.type_error");
    TestProto(t, i->typedArrayObject, i->typedArrayPrototype, "Realm.typed_array");
    TestProto(t, i->uriErrorObject, i->uriErrorPrototype, "Realm.uri_error");
    TestProto(t, i->syntaxErrorObject, i->syntaxErrorPrototype, "Realm.syntax_error");
    TestProto(t, i->weakMapObject, i->weakMapPrototype, "Realm.weakmap");
    TestProto(t, i->weakSetObject, i->weakSetPrototype, "Realm.weakset");

    RealmComplete(e, r);

    // We can't use getBindingValue since we are using the global object
    // properties to initialize constructor functions
    // LexEnv* lex = r->globalEnv->lex;
    // Env* ge = lex->envRec;
    // Val* N = ValNewStrA(e, "Object");
    // Val* R = ge->vtable->getBindingValue(e, ge, N, FALSE);
    Val* R = GetA(e, r->globalThis, "Object");
    ok(t, R->type == TYPE_OBJ && ObjectGetMethod(e, R->obj, _Call_) == BuiltinFunctionCall, "Realm.getBindingValue");
    ValDel(e, R);
    // ValDel(e, N);
    RealmDelete(e, r);
    
}

void CompTest(test* t) {
    Js* e = t->js;
    Completion* c = CompNew(e, COMP_BREAK, NULL, NULL);
    ok(t, c->value->type == TYPE_UNDEF, "Completion.alloc0");
    ok(t, c->target == NULL, "Completion.alloc1");
    ok(t, c->type == COMP_BREAK, "Completion.alloc2");
    CompDel(e, c);
    
    Val* v;
    v = ValNewNum(e, 3.14);
    // c will own the Val v from now on
    c = CompNew(e, COMP_NORMAL, v, NULL);
    ValDel(e, v);
    Val* vc = CompGetValue(e, c);
    ok(t, vc->type == TYPE_NUM, "Completion.alloc3");
    ok(t, vc->num == 3.14, "Completion.alloc4");
    ok(t, c->target == NULL, "Completion.alloc5");
    ok(t, c->type == COMP_NORMAL, "Completion.alloc6");
    ok(t, !CompIsAbrupt(e, c), "Completion.is_abrupt");
    CompDel(e, c);
    ValDel(e, vc);
    
    Val* label = ValNewStrA(e, "hello");
    c = CompNew(e, COMP_RETURN, NULL, label);
    ValDel(e, label);
    ok(t, StrEqChars(e, c->target->str, "hello"), "Completion.alloc7");
    ok(t, CompIsAbrupt(e, c), "Completion.is_abrupt2");
    CompDel(e, c);
}


void ListTest(test* t) {
    Js* e = t->js;
    Val* v0 = ValNewNum(e, 1);
    Val* v1 = ValNewStrA(e, "hello");
    List* l = ListNew(e);
    ok(t, ListGetCount(e, l) == 0, "List.get_count");
    ok(t, ListGetValue(e, l, 1) == NULL, "list_get_invalid_index");
    ListAddValue(e, l, v0);
    ListAddValue(e, l, v1);
    
    Val* v0c = ListGetValue(e, l, 0);
    ok(t, v0c->num == 1, "List.get_value0");
    Val* v1c = ListGetValue(e, l, 1);
    ok(t, StrEqChars(e, v1c->str, "hello"), "List.get_value1");
    ValDel(e, v0c);
    ValDel(e, v1c);
    ListDel(e, l);
}

void RefTest(test* t) {
    Js* e = t->js;
    Val* n1 = ValNewStrA(e, "testRef");
    Ref* r1 = RefNew(e, NULL, n1, FALSE, NULL);
    Val* v1 = ValNewRef(e, r1);
    ok(t, v1->type == TYPE_REF, "Ref.newa");
    Val* v2 = ValNewStrA(e, "howzit");
    ValSet(e, v2, v1);
    ok(t, v2->type == TYPE_REF, "Val.set");
    ok(t, StrEqChars(e, RefGetReferencedName(e, v2)->str, "testRef"), "Ref.new");
    ValDel(e, v1);
    ValDel(e, v2);
    ValDel(e, n1);
    
    
    Val* nv = ValNewNum(e, 1.2345);               // create num value
    Val* rvn = ValNewStrA(e, "X");                  // create Ref name
    Ref* rn = RefNew(e, nv, rvn, TRUE, NULL); // create reference
    Val* vr = ValNewRef(e, rn);                   // create a Ref value
    ok(t, RefIsUnresolvable(e, vr) == FALSE, "Ref.is_unresolvable");
    ok(t, RefIsStrict(e, vr) == TRUE, "Ref.is_strict");
    ok(t, RefIsSuper(e, vr) == FALSE, "Ref.is_super");
    ok(t, RefIsPropRef(e, vr) == TRUE, "Ref.is_prop_ref");
    ok(t, RefHasPrimitiveBase(e, vr) == TRUE, "Ref.has_primitive_base");
    Val* base = RefGetBase(e, vr);
    ok(t, base->type == TYPE_NUM, "Ref.get_base");
    Val* vg = GetValue(e, base);
    ok(t, vg->type == TYPE_NUM, "Ref.get_value(non_ref)");
    ValDel(e, base);
    ValDel(e, vg);
    ValDel(e, vr);                              // _free Ref value
    ValDel(e, nv);                              // _free num value
    ValDel(e, rvn);                                  // _free Ref name
    
    
    Val* vo1 = ValNewObject(e);
    ObjectSetANum(e, vo1, "PI",3.14);
    Val* vr1 = ValNewRefA(e, vo1, "PI", FALSE, NULL);
    ok(t, RegGetEqNum(e, vr1, 3.14), "Ref.get_value(property_ref)");
    ValDel(e, vo1);
    ValDel(e, vr1);
    
    Val* abrupt = ValNewCompA(e, COMP_RETURN, NULL, NULL);
    ok(t, RegGetAbrupt(e, abrupt), "Ref.get_value(abrupt)");
    ValDel(e, abrupt);
    
    Val* nr = ValNewNum(e, 10);
    ok(t, RegGetEqNum(e, nr, 10), "Ref.get_value(non_ref)");
    ValDel(e, nr);

    base = ValNew(e);
    vr = ValNewRefA(e, base, "na", FALSE, NULL);
    Val* gv = GetValue(e, vr);
    ok(t, ValIsThrow(e, gv, CurrentRealm(e)->referenceErrorObject), "Ref.get_value(unresolvable)");
    ValDel(e, base);
    ValDel(e, vr);
    ValDel(e, gv);
    
#if ENV_OLD
    base = ValNewEnv(e);
    vr = ValNewRefA(e, base, "na", FALSE, NULL);
    gv = GetValue(e, vr);
    ok(t, gv->type == TYPE_UNDEF, "Ref.get_value(Env)");
    ValDel(e, base);
    ValDel(e, vr);
    ValDel(e, gv);
#endif
    
    Val* V = ValNewCompA(e, COMP_BREAK, NULL, NULL);
    Val* W = ValNewNum(e, 1);
    Val* R = PutValue(e, V, W);
    ok(t, R->type == TYPE_COMP && CompIsAbrupt(e, R->completion), "Ref.put_value(abrupt_v)");
    ValDel(e,V);
    ValDel(e, W);
    ValDel(e, R);

    V = ValNewNum(e, 1);
    W = ValNewCompA(e, COMP_BREAK, NULL, NULL);
    R = PutValue(e, V, W);
    ok(t, R->type == TYPE_COMP && CompIsAbrupt(e, R->completion), "Ref.put_value(abrupt_w)");
    ValDel(e,V);
    ValDel(e, W);
    ValDel(e, R);

    base = ValNew(e);
    V = ValNewRefA(e, base, "na", TRUE, NULL);
    W = ValNewNum(e, 1);
    R = PutValue(e, V, W);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->referenceErrorObject), "Ref.put_value(unresolvable_strict)");
    ValDel(e, base);
    ValDel(e, V);
    ValDel(e, W);
    ValDel(e, R);

    base = ValNew(e);
    V = ValNewRefA(e, base, "X", FALSE, NULL);
    W = ValNewNum(e, 1);
    R = PutValue(e, V, W);
    Val* G = GetGlobalObject(e);
    Val* X = GetA(e, G, "X");
    ok(t, X->type == TYPE_NUM, "Ref.put_value(unresolvable_non_strict)");
    ok(t, X->num == 1, "Ref.put_value(unresolvable_non_strict)");
    ValDel(e, X);
    // let's delete the "X" property so that we don't leak temporarily in the test
    // it's not a real leak since RealmDelete() will delete the global object
    // and that will _free up all its properties
    DelA(e, G, "X");
    ValDel(e, G);
    ValDel(e, R);
    ValDel(e, base);
    ValDel(e, V);
    ValDel(e, W);

    base = ValNewObject(e);
    PutA(e, base, "Z", ValNewNum(e, 9.3), TRUE);
    V = ValNewRefA(e, base, "Z", FALSE, NULL);
    W = ValNewNum(e, 1);
    R = PutValue(e, V, W);
    Val* Z = GetA(e, base, "Z");
    ok(t, Z->type == TYPE_NUM, "Ref.put_value(Property)");
    ok(t, Z->num == 1, "Ref.put_value(Property)");
    ValDel(e, Z);
    ValDel(e, R);
    ValDel(e, W);
    ValDel(e, V);
    ValDel(e, base);
    
#ifdef ENV_OLD
    base = ValNewEnv(e);
    V = ValNewRefA(e, base, "E", FALSE, NULL);
    W = ValNewNum(e, 1);
    R = PutValue(e, V, W);
    ok(t, R->type == TYPE_UNDEF, "Ref.put_value(Env)");
    ValDel(e, R);
    ValDel(e, W);
    ValDel(e, V);
    ValDel(e, base);
#endif

    V = ValNewCompA(e, COMP_BREAK, NULL, NULL);
    R = RefGetThis(e, V);
    ok(t, R->type == TYPE_COMP && CompIsAbrupt(e, R->completion), "Ref.get_this(abrupt_v)");
    ValDel(e,V);
    ValDel(e, R);

    V = ValNewNum(e, 1);
    R = RefGetThis(e, V);
    ok(t, R->type == TYPE_NUM && R->num == 1, "Ref.get_this(non_ref)");
    ValDel(e,V);
    ValDel(e, R);

    base = ValNew(e);
    V = ValNewRefA(e, base, "na", TRUE, NULL);
    R = RefGetThis(e, V);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->referenceErrorObject), "Ref.put_value(unresolvable)");
    ValDel(e, base);
    ValDel(e, V);
    ValDel(e, R);

    Val* super = ValNewObject(e);
    base = ValNewNum(e,1);
    V = ValNewRefA(e, base, "na", TRUE, super);
    R = RefGetThis(e, V);
    ok(t, VallAllEq(e, R, super), "Ref.get_this(super)");
    ValDel(e, R);
    ValDel(e, V);
    ValDel(e, base);
    ValDel(e, super);

    base = ValNewNum(e,1);
    V = ValNewRefA(e, base, "na", TRUE, NULL);
    R = RefGetThis(e, V);
    ok(t, VallAllEq(e, R, base), "Ref.get_this(base)");
    ValDel(e, R);
    ValDel(e, V);
    ValDel(e, base);
}

void DataTest(test* t) {
    Js* e = t->js;
    
    Data* D1 = DataCreate(e, 10);
    for(int i=0; i < 10; i++)
        D1->data[i] = i+1;

    Data* D2 = DataCreate(e, 10);
    Val* R = DataCopyBytes(e, D2, 0, D1, 0, 10);
    bool_t worked = TRUE;
    for(int i=0; i < 10; i++) {
        if(D2->data[i] != i+1) {
            worked = FALSE;
            break;
        }
    }
    ok(t, worked == TRUE, "Data.copybytes");
    ValDel(e, R);
    DataDel(e, D1);
    DataDel(e, D2);
}

void ConvTest(test* t) {
    Js* e = t->js;
    
    Val* N = ValNewNum(e, 9);
    Val * R = ToPrimitive(e, N, NULL);
    ok(t, R->type == TYPE_NUM, "conv.ToPrimitive(num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, 9);
    Val* C = ValNewCompA(e, COMP_THROW, N, NULL);
    R = ToPrimitive(e, C, NULL);
    ok(t, R->type == TYPE_COMP, "conv.ToPrimitive(abrupt_comp)");
    ValDel(e, C);
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, 9);
    C = ValNewCompA(e, COMP_NORMAL, N, NULL);
    R = ToPrimitive(e, C, NULL);
    ok(t, R->type == TYPE_NUM, "conv.ToPrimitive(normal_comp)");
    ValDel(e, C);
    ValDel(e, R);
    ValDel(e, N);

    Val* O = ValNewObject(e);
    R = ToPrimitive(e, O, NULL);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->typeErrorObject), "comv.ToPrimitive(obj_blank)");
    ValDel(e, R);
    ValDel(e, O);
    
    
    N = ValNewNum(e, 2);
    R = ToBoolean(e, N);
    ok(t, R->type == TYPE_BOOL && R->b == TRUE, "conv.ToBoolean(num_non_zero)");
    ValDel(e, R);
    ValDel(e, N);
    
    N = ValNewNum(e, 0);
    R = ToBoolean(e, N);
    ok(t, R->type == TYPE_BOOL && R->b == FALSE, "conv.ToBoolean(num_zero)");
    ValDel(e, R);
    ValDel(e, N);
    
    N = ValNewNum(e, sqrt(-1));
    R = ToBoolean(e, N);
    ok(t, R->type == TYPE_BOOL && R->b == FALSE, "conv.ToBoolean(nan)");
    ValDel(e, R);
    ValDel(e, N);
    
    Val* S = ValNewStrA(e, "");
    R = ToBoolean(e, S);
    ok(t, R->type == TYPE_BOOL && R->b == FALSE, "conv.ToBoolean(empty_string)");
    ValDel(e, R);
    ValDel(e, S);
    
    S = ValNewStrA(e, "hello");
    R = ToBoolean(e, S);
    ok(t, R->type == TYPE_BOOL && R->b == TRUE, "conv.ToBoolean(non_empty_string)");
    ValDel(e, R);
    ValDel(e, S);
    
    S = ValNewStrA(e, "0xf00babe");
    R = ToNumber(e, S);
    ok(t, R->type == TYPE_NUM && R->num == 0xf00babe, "conv.ToNumber(string_hex)");
    ValDel(e, R);
    ValDel(e, S);

    S = ValNewStrA(e, "1.2e1");
    R = ToNumber(e, S);
    ok(t, R->type == TYPE_NUM && R->num == 12, "conv.ToNumber(string_sci)");
    ValDel(e, R);
    ValDel(e, S);

    S = ValNewStrA(e, "hello");
    R = ToNumber(e, S);
    ok(t, R->type == TYPE_NUM && isnan(R->num), "conv.ToNumber(string_non_num)");
    ValDel(e, R);
    ValDel(e, S);

    N = ValNewNum(e, 1.4);
    R = ToInteger(e, N);
    ok(t, R->type == TYPE_NUM && R->num == 1, "conv.ToInteger(+num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -3.4);
    R = ToInteger(e, N);
    ok(t, R->type == TYPE_NUM && R->num == -3, "conv.ToInteger(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -1.23);
    R = ToInt32(e, N);
    ok(t, R->type == TYPE_NUM && R->num == -1, "conv.ToInt32(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -1.23);
    R = ToUint32(e, N);
    ok(t, R->type == TYPE_NUM && (uint32) R->num == (uint32) -1, "conv.ToUint32(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -1.23);
    R = ToInt16(e, N);
    ok(t, R->type == TYPE_NUM && (int16) R->num == (int16) -1, "conv.ToInt16(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -1.23);
    R = ToUint16(e, N);
    ok(t, R->type == TYPE_NUM && (uint16) R->num == (uint16) -1, "conv.ToUint16(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -1.23);
    R = ToInt8(e, N);
    ok(t, R->type == TYPE_NUM && (int8) R->num == (int8) -1, "conv.ToInt8(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -1.23);
    R = ToUint8(e, N);
    ok(t, R->type == TYPE_NUM && (uint8) R->num == (uint8) -1, "conv.ToUint8(-num)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, 256);
    R = ToUint8Clamp(e, N);
    ok(t, R->type == TYPE_NUM && R->num == 255, "conv.ToUint8Clamp(> 255)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, -2);
    R = ToUint8Clamp(e, N);
    ok(t, R->type == TYPE_NUM && R->num == 0, "conv.ToUint8Clamp(< 0)");
    ValDel(e, R);
    ValDel(e, N);

    N = ValNewNum(e, 3.14);
    S = ToString(e, N);

    ok(t, StrEqChars(e, S->str, "3.14"), "conv.ToString(num)");
    ValDel(e, S);
    ValDel(e, N);

    N = ValNewNum(e, 0);
    S = ToString(e, N);
    ok(t, StrEqChars(e, S->str, "0"), "conv.ToString(0)");
    ValDel(e, S);
    ValDel(e, N);    


    N = ValNewNum(e, sqrt(-1));
    S = ToString(e, N);
    ok(t, StrEqChars(e, S->str, "NaN"), "conv.ToString(NaN)");
    ValDel(e, S);
    ValDel(e, N);    

    number z = 0;
    N = ValNewNum(e, 1/z);
    S = ToString(e, N);
    ok(t, StrEqChars(e, S->str, "Infinity"), "conv.ToString(Infinity)");
    ValDel(e, S);
    ValDel(e, N);    

    N = ValNewNum(e, -1/z);
    S = ToString(e, N);
    ok(t, StrEqChars(e, S->str, "-Infinity"), "conv.ToString(-Infinity)");
    ValDel(e, S);
    ValDel(e, N);    

    Val* U = ValNew(e);
    S = ToString(e, U);
    ok(t, StrEqChars(e, S->str, "undefined"), "conv.ToString(undef)");
    ValDel(e, S);
    ValDel(e, U);

    N = ValNewNull(e);
    S = ToString(e, N);
    ok(t, StrEqChars(e, S->str, "null"), "conv.ToString(null)");
    ValDel(e, S);
    ValDel(e, N);
    
    N = ValNewNum(e, 3.14);
    O = ToObject(e, N);
    Val* V =  ObjectGetSlot(e, O->obj, _NumberData_); //  GetA(e, O, _NumberData_);
    ok(t, V->num == 3.14, "conv.ToObject(num)");
    ValDel(e, O);
    ValDel(e, N);

    Val* B = ValNewBool(e, TRUE);
    O = ToObject(e, B);
    V = GetA(e, O, _BooleanData_);
    ok(t, V->b == TRUE, "conv.ToObject(bool)");
    ValDel(e, V);
    ValDel(e, O);
    ValDel(e, B);

    S = ValNewStrA(e, "hello");
    O = ToObject(e, S);
    V = ObjectGetSlot(e, O->obj, _StringData_);
    ok(t, StrEqChars(e, V->str, "hello") , "conv.ToObject(string)");
    ValDel(e, O);
    ValDel(e, S);

    S = ValNewSymbol(e, "sym1");
    Val* P = ToPropKey(e, S);
    ok(t, P->type == TYPE_SYMA && ValEqStrA(e, P, "sym1"), "conv.ToPropKey(sym)");
    ValDel(e, P);
    ValDel(e, S);

    N = ValNewNum(e, 1.23);
    P = ToPropKey(e, N);
    ok(t, P->type == TYPE_STR && ValEqStrA(e, P, "1.23") , "conv.ToPropKey(num)");
    ValDel(e, P);
    ValDel(e, N);
    
    N = ValNewNum(e, 45.5);
    Val* L = ToLength(e, N);
    ok(t, L->type == TYPE_NUM && L->num == 45, "conv.ToLength(num)");
    ValDel(e, L);
    ValDel(e, N);

    N = ValNewNum(e, pow(2, 55));
    L = ToLength(e, N);
    ok(t, L->type == TYPE_NUM && L->num == (pow(2,53)-1), "conv.ToLength(num)");
    ValDel(e, L);
    ValDel(e, N);
    

    N = ValNewNum(e, 0.6e-6);
    S = ToString(e, N);
    ok(t, ValEqStrA(e, S, "6e-7"), "conv.ToString(0.6e-6)");
    ValDel(e,S);    
    ValDel(e, N);
}


void CheckTest(test* t) {
    Js* e = t->js;
    
    Val* N = ValNewNum(e, 3.14);
    Val* C = RequireObjectCoercible(e, N);
    ok(t, C->num == 3.14, "check.object_coercible(num)");
    ValDel(e, C);
    ValDel(e, N);
    
    N = ValNewNull(e);
    C = RequireObjectCoercible(e, N);
    ok(t, ValIsThrow(e, C, CurrentRealm(e)->typeErrorObject), "check.object_coercible(null)");
    ValDel(e, C);
    ValDel(e, N);
    
    N = ValNewNum(e, 3.14);
    C = IsCallable(e, N);
    ok(t, C->type == TYPE_BOOL && C->b == FALSE, "check.IsCallable");
    ValDel(e, C);
    ValDel(e, N);
    
    Val* V1 = ValNewNum(e, +0.0);
    Val* V2 = ValNewNum(e, -0.0);
    C = SameValue(e, V1, V2);
    ok(t, C->type == TYPE_BOOL && C->b == FALSE, "check.SameValue(+0,-0)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewNum(e, -0.0);
    V2 = ValNewNum(e, +0.0);
    C = SameValue(e, V1, V2);
    ok(t, C->type == TYPE_BOOL && C->b == FALSE, "check.SameValue(-0,+0)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewNum(e, +0.0);
    V2 = ValNewNum(e, +0.0);
    C = SameValue(e, V1, V2);
    ok(t, C->type == TYPE_BOOL && C->b == TRUE, "check.SameValue(0,0)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);
    
    V1 = ValNewStrA(e, "hello");
    V2 = ValNewStrA(e, "hel");
    C = SameValue(e, V1, V2);
    ok(t, C->b == FALSE, "check.SameValue(different_strings)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewStrA(e, "hello");
    V2 = ValNewStrA(e, "hello");
    C = SameValue(e, V1, V2);
    ok(t, C->b == TRUE, "check.SameValue(different_strings)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);
    
    V1 = ValNew(e);
    V2 = ValNew(e);
    C = SameValue(e, V1, V2);
    ok(t, C->b == TRUE, "check.SameValue(undef, undef)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewBool(e, FALSE);
    V2 = ValNewBool(e, TRUE);
    C = SameValue(e, V1, V2);
    ok(t, C->b == FALSE, "check.SameValue(false, true)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);
    
    V1 = ValNewBool(e, FALSE);
    V2 = ValNewBool(e, FALSE);
    C = SameValue(e, V1, V2);
    ok(t, C->b == FALSE, "check.SameValue(false, false)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewBool(e, TRUE);
    V2 = ValNewBool(e, TRUE);
    C = SameValue(e, V1, V2);
    ok(t, C->b == TRUE, "check.SameValue(true, true)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);
    
    
    V1 = ValNewNum(e, +0.0);
    V2 = ValNewNum(e, -0.0);
    C = SameValueZero(e, V1, V2);
    ok(t, C->type == TYPE_BOOL && C->b == TRUE, "check.SameValueZero(+0,-0)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewNum(e, -0.0);
    V2 = ValNewNum(e, +0.0);
    C = SameValueZero(e, V1, V2);
    ok(t, C->type == TYPE_BOOL && C->b == TRUE, "check.SameValueZero(-0,+0)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);

    V1 = ValNewNum(e, +0.0);
    V2 = ValNewNum(e, +0.0);
    C = SameValueZero(e, V1, V2);
    ok(t, C->type == TYPE_BOOL && C->b == TRUE, "check.SameValueZero(0,0)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);
    
    V1 = ValNewBool(e, TRUE);
    V2 = ValNewBool(e, TRUE);
    C = SameValueZero(e, V1, V2);
    ok(t, C->b == TRUE, "check.SameValueZero(true, true)");
    ValDel(e, C);
    ValDel(e, V1);
    ValDel(e, V2);
    
    V1 = ValNewStrA(e, "x");
    C = IsPropKey(e, V1);
    ok(t, C->b == TRUE, "check.IsPropKey(string)");
    ValDel(e, C);
    ValDel(e, V1);

    V1 = ValNewSymbol(e, "x");
    C = IsPropKey(e, V1);
    ok(t, C->b == TRUE, "check.IsPropKey(symbol)");
    ValDel(e, C);
    ValDel(e, V1);

    V1 = ValNewNum(e, 1);
    C = IsPropKey(e, V1);
    ok(t, C->b == FALSE, "check.IsPropKey(num)");
    ValDel(e, C);
    ValDel(e, V1);

    V1 = ValNewNum(e, 1);
    V2 = ValNewNum(e, 2);
    C = AbstractRelational(e, V1, V2, TRUE);
    ok(t, C->b == TRUE, "check.AbstractRelational(1,2)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, 2);
    V2 = ValNewNum(e, 1);
    C = AbstractRelational(e, V1, V2, FALSE);
    ok(t, C->b == TRUE, "check.AbstractRelational(2,1)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, NAN);
    V2 = ValNewNum(e, 1);
    C = AbstractRelational(e, V1, V2, FALSE);
    ok(t, C->type == TYPE_UNDEF, "check.AbstractRelational(NaN,1)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, +0.0);
    V2 = ValNewNum(e, -0.0);
    C = AbstractRelational(e, V1, V2, FALSE);
    ok(t, C->b == FALSE, "check.AbstractRelational(+0,-0)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewStrA(e, "ABC");
    V2 = ValNewStrA(e, "AB");
    C = AbstractRelational(e, V1, V2, FALSE);
    ok(t, C->b == TRUE, "check.AbstractRelational(ABC,AB)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewStrA(e, "AB");
    V2 = ValNewStrA(e, "ABC");
    C = AbstractRelational(e, V1, V2, TRUE);
    ok(t, C->b == TRUE, "check.AbstractRelational(AB,ABC)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNew(e);
    V2 = ValNewNull(e);
    C = AbstractEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.AbstractEquality(undef, null)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNull(e);
    V2 = ValNew(e);
    C = AbstractEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.AbstractEquality(null, undef)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, 1.23);
    V2 = ValNewStrA(e, "1.23");
    C = AbstractEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.AbstractEquality(num, str)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, 1.2);
    V2 = ValNewStrA(e, "1.23");
    C = AbstractEquality(e, V1, V2);
    ok(t, C->b == FALSE, "check.AbstractEquality(num, str)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, 1);
    V2 = ValNewBool(e, TRUE);
    C = AbstractEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.AbstractEquality(1, true)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewNum(e, 1);
    V2 = ValNewBool(e, TRUE);
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == FALSE, "check.StrictEquality(1, true)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewStrA(e, "ABC");
    V2 = ValNewStrA(e, "ABC");
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.StrictEquality(ABC, ABC)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewStrA(e, "ABC");
    V2 = ValNewStrA(e, "AB");
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == FALSE, "check.StrictEquality(ABC, AB)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewBool(e, TRUE);
    V2 = ValNewBool(e, TRUE);
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.StrictEquality(true, true)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewBool(e, FALSE);
    V2 = ValNewBool(e, TRUE);
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == FALSE, "check.StrictEquality(false, true)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewBool(e, TRUE);
    V2 = ValNewBool(e, FALSE);
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == FALSE, "check.StrictEquality(true, false)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

    V1 = ValNewBool(e, FALSE);
    V2 = ValNewBool(e, FALSE);
    C = StrictEquality(e, V1, V2);
    ok(t, C->b == TRUE, "check.StrictEquality(false, false)");
    ValDel(e, C);
    ValDel(e, V2);
    ValDel(e, V1);

}

Val* MockCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    return ValNewNum(e, 1.234);
}

Val* MockCallCreate(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    Val* r = ValNewObject(e);
    ObjectSetProto(e, r, CurrentRealm(e)->objectPrototype);
    PutA(e, r, "X", ValNewNum(e, 99), TRUE);
    return r;
}

Val* MockConstruct(Js* e, Val* o, Val* args) {
    return NULL;
}

Val* MockConstructInit(Js* e, Val* o, Val* othis, Val* args) {
    PutA(e, othis, "PI", ValNewNum(e, 3.14), TRUE);
    return ValNew(e);
}

void ObjOpsTest(test* t) {
    Js* e = t->js;
    
    Val* O = ValNewObject(e);
    Val* V = ValNewNum(e, 9);
    Val* P = ValNewStrA(e, "X");
    Val* R = Put(e, O, P, V, TRUE);
    ok(t, ValIsTrueDel(e, R), "objops.Put");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_NUM && R->num == 9, "objops.Get");
    ValDel(e, R);
    ValDel(e, P);
    ValDel(e, V);
    ValDel(e, O);
    

    O = ValNewObject(e);
    V = ValNewNum(e, 9);
    P = ValNewStrA(e, "X");
    R = CreateDataProp(e, O, P, V);
    ok(t, ValIsTrueDel(e, R), "objops.CreateDataProp");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_NUM && R->num == 9, "objops.Get");
    ValDel(e, R);
    ValDel(e, P);
    ValDel(e, V);
    ValDel(e, O);

    O = ValNewObject(e);
    V = ValNewNum(e, 9);
    P = ValNewStrA(e, "X");
    R = CreateDataPropOrThrow(e, O, P, V);
    ok(t, ValIsTrueDel(e, R), "objops.CreateDataPropOrThrow");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_NUM && R->num == 9, "objops.Get");
    ValDel(e, R);
    ValDel(e, P);
    ValDel(e, V);
    ValDel(e, O);
 
    O = ValNewObject(e);
    Val* desc = ValNewDesc(e);
    V = ValNewNum(e, 3.14);
    P = ValNewStrA(e, "Y");
    PropSetValue(e, desc->desc, V);
    R = DefinePropOrThrow(e, O, P, desc);
    ok(t, ValIsTrueDel(e, R), "objops.DefinePropOrThrow");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_NUM && R->num == 3.14, "objops.Get");
    ValDel(e, R);
    R = DeletePropOrThrow(e, O, P);
    ok(t, !ValIsTrueDel(e, R), "objops.DeletePropOrThrow(unconfigurable)");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_NUM, "objops.DeletePropOrThrow(unconfigurable)");
    ValDel(e, R);
    ValDel(e, P);
    ValDel(e, V);
    ValDel(e, O);
    ValDel(e, desc);

    O = ValNewObject(e);
    desc = ValNewDesc(e);
    PropSetConfigurable(e, desc->desc, TRUE);
    V = ValNewNum(e, 3.14);
    P = ValNewStrA(e, "Y");
    PropSetValue(e, desc->desc, V);
    R = DefinePropOrThrow(e, O, P, desc);
    ok(t, ValIsTrueDel(e, R), "objops.DefinePropOrThrow");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_NUM && R->num == 3.14, "objops.Get");
    ValDel(e, R);
    R = DeletePropOrThrow(e, O, P);
    ok(t, ValIsTrueDel(e, R), "objops.DeletePropOrThrow(configurable)");
    R = Get(e, O, P);
    ok(t, R->type == TYPE_UNDEF, "objops.DeletePropOrThrow(configurable)");
    ValDel(e, R);
    ValDel(e, P);
    ValDel(e, V);
    ValDel(e, O);
    ValDel(e, desc);


    Val* T = NativeFuncNew(e, NULL, MockCall);
    O = ValNewObject(e);
    P = ValNewStrA(e, "someMethod");
    R = Put(e, O, P, T, TRUE);
    ValDel(e, R);
    Val* M = GetMethod(e, O, P);
    ok(t, M->type == TYPE_OBJ, "objops.GetMethod");
    ValDel(e, M);
    ValDel(e, P);
    ValDel(e, O);
    ValDel(e, T);
    
    
    O = ValNewObject(e);
    P = ValNewStrA(e, "X");
    V = ValNewNum(e, 3.14);
    R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    ok(t, ValIsTrueDel(e, HasProp(e, O, P)), "objops.HasProp");
    ValDel(e, P);
    P = ValNewStrA(e, "Y");
    ok(t, !ValIsTrueDel(e, HasProp(e, O, P)), "objops.HasProp");
    ValDel(e, V);
    ValDel(e, P);
    ValDel(e, O);

    O = ValNewObject(e);
    P = ValNewStrA(e, "X");
    V = ValNewNum(e, 3.14);
    R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    ok(t, ValIsTrueDel(e, HasOwnProp(e, O, P)), "objops.HasOwnProp");
    ValDel(e, V);
    ValDel(e, P);
    ValDel(e, O);
 
    T = NativeFuncNew(e, NULL, MockCall);
    O = ValNewObject(e);
    P = ValNewStrA(e, "someMethod");
    R = Put(e, O, P, T, TRUE);
    ValDel(e, R);
    R = Invoke(e, O, P, NULL);
    ok(t, R->num == 1.234, "objops.Invoke");
    ValDel(e, R);
    ValDel(e, P);
    ValDel(e, O);
    ValDel(e, T);

    O = ValNewObject(e);
    P = ValNewStrA(e, "X");
    V = ValNewNum(e, 3.14);
    R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    Val* L = ValNewStrA(e, "sealed");
    R = SetIntegrityLevel(e, O, L);
    Val* D = DoGetOwnProperty(e, O, P);
    ok(t, PropHasConfigurable(e, D->desc) && !PropIsConfigurable(e, D->desc) &&
            PropHasWritable(e, D->desc) && PropIsWritable(e, D->desc) ,  "objops.SetIntegrityLevel(sealed)");
    ValDel(e, D);
    ValDel(e, R);
    ValDel(e, L);
    ValDel(e, V);
    ValDel(e, P);
    ValDel(e, O);

    O = ValNewObject(e);
    P = ValNewStrA(e, "X");
    V = ValNewNum(e, 3.14);
    R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    L = ValNewStrA(e, "frozen");
    R = SetIntegrityLevel(e, O, L);
    D = DoGetOwnProperty(e, O, P);
    ok(t, PropHasConfigurable(e, D->desc) && !PropIsConfigurable(e, D->desc) &&
        PropHasWritable(e, D->desc) && !PropIsWritable(e, D->desc) , "objops.SetIntegrityLevel(frozen)");
    ValDel(e, D);
    ValDel(e, R);
    ValDel(e, L);
    ValDel(e, V);
    ValDel(e, P);
    ValDel(e, O);
    
    O = ValNewObject(e);
    P = ValNewStrA(e, "X");
    V = ValNewNum(e, 3.14);
    R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    L = ValNewStrA(e, "sealed");
    R = TestIntegrityLevel(e, O, L);
    ok(t, !ValIsTrueDel(e, R), "objops.TestIntegrityLevel(sealed_no)");
    R = SetIntegrityLevel(e, O, L);
    ValDel(e, R);
    R = TestIntegrityLevel(e, O, L);
    ok(t, ValIsTrueDel(e, R), "objops.TestIntegrityLevel(sealed)"); // @todo: review
    ValDel(e, L);
    ValDel(e, V);
    ValDel(e, P);
    ValDel(e, O);
    
    
    O = ValNewObject(e);
    P = ValNewStrA(e, "X");
    V = ValNewNum(e, 3.14);
    R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    L = ValNewStrA(e, "frozen");
    R = TestIntegrityLevel(e, O, L);
    ok(t, !ValIsTrueDel(e, R), "objops.TestIntegrityLevel(frozen_no)");
    R = SetIntegrityLevel(e, O, L);
    ValDel(e, R);
    R = TestIntegrityLevel(e, O, L);
    ok(t, ValIsTrueDel(e, R), "objops.TestIntegrityLevel(frozen)");
    ValDel(e, L);
    ValDel(e, V);
    ValDel(e, P);
    ValDel(e, O);

    
    List* l = ListNew(e);
    Val* V0 = ValNewNum(e, 3);
    Val* V1 = ValNewNum(e, 9);
    ListAddValue(e, l, V0);
    ListAddValue(e, l, V1);
    Val* elements = ValNewList(e, l);
    Val* A = CreateArrayFromList(e, elements);
    R = GetA(e, A, "0");
    ok(t, R->num == 3, "objops.CreateArrayFromList(0)");
    ValDel(e, R);
    R = GetA(e, A, "1");
    ok(t, R->num == 9, "objops.CreateArrayFromList(0)");
    ValDel(e, R);
    ValDel(e, A);
    ValDel(e, elements);
    
    A = ValNewObject(e);
    PutA(e, A, "0", ValNewNum(e,8), TRUE);
    PutA(e, A, "1", ValNewNum(e,14), TRUE);
    PutA(e, A, "length", ValNewNum(e, 2), TRUE);
    L = CreateListFromArrayLike(e, A);
    l = L->list;
    ok(t, l->count ==2, "objops.CreateListFromArrayLike");
    ok(t, l->head->value->num == 8, "objops.CreateListFromArrayLike(0)");
    ok(t, l->head->next->value->num == 14, "objops.CreateListFromArrayLike(1)");
    ValDel(e, L);
    ValDel(e, A);

    
    P = ValNewObject(e);
    Val* C = ValNewObject(e);    // constructor
    ObjectSetMethod(e, C->obj, _Call_, MockCall, FALSE);
    PutA(e, C, "prototype", P, FALSE);
    // ObjectSetProto(e, C, P);
    O = ValNewObject(e);
    ObjectSetProto(e, O, P);
    R = OrdinaryHasInstance(e, C, O);
    ok(t, ValIsTrueDel(e, R), "objops.OrdinaryHasInstance");
    ValDel(e, C);
    ValDel(e, P);
    ValDel(e, O);
    
    
    
    P = ValNewObject(e);
    C = ValNewObject(e);    // object constructor
    ObjectSetMethod(e, C->obj, _Construct_, MockConstruct, FALSE);
    R = DoSet(e, C, e->prototype, P, C);
    ValDel(e, R);
    Val* S = ValNewStrA(e, "%stringPrototype%");
    R = GetPrototypeFromConstructor(e, C, S);
    ok(t, R->type == TYPE_OBJ && R->obj == P->obj, "objops.GetPrototypeFromConstructor(has_proto)");
    ValDel(e, R);
    ValDel(e, S);
    ValDel(e, C);
    ValDel(e, P);
    
    C = ValNewObject(e);    // non-object constructor
    ObjectSetMethod(e, C->obj, _Construct_, MockConstruct, FALSE);
    P = ValNewNull(e);
    ObjectSetProto(e, C, P);
    ValDel(e, P);
    S = ValNewStrA(e, "%stringPrototype%");
    R = GetPrototypeFromConstructor(e, C, S);
    Val* SP = e->currentContext->realm->stringPrototype;
    ok(t, R->type == TYPE_OBJ && R->obj == SP->obj, "objops.GetPrototypeFromConstructor(no_proto,curr_realm)");
    ValDel(e, R);
    ValDel(e, S);
    ValDel(e, C);

    Realm* realm = RealmNew(e);
    P = ValNewNull(e);
    C = ValNewObject(e);    // non-object constructor
    ObjectSetMethod(e, C->obj, _Construct_, MockConstruct, FALSE);
    Val *r = DoSetPrototypeOf(e, C, P);
    ValDel(e, r);
    ObjectSetSlot(e, C->obj, _Realm_, ValNewPtr(e, realm), FALSE, TRUE);
    S = ValNewStrA(e, "%Function%");
    R = GetPrototypeFromConstructor(e, C, S);
    Val* FP = realm->functionConstructor;
    ok(t, R->type == TYPE_OBJ && R->obj == FP->obj, "objops.GetPrototypeFromConstructor(no_proto,cons.[[Realm]])");
    ValDel(e, R);
    ValDel(e, S);
    ValDel(e, C);
    ValDel(e, P);
    RealmDelete(e, realm);
 

    
    // Val* F = ValNewObject(e);
    // O = CreateFromConstructor(e, F);
    // ok(t, O->type == TYPE_UNDEF, "objops.CreateFromConstructor(F no create method)");
    // ValDel(e, O);
    // ValDel(e, F);
    

    // F = ValNewObject(e);
    // C = NativeFuncNew(e, NULL, MockCall);
    // ObjectSetCreateAction(e, F, C);
    // O = CreateFromConstructor(e, F);
    // ok(t, ValIsThrow(e, O, CurrentRealm(e)->typeErrorObject), "objops.CreateFromConstructor(F create not obj)");
    // ValDel(e, O);
    // ValDel(e, C);
    // ValDel(e, F);

    
    // F = ValNewObject(e);
    // C = NativeFuncNew(e, NULL, MockCallCreate);
    // ObjectSetCreateAction(e, F, C);
    // O = CreateFromConstructor(e, F);
    // ok(t, O->type == TYPE_OBJ, "objops.CreateFromConstructor(F create obj)");
    // Val* X = GetA(e, O, "X");
    // ok(t, X->num == 99, "objops.CreateFromConstructor(F create obj)");
    // ValDel(e, X);
    // ValDel(e, O);
    // ValDel(e, C);
    // ValDel(e, F);

    // F = ValNewObject(e);
    // C = NativeFuncNew(e, NULL, MockCallCreate);
    // ObjectSetCreateAction(e, F, C);
    // // A constructor must be callable to initialize the created object
    // ObjectSetMethod(e, F->obj, _Call_, MockConstructInit, FALSE);
    // O = Construct(e, F, NULL, NULL);
    // ok(t, O->type == TYPE_OBJ, "objops.Construct(F create obj)");
    // X = GetA(e, O, "PI");
    // ok(t, X->num == 3.14, "objops.Construct(F create obj).PI");
    // ValDel(e, X);
    // X = GetA(e, O, "X");
    // ok(t, X->num == 99, "objops.Construct(F create obj).X");
    // ValDel(e, X);
    
    // ValDel(e, O);
    // ValDel(e, C);
    // ValDel(e, F);


    // F = ValNewObject(e);
    // ObjectSetMethod(e, F->obj, _Construct_, MockConstruct, FALSE);
    // // @todo: It's not clear why we need both [[Construct]] and [[Call]] to make this work
    // ObjectSetMethod(e, F->obj, _Call_, MockConstructInit, FALSE);
    // O = Construct(e, F, NULL, NULL);
    // ok(t, O->type == TYPE_OBJ, "objops.Construct(F no creator)");
    // X = GetA(e, O, "PI");
    // ok(t, X->num == 3.14, "objops.Construct(F create obj).PI");
    // ValDel(e, X);
    // X = GetA(e, O, "X");
    // ok(t, ValIsUndef(X), "objops.Construct(F create obj).X");
    // ValDel(e, X);
    // X = DoGetPrototypeOf(e, O);
    // Val* Y = e->currentContext->realm->objectPrototype;
    // ok(t, X->obj == Y->obj, "objops.Construct(F no creator)");
    // ValDel(e, X);
    // ValDel(e, O);
    // ValDel(e, F);

    Val* Options = ValNew(e);
    P = ValNewStrA(e, "X");
    O = GetOption(e, Options, P);
    ok(t, O->type == TYPE_UNDEF, "objops.GetOption(undefined)");
    ValDel(e, O);
    ValDel(e, P);
    ValDel(e, Options);
    
    Options = ValNewObject(e);
    P = ValNewStrA(e, "X");
    Val* N = ValNewNum(e, 77);
    R = Put(e, Options, P, N, TRUE);
    ValDel(e, R);
    O = GetOption(e, Options, P);
    ok(t, O->type == TYPE_NUM && O->num == 77, "objops.GetOption(obj)");
    ValDel(e, N);
    ValDel(e, O);
    ValDel(e, P);
    ValDel(e, Options);
}

void IterTest(test* t) {
    Js* e = t->js;

    Val* I = CreateEmptyIterator(e);
    Val* R = GetA(e, I, "next");
    ok(t, R->type == TYPE_OBJ, "iter.CreateEmptyIterator()");
    ok(t, ValIsTrueDel(e, IsCallable(e, R)), "iter.CreateEmptyIterator()");
    ValDel(e, R);
    ValDel(e, I);
    
    List* l = ListNew(e);
    ListAddValue(e, l, ValNewNum(e, 1));
    ListAddValue(e, l, ValNewNum(e, 2));
    ListAddValue(e, l, ValNewNum(e, 3));
    Val* L = ValNewList(e, l);
    I = CreateListIterator(e, L);
    ValDel(e, L);
    ok(t, I->type == TYPE_OBJ, "iter.CreateListIterator(1,2,3)");
    R = IteratorNext(e, I, NULL);
    ok(t, R->type == TYPE_OBJ, "iter.next() type");
    Val* V = IteratorValue(e, R); //  GetA(e, R, "value");
    ok(t, V->type == TYPE_NUM && V->num == 1, "iter.next(0).value");
    Val* done = IteratorComplete(e, R); //  GetA(e, R, "done");
    ok(t, !ValIsTrue(e, done), "iter.next(0).done");
    ValDel(e, done);
    ValDel(e, V);
    ValDel(e, R);
    R = IteratorNext(e, I, NULL);
    V = IteratorValue(e, R);
    ok(t, V->type == TYPE_NUM && V->num == 2, "iter.next(1).value");
    done = IteratorComplete(e, R);
    ok(t, !ValIsTrue(e, done), "iter.next(1).done");
    ValDel(e, done);
    ValDel(e, V);
    ValDel(e, R);
    R = IteratorNext(e, I, NULL);
    V = IteratorValue(e, R);
    ok(t, V->type == TYPE_NUM && V->num == 3, "iter.next(2).value");
    done = IteratorComplete(e, R);
    ok(t, !ValIsTrue(e, done), "iter.next(2).done");
    ValDel(e, done);
    ValDel(e, V);
    ValDel(e, R);
    R = IteratorNext(e, I, NULL);
    V = IteratorValue(e, R);
    ok(t, V->type == TYPE_UNDEF, "iter.next(3).value");
    done = IteratorComplete(e, R);
    ok(t, ValIsTrue(e, done), "iter.next(3).done");
    ValDel(e, done);
    ValDel(e, V);
    ValDel(e, R);
    ValDel(e, I);

    Val* O = ValNewObject(e);
    Val* M = NativeFuncNew(e, NULL, MockCallCreate);
    R = Put(e, O, e->iterator, M, TRUE);
    ValDel(e, R);
    I = GetIterator(e, O, NULL);
    ok(t, I->type == TYPE_OBJ, "iter.GetIterator()");
    ValDel(e, I);
    ValDel(e, M);
    ValDel(e, O);
    

}

void PromiseTest(test* t) {
    fail(t, "promise.all");
}

void DeclEnvTest(test* t) {
    Js* e = t->js;
    
    Val* NX = ValNewStrA(e, "X");
    Val* NY = ValNewStrA(e, "Y");
    Val* NZ = ValNewStrA(e, "Z");
    Val* VX = ValNewNum(e, 1);
    Val* VY = ValNewNum(e, 2);
    Val* VZ = ValNewNum(e, 3);
    
    Env* E = DeclEnvNew(e);
    Val* R = E->vtable->hasBinding(e, E, NX);
    ok(t, R->b == FALSE, "DeclEnv.hasBinding(X)");
    ValDel(e, R);
    R = E->vtable->createMutableBinding(e, E, NX, TRUE);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "DeclEnv.createMutableBinding(X,can_del)");
    ValDel(e, R);
    R = E->vtable->setMutableBinding(e, E, NX, VX, TRUE);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->referenceErrorObject), "DeclEnv.setMutableBinding(X,1)");
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, NX, FALSE);
    // ok(t, R->type == TYPE_UNDEF, "DeclEnv.getBindingValue(X, not_strict)");
    // #402 Changed DeclarativeEnvironment.GetBindingValue() to always return an error if the binding
    // is uninitialized regardless of strict or not
    ok(t, ValIsAbrupt(e, R), "DeclEnv.getBindingValue(X, not_strict)");
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, NX, TRUE);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->referenceErrorObject), "DeclEnv.getBindingValue(X, strict)");
    ValDel(e, R);
    R = E->vtable->initializeBinding(e, E, NX, VX);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "DeclEnv.initializeBinding(X,1)");
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, NX, TRUE);
    ok(t, R->type == TYPE_NUM && R->num == 1, "DeclEnv.getBindingValue(X, strict)");
    ValDel(e, R);
    R = E->vtable->deleteBinding(e, E, NY);
    ok(t, R->type == TYPE_BOOL && R->b == TRUE, "DeclEnv.deleteBinding(Y)");
    ValDel(e, R);
    R = E->vtable->deleteBinding(e, E, NX);
    ok(t, R->type == TYPE_BOOL && R->b == TRUE, "DeclEnv.deleteBinding(X)");
    ValDel(e, R);
    R = E->vtable->hasBinding(e, E, NX);
    ok(t, R->b == FALSE, "DeclEnv.hasBinding(X)");
    ValDel(e, R);
    

    R = E->vtable->createImmutableBinding(e, E, NX);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "DeclEnv.createImmutableBinding(X)");
    ValDel(e, R);
    R = E->vtable->setMutableBinding(e, E, NX, VX, TRUE);
    ok(t, ValIsThrow(e, R,CurrentRealm(e)->referenceErrorObject), "DeclEnv.setMutableBinding(X,1)");
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, NX, FALSE);
    // #402 changed so that uninitialized reference always errors
    ok(t, ValIsAbrupt(e, R), "DeclEnv.getBindingValue(X, not_strict)");
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, NX, TRUE);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->referenceErrorObject), "DeclEnv.getBindingValue(X, strict)");
    ValDel(e, R);
    R = E->vtable->initializeBinding(e, E, NX, VX);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "DeclEnv.initializeBinding(X,1)");
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, NX, TRUE);
    ok(t, R->type == TYPE_NUM && R->num == 1, "DeclEnv.getBindingValue(X, strict)");
    ValDel(e, R);
    R = E->vtable->deleteBinding(e, E, NY);
    ok(t, R->type == TYPE_BOOL && R->b == TRUE, "DeclEnv.deleteBinding(Y)");
    ValDel(e, R);
    R = E->vtable->deleteBinding(e, E, NX);
    ok(t, R->type == TYPE_BOOL && R->b == FALSE, "DeclEnv.deleteBinding(X)");
    ValDel(e, R);
    R = E->vtable->hasBinding(e, E, NX);
    ok(t, R->b == TRUE, "DeclEnv.hasBinding(X)");
    ValDel(e, R);

    R = E->vtable->createMutableBinding(e, E, NY, TRUE);
    ValDel(e, R);
    R = E->vtable->initializeBinding(e, E, NY, VY);
    ValDel(e, R);
    R = E->vtable->createImmutableBinding(e, E, NZ);
    ValDel(e, R);
    R = E->vtable->initializeBinding(e, E, NZ, VZ);
    ValDel(e, R);
    R = E->vtable->deleteBinding(e, E, NY);
    ok(t, R->type == TYPE_BOOL && R->b == TRUE, "DeclEnv.deleteBinding(Y)");
    ValDel(e, R);

    R = E->vtable->hasThisBinding(e, E);
    ok(t, R->b == FALSE, "DeclEnv.hasThisBinding()");
    ValDel(e, R);
    R = E->vtable->hasSuperBinding(e, E);
    ok(t, R->b == FALSE, "DeclEnv.hasSuperBinding()");
    ValDel(e, R);
    R = E->vtable->withBaseObject(e, E);
    ok(t, R->type == TYPE_UNDEF, "DeclEnv.withBaseObject()");
    ValDel(e, R);
    
    EnvDel(e, E);
    ValDel(e, VX);
    ValDel(e, VY);
    ValDel(e, VZ);
    ValDel(e, NX);
    ValDel(e, NY);
    ValDel(e, NZ);
}

void ObjEnvTest(test* t) {
    Js* e = t->js;
    Val* N = ValNewStrA(e, "X");
    Val* V = ValNewNum(e, 1.234);
    
    Val* O = ValNewObject(e);
    Env* E = ObjEnvNew(e, O, FALSE);
    Val* R = E->vtable->hasBinding(e, E, N);
    ok(t, R->type == TYPE_BOOL && R->b == FALSE, "ObjEnv.hasBinding(X)");
    ValDel(e, R);
    R = E->vtable->createMutableBinding(e, E, N, TRUE);
    ValDel(e, R);
    ok(t, PropIsConfigurable(e, O->obj->properties), "ObjEnv.createMutableBinding(X,true)");
    R = E->vtable->deleteBinding(e, E, N);
    ValDel(e, R);
    R = E->vtable->createMutableBinding(e, E, N, FALSE);
    ValDel(e, R);
    ok(t, !PropIsConfigurable(e, O->obj->properties), "ObjEnv.createMutableBinding(X,false)");
    R = E->vtable->setMutableBinding(e, E, N,V, TRUE);
    ValDel(e, R);
    
    R = E->vtable->getBindingValue(e, E, N, FALSE);
    ok(t, R->num == 1.234, "ObjEnv.setMutableBinding(X,1.234)");
    ValDel(e, R);
    
    R = E->vtable->withBaseObject(e, E);
    ok(t, R->type == TYPE_UNDEF, "ObjEnv.withBaseObject(false)");
    ValDel(e, R);
    EnvDel(e, E);
    
    E = ObjEnvNew(e, O, TRUE);
    R = E->vtable->withBaseObject(e, E);
    ok(t, R->obj == O->obj, "ObjEnv.withBaseObject(false)");
    ValDel(e, R);

    EnvDel(e, E);
    ValDel(e, O);
    ValDel(e, V);
    ValDel(e, N);
    
}

void FuncEnvTest(test* t) {
    Js* e = t->js;
    // Val* N = ValNewStrA(e, "someMethod");
    Val* H = ValNewObject(e);
    Val* P = DoGetPrototypeOf(e, H);
    Val* T = ValNewObject(e);
    Val* XN = ValNewStrA(e, "X");
    Val* XV = ValNewNum(e, 3.14);
    Env* E = FuncEnvNew(e);
    Val* R = E->vtable->createMutableBinding(e, E, XN, FALSE);
    ValDel(e, R);
    R = E->vtable->initializeBinding(e, E, XN, XV);
    ValDel(e, R);
    R = E->vtable->getBindingValue(e, E, XN, TRUE);
    ok(t, R->type == TYPE_NUM && R->num == 3.14, "FuncEnv.getBindingValue(X)");
    ValDel(e, R);
    R = E->vtable->hasThisBinding(e, E);
    ok(t, ValIsTrue(e, R), "FuncEnv.hasThisBinding");
    ValDel(e, R);
    R = E->vtable->hasSuperBinding(e, E);
    ok(t, ValIsTrue(e, R), "FuncEnv.hasSuperBinding");
    ValDel(e, R);
    // R = E->vtable->getMethodName(e, E);
    // ok(t, ValIsTrueDel(e, SameValue(e, R, N)), "FuncEnv.getMethodName");
    // ValDel(e, R);
    R = E->vtable->getThisBinding(e, E);
    ok(t, ValIsTrueDel(e, SameValue(e, R, T)), "FuncEnv.getThisBinding");
    ValDel(e, R);
    R = E->vtable->getSuperBase(e, E);
    ok(t, ValIsTrueDel(e, SameValue(e, R, P)), "FuncEnv.getSuperBase");
    ValDel(e, R);
    
    EnvDel(e, E);
    ValDel(e, XV);
    ValDel(e, XN);
    ValDel(e, T);
    ValDel(e, P);
    ValDel(e, H);
    // ValDel(e, N);
}

void GlobalEnvTest(test* t) {
    Js* e = t->js;
    Val* FN = ValNewStrA(e, "SomeGlobalFunc");
    Val* VN = ValNewStrA(e, "SomeGlobalVar");
    Val* UN = ValNewStrA(e, "Unknown");
    
    Env* G = GlobalEnvNew(e, NULL, NULL);
    GlobalEnv* ge = (GlobalEnv*) G;
    ObjEnv* oe = (ObjEnv*) ge->objRec;
    
    ok(t, ValIsTrueDel(e, G->vtable->hasThisBinding(e, G)), "GlobalEnv.hasThisBinding");
    ok(t, !ValIsTrueDel(e, G->vtable->hasSuperBinding(e, G)), "GlobalEnv.hasSuperBinding");
    Val* R = G->vtable->withBaseObject(e, G);
    ok(t, R->type == TYPE_UNDEF, "GlobalEnv.withBaseObject");
    ValDel(e, R);
    R = G->vtable->getThisBinding(e, G);
    ok(t, R->obj == oe->bindingObj->obj, "GlobalEnv.getThisBinding");
    ValDel(e, R);

    R = G->vtable->canDeclGlobalVar(e, G, FN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.canDeclGlobalVar(F)");
    R = G->vtable->canDeclGlobalVar(e, G, VN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.canDeclGlobalVar(V)");
    R = G->vtable->canDeclGlobalVar(e, G, UN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.canDeclGlobalVar(U)");
    
    R = G->vtable->createGlobalVarBinding(e, G, VN, TRUE);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "GlobalEnv.createGlobalVarBinding");
    ValDel(e, R);

    R = G->vtable->canDeclGlobalFunc(e, G, FN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.canDeclGlobalFunc(F)");
    R = G->vtable->canDeclGlobalFunc(e, G, VN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.canDeclGlobalFunc(V)");
    R = G->vtable->canDeclGlobalFunc(e, G, UN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.canDeclGlobalFunc(U)");

    Val* FV = ValNewNum(e, 3.14);
    R = G->vtable->createGlobalFuncBinding(e, G, FN, FV, TRUE);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "GlobalEnv.createGlobalFuncBinding");
    ValDel(e, R);
    
    R = G->vtable->hasLexDecl(e, G, FN);
    ok(t, !ValIsTrueDel(e, R), "GlobalEnv.hasLexDecl(F)");
    R = G->vtable->hasVarDecl(e, G, FN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.hasVarDecl(F)");
    
    Val* N = ValNewNum(e, 99191);
    R = G->vtable->createMutableBinding(e, G, FN, TRUE);
    ok(t, R->type == TYPE_COMP && R->completion->type == COMP_NORMAL, "GlobalEnv.createMutableBinding(F)");
    ValDel(e, R);
    R = G->vtable->initializeBinding(e, G, FN, N);
    ValDel(e, R);

    R = G->vtable->hasLexDecl(e, G, FN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.hasLexDecl(F)");
    
    R = G->vtable->getBindingValue(e, G, FN, TRUE);
    ok(t, R->type == TYPE_NUM && R->num == 99191, "GlobalEnv.getBindingValue(F)");
    ValDel(e, R);
    
    R = G->vtable->deleteBinding(e, G, FN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.delet_binding(F)");

    R = G->vtable->getBindingValue(e, G, FN, TRUE);
    ok(t, R->type == TYPE_NUM && R->num == 3.14, "GlobalEnv.getBindingValue(F)");
    ValDel(e, R);
    
    R = G->vtable->deleteBinding(e, G, VN);
    ok(t, ValIsTrueDel(e, R), "GlobalEnv.deleteBinding(N)");

    R = G->vtable->hasBinding(e, G, VN);
    ok(t, !ValIsTrueDel(e, R), "GlobalEnv.hasBinding(N)");
    
    ValDel(e, N);
    ValDel(e, FV);
    ValDel(e, UN);
    ValDel(e, VN);
    ValDel(e, FN);
    EnvDel(e, G);
}


void LexEnvTest(test* t) {
    Js* e = t->js;
    Val* o = ValNewObject(e);
    Val* f = ValNewObject(e);
    Val* ft = ValNewObject(e);

    Val* outer = NewDeclEnv(e, NULL);
    Val* middle = NewObjEnv(e, o, outer);
    Val* lower = NewFunctionEnvironment(e, f, ft);

    Env* de = outer->lex->envRec;
    Env* oe = middle->lex->envRec;
    Env* fe = lower->lex->envRec;
    
    Val* no = ValNewStrA(e, "outerName");
    Val* nm = ValNewStrA(e, "middleName");
    Val* nl = ValNewStrA(e, "lowerName");
    
    Val* r = de->vtable->createImmutableBinding(e, de, no);
    ValDel(e, r);

    r = oe->vtable->createMutableBinding(e, oe, nm, FALSE);
    ValDel(e, r);
    
    r = fe->vtable->createMutableBinding(e, fe, nl, FALSE);
    ValDel(e, r);

    r = GetIdentifierRef(e, outer, no, FALSE);
    ok(t, r->type == TYPE_REF, "LexEnv.GetIdentifierRef(outer, no)");
    ok(t, ValIsTrueDel(e, SameValue(e, no, r->Ref->name)), "LexEnv.GetIdentifierRef(outer, no)");
    ValDel(e, r);

    r = GetIdentifierRef(e, outer, nm, FALSE);
    ok(t, r->Ref->base->type == TYPE_UNDEF, "LexEnv.GetIdentifierRef(outer, nm)");
    ValDel(e, r);

    r = GetIdentifierRef(e, middle, no, FALSE);
    ok(t, ValIsTrueDel(e, SameValue(e, no, r->Ref->name)), "LexEnv.GetIdentifierRef(middle, no)");
    ValDel(e, r);
    
    r = GetIdentifierRef(e, middle, nm, FALSE);
    ok(t, ValIsTrueDel(e, SameValue(e, nm, r->Ref->name)), "LexEnv.GetIdentifierRef(middle, nm)");
    ValDel(e, r);

    r = GetIdentifierRef(e, middle, nl, FALSE);
    ok(t, r->Ref->base->type == TYPE_UNDEF, "LexEnv.GetIdentifierRef(middle, nl)");
    ValDel(e, r);
    

    ValDel(e, no);
    ValDel(e, nm);
    ValDel(e, nl);
    
    ValDel(e, lower);
    ValDel(e, middle);
    ValDel(e, outer);

    ValDel(e, ft);
    ValDel(e, f);
    ValDel(e, o);

}

void ContextTest(test* t) {
    Js* e = t->js;
    
    Val* gvn = ValNewStrA(e, "globalX");
    Context* c1 = e->currentContext;
    Env* ge = c1->lex->lex->envRec;
    Val* r = ge->vtable->createGlobalVarBinding(e, ge, gvn, TRUE);
    ValDel(e, r);
    Val* gv = ValNewNum(e, 88);
    r = ge->vtable->setMutableBinding(e, ge, gvn, gv, TRUE);
    ValDel(e, r);
    r = ResolveBinding(e, gvn, TRUE);
    ok(t, r->type == TYPE_REF, "context.ResolveBinding() Ref");
    ok(t, r->Ref->base->type == TYPE_ENV, "context.ResolveBinding() Ref to Env");
    Env* ev = r->Ref->base->env;
    Val* r2 = ev->vtable->getBindingValue(e, ev, r->Ref->name, r->Ref->strict);
    ValDel(e, r);
    ok(t, r2->num == 88, "context.ResolveBinding() getBindingValue()");
    ValDel(e, r2);
    
    Context* c2 = ContextNew(e, NULL, NULL, FALSE);
    Env* le = c2->lex->lex->envRec;
    Val* lvn = ValNewStrA(e, "localX");
    Val* lv = ValNewNum(e, 44);
    r = le->vtable->createMutableBinding(e, le, lvn, TRUE);
    ValDel(e, r);
    r = le->vtable->initializeBinding(e, le, lvn, lv);
    ValDel(e, r);
    r = ResolveBinding(e, lvn, TRUE);
    ok(t, r->type == TYPE_REF, "context.ResolveBinding() Ref");
    ok(t, r->Ref->base->type == TYPE_ENV, "context.ResolveBinding() Ref to Env");
    ev = r->Ref->base->env;
    r2 = ev->vtable->getBindingValue(e, ev, r->Ref->name, r->Ref->strict);
    ValDel(e, r);
    ok(t, r2->num == 44, "context.ResolveBinding() getBindingValue()");
    ValDel(e, r2);
    r = le->vtable->deleteBinding(e, le, lvn);
    ValDel(e, r);
    ValDel(e, lv);
    ValDel(e, lvn);
    r = ResolveThisBinding(e);
    ok(t, r->type == TYPE_OBJ, "context.resolve_this.Binding()");
    ValDel(e, r);
    ContextDelete(e, c2);
    
    r = ge->vtable->deleteBinding(e, ge, gvn);
    ValDel(e, r);
    ValDel(e, gv);
    ValDel(e, gvn);
}

void test_task(Js* e, List* args) {
    e->testResult = 100;
}

void TaskTest(test* t) {
    Js eng;
    JsInit(&eng, TRUE);
    Js* e = &eng;
    List* args = ListNew(e);
    ListAddValue(e, args, ValNewNum(e, 1));
    Val* ql = ValNewStrA(e, "LoadingTasks");
    Val* qp = ValNewStrA(e, "PromiseTasks");
    Val* cm = EnqueueTask(e, ql, test_task, args);
    ValDel(e, cm);
    cm = EnqueueTask(e, qp, test_task, args);
    ValDel(e, cm);
    ListDel(e, args);
    ValDel(e, ql);
    ValDel(e, qp);

    Val* result = ValNew(e);
    e->testResult = 0;
    NextTask(e, result);
    ok(t, e->testResult == 100, "Task.next(0)");
    e->testResult = 0;
    NextTask(e, result);
    ok(t, e->testResult == 100, "Task.next(1)");
    e->testResult = 0;
    NextTask(e, result);
    ok(t, e->testResult == 0, "Task.next(2)");
    
    ValDel(e, result);
    JsClear(&eng);
    // MemPrint(&eng);
    
}



void FunctionTest(test* t) {
    Js* e = t->js;
    
    Val* N = ValNewStrA(e, "caller");
    Val* F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, FALSE, NULL);
    Val* C = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    PutA(e, F, "caller", C, FALSE);
    Val* R = DoGetOwnProperty(e, F, N);
    ok(t, R->type == TYPE_DESC, "function.GetOwnProperty(strict_caller).type");
    ok(t, ValIsNull(R->desc->value), "function.GetOwnProperty(strict_caller).value");
    ValDel(e, R);
    ValDel(e, F);
    ValDel(e, C);

    F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    C = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    PutA(e, F, "caller", C, FALSE);
    R = DoGetOwnProperty(e, F, N);
    ok(t, R->type == TYPE_DESC, "function.GetOwnProperty(caller).type");
    ok(t, !ValIsNull(R->desc->value), "function.GetOwnProperty(caller).value");
    ValDel(e, R);
    ValDel(e, F);
    ValDel(e, C);
    ValDel(e, N);
    
    F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    ok(t, ValEqStrA(e, ObjectGetSlot(e, F->obj, _FunctionKind_), "normal"), "function.allocate(kind)");
    ok(t, ObjectGetSlot(e, F->obj, _Strict_)->b, "function.allocate(strict)");
    ValDel(e, F);

    
    F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    Val* O = ObjectCreate(e, NULL, NULL);
    R = DoCall(e, F, O, NULL);
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->typeErrorObject), "function.call(no code)");
    ValDel(e, R);
    ValDel(e, O);
    ValDel(e, F);

 
    F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    R = FunctionInitialize(e, F, FUNC_NORMAL, NULL, NULL, NULL);
    ValDel(e, R);
    ok(t, ObjectGetSlot(e, F->obj, _Strict_)->b, "function.init_normal_strict");
    ok(t, ObjectGetSlot(e, F->obj, _ThisMode_)->num == THIS_MODE_STRICT, "function.init_normal_this_mode");
    ValDel(e, F);

    F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, TRUE, NULL);
    R = FunctionInitialize(e, F, FUNC_ARROW, NULL, NULL, NULL);
    ValDel(e, R);
    ok(t, ObjectGetSlot(e, F->obj, _Strict_)->b, "function.init_arrow_strict");
    ok(t, ObjectGetSlot(e, F->obj, _ThisMode_)->num == THIS_MODE_LEXICAL, "function.init_arrow_this_mode");
    ValDel(e, F);

    F = FunctionAllocate(e, CurrentRealm(e)->functionPrototype, FALSE, NULL);
    R = FunctionInitialize(e, F, FUNC_METHOD, NULL, NULL, NULL);
    ValDel(e, R);
    ok(t, !ObjectGetSlot(e, F->obj, _Strict_)->b, "function.init_method_non_strict");
    ok(t, ObjectGetSlot(e, F->obj, _ThisMode_)->num == THIS_MODE_GLOBAL, "function.init_method_this_mode");
    ValDel(e, F);
    
    F = FunctionCreate(e, FUNC_ARROW, NULL, NULL, NULL, FALSE, NULL, 0,0);
    ok(t, ObjectGetSlot(e, F->obj, _ThisMode_)->num == THIS_MODE_LEXICAL, "function.create(arrow) this mode");
    ValDel(e, F);
    
    F = GenFunctionCreate(e, FUNC_ARROW, NULL, NULL, NULL, FALSE, NULL);
    ok(t, ObjectIs(e, F, CurrentRealm(e)->generatorObject), "function.GenFunctionCreate() prototype");
    ValDel(e, F);

    F = GenFunctionCreate(e, FUNC_ARROW, NULL, NULL, NULL, FALSE, NULL);
    PutA(e, F, "caller", ValNewNum(e, 1), TRUE);
    R = GetA(e, F, "caller");
    ok(t, R->num == 1, "function.non strict caller access");
    ValDel(e, R);
    PutA(e, F, "arguments", ValNewNum(e, 1), TRUE);
    R = GetA(e, F, "arguments");
    ok(t, R->num == 1, "function.non strict arguments access");
    ValDel(e, R);
    ValDel(e, F);

    F = GenFunctionCreate(e, FUNC_ARROW, NULL, NULL, NULL, TRUE, NULL);
    PutA(e, F, "caller", ValNewNum(e, 1), TRUE);
    R = GetA(e, F, "caller");
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->typeErrorObject), "function.strict caller access");
    ValDel(e, R);
    PutA(e, F, "arguments", ValNewNum(e, 1), TRUE);
    R = GetA(e, F, "arguments");
    ok(t, ValIsThrow(e, R, CurrentRealm(e)->typeErrorObject), "function.strict arguments access");
    ValDel(e, R);
    ValDel(e, F);
    
    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    R = MakeCons(e, F, NULL, NULL);     // no writable, no proto
    ok(t, ObjectGetMethod(e, F->obj, _Construct_) != NULL, "function.MakeCons(no_writable, no_proto)");
    Val* D = DoGetOwnProperty(e, F, e->prototype);
    // @todo: We must delete the "prototype" property to avoid the circular reference
    ValDel(e, R);
    Val* UN = ValNew(e);
    R = DoSet(e, F, e->prototype, UN, F);
    ValDel(e, UN);
    ok(t, PropIsWritable(e, D->desc), "function.MakeCons(is_writeable_proto)");
    ValDel(e, R);
    ValDel(e, F);
    ValDel(e, D);

    Val* P = ValNewObject(e);
    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    bool_t W = FALSE;
    R = MakeCons(e, F, &W, P);     // not writable, obj proto
    ok(t, ObjectGetMethod(e, F->obj, _Construct_) != NULL, "function.MakeCons(not_writable, proto)");
    D = DoGetOwnProperty(e, F, e->prototype);
    ok(t, !PropIsWritable(e, D->desc), "function.MakeCons(not_writeable_proto)");
    ValDel(e, R);
    ValDel(e, D);
    ValDel(e, P);
    ValDel(e, F);
    
    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    Val* U = ValNew(e);
    O = ValNewObject(e);
    R = MakeMethod(e, F, U, O);
    ok(t, ObjectGetSlot(e, F->obj, _NeedsSuper_)->b, "function.MakeMethod(undef, obj)");
    ok(t, ObjectGetSlot(e, F->obj, _HomeObject_)->type == TYPE_OBJ, "function.MakeMethod(undef, obj)");
    ValDel(e, R);
    ValDel(e, O);
    ValDel(e, F);
    ValDel(e, U);
    
    N = ValNewStrA(e, "someMethod");
    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    O = ValNew(e);
    R = MakeMethod(e, F, N, O);
    ok(t, ObjectGetSlot(e, F->obj, _NeedsSuper_)->b, "function.MakeMethod(undef, obj)");
    ok(t, ObjectGetSlot(e, F->obj, _HomeObject_)->type == TYPE_UNDEF, "function.MakeMethod('someMethod', undef)");
    ok(t, ValEqStrA(e, ObjectGetSlot(e, F->obj, _MethodName_), "someMethod"), "function.MakeMethod('someMethod')");
    ValDel(e, R);
    ValDel(e, O);
    ValDel(e, F);
    ValDel(e, N);
    

    F = ValNew(e);
    R = GetSuperBinding(e, F);
    ok(t, ValIsUndef(R), "function.GetSuperBinding(non_object)");
    ValDel(e, R);
    ValDel(e, F);
    
    F = ValNewObject(e);
    R = GetSuperBinding(e, F);
    ok(t, ValIsUndef(R), "function.GetSuperBinding(non_function)");
    ValDel(e, R);
    ValDel(e, F);
    
    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    U = ValNew(e);
    O = ValNewObject(e);
    R = MakeMethod(e, F, U, O);
    ValDel(e, R);
    R = GetSuperBinding(e, F);
    ok(t, R->type == TYPE_OBJ, "GetSuperBinding(function)");
    ok(t, R->obj == O->obj, "GetSuperBinding(function)");
    ValDel(e, R);
    ValDel(e, O);
    ValDel(e, F);
    ValDel(e, U);

    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    N = ValNewStrA(e, "methodName");
    Val* H = ValNewObject(e);
    R = MakeMethod(e, F, N, H);
    ValDel(e, R);
    Val* H2 = ValNewObject(e);
    C = clone_method(e, F, H2, NULL);
    ok(t, ObjectIs(e, C, CurrentRealm(e)->functionConstructor), "function.clone_method(F,x,x)");
    ok(t, ObjectGetSlot(e, C->obj, _HomeObject_)->obj == H2->obj, "function.clone_method(F,x,x)");
    ok(t, StrEqChars(e, ObjectGetSlot(e, C->obj, _MethodName_)->str, "methodName"),"function.clone_method(F,x,x)");
    ValDel(e, H2);
    ValDel(e, C);
    ValDel(e, F);
    ValDel(e, N);
    ValDel(e, H);

    F = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, FALSE, NULL,0,0);
    N = ValNewStrA(e, "methodName");
    H = ValNewObject(e);
    R = MakeMethod(e, F, N, H);
    ValDel(e, R);
    H2 = ValNewObject(e);
    Val* N2 = ValNewStrA(e, "anotherMethod");
    C = clone_method(e, F, H2, N2);
    ok(t, ObjectIs(e, C, CurrentRealm(e)->functionConstructor), "function.clone_method(F,x,x)");
    ok(t, ObjectGetSlot(e, C->obj, _HomeObject_)->obj == H2->obj, "function.clone_method(F,x,x)");
    ok(t, StrEqChars(e, ObjectGetSlot(e, C->obj, _MethodName_)->str, "anotherMethod"),"function.clone_method(F,x,x)");
    ValDel(e, H2);
    ValDel(e, N2);
    ValDel(e, C);
    ValDel(e, F);
    ValDel(e, N);
    ValDel(e, H);

}

Val* BuiltinMockCall(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    PutA(e, othis, "X", ValNewNum(e, 2.34), TRUE);
    return ValNew(e);
}

void BuiltinTest(test* t) {
    Js* e = t->js;
    Val* f = CreateBuiltinFunction(e, CurrentRealm(e), BuiltinMockCall);
    Val* o = ValNewObject(e);
    Val* ret = DoCall(e, f, o, NULL);
    ok(t, !ValIsAbrupt(e, ret), "Builtin.[[Call]]");
    ValDel(e, ret);
    Val* p = GetA(e, o, "X");
    ok(t, p->type == TYPE_NUM && p->num == 2.34, "Builtin.[[Call]]");
    ValDel(e, p);
    p = DoGetPrototypeOf(e, f);
    ok(t, ValIsObject(p) && p->obj == CurrentRealm(e)->functionPrototype->obj, "Builtin.[[Prototype]]");
    ValDel(e, p);
    ValDel(e, o);
    ValDel(e, f);
}

Val* MockCallTarget(Js* e, Val* o, Val* othis, Val* args, Val* newTarget) {
    PutA(e, othis, "X", ValNewNum(e, 5.67), TRUE);
    // ensure that args = 1,2,3,4,5,6
    Val* v0, *v1, *v2, *v3, *v4, *v5;
    bool_t success = FALSE;
    
    v0  = ListGetValue(e, args->list, 0);
    v1  = ListGetValue(e, args->list, 1);
    v2  = ListGetValue(e, args->list, 2);
    v3  = ListGetValue(e, args->list, 3);
    v4  = ListGetValue(e, args->list, 4);
    v5  = ListGetValue(e, args->list, 5);
    
    if(v0->num == 1 && v1->num == 2 && v2->num == 3 && v3->num == 4 &&
       v4->num == 5 && v5->num == 6)
        success = TRUE;
    ValDel(e, v0);
    ValDel(e, v1);
    ValDel(e, v2);
    ValDel(e, v3);
    ValDel(e, v4);
    ValDel(e, v5);
    return ValNewBool(e, success);
}


void ArrayTest(test* t) {
    Js* e = t->js;
    
    Val* A = ArrayCreate(e, NULL, NULL);
    ok(t, ValIsObject(A), "Array.isObject");
    ok(t, A->obj->prototype->obj == CurrentRealm(e)->arrayPrototype->obj, "Array.prototype");
    Val* length = GetA(e, A, "length");
    ok(t, !ValIsUndef(length), "Array.defaultLength == 0");
    ValDel(e, length);
    ValDel(e, A);


    length = ValNewNum(e, 20);
    A = ArrayCreate(e, length, NULL);
    ValDel(e, length);
    length = GetA(e, A, "length");
    ok(t, length->num == 20, "Array.Array(20)");
    ValDel(e, length);
    ValDel(e, A);
    
    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "X", ValNewNum(e, 9), TRUE);
    Val* R = GetA(e, A, "X");
    ok(t, R->num == 9, "Array.X=9");
    ValDel(e, R);
    ValDel(e, A);
    
    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "length", ValNewNum(e, 9), TRUE);
    R = GetA(e, A, "length");
    ok(t, R->num == 9, "Array.length=9");
    ValDel(e, R);
    ValDel(e, A);


    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "2", ValNewNum(e, 2), TRUE);
    R = GetA(e, A, "length");
    ok(t, R->num == 3, "Array.['2'] => length=3");
    ValDel(e, R);
    ValDel(e, A);

    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "2", ValNewNum(e, 2), TRUE);
    PutA(e, A, "0", ValNewNum(e, 0), TRUE);
    R = GetA(e, A, "length");
    ok(t, R->num == 3, "Array.['2'],['0'] => length=3");
    ValDel(e, R);
    ValDel(e, A);
    
    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "2", ValNewNum(e, 2), TRUE);
    PutA(e, A, "0", ValNewNum(e, 0), TRUE);
    PutA(e, A, "8", ValNewNum(e, 8), TRUE);
    R = GetA(e, A, "length");
    ok(t, R->num == 9, "Array.['2'],['0'],['8'] => length=9");
    ValDel(e, R);
    ValDel(e, A);

    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "2", ValNewNum(e, 2), TRUE);
    PutA(e, A, "0", ValNewNum(e, 0), TRUE);
    PutA(e, A, "length", ValNewNum(e, 5), TRUE);
    R = GetA(e, A, "length");
    ok(t, R->num == 5, "Array.Shrink");
    ValDel(e, R);
    ValDel(e, A);

    A = ArrayCreate(e, NULL, NULL);
    PutA(e, A, "2", ValNewNum(e, 2), TRUE);
    PutA(e, A, "0", ValNewNum(e, 0), TRUE);
    PutA(e, A, "length", ValNewNum(e, 14), TRUE);
    R = GetA(e, A, "length");
    ok(t, R->num == 14, "Array.Grow");
    ValDel(e, R);
    ValDel(e, A);
    
}

void StringTest(test* t) {
    Js* e = t->js;
    
    Val* S = StringCreate(e, CurrentRealm(e)->stringPrototype, e->strLength);
    ok(t, S->obj->prototype->obj == CurrentRealm(e)->stringPrototype->obj, "String.prototype");
    Val* R = GetA(e, S, "length");
    ok(t, R->num == 6, "String.length");
    ValDel(e, R);
    R = GetA(e, S, "2");
    ok(t, ValEqStrA(e, R, "n"), "String.['2']");
    ValDel(e, R);
    PutA(e, S, "2", ValNewStrA(e, "X"), TRUE);
    R = GetA(e, S, "2");
    ok(t, ValEqStrA(e, R, "n"), "String.['2']");
    ValDel(e, R);
    R = DoEnumerate(e, S);
    ok(t, ValIsUndef(R), "String.enumerate");
    ValDel(e, R);
    R = DoOwnPropertyKeys(e, S);
    ok(t, ValIsUndef(R), "String.ownPropertyKeys");
    ValDel(e, R);
    
    ValDel(e, S);

}

void ArgumentsTest(test* t) {
    Js* e = t->js;
    
    List* list = ListNew(e);
    ListAddValue(e, list, ValNewNum(e,1));
    ListAddValue(e, list, ValNewNum(e,2));
    Val* args = ValNewList(e, list);
    Val* arguments = InstantiateArgumentsObject(e, args);
    Val* result = Get(e, arguments, e->strLength);
    ok(t, result->type == TYPE_NUM && result->num == 2, "Arguments.length");
    ValDel(e, result);
    CompleteStrictArgumentsObject(e, arguments, NULL, NULL, NULL);
    result = Get(e, arguments, e->strCaller);
    ok(t, ValIsThrow(e, result, CurrentRealm(e)->typeErrorObject), "Arguments.caller");
    ValDel(e, result);
    result = Get(e, arguments, e->strArguments);
    ok(t, ValIsThrow(e, result, CurrentRealm(e)->typeErrorObject), "Arguments.arguments");
    ValDel(e, result);
    ValDel(e, args);
    ValDel(e, arguments);
    
    Val* func = FunctionCreate(e, FUNC_NORMAL, NULL, NULL, NULL, TRUE, NULL,0,0);
    list = ListNew(e);
    ListAddValue(e, list, ValNewNum(e,1));
    ListAddValue(e, list, ValNewNum(e,2));
    ListAddValue(e, list, ValNewNum(e,3));
    args = ValNewList(e, list);
    Parser* parser = ParserNew(e);
    arguments = InstantiateArgumentsObject(e, args);
    CompleteMappedArgumentsObject(e, arguments, func, NULL, e->currentContext->vars);
    result = Get(e, arguments, e->strCallee);
    ok(t, ValIsObject(result), "Arguments.callee type");
    ok(t, result->obj == func->obj, "Arguments.callee");
    ValDel(e, result);
    ParserDel(parser);

    Val* p = ValNewStrA(e, "testProp");
    Val* n = ValNewNum(e, 1.2);
    result = Put(e, arguments, p, n, TRUE);
    ok(t, ValIsTrueDel(e, result), "Arguments.<property> set");
    result = Get(e, arguments, p);
    ok(t, result->num == 1.2, "Arguments.get");
    ValDel(e, result);
    result = DoDelete(e, arguments, p);
    ok(t, ValIsTrueDel(e, result), "Arguments.delete");
    result = Get(e, arguments, p);
    ok(t, ValIsUndef(result), "Arguments.delete");
    ValDel(e, result);

    ValDel(e, p);
    ValDel(e, n);
    ValDel(e, func);
    ValDel(e, args);
    ValDel(e, arguments);
    
//    ok(t, ObjectGetSlot(e, arguments->obj, _ParameterMap_) != NULL, "Arguments.[[ParameterMap]]");
// @todo: Val* MakeArgGetter(Js* e, Val* name, Val* env);
// @todo: Val* MakeArgSetter(Js* e, Val* name, Val* env);
}


void IntegerIndexedTest(test* t) {
    Js* e = t->js;
    Val* O = IntegerIndexedObjectCreate(e, NULL);
    ok(t, ValIsObject(O), "InteggerIndexed.create");
    ok(t, ObjectGetMethod(e, O->obj, _DefineOwnProperty_) == IntegerIndexedDefineOwnProperty, "InteggerIndexed.vtable");
    
    // Simulate the properties TypedArray objects would create
    Val* VAB = ObjectCreate(e, NULL, NULL);
    ObjectSetSlot(e, O->obj, _ViewArrayBuffer_, VAB, FALSE, FALSE);
    Val* ABD = CreateByteDataSize(e, sizeof(float)*20); // ValNewData(e, sizeof(float)*20);
    float* fp = (float*) ABD->block->data;
    for(int i=0; i < 20; i++ ){
        fp[i] = (float)(i*2);
    }
    ObjectSetSlotNoCopy(e, VAB->obj, _ArrayBufferData_, ABD, FALSE);
    ObjectSetSlot(e, O->obj, _ArrayLength_, ValNewNum(e, 20), FALSE, TRUE);
    ObjectSetSlot(e, O->obj, _ByteOffset_, ValNewNum(e, 0), FALSE, TRUE);
    ObjectSetSlot(e, O->obj, _TypedArrayName_, ValNewStrA(e, "Float32Array"), FALSE, TRUE);
    
    Val* buffer = ObjectGetSlot(e, O->obj, _ViewArrayBuffer_);
    Val* length = ObjectGetSlot(e, O->obj, _ArrayLength_);
    Val* offset = ObjectGetSlot(e, O->obj, _ByteOffset_);
    Val* arrayTypeName = ObjectGetSlot(e, O->obj, _TypedArrayName_);
    ok(t, buffer != NULL, "IntegerIndexed.[[ViewArrayBuffer]]");
    ok(t, length != NULL, "IntegerIndexed.[[ArrayLength]]");
    ok(t, offset != NULL, "IntegerIndexed.[[ByteOffset]]");
    ok(t, arrayTypeName != NULL, "IntegerIndexed.[[TypedArrayName");
    
    
    for(int i=0; i < 20; i++) {
        char buff[20];
        sprintf(buff, "%d", i);
        Val* R = GetA(e, O, buff);
        ok(t, R->type == TYPE_NUM && R->num == i*2, "IntegerIndexed.[[Get]]");
        ValDel(e, R);
    }
    
    Val* P = ValNewStrA(e, "3");
    Val* V = ValNewNum(e, 9);
    Val* R = Put(e, O, P, V, TRUE);
    ValDel(e, R);
    R = GetA(e, O, "3");
    ok(t, R->type == TYPE_NUM && R->num == 9, "IntegerIndexed.[[Set]]");
    ValDel(e, R);
    ValDel(e, V);
    ValDel(e, P);
    
    R = GetA(e, O, "25");
    ok(t, ValIsUndef(R), "IntegerIndexed.Out of bounds");
    ValDel(e, R);

    R = GetA(e, O, "-2");
    ok(t, ValIsUndef(R), "IntegerIndexed.Out of bounds");
    ValDel(e, R);

    PutA(e, O, "XY", ValNewNum(e, 3.14), TRUE);
    R = GetA(e, O, "XY");
    ok(t, R->type == TYPE_NUM && R->num == 3.14, "IntegerIndexed.Property");
    ValDel(e, R);

    R = GetA(e, O, "XYZ");
    ok(t, ValIsUndef(R), "IntegerIndexed.Unfound Property");
    ValDel(e, R);
    
    ValDel(e, O);
    ValDel(e, VAB);

}

bool_t ProxyMethod(Js* e, Val* proxy, char* name, void* method) {
    if(ObjectGetMethod(e, proxy->obj, name) == method)
        return TRUE;
    return FALSE;
}

void ObjAddMeth(Js* e, Val* o, char* name, CallPtr func) {
    Val* method = ObjectCreate(e, CurrentRealm(e)->functionPrototype, NULL);
    ObjectSetMethod(e, method->obj, _Call_, func, FALSE);
    PutA(e, o, name, method, TRUE);
}

Val* MockProxySetPrototypeOf(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* proto = ListGetValue(e, args->list, 1);
    PutA(e, target, "__prototype", proto, FALSE);
    ValDel(e, target);
    ValDel(e, proto);
    return ValNewBool(e, TRUE);
}

Val* MockProxyGetPrototypeOf(Js* e, Val* o, Val* othis, Val* args) {
    Val* p = ObjectCreate(e, NULL, NULL);
    PutA(e, p, "isProxyPrototype", ValNewBool(e, TRUE), TRUE);
    return p;
}

Val* MockProxyIsExtensible(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* ep = GetA(e, target, "__extensionsPrevented");
    if(ValIsUndef(ep)) {
        ValDel(e, ep);
        ValDel(e, target);
        return ValNewBool(e, FALSE);
    }
    
    if(!ValIsTrueDel(e, ep)) {
        ValDel(e, ep);
        ValDel(e, target);
        return ValNewBool(e, TRUE);
    }
    ValDel(e, target);
    ValDel(e, ep);
    return ValNewBool(e, FALSE);
}


Val* MockProxyPreventExtensions(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    PutA(e, target, "__extensionsPrevented", ValNewBool(e, TRUE), TRUE);
    Val* ret = DoPreventExtensions(e, target);
    ValDel(e, ret);
    ValDel(e, target);
    return ValNewBool(e, TRUE);
}

Val* MockProxyGetOwnProperty(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* p = ListGetValue(e, args->list, 1);
    Val* desc = ObjectCreate(e, NULL, NULL);
    PutA(e, desc, "value", ValNewNum(e, 3.14), TRUE);
    PutA(e, desc, "configurable", ValNewBool(e, TRUE), TRUE);
    PutA(e, desc, "name", p, FALSE);
    PutA(e, desc, "writable", ValNewBool(e, TRUE), TRUE);
    PutA(e, desc, "emumerable", ValNewBool(e, FALSE), TRUE);
    ValDel(e, p);
    ValDel(e, target);
    return desc;
}

Val* MockProxyDefineOwnProperty(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* p = ListGetValue(e, args->list, 1);
    Val* desc = ListGetValue(e, args->list, 2);

    PutA(e, target, "__property", p, FALSE);
    Val* value = GetA(e, desc, "value");
    PutA(e, target, "__value", value, FALSE);
    ValDel(e, value);

    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, desc);
    return ValNewBool(e, TRUE);
}

Val* MockProxyHasProperty(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* p = ListGetValue(e, args->list, 1);
    bool_t ret = FALSE;
    if(ValEqStrA(e, p, "XY"))
        ret = TRUE;

    ValDel(e, p);
    ValDel(e, target);
    return ValNewBool(e, ret);
}

Val* MockProxyGet(Js* e, Val* o, Val* othis, Val* args) {
    Val* p = ListGetValue(e, args->list, 1);
    return p;
}

Val* MockProxySet(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* p = ListGetValue(e, args->list, 1);
    PutA(e, target, "didSet", p, TRUE);
    ValDel(e, target);
    return ValNewBool(e, TRUE);
}

Val* MockProxyDelete(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* p = ListGetValue(e, args->list, 1);
    PutA(e, target, "deleted", p, TRUE);
    ValDel(e, target);
    return ValNewBool(e, TRUE);
}

Val* MockProxyEnumerate(Js* e, Val* o, Val* othis, Val* args) {
    Val* ret = ObjectCreate(e, NULL, NULL);
    PutA(e, ret, "something", ValNewStrA(e, "else"), TRUE);
    return ret;
}

Val* MockProxyOwnKeys(Js* e, Val* o, Val* othis, Val* args) {
    Val* ret = ObjectCreate(e, NULL, NULL);
    PutA(e, ret, "keys", ValNewStrA(e, "yes"), TRUE);
    return ret;
}


Val* MockProxyCall(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* thisArg = ListGetValue(e, args->list, 1);
    Val* argsArray = ListGetValue(e, args->list, 2);

    PutA(e, target, "thisArg", thisArg, TRUE);
    PutA(e, target, "argArray", argsArray, TRUE);
    ValDel(e, target);
    return ValNewBool(e, TRUE);
}

Val* MockProxyConstruct(Js* e, Val* o, Val* othis, Val* args) {
    Val* target = ListGetValue(e, args->list, 0);
    Val* argsArray = ListGetValue(e, args->list, 1);
    Val* ret = ObjectCreate(e, NULL, NULL);
    PutA(e, ret, "argArray", argsArray, TRUE);
    ValDel(e, target);
    return ret;
}

void ProxyTest(test* t) {
    Js* e = t->js;
    Val* handler = ObjectCreate(e, NULL, NULL);
    Val* target = ObjectCreate(e, NULL, NULL);
    Val* proxy = ProxyCreate(e, target, NULL);
    ok(t, ValIsThrow(e, proxy, CurrentRealm(e)->typeErrorObject), "Proxy.NonObjectHandler");
    ValDel(e, proxy);
    proxy = ProxyCreate(e, NULL, handler);
    ok(t, ValIsThrow(e, proxy, CurrentRealm(e)->typeErrorObject), "Proxy.NonObjectTarget");
    ValDel(e, proxy);
    
    proxy = ProxyCreate(e, target, handler);
    ok(t, ValIsObject(proxy), "Proxy.Create");
    ok(t, ProxyMethod(e, proxy, _GetPrototypeOf_, ProxyGetPrototypeOf), "Proxy.[[GetPrototypeOf]]");
    ok(t, ProxyMethod(e, proxy, _SetPrototypeOf_, ProxySetPrototypeOf), "Proxy.[[SetPrototypeOf]]");
    ok(t, ProxyMethod(e, proxy, _IsExtensible_, ProxyIsExtensible), "Proxy.[[IsExtensible]]");
    ok(t, ProxyMethod(e, proxy, _PreventExtensions_, ProxyPreventExtensions), "Proxy.[[PreventExtensions]]");
    ok(t, ProxyMethod(e, proxy, _GetOwnProperty_, ProxyGetOwnProperty), "Proxy.[[GetOwnProperty]]");
    ok(t, ProxyMethod(e, proxy, _DefineOwnProperty_, ProxyDefineOwnProperty), "Proxy.[[DefineOwnProperty]]");
    ok(t, ProxyMethod(e, proxy, _HasProperty_, ProxyHasProperty), "Proxy.[[HasProperty]]");
    ok(t, ProxyMethod(e, proxy, _Get_, ProxyGet), "Proxy.[[Get]]");
    ok(t, ProxyMethod(e, proxy, _Set_, ProxySet), "Proxy.[[Set]]");
    ok(t, ProxyMethod(e, proxy, _Delete_, ProxyDelete), "Proxy.[[Delete]]");
    ok(t, ProxyMethod(e, proxy, _Enumerate_, ProxyEnumerate), "Proxy.[[Enumerate]]");
    ok(t, ProxyMethod(e, proxy, _OwnPropertyKeys_, ProxyOwnPropertyKeys), "Proxy.[[OwnPropertyKeys]]");
    ok(t, ProxyMethod(e, proxy, _Call_, NULL), "Proxy.[[Call]].NonCallable");
    ok(t, ProxyMethod(e, proxy, _Construct_, NULL), "Proxy.[[Construct]].NonCallable");
    ValDel(e, handler);
    ValDel(e, target);
    ValDel(e, proxy);
    
    
    
    handler = ObjectCreate(e, NULL, NULL);
    Val* consTarget = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, consTarget->obj, _Call_, MockCall, FALSE);
    ObjectSetMethod(e, consTarget->obj, _Construct_, MockConstruct, FALSE);
    proxy = ProxyCreate(e, consTarget, handler);
    ok(t, ProxyMethod(e, proxy, _Call_, ProxyCall), "Proxy.[[Call]].NonCallable");
    ok(t, ProxyMethod(e, proxy, _Construct_, ProxyConstruct), "Proxy.[[Construct]].NonCallable");
    ValDel(e, consTarget);
    ValDel(e, handler);
    ValDel(e, proxy);


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "getPrototypeOf", MockProxyGetPrototypeOf);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    Val* res = DoGetPrototypeOf(e, proxy);
    ok(t, ValIsObject(res), "Proxy.getPrototypeOf.Type");
    Val* b = GetA(e, res, "isProxyPrototype");
    ok(t, ValIsTrueDel(e, b), "Proxy.getPrototypeOf");
    ValDel(e, res);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);

    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "setPrototypeOf", MockProxySetPrototypeOf);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    Val* proto = ValNewObject(e);
    res = DoSetPrototypeOf(e, proxy, proto);
    ok(t, ValIsTrueDel(e,res), "Proxy.setPrototypeOf.Result");
    res = GetA(e, target, "__prototype");
    ok(t, ValIsObject(res) && res->obj == proto->obj, "Proxy.setPrototypeOf.Value");
    ValDel(e, res);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);
    ValDel(e, proto);


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "isExtensible", MockProxyIsExtensible);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    res = DoIsExtensible(e, proxy);
    ok(t, !ValIsTrueDel(e,res), "Proxy.isExtensible");
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "preventExtensions", MockProxyPreventExtensions);
    ObjAddMeth(e, handler, "isExtensible", MockProxyIsExtensible);  // Needed for preventExtensions
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    res = DoPreventExtensions(e, proxy);
    ok(t, ValIsTrueDel(e,res), "Proxy.preventExtensions.True");
    res = GetA(e, target, "__extensionsPrevented");
    ok(t, ValIsTrueDel(e, res), "Proxy.preventExtensions");
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);
    

    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "getOwnPropertyDescriptor", MockProxyGetOwnProperty);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    Val* p = ValNewStrA(e, "XYZ");
    Val* desc = DoGetOwnProperty(e, proxy, p);
    ok(t, desc->type == TYPE_DESC, "Proxy.getOwnProperty.Type");
    ok(t, PropIsConfigurable(e, desc->desc), "Proxy.getOwnProperty.configurable");
    ok(t, PropIsWritable(e, desc->desc), "Proxy.getOwnProperty.writable");
    ok(t, !PropIsEnumerable(e, desc->desc), "Proxy.getOwnProperty.enumerable");
    ok(t, desc->desc->value->num == 3.14 , "Proxy.getOwnProperty.value");
    ValDel(e, desc);
    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);
    

    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "defineProperty", MockProxyDefineOwnProperty);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    desc = DescNew(e, ValNewNum(e,4.56), TRUE, TRUE, TRUE, TRUE);
    p = ValNewStrA(e, "SomeProp");
    res = DoDefineOwnProperty(e, proxy, p, desc);
    ok(t, ValIsTrue(e, res), "Proxy.defineProperty.Return");
    ValDel(e, res);
    res = GetA(e, target, "__property");
    ok(t, ValEqStrA(e, res, "SomeProp"), "Proxy.defineProperty.name");
    ValDel(e, res);
    res = GetA(e, target, "__value");
    ok(t, res->num == 4.56, "Proxy.defineProperty.value");
    ValDel(e, res);
    ValDel(e, desc);
    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);

    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "has", MockProxyHasProperty);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    p = ValNewStrA(e, "X");
    res = DoHasProperty(e, proxy, p);
    ok(t, !ValIsTrueDel(e, res), "Proxy.has.false");
    ValDel(e, p);
    p = ValNewStrA(e, "XY");
    res = DoHasProperty(e, proxy, p);
    ok(t, ValIsTrueDel(e, res), "Proxy.has.true");
    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "get", MockProxyGet);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    p = ValNewStrA(e, "X");
    res = DoGet(e, proxy, p, proxy);
    ok(t, ValEqStrA(e, res, "X"), "Proxy.get");
    ValDel(e, res);
    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);    

    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "set", MockProxySet);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    p = ValNewStrA(e, "XYX");
    Val* v = ValNewNum(e, 3.14);
    res = DoSet(e, proxy, p, v, proxy);
    ok(t, ValIsTrueDel(e, res), "Proxy.set.return");
    res = GetA(e, target, "didSet");
    ok(t, ValEqStrA(e, res, "XYX"), "Proxy.set");
    ValDel(e, res);
    ValDel(e, v);
    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);        


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "deleteProperty", MockProxyDelete);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    p = ValNewStrA(e, "someprop");
    res = DoDelete(e, proxy, p);
    ok(t, ValIsTrueDel(e, res), "Proxy.delete.return");
    res = GetA(e, target, "deleted");
    ok(t, ValEqStrA(e, res, "someprop"), "Proxy.delete");
    ValDel(e, res);
    ValDel(e, p);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);        


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "enumerate", MockProxyEnumerate);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    res = DoEnumerate(e, proxy);
    ok(t, ValIsObject(res), "Proxy.enumerate.type");
    v = GetA(e, res, "something");
    ok(t, ValEqStrA(e, v, "else"), "Proxy.enumerate");
    ValDel(e, res);
    ValDel(e, v);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);        

    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "ownKeys", MockProxyOwnKeys);
    target = ObjectCreate(e, NULL, NULL);
    proxy = ProxyCreate(e, target, handler);
    res = DoOwnPropertyKeys(e, proxy);
    ok(t, ValIsObject(res), "Proxy.ownKeys.type");
    v = GetA(e, res, "keys");
    ok(t, ValEqStrA(e, v, "yes"), "Proxy.ownKeys");
    ValDel(e, res);
    ValDel(e, v);
    ValDel(e, target);
    ValDel(e, handler);
    ValDel(e, proxy);


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "apply", MockProxyCall);
    target = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, target->obj, _Call_, MockCall, FALSE);
    ObjectSetMethod(e, target->obj, _Construct_, MockConstruct, FALSE);    
    proxy = ProxyCreate(e, target, handler);
    v = ValNewNum(e, 1);
    Val* args = ListNewWithArg(e, v);
    ValDel(e, v);
    Val* othis = ObjectCreate(e, NULL, NULL);
    res = DoCall(e, proxy, othis, args);
    ok(t, ValIsTrueDel(e, res), "Proxy.call.return");
    res = GetA(e, target, "thisArg");
    ok(t, res->obj == othis->obj, "Proxy.call.othis");
    ValDel(e, res);
    res = GetA(e, target, "argArray");
    v = GetA(e, res, "length");
    ok(t, v->num == 1, "Proxy.call.args");
    ValDel(e, v);
    ValDel(e, res);
    ValDel(e, target);
    ValDel(e, args);
    ValDel(e, othis);
    ValDel(e, handler);
    ValDel(e, proxy);    


    handler = ObjectCreate(e, NULL, NULL);
    ObjAddMeth(e, handler, "construct", MockProxyConstruct);
    target = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, target->obj, _Call_, MockCall, FALSE);
    ObjectSetMethod(e, target->obj, _Construct_, MockConstruct, FALSE);    
    proxy = ProxyCreate(e, target, handler);
    v = ValNewNum(e, 1);
    args = ListNewWithArg(e, v);
    ValDel(e, v);
    res = DoConstruct(e, proxy, args, NULL);
    ok(t, ValIsObject(res), "Proxy.construct.return");
    Val* array = GetA(e, res, "argArray");
    v = GetA(e, array, "length");
    ok(t, v->num == 1, "Proxy.construct.args");
    ValDel(e, v);
    ValDel(e, array);
    ValDel(e, res);
    ValDel(e, target);
    ValDel(e, args);
    ValDel(e, handler);
    ValDel(e, proxy);    

}




Val* MockConstructTarget(Js* e, Val* obj, Val* args) {
    Val* ret = ValNewObject(e);
    if(args && args->type == TYPE_LIST && args->list->count > 0) {
        PutA(e, ret, "Y", ListGetValue(e, args->list, 0), TRUE);
    }
    else
        PutA(e, ret, "Y", ValNewNum(e, 3.45), TRUE);
    return ret;
}


void BoundFunctionTest(test* t) {
    Js* e = t->js;
    Val* targetFunc = CreateBuiltinFunction(e, CurrentRealm(e), MockCallTarget);
    Val* targetThis = ValNewObject(e);
    List* args = ListNew(e);
    ListAddValue(e, args, ValNewNum(e, 1));
    ListAddValue(e, args, ValNewNum(e, 2));
    ListAddValue(e, args, ValNewNum(e, 3));
    Val* targetArgs = ValNewList(e, args);
    Val* boundFunc = BoundFunctionCreate(e, targetFunc, targetThis, targetArgs);
    ok(t, !ObjectGetMethod(e, boundFunc->obj, _Construct_), "BoundFunction.[[Construct]]");
    Val* tempThis = ValNewObject(e);
    List* args2 = ListNew(e);
    ListAddValue(e, args2, ValNewNum(e, 4));
    ListAddValue(e, args2, ValNewNum(e, 5));
    ListAddValue(e, args2, ValNewNum(e, 6));
    Val* extraArgs = ValNewList(e, args2);
    Val* result = DoCall(e, boundFunc, tempThis, extraArgs);
    ok(t, ValIsTrueDel(e,result), "BoundFunction.[[Call]]");
    result = GetA(e, targetThis, "X");
    ok(t, result->num == 5.67, "BoundFunction.[[Call]]");
    ValDel(e, result);
    ValDel(e, tempThis);
    ValDel(e, extraArgs);
    ValDel(e, boundFunc);
    ValDel(e, targetFunc);
    ValDel(e, targetThis);
    ValDel(e, targetArgs);

    

    Val* targetCons = ObjectCreate(e, CurrentRealm(e)->functionPrototype, NULL);
    ObjectSetMethod(e, targetCons->obj, _Construct_, MockConstructTarget, FALSE);
    ObjectSetMethod(e, targetCons->obj, _Call_, MockCallTarget, FALSE);
    targetThis = ValNewObject(e);
    args = ListNew(e);
    ListAddValue(e, args, ValNewNum(e, 1));
    ListAddValue(e, args, ValNewNum(e, 2));
    ListAddValue(e, args, ValNewNum(e, 3));
    targetArgs = ValNewList(e, args);
    boundFunc = BoundFunctionCreate(e, targetCons, targetThis, targetArgs);
    ok(t, ObjectGetMethod(e, boundFunc->obj, _Construct_) != NULL, "BoundCons.[[Construct]]");
    tempThis = ValNewObject(e);
    args2 = ListNew(e);
    ListAddValue(e, args2, ValNewNum(e, 4));
    ListAddValue(e, args2, ValNewNum(e, 5));
    ListAddValue(e, args2, ValNewNum(e, 6));
    extraArgs = ValNewList(e, args2);
    result = DoConstruct(e, boundFunc, extraArgs, NULL);
    ok(t, ValIsObject(result), "BoundCons.[[Construct]]");
    Val* p = GetA(e, result, "Y");
    ok(t, p->num == 1, "BoundCons.[[Construct]]");
    ValDel(e, p);
    ValDel(e, result);
    ValDel(e, tempThis);
    ValDel(e, extraArgs);
    ValDel(e, boundFunc);
    ValDel(e, targetCons);
    ValDel(e, targetThis);
    ValDel(e, targetArgs);

    
}


#define X       root
#define L       left
#define R       right
#define T       token
#define TIN(p,x,n)    TokIsNum(p->e, p->tk, x, n)
#define TIK(p,x,k)    TokIsKey(p->e, p->tk, x, k)
#define TID(p,x,k)    TokIsId(p->e, p->tk, x, k)
#define TIT(p,k,t)    (TkGetTokType(p->e, p->tk, k->token) == t)
#define TIS(p,x,s)    TokIsStr(p->e, p->tk, x,s)

bool_t IsKeyword(Parser* p, Node* n, int k) {
    if(!n) return FALSE;
    if(TkGetTokType(p->e, p->tk, n->token) != TOK_KEYWORD)
        return FALSE;
    if(TkGetTokKeyword(p->e, p->tk, n->token) != k)
        return FALSE;
    return TRUE;
}

bool_t IsType(Parser* p, Node* n, int t) {
    if(!n) return FALSE;
    return (TkGetTokType(p->e, p->tk, n->token) ==  t);
}

bool_t TokIsKey(Js* e, Tokenizer* tk, Node* n, int id) {
    if(!n) return FALSE;
    return (TkGetTokKeyword(e, tk, n->token) == id);
}

bool_t TokNotNull(Js*e, Tokenizer* tk, Node* n) {
    return n != NULL;
}



bool_t TokIsNum(Js* e, Tokenizer* tk, Node* n, number x) {
    if(!n) return FALSE;
    if (TkGetTokType(e, tk, n->token) != TOK_NUMLIT)
        return FALSE;
    number tn = TkGetTokNumVal(e, tk, n->token);
    return (tn == x);
}

bool_t TokIsStr(Js* e, Tokenizer* tk, Node* n, char* s) {
    if(!n) return FALSE;
    int t = TkGetTokType(e, tk, n->token);
    if(t == TOK_TEMPHEAD || t == TOK_TEMPMID || t == TOK_TEMPLIT || t == TOK_TEMPTAIL|| t == TOK_STRLIT) {
        Str* us = TkGetTokStr(e, tk, n->token);
        return StrEqChars(e, us, s);
    }
    return FALSE;
}

bool_t TokIsNull(Js* e, Tokenizer* tk, Node* n) {
    if(!n) return FALSE;
    return (n->token == TOK_NOT_FOUND);
}

void ParserTest(test* t) {
    Js* e = t->js;
    Parser* p = ParserNew(e); 
    Val* v = ParseA(p, "foo();", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.CallExpression.NoArgs");
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lpar), "Parser.CallExpression.NoArgs");
    ok(t, TokIsId(e, p->tk, p->X->L->L, "foo"), "Parser.CallExpression.NoArgs");
    ok(t, p->X->L->R == NULL, "Parser.CallExpression.NoArgs");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "foo(1);", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.CallExpression.OneArg");
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lpar), "Parser.CallExpression.OneArg");
    ok(t, TokIsId(e, p->tk, p->X->L->L, "foo"), "Parser.CallExpression.OneArg");
    ok(t, TokIsNull(e, p->tk, p->X->L->R), "Parser.CallExpression.OneArg");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->L,1), "Parser.CallExpression.OneArg");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "foo(1,'hello', 3);", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.CallExpression.ThreeArg");
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lpar), "Parser.CallExpression.ThreeArgs");
    ok(t, TokIsId(e, p->tk, p->X->L->L, "foo"), "Parser.CallExpression.ThreeArgs");
    ok(t, TokIsNull(e, p->tk, p->X->L->R), "Parser.CallExpression.ThreeArgs");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->L,1), "Parser.CallExpression.ThreeArgs");
    ok(t, TokIsStr(e, p->tk, p->X->L->R->R->L,"hello"), "Parser.CallExpression.ThreeArgs");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->R->R->L,3), "Parser.CallExpression.ThreeArgs");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e); 
    v = ParseA(p, "foo(1);foo(2);foo(3);", 0);
    Node* C1 = p->X->L;
    Node* C2 = p->X->R->L;
    Node* C3 = p->X->R->R->L;
    ok(t, TokIsKey(e, p->tk, C1, id_lpar), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsId(e, p->tk, C1->L, "foo"), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsNum(e, p->tk, C1->R->L, 1), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsKey(e, p->tk, C2, id_lpar), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsId(e, p->tk, C2->L, "foo"), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsNum(e, p->tk, C2->R->L, 2), "Parser.CallExpression.ThreeCalls");    
    ok(t, TokIsKey(e, p->tk, C3, id_lpar), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsId(e, p->tk, C3->L, "foo"), "Parser.CallExpression.ThreeCalls");
    ok(t, TokIsNum(e, p->tk, C3->R->L, 3), "Parser.CallExpression.ThreeCalls");    
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e); 
    v = ParseA(p, "x++",0);
    ok(t, TokIsKey(e,p->tk, p->X->L, id_plusplus),"Parser.AutoSemiPostFixExpressionNoLineTerm.PlusPlus");
    ok(t, TokIsId(e, p->tk, p->X->L->L, "x"), "Parser.AutoSemiPostFixExpressionNoLineTerm.Identifier");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "x\n++",0);
    ok(t, p->error[0], "Parser.AutoSemi.PostFixExpression.NoLineTerm");
// This should be a syntax error >>>    ok(t, TokIsId(e, p->tk, p->X->L, "x"), "Parser.AutoSemiPostFixExpressionLineTerm.Identifier");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "foo(1",0);
    ok(t, ValIsAbrupt(e, v), "Parser.CallExpression.Error");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e); 
    v = ParseA(p, "yield=1",PSTRICT);
    ok(t, ValIsAbrupt(e, v), "Parser.Strict.yield");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e); 
    v = ParseA(p, "default=1",PDEFAULT);
    ok(t, !ValIsAbrupt(e, v), "Parser.NonStrict.default");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e); 
    v = ParseA(p, "default=1",0);
    ok(t, ValIsAbrupt(e, v), "Parser.Strict.default");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e); 
    v = ParseA(p, "let=1",0);
    ok(t, !ValIsAbrupt(e, v), "Parser.NonStrict.let");
    ValDel(e, v);
    ParserDel(p);                

    p = ParserNew(e); 
    v = ParseA(p, "let=1",PSTRICT);
    ok(t, ValIsAbrupt(e, v), "Parser.Strict.let");
    ValDel(e, v);
    ParserDel(p);                    

#ifdef TODO     // BindingIdentifier not yet used 
    p = ParserNew(e); 
    v = ParseA(p, "eval('x=2')",PSTRICT);
    ok(t, ValIsAbrupt(e, v), "Parser.Strict.eval");
    ValDel(e, v);
    ParserDel(p);                        
#endif

    p = ParserNew(e); 
    v = ParseA(p, "eval('x=2')",0);
    ok(t, !ValIsAbrupt(e, v), "Parser.NonStrict.eval");
    ValDel(e, v);
    ParserDel(p);   

    p = ParserNew(e); 
    v = ParseA(p, "default = 1",PDEFAULT);
    ok(t, !ValIsAbrupt(e, v), "Parser.defaultAllowed");
    // ok(t, TokIsId(e, p->tk, p->X->L->L, "default"), "Parser.defaultAllowed");
    ValDel(e, v);
    ParserDel(p);                                

    p = ParserNew(e); 
    v = ParseA(p, "yield= 1",0);
    ok(t, !ValIsAbrupt(e, v), "Parser.yieldAllowed");
    // ok(t, TokIsId(e, p->tk, p->X->L->L, "yield"), "Parser.yieldAllowed");
    ValDel(e, v);
    ParserDel(p);                                    

    p = ParserNew(e); 
    v = ParseA(p, "yield= 1",PNOYIELD);
    ok(t, ValIsAbrupt(e, v), "Parser.yieldNotAllowed");
    ok(t, TkGetTokKeyword(e, p->tk, 0) == id_yield, "Parser.yieldNotAllowed");
    ValDel(e, v);
    ParserDel(p);      

    p = ParserNew(e);
    v = ParseA(p, "x = ()", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.() without expression");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "x = (... A)", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.(... A)");
    ok(t, TokIsKey(e, p->tk, p->X->L, id_eq), "Parser.(...A) X->L");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_dotdotdot), "Parser.(...A) X->L->R");
    ok(t, TokIsId(e, p->tk, p->X->L->R->R, "A"), "Parser.(...A) X->L->R->R");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "x = (2+3, ... A)", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.(2+3, ... A)");
    ok(t, TokIsKey(e, p->tk, p->X->L, id_eq), "Parser.(2+3,...A) X->L");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_dotdotdot), "Parser.(2+3,...A) X->L->R");
    ok(t, TokIsId(e, p->tk, p->X->L->R->R, "A"), "Parser.(2+3,...A) X->L->R->R");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "x = []", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.Array[].NoError");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_lbracket), "Parser.Array[] X->L->R");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "x = [1]", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.Array[1].NoError");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_lbracket), "Parser.Array[1] X->L->R");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->R->L, 1), "Parser.Array[1] X->L->R->R->L");
    ValDel(e, v);
    ParserDel(p);    


    p = ParserNew(e);
    v = ParseA(p, "x = [,,,]", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.Array[,,,].NoError");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_lbracket), "Parser.Array[,,,] X->L->R");    
    ok(t, p->X->L->R->R != NULL, "Parser.Array[,,,] X->L->R->R");
    ok(t, p->X->L->R->R->R != NULL, "Parser.Array[,,,] X->L->R->R->R");
    ok(t, p->X->L->R->R->R->R != NULL, "Parser.Array[,,,] X->L->R->R->R->R");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "x = [,1,,]", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.Array[,1,,].NoError");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_lbracket), "Parser.Array[,1,,] X->L->R");    
    ok(t, TokNotNull(e, p->tk, p->X->L->R->R), "Parser.Array[,1,,] X->L->R->R");
    ok(t, TokNotNull(e, p->tk, p->X->L->R->R->R), "Parser.Array[,1,,] X->L->R->R->R");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->R->R->L, 1), "Parser.Array[,1,,] X->L->R->R->R->L");
    ok(t, TokNotNull(e, p->tk, p->X->L->R->R->R->R), "Parser.Array[,1,,] X->L->R->R->R->R");
    ValDel(e, v);
    ParserDel(p);    


    p = ParserNew(e);
    v = ParseA(p, "[... A]", 0);
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lbracket), "Parser[... A] X->L");
    ok(t, TokIsKey(e, p->tk, p->X->L->R->L, id_dotdotdot), "Parser[... A] X->L->R->L");
    ok(t, TokIsId(e, p->tk, p->X->L->R->L->L, "A"), "Parser[... A] X->L->R->L->L");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "[1,2,3]", 0);
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lbracket), "Parser[1,2,3] X->L");
    ok(t, TokNotNull(e, p->tk, p->X->L->R), "Parser[1,2,3] X->L->R");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->L, 1), "Parser[1,2,3] X->L->R->L");
    ok(t, TokNotNull(e, p->tk, p->X->L->R->R), "Parser[1,2,3] X->L->R->R");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->R->L, 2), "Parser[1,2,3] X->L->R->L->R");    
    ok(t, TokNotNull(e, p->tk, p->X->L->R->R->R), "Parser[1,2,3] X->L->R->R->R");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->R->R->L, 3), "Parser[1,2,3] X->L->R->L->R->R");        
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "[1, ... A]", 0);
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lbracket), "Parser[... A] X->L");
    ok(t, TokIsNum(e, p->tk, p->X->L->R->L, 1), "Parser.[1,... A] X->R->L");
    ok(t, TokIsKey(e, p->tk, p->X->L->R->R->L, id_dotdotdot), "Parser.[1,... A] X->R->R->L");
    ok(t, TokIsId(e, p->tk, p->X->L->R->R->L->L, "A"), "Parser.[1,... A] X->R->R->L->L");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "[for (i of [1, 2, 3]) i * i];", 0);    
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lbracket), "Parser.ArrayComprehension.For.Bracket");
    ok(t, TokIsKey(e, p->tk, p->X->L->L, id_for), "Parser.ArrayComprehension.For.For");
    ok(t, TokIsId(e, p->tk, p->X->L->L->L, "i"), "Parser.ArrayComprehension.For.i");
    ok(t, TokIsKey(e, p->tk, p->X->L->L->R, id_lbracket), "Parser.ArrayComprehension.For.ofArray");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_mult), "Parser.ArrayComprehension.For.*");
    ok(t, TokIsId(e, p->tk, p->X->L->R->L, "i"), "Parser.ArrayComprehension.For.*.Left");
    ok(t, TokIsId(e, p->tk, p->X->L->R->R, "i"), "Parser.ArrayComprehension.For.*.Right");
    ValDel(e, v);
    ParserDel(p);        
    
    p = ParserNew(e);
    v = ParseA(p, "[for (i of [1,4,2,3,-8]) if (i < 3) i];", 0);
    ok(t, TokIsKey(e, p->tk, p->X->L, id_lbracket), "Parser.ArrayComprehension.ForIf.Bracket");    
    ok(t, TokIsKey(e, p->tk, p->X->L->L, id_for), "Parser.ArrayComprehension.ForIf.For");
    ok(t, TokIsId(e, p->tk, p->X->L->L->L, "i"), "Parser.ArrayComprehension.ForIf.i");
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_if), "Parser.ArrayComprehension.ForIf.if");    
    ok(t, TokIsKey(e, p->tk, p->X->L->R->L, id_lt), "Parser.ArrayComprehension.ForIf.if.Lt");    
    ok(t, TokIsId(e, p->tk, p->X->L->R->L->L, "i"), "Parser.ArrayComprehension.ForIf.if.Lt.Left");    
    ok(t, TokIsNum(e, p->tk, p->X->L->R->L->R, 3), "Parser.ArrayComprehension.ForIf.if.Lt.Rigt");    
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "[for (let of [1]) let * let];", 0);
    ok(t, ValIsAbrupt(e,v), "Parser.ArrayComprehension.For.CantUseLet");
    ValDel(e, v);
    ParserDel(p);            


    p = ParserNew(e);
    v = ParseA(p, "z = {};", 0);
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_lbrace), "Parser.ObjectLiteral.Empty");    
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "z = {x,y};", 0);
    ok(t, TokIsKey(e, p->tk, p->X->L->R, id_lbrace), "Parser.ObjectLiteral.IdentifierReferenceList {x,y}");
    ok(t, TokIsId(e, p->tk, p->X->L->R->R->L, "x"), "Parser.ObjectLiteral.IdentifierReferenceList.x");
    ok(t, TokIsId(e, p->tk, p->X->L->R->R->R->L, "y"), "Parser.ObjectLiteral.IdentifierReferenceList.y");
    ValDel(e, v);
    ParserDel(p);            


    p = ParserNew(e);
    v = ParseA(p, "z = {x=1,y=2};", 0);
    Node *Z = p->X->L->R;
    ok(t, TokIsKey(e, p->tk, Z, id_lbrace), "Parser.ObjectLiteral.CoverInit {x=1,y=2}");
    ok(t, TokIsKey(e, p->tk, Z->R->L, id_eq), "Parser.ObjectLiteral.CoverInit.x");
    ok(t, TokIsId(e, p->tk, Z->R->L->L, "x"), "Parser.ObjectLiteral.CoverInit.x");
    ok(t, TokIsNum(e, p->tk, Z->R->L->R, 1), "Parser.ObjectLiteral.CoverInit.x");
    ok(t, TokIsKey(e, p->tk, Z->R->R->L, id_eq), "Parser.ObjectLiteral.CoverInit.y");
    ok(t, TokIsId(e, p->tk, Z->R->R->L->L, "y"), "Parser.ObjectLiteral.CoverInit.y");
    ok(t, TokIsNum(e, p->tk, Z->R->R->L->R, 2), "Parser.ObjectLiteral.CoverInit.y");        
    ValDel(e, v);
    ParserDel(p);                

    p = ParserNew(e);
    v = ParseA(p, "z = {x:1,y:2};", 0);
    Z = p->X->L->R;
    ok(t, TokIsKey(e, p->tk, Z, id_lbrace), "Parser.ObjectLiteral.PropInit {x:1,y:2}");
    ok(t, TokIsKey(e, p->tk, Z->R->L, id_colon), "Parser.ObjectLiteral.PropInit.x");
    ok(t, TokIsId(e, p->tk, Z->R->L->L, "x"), "Parser.ObjectLiteral.PropInit.x");
    ok(t, TokIsNum(e, p->tk, Z->R->L->R, 1), "Parser.ObjectLiteral.PropInit.x");
    ok(t, TokIsKey(e, p->tk, Z->R->R->L, id_colon), "Parser.ObjectLiteral.PropInit.y");
    ok(t, TokIsId(e, p->tk, Z->R->R->L->L, "y"), "Parser.ObjectLiteral.PropInit.y");
    ok(t, TokIsNum(e, p->tk, Z->R->R->L->R, 2), "Parser.ObjectLiteral.PropInit.y");        
    ValDel(e, v);
    ParserDel(p);         

    p = ParserNew(e);
    v = ParseA(p, "z = {'x':1,3:2};", 0);
    Z = p->X->L->R;
    ok(t, TokIsKey(e, p->tk, Z, id_lbrace), "Parser.ObjectLiteral.PropInit {x:1,y:2}");
    ok(t, TokIsKey(e, p->tk, Z->R->L, id_colon), "Parser.ObjectLiteral.PropInit.x");
    ok(t, TokIsStr(e, p->tk, Z->R->L->L, "x"), "Parser.ObjectLiteral.PropInit.x");
    ok(t, TokIsNum(e, p->tk, Z->R->L->R, 1), "Parser.ObjectLiteral.PropInit.x");
    ok(t, TokIsKey(e, p->tk, Z->R->R->L, id_colon), "Parser.ObjectLiteral.PropInit.y");
    ok(t, TokIsNum(e, p->tk, Z->R->R->L->L, 3), "Parser.ObjectLiteral.PropInit.y");
    ok(t, TokIsNum(e, p->tk, Z->R->R->L->R, 2), "Parser.ObjectLiteral.PropInit.y");        
    ValDel(e, v);
    ParserDel(p);         


    p = ParserNew(e);
    v = ParseA(p, "z = /./gi;", 0);
    ok(t, TkGetTokType(e, p->tk, p->X->L->R->token) == TOK_REGEX, "Parser.RegExp.Ok");
    ok(t, !ValIsAbrupt(e, v), "Parser.RegExp.Ok.Result");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "z = /./gimi;", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.RegExp.InvalidFlag.Duplicate(i)");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "z = /./gx;", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.RegExp.InvalidFlag.(x)");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "`ABC`", 0);
    ok(t, TkGetTokType(e, p->tk, p->X->L->token) == TOK_TEMPLIT, "Parser.NoSubstitutionTemplate");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "`ABC${1}`", 0);
    ok(t, TkGetTokType(e, p->tk, p->X->L->token) == TOK_TEMPHEAD, "Parser.TemplateHead");
    ok(t, TokIsStr(e, p->tk, p->X->L, "ABC"), "Parser.TemplateHead.String");    
    ok(t, TokIsNum(e, p->tk, p->X->L->L, 1), "Parser.TemplateHead.Expression");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "`ABC${1}D`", 0);
    ok(t, TkGetTokType(e, p->tk, p->X->L->token) == TOK_TEMPHEAD, "Parser.TemplateHead");
    ok(t, TokIsStr(e, p->tk, p->X->L, "ABC"), "Parser.TemplateHead.String");    
    ok(t, TokIsNum(e, p->tk, p->X->L->L, 1), "Parser.TemplateHead.Expression");
    ok(t, TkGetTokType(e, p->tk, p->X->L->R->token) == TOK_TEMPTAIL, "Parser.TempTail");
    ok(t, TokIsStr(e, p->tk, p->X->L->R, "D"), "Parser.TemplateTail.String");    
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "`A${1}B${2}C${3}D${4}E`", 0);
    Node* n = p->X->L;
    ok(t, TkGetTokType(e, p->tk, n->token) == TOK_TEMPHEAD, "Parser.TemplateHead");
    ok(t, TokIsStr(e, p->tk, n, "A"), "Parser.TemplateHead.String");    
    ok(t, TokIsNum(e, p->tk, n->L, 1), "Parser.TemplateHead.Expression");
    n = n->right;
    ok(t, TkGetTokType(e, p->tk,n->token) == TOK_TEMPMID, "Parser.TemplateMid1");
    ok(t, TokIsStr(e, p->tk, n, "B"), "Parser.TemplateHead.String");    
    ok(t, TokIsNum(e, p->tk, n->L, 2), "Parser.TemplateHead.Expression");
    n = n->right;
    ok(t, TkGetTokType(e, p->tk,n->token) == TOK_TEMPMID, "Parser.TemplateMid2");
    ok(t, TokIsStr(e, p->tk, n, "C"), "Parser.TemplateHead.String");    
    ok(t, TokIsNum(e, p->tk, n->L, 3), "Parser.TemplateHead.Expression");
    n = n->right;
    ok(t, TkGetTokType(e, p->tk,n->token) == TOK_TEMPMID, "Parser.TemplateMid3");
    ok(t, TokIsStr(e, p->tk, n, "D"), "Parser.TemplateHead.String");    
    ok(t, TokIsNum(e, p->tk, n->L, 4), "Parser.TemplateHead.Expression");
    n = n->right;    
    ok(t, TkGetTokType(e, p->tk,n->token) == TOK_TEMPTAIL, "Parser.TemplateTail");
    ok(t, TokIsStr(e, p->tk, n, "E"), "Parser.TemplateHead.String");    
    n = n->right;        
    ok(t, n == NULL, "Parser.TemplateTail.Next");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "1+2", 0);
    ok(t, TIK(p,p->X->L, id_plus), "Parser.MemberExpression.PrimaryExpression.Root");
    ok(t, TIN(p,p->X->L->L, 1), "Parser.MemberExpression.PrimaryExpression.Left");
    ok(t, TIN(p,p->X->L->R, 2), "Parser.MemberExpression.PrimaryExpression.Right");
    ValDel(e, v);
    ParserDel(p);    
    
    p = ParserNew(e);
    v = ParseA(p, "a[1]", 0);
    ok(t, TIK(p,p->X->L, id_lbracket), "Parser.MemberExpression.MemberExpression[Expression].Root");
    ok(t, TID(p,p->X->L->L, "a"), "Parser.MemberExpression.MemberExpression[Expression].Left");
    ok(t, TIN(p,p->X->L->R, 1), "Parser.MemberExpression.MemberExpression[Expression].Right");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "a.x", 0);
    ok(t, TIK(p,p->X->L, id_dot), "Parser.MemberExpression.MemberExpression.Identifier.Root");
    ok(t, TID(p,p->X->L->L, "a"), "Parser.MemberExpression.MemberExpression.Identifier.Left");
    ok(t, TID(p,p->X->L->R, "x"), "Parser.MemberExpression.MemberExpression.Identifier.Right");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "a`X`", 0);
    ok(t, TIT(p,p->X->L, TOK_TEMPLIT), "Parser.MemberExpression.MemberExpression TemplateLiteral.Root");
    ok(t, TID(p,p->X->L->L, "a"), "Parser.MemberExpression.MemberExpression TemplateLiteral.Left");
    ok(t, TIS(p,p->X->L->R, "X"), "Parser.MemberExpression.MemberExpression TemplateLiteral.Right");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "a`X${1}`", 0);
    ok(t, TIT(p,p->X->L, TOK_TEMPHEAD), "Parser.MemberExpression.MemberExpression TemplateLiteral.Root");
    ok(t, TID(p,p->X->L->L, "a"), "Parser.MemberExpression.MemberExpression TemplateLiteral.Left");
    ok(t, TIS(p,p->X->L->R, "X"), "Parser.MemberExpression.MemberExpression TemplateLiteral.Right");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "super[1]", 0);
    ok(t, TIK(p,p->X->L, id_lbracket), "Parser.MemberExpression.super [Expression].Root");
    ok(t, TIK(p,p->X->L->L, id_super), "Parser.MemberExpression.super [Expression].Left");
    ok(t, TIN(p,p->X->L->R, 1), "Parser.MemberExpression.super [Expression].Right");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "super.a", 0);
    ok(t, TIK(p,p->X->L, id_dot), "Parser.MemberExpression.super.Identifier.Root");
    ok(t, TIK(p,p->X->L->L, id_super), "Parser.MemberExpression.super.Identifier.Left");
    ok(t, TID(p,p->X->L->R, "a"), "Parser.MemberExpression.super.Identifier.Right");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "new super(1)", 0);
    ok(t, TIK(p,p->X->L, id_new), "Parser.MemberExpression.new super Arguments.Root");
    ok(t, TIK(p,p->X->L->L, id_super), "Parser.MemberExpression.super Arguments.Left");
    ok(t, TIN(p,p->X->L->R->L, 1), "Parser.MemberExpression.super Arguments.Right");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "new super(1)", 0);
    ok(t, TIK(p,p->X->L, id_new), "Parser.MemberExpression.new super Arguments.Root");
    ok(t, TIK(p,p->X->L->L, id_super), "Parser.MemberExpression.super Arguments.Left");
    ok(t, TIN(p,p->X->L->R->L, 1), "Parser.MemberExpression.super Arguments.Right");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "new Func(1)", 0);
    ok(t, TIK(p,p->X->L, id_new), "Parser.NewExpression.new MemberExpression Arguments.Root");
    ok(t, TID(p,p->X->L->L, "Func"), "Parser.NewExpression.new MemberExpression Arguments.Left");
    ok(t, TIN(p,p->X->L->R->L, 1), "Parser.NewExpression.new MemberExpression Arguments.Right");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "new super", 0);
    ok(t, TIK(p,p->X->L, id_new), "Parser.NewExpression.new super.Root");
    ok(t, TIK(p,p->X->L->L, id_super), "Parser.NewExpression.super.Right");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e);
    v = ParseA(p, "A(1)", 0);
    ok(t, TIK(p,p->X->L, id_lpar), "Parser.CallExpression.MemberExpression Arguments.Root");
    ok(t, TID(p,p->X->L->L, "A"), "Parser.CallExpression.MemberExpression Arguments.Left");
    ok(t, TIN(p,p->X->L->R->L, 1), "Parser.CallExpression.MemberExpression Arguments.Right");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e);
    v = ParseA(p, "super(1)", 0);
    ok(t, TIK(p,p->X->L, id_lpar), "Parser.CallExpression.super Arguments.Root");
    ok(t, TIK(p,p->X->L->L, id_super), "Parser.CallExpression.super Arguments.Left");
    ok(t, TIN(p,p->X->L->R->L, 1), "Parser.CallExpression.super Arguments.Right");
    ValDel(e, v);
    ParserDel(p);                

    p = ParserNew(e);
    v = ParseA(p, "new A(1).B[2](3)", 0);
    n = p->X->L;
    ok(t, TIK(p,n, id_lpar), "Parser.CallExpression.Complex.Root");
    ok(t, TIN(p,n->R->L, 3), "Parser.CallExpression.Right");
    n = n->left;
    ok(t, TIK(p,n, id_lbracket), "Parser.CallExpression.Complex.Array");
    ok(t, TIN(p,n->R, 2), "Parser.CallExpression.Complex.ArrayIndex");
    n = n->left;
    ok(t, TIK(p,n, id_dot), "Parser.CallExpression.Complex.Dot");
    ok(t, TID(p, n->R, "B"), "Parser.CallExpression.Complex.PropName");
    n = n->left;
    ok(t, TIK(p,n, id_new), "Parser.CallExpression.Complex.New");
    ok(t, TIN(p,n->R->L, 1), "Parser.CallExpression.Complex.Args");
    ok(t, TID(p,n->L, "A"), "Parser.CallExpression.Complex.Func");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "({ a, b }) = Y;", 0);
    n = p->X->L;
    ok(t, TIK(p,n, id_eq), "Parser.ObjectAssignmentPattern.=");
    ok(t, TID(p, n->right, "Y"), "Parser.ObjectAssignmentPattern.rvalue");
    n = n->left;
    ok(t, TIK(p,n ,id_lbrace), "Parser.ObjectAssignmentPattern.{");
    n = n->right;
    ok(t, TID(p, n->left, "a"), "Parser.ObjectAssignmentPattern.a");
    n = n->right;
    ok(t, TID(p, n->left, "b"), "Parser.ObjectAssignmentPattern.b");    
    ValDel(e, v);
    ParserDel(p);                

    p = ParserNew(e);
    v = ParseA(p, "({ a=1, b =2 }) = Y;", 0);
    n = p->X->L;
    ok(t, TIK(p,n, id_eq), "Parser.ObjectAssignmentPattern.=");
    ok(t, TID(p, n->right, "Y"), "Parser.ObjectAssignmentPattern.rvalue");
    n = n->left;
    ok(t, TIK(p,n ,id_lbrace), "Parser.ObjectAssignmentPattern.{");
    n = n->right;
    ok(t, TIK(p, n->left, id_eq), "Parser.ObjectAssignmentPattern.a.=");
    ok(t, TID(p, n->left->left, "a"), "Parser.ObjectAssignmentPattern.a.left");
    ok(t, TIN(p, n->left->right, 1), "Parser.ObjectAssignmentPattern.a.right");
    n = n->right;
    ok(t, TIK(p, n->left, id_eq), "Parser.ObjectAssignmentPattern.b.=");
    ok(t, TID(p, n->left->left, "b"), "Parser.ObjectAssignmentPattern.b.left");    
    ok(t, TIN(p, n->left->right, 2), "Parser.ObjectAssignmentPattern.b.right");
    ValDel(e, v);
    ParserDel(p);                    

    p = ParserNew(e);
    v = ParseA(p, "({ a:1, b:2 }) = Y;", 0);
    n = p->X->L;
    ok(t, TIK(p,n, id_eq), "Parser.ObjectAssignmentPattern.=");
    ok(t, TID(p, n->right, "Y"), "Parser.ObjectAssignmentPattern.rvalue");
    n = n->left;
    ok(t, TIK(p,n ,id_lbrace), "Parser.ObjectAssignmentPattern.{");
    n = n->right;
    ok(t, TIK(p, n->left, id_colon), "Parser.ObjectAssignmentPattern.a.:");
    ok(t, TID(p, n->left->left, "a"), "Parser.ObjectAssignmentPattern.a.left");
    ok(t, TIN(p, n->left->right, 1), "Parser.ObjectAssignmentPattern.a.right");
    n = n->right;
    ok(t, TIK(p, n->left, id_colon), "Parser.ObjectAssignmentPattern.b.:");
    ok(t, TID(p, n->left->left, "b"), "Parser.ObjectAssignmentPattern.b.left");    
    ok(t, TIN(p, n->left->right, 2), "Parser.ObjectAssignmentPattern.b.right");
    ValDel(e, v);
    ParserDel(p);                        

    p = ParserNew(e);
    v = ParseA(p, "({ a:1, b: w=2 }) = Y;", 0);
    n = p->X->L;
    ok(t, TIK(p,n, id_eq), "Parser.ObjectAssignmentPattern.=");
    ok(t, TID(p, n->right, "Y"), "Parser.ObjectAssignmentPattern.rvalue");
    n = n->left;
    ok(t, TIK(p,n ,id_lbrace), "Parser.ObjectAssignmentPattern.{");
    n = n->right;
    ok(t, TIK(p, n->left, id_colon), "Parser.ObjectAssignmentPattern.a.:");
    ok(t, TID(p, n->left->left, "a"), "Parser.ObjectAssignmentPattern.a.left");
    ok(t, TIN(p, n->left->right, 1), "Parser.ObjectAssignmentPattern.a.right");
    n = n->right;
    ok(t, TIK(p, n->left, id_colon), "Parser.ObjectAssignmentPattern.b.:");
    ok(t, TID(p, n->left->left, "b"), "Parser.ObjectAssignmentPattern.b.left");    
    ok(t, TIK(p, n->left->right, id_eq), "Parser.ObjectAssignmentPattern.b.right");
    ok(t, TID(p, n->left->right->left, "w"), "Parser.ObjectAssignmentPattern.b.left.w");
    ok(t, TIN(p, n->left->right->right, 2), "Parser.ObjectAssignmentPattern.b.left.2");    
    ValDel(e, v);
    ParserDel(p);                            


    p = ParserNew(e);
    v = ParseA(p, "[ a, b = 2] = Y;", 0);
    n = p->X->L;
    ok(t, TIK(p,n, id_eq), "Parser.ArrayAssignmentPattern.=");
    ok(t, TID(p, n->right, "Y"), "Parser.ArrayAssignmentPattern.rvalue");
    n = n->left;
    ok(t, TIK(p,n ,id_lbracket), "Parser.ArrayAssignmentPattern.{");
    n = n->right;
    ok(t, TID(p, n->left, "a"), "Parser.ArrayAssignmentPattern.a");
    n = n->right;
    ok(t, TIK(p, n->left, id_eq), "Parser.ArrayAssignmentPattern.=");    
    ok(t, TID(p, n->left->left, "b"), "Parser.ArrayAssignmentPattern.b");
    ok(t, TIN(p, n->L->R, 2), "Parser.ArrayAssignmentPattern.2");
    ValDel(e, v);
    ParserDel(p);            


    p = ParserNew(e);
    v = ParseA(p, "for(i=0; i < 20; i++) x = i;", 0);
    ok(t, NodeHasFlag(p, p->X->L, ForEEE) != NULL, "Parser.ForEEE.for");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e);
    v = ParseA(p, "for(var i=0; i < 20; i++) x = i;", 0);
    ok(t, NodeHasFlag(p, p->X->L, ForVEE) != NULL, "Parser.ForVEE.for");
    ValDel(e, v);
    ParserDel(p);            

    p = ParserNew(e);
    v = ParseA(p, "for(const i=0; i < 20; i++) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForLEE) != NULL, "Parser.ForLEE.for");
    ValDel(e, v);
    ParserDel(p);                
   
    p = ParserNew(e);
    v = ParseA(p, "for(i in o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForLIE) != NULL, "Parser.ForLIE");
    ValDel(e, v);
    ParserDel(p);                

    p = ParserNew(e);
    v = ParseA(p, "for(var i in o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForVIE) != NULL, "Parser.ForVIE");
    ValDel(e, v);
    ParserDel(p);                    

    p = ParserNew(e);
    v = ParseA(p, "for(const i in o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForFIE) != NULL, "Parser.ForFIE");
    ValDel(e, v);
    ParserDel(p);                        

    p = ParserNew(e);
    v = ParseA(p, "for(let i in o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForFIE) != NULL, "Parser.ForFIE");
    ValDel(e, v);
    ParserDel(p);                            


    p = ParserNew(e);
    v = ParseA(p, "for(i of o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForLOA) != NULL, "Parser.ForLOA");
    ValDel(e, v);
    ParserDel(p);                                

    p = ParserNew(e);
    v = ParseA(p, "for(var i of o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForVOA) != NULL, "Parser.ForVOA");
    ValDel(e, v);
    ParserDel(p);                                    

    p = ParserNew(e);
    v = ParseA(p, "for(let i of o) x = i;", 0);    
    ok(t, NodeHasFlag(p, p->X->L, ForFOA) != NULL, "Parser.ForFOA");
    ValDel(e, v);
    ParserDel(p);                                        


    p = ParserNew(e);
    v = ParseA(p, "switch(x) { case 1: y=2; case 2: { z = x; } default: m = 9;}", 0);    
    ok(t, !ValIsAbrupt(e, v), "Parser.SwitchStatement.SingleDefault");
    ok(t, NodeHasFlag(p, p->X->L, SwitchStatement) != NULL, "Parser.SwitchStatement");
    ValDel(e, v);
    ParserDel(p);                                        

    p = ParserNew(e);
    v = ParseA(p, "switch(x) { default: k = 2; case 1: y=2; case 2: { z = x; } default: m = 9;}", 0);  
    ok(t, ValIsAbrupt(e, v), "Parser.SwitchStatement.MultipleDefault");
    ValDel(e, v);
    ParserDel(p);                                            

    p = ParserNew(e);
    v = ParseA(p, "x = 1; { x++ }", 0);  
    ok(t, !ValIsAbrupt(e, v), "Parser.AutoSemi.PlusPlus");
    ValDel(e, v);
    ParserDel(p);                                            

    p = ParserNew(e);
    v = ParseA(p, "function foo(a,b) { return a+b; }", 0);  
    ok(t, !ValIsAbrupt(e, v), "Parser.Function.Declaration");
    ValDel(e, v);
    ParserDel(p);                                                

    p = ParserNew(e);
    v = ParseA(p, "x = function foo(a,b) { return a+b; }", 0);  
    ok(t, !ValIsAbrupt(e, v), "Parser.Function.Expression.Named");
    ValDel(e, v);
    ParserDel(p);                                                

    p = ParserNew(e);
    v = ParseA(p, "x = function(a,b) { return a+b; }", 0);  
    ok(t, !ValIsAbrupt(e, v), "Parser.Function.Expression.Anonymous");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "'x'\ny=2", 0);  
    ok(t, !IsStrict(p, p->root), "Parser.Script.NotStrict");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e);
    v = ParseA(p, "'use strict'\ny=2", 0);  
    ok(t, IsStrict(p, p->root), "Parser.Script.IsStrict");
    ValDel(e, v);
    ParserDel(p);    

    p = ParserNew(e);
    v = ParseA(p, "(function(a,b) { return a+b; })", 0);
    ok(t, IsAnonymousFunctionDefinition(p, p->root->left), "Parser.Script.IsAnonymousFunctionDefinition");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "const M = 30; const N;k=N;", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.const.Uninitialized.SyntaxError.#405");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "function x(c) { A = a.b\n.c; }", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.function.NewLine.SyntaxError.#433");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "function x(c) { A = a.b()\n.d(); }", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.function.NewLine.SyntaxError.#433");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "function a() { if( 1 ) Q = 1; else Q = 2; }", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.function.ifElse.Simple.SyntaxError.#433");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "function a() { if( A ) Q = {P:N} ; else Q = 2; }", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.function.ifElse.ObjLiteral.SyntaxError.#433");
    ValDel(e, v);
    ParserDel(p);        


    p = ParserNew(e);
    v = ParseA(p, "o = { new: true };", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.ObjectLiteral.Property.new.#433");
    ValDel(e, v);
    ParserDel(p);        

    p = ParserNew(e);
    v = ParseA(p, "module.x = 9;", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.module.asIdentifier");
    ValDel(e, v);
    ParserDel(p);            


    p = ParserNew(e);
    v = ParseA(p, "try\n {\n x = 1;\n }\n catch(e)\n {\n y = 1;\n }", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.try.BlockExpected");
    ValDel(e, v);
    ParserDel(p);            

}

Val* TestVal(Js* e, Realm* realm, char* name) {
    Val* i = ValNewStrA(e, name);
    Val* v = GetIdentifierRef(e, realm->globalEnv, i, FALSE);
    ValDel(e, i);
    Val* ret = GetValue(e, v);
    ValDel(e, v);
    return ret;
}

Val* TestObjValue(Js* e, Realm* realm, char* array, char* index) {
    Val* i = ValNewStrA(e, array);
    Val* v = GetIdentifierRef(e, realm->globalEnv, i, FALSE);
    ValDel(e, i);
    i = GetValue(e, v);
    ValDel(e,v);    
    Val* ret = GetA(e, i, index);
    ValDel(e, i);
    return ret;
}


void TestParseRunInitGlobal(Js* e, Realm** rp, Parser** pp, char* name, Val* value, char* source) {
    *rp = RealmNew(e);
    RealmRetain(e, *rp);
    PutA(e, (*rp)->globalThis, name, value, TRUE);
    *pp = ParserNew(e);
    Val* v = ParseA(*pp, source, 0);    
    ValDel(e, v);
    v = ScriptEval(*pp, *rp, FALSE,0, 0);    
    ValDel(e, v);    
}


void TestParseRunInitGlobal2(Js* e, Realm** rp, Parser** pp, char* n1, Val* v1, char* n2, Val* v2, char* source) {
    *rp = RealmNew(e);
    RealmRetain(e, *rp);
    PutA(e, (*rp)->globalThis, n1, v1, TRUE);
    PutA(e, (*rp)->globalThis, n2, v2, TRUE);
    *pp = ParserNew(e);
    Val* v = ParseA(*pp, source, 0);    
    ValDel(e, v);
    v = ScriptEval(*pp, *rp, FALSE,0, 0);    
    ValDel(e, v);    
}

int TestParseRun(Js* e, Realm** rp, Parser** pp, char* source) {
    *rp = RealmNew(e);
    RealmRetain(e, *rp);
    *pp = ParserNew(e);
    Val* v = ParseA(*pp, source, 0);    
    ParserSetFileName(*pp, "test.js");
    ValDel(e, v);
    if(!(*pp)->root)
        return FALSE;
    v = ScriptEval(*pp, *rp, FALSE,0, 0);    
    int ret = TRUE;
    if(ValIsAbrupt(e, v))
        ret = FALSE;
    ValDel(e, v);    
    return ret;
}

Val* TestParseRunVal(Js* e, Realm** rp, Parser** pp, char* source) {
    *rp = RealmNew(e);
    RealmRetain(e, *rp);
    *pp = ParserNew(e);
    Val* v = ParseA(*pp, source, 0);    
    ValDel(e, v);
    if(!(*pp)->root)
        return NULL;
    return ScriptEval(*pp, *rp, FALSE,0, 0);    
}

void TestParseRunClean(Js* e, Realm* r, Parser* p) {
    ParserDel(p);        
    RealmRelease(e, r);          
}

void ScratchTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;
    TestParseRun(e, &realm, &p, "a={}; b={}; a.x=b; b.y=a; a=null; b=null;");
    TestParseRunClean(e, realm, p);
}

#define VIN(x,n)  (x->type == TYPE_NUM && x->num ==n)

Val* TestTemplateCall(Js* e, Val* o, Val* othis, Val* args) {
    // Should expect args: 0: siteObj, 1: v1  (1), 2: (2)
    // siteObj: 0: cookedS0, 1: cookedS1, ..., raw: rawObj
    // rawObj: 0: rawS0, rawS1
    Val* siteObj = NULL, *raw = NULL, *ret = NULL, *s0 = NULL, *s1 = NULL;
    Val* r0 = NULL, *r1 = NULL, *v1= NULL, *v2= NULL;

    siteObj = ListGetValue(e, args->list, 0);
    if(!ValIsObject(siteObj))
        RET(ValNewBool(e, FALSE));

    raw = GetA(e, siteObj, "raw");
    if(!ValIsObject(raw))
        RET(ValNewBool(e, FALSE));

    s0 = GetA(e, siteObj, "0");
    s1 = GetA(e, siteObj, "1");
    r0 = GetA(e, raw, "0");
    r1 = GetA(e, raw, "1");
    v1 = ListGetValue(e, args->list, 1);
    v2 = ListGetValue(e, args->list, 2);

    if(!ValEqStrA(e, s0, "a"))
        RET(ValNewBool(e, FALSE));
    if(!ValEqStrA(e, s1, "b"))
        RET(ValNewBool(e, FALSE));    
    if(!ValEqStrA(e, r0, "a"))
        RET(ValNewBool(e, FALSE));
    if(!ValEqStrA(e, r1, "b"))
        RET(ValNewBool(e, FALSE));    
    if(!VIN(v1, 1))
        RET(ValNewBool(e, FALSE));    
    if(!VIN(v2, 2))
        RET(ValNewBool(e, FALSE));    
    ret = ValNewBool(e, TRUE);
exit:
    IFD(siteObj);
    IFD(raw);
    IFD(s0);
    IFD(s1);
    IFD(r0);
    IFD(r1);
    IFD(v1);
    IFD(v2);
    return ret;
}

Val* TestCallSum(Js* e, Val* o, Val* othis, Val* args) {
    if(!args)
        return ValNewNum(e, 0);

    List* l = args->list;
    number sum = 0;
    for(Item* i = l->head; i != NULL; i = i->next) {
        if(i->value->type == TYPE_NUM)
            sum += i->value->num;
    }
    return ValNewNum(e, sum);
}

void InterpreterTest(test* t) {
    Js* e = t->js;

    Parser* p = ParserNew(e);
    Val* v = ParseA(p, "debugger;",0);
    ok(t, p->root != NULL, "Parser.single.root");
    ok(t, !p->root->right, "Parser.single.root.right");
    ok(t, !ValIsAbrupt(e, v), "Parser.singleStatement");
    ValDel(e, v);
    v = ScriptEval(p, CurrentRealm(e), FALSE,0, 0);
    ok(t, ValIsAbrupt(e, v), "Parser.eval.debugger.return");
    ValDel(e, v);
    ParserDel(p);

//  Create a new realm and new context so that we can cleanup memory
    Realm* realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0 
    p = ParserNew(e);
    v = ParseA(p, "x=20;",0);
    ok(t, TkGetTokKeyword(e, p->tk, p->X->T) == TOK_NOT_FOUND, "Parser.assignment.root");
    ok(t, TkGetTokKeyword(e, p->tk, p->X->L->T) == id_eq, "Parser.assignment.root.left");
    ok(t, TkGetTokType(e, p->tk, p->X->L->L->T) == TOK_IDENTIFIER, "Parser.assignment.root.left.left");    
    ok(t, TkGetTokType(e, p->tk, p->X->L->R->token) == TOK_NUMLIT, "Parser.assignment.root.left.right");        
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ok(t, v->num == 20, "Parser.assignment.x");
    ValDel(e, v);
    ParserDel(p);
    p = ParserNew(e);
    v = ParseA(p, "y=x;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ok(t, v->num == 20, "Parser.assignment.y");
    ValDel(e, v);
    ParserDel(p);
    RealmRelease(e, realm);


    realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0 
    p = ParserNew(e);
    v = ParseA(p, "x=w;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ok(t, ValIsAbrupt(e, v), "Parser.unresolvedReference");
    // ValPrintLn(e, "_ ", v, TRUE);
    ValDel(e, v);
    ParserDel(p);
    RealmRelease(e, realm);


    p = ParserNew(e);
    v = ParseA(p, "1+2",0);
    ok(t, IsKeyword(p, p->X->L, id_plus), "Parser.addition.root");
    ok(t, IsType(p, p->X->L->L, TOK_NUMLIT), "Parser.addition.left");
    ok(t, IsType(p, p->X->L->R, TOK_NUMLIT), "Parser.addition.right");
    ValDel(e, v);
    ParserDel(p);

    v = RunA(e, "1+2",0);
    ok(t, v->num == 3, "Parser.add");
    ValDel(e, v);

    v = RunA(e, "2*3",0);
    ok(t, v->num == 6, "Parser.mult");
    ValDel(e, v);

    v = RunA(e, "8/2",0);
    ok(t, v->num == 4, "Parser.div");
    ValDel(e, v);    

    v = RunA(e, "8-2",0);
    ok(t, v->num == 6, "Parser.sub");
    ValDel(e, v);    

    v = RunA(e, "1+2*3",0);
    ok(t, v->num == 7, "Parser.addMult");
    ValDel(e, v);    

    v = RunA(e, "1+2+3",0);
    ok(t, v->num == 6, "Parser.addAdd");
    ValDel(e, v);    


    v = RunA(e, "1+3*4/2",0);
    ok(t, v->num == 7, "Parser.addMultDiv");
    ValDel(e, v);    

    v = RunA(e, "1*3+4/2",0);
    ok(t, v->num == 5, "Parser.multAddDiv");
    ValDel(e, v);

    v = RunA(e, "1+",0);
    ok(t, ValIsAbrupt(e, v), "Parser.exprIncomplete");
    ValDel(e, v);      

    v = RunA(e, "true",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.true");
    ValDel(e, v);         

    v = RunA(e, "true && false",0);
    ok(t, v->type == TYPE_BOOL && v->b == FALSE, "Parser.true && false");
    ValDel(e, v);

    v = RunA(e, "2 == 5",0);
    ok(t, v->type == TYPE_BOOL && v->b == FALSE, "Parser.2 == 5");
    ValDel(e, v);

    v = RunA(e, "2 != 5",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.2 != 5");
    ValDel(e, v);   

    v = RunA(e, "2 == '2'",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.2 == '2'");
    ValDel(e, v);      

    v = RunA(e, "2 === '2'",0);
    ok(t, v->type == TYPE_BOOL && v->b == FALSE, "Parser.2 === '2'");
    ValDel(e, v);         

    v = RunA(e, "2 !== '2'",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.2 !== '2'");
    ValDel(e, v);            

    v = RunA(e, "9 % 3",0);
    ok(t, v->num == 0, "Parser.9 % 3");
    ValDel(e, v);

    // Basic operator checks
    ok(t, ValIsNumDel(e, RunA(e, "7 * 2", 0), 14), "Interpreter.MultBasic");
    ok(t, ValIsNumDel(e, RunA(e, "7 / 2", 0), 3.5), "Interpreter.DivBasic");
    ok(t, ValIsNumDel(e, RunA(e, "0xff & 0xf0", 0), 0xf0), "Interpreter.BitwiseAnd");
    ok(t, ValIsNumDel(e, RunA(e, "0xf0 | 0x0f", 0), 0xff), "Interpreter.BitwiseOr");
    ok(t, ValIsNumDel(e, RunA(e, "0xf0 ^ 0x01", 0), 241), "Interpreter.BitwiseXor");
    ok(t, ValIsTrueDel(e, RunA(e, "true && true", 0)), "Interpreter.TrueAndTrue");
    ok(t, !ValIsTrueDel(e, RunA(e, "true && false", 0)), "Interpreter.TrueAndFalse");    
    ok(t, !ValIsTrueDel(e, RunA(e, "false && false", 0)), "Interpreter.FalseAndFalse");        
    ok(t, ValIsTrueDel(e, RunA(e, "true || true", 0)), "Interpreter.TrueOrTrue");
    ok(t, ValIsTrueDel(e, RunA(e, "true || false", 0)), "Interpreter.TrueOrFalse");    
    ok(t, !ValIsTrueDel(e, RunA(e, "false || false", 0)), "Interpreter.FalseOrFalse");        
    ok(t, ValIsNumDel(e, RunA(e, "(3 > 4) ? 7 : 8", 0), 8), "Interpreter.ConditionalFalse");
    ok(t, ValIsNumDel(e, RunA(e, "(3 < 4) ? 7 : 8", 0), 7), "Interpreter.ConditionalTrue");    

    v = RunA(e, "9 > 3",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.9 > 3");
    ValDel(e, v);

    v = RunA(e, "9 < 3",0);
    ok(t, v->type == TYPE_BOOL && v->b == FALSE, "Parser.9 < 3");
    ValDel(e, v);

    v = RunA(e, "3 < 3",0);
    ok(t, v->type == TYPE_BOOL && v->b == FALSE, "Parser.3 < 3");
    ValDel(e, v);

    v = RunA(e, "3 <= 3",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.3 <= 3");
    ValDel(e, v);

    v = RunA(e, "3 >= 3",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.3 >= 3");
    ValDel(e, v);

    v = RunA(e, "3 >= 2",0);
    ok(t, v->type == TYPE_BOOL && v->b == TRUE, "Parser.3 >= 3");
    ValDel(e, v);

    v = RunA(e, "2*(3+4)",0);
    ok(t, v->num == 14, "Parser.ParenthesizedExpression 2*(3+4)");
    ValDel(e, v);

    v = RunA(e, "2*3+4",0);
    ok(t, v->num == 10, "Parser.ParenthesizedExpression 2*3+4");
    ValDel(e, v);    

    v = RunA(e, "(2*3)+4",0);
    ok(t, v->num == 10, "Parser.ParenthesizedExpression (2*3)+4");
    ValDel(e, v);

    v = RunA(e, "5/10*100",0);
    ok(t, v->num == 50, "Parser(5/10*100)");
    ValDel(e, v);    

    v = RunA(e, "\n5/10*100",0);
    ok(t, v->num == 50, "Parser(\\n5/10*100)");
    ValDel(e, v);    

    v = RunA(e, "1;{}",0);
    ok(t, ValIsNumDel(e, v, 1), "BlockStatement.Return");

    v = RunA(e, "1;{}2;",0);
    ok(t, ValIsNumDel(e, v, 2), "BlockStatement.Return");

    v = RunA(e, "1;;;;",0);
    ok(t, ValIsNumDel(e, v, 1), "BlockStatement.Return");

    ok(t, ValIsNumDel(e, RunA(e, "2* \n3",0), 6), "Mult with LINETERM");
    ok(t, ValIsNumDel(e, RunA(e, "9+6*2",0), 21), "Add.BasicNumbers");
    ok(t, ValIsStrADel(e, RunA(e, "'Hello '+'World'",0), "Hello World"), "Add.BasicStrings");
    ok(t, ValIsNumDel(e, RunA(e, "5-2",0), 3), "Sub.BasicNumbers");
    ok(t, ValIsNumDel(e, RunA(e, "'5'-'2'",0), 3), "Sub.StrNumbers");


    realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0 
    p = ParserNew(e);
    v = ParseA(p, "x=10;y=x;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ValDel(e, v);
    Val* y = ValNewStrA(e, "y");
    v = GetIdentifierRef(e, realm->globalEnv, y, FALSE);
    ValDel(e, y);
    ok(t, v->type == TYPE_REF, "Parser.y=x.type");
    y = GetValue(e, v);
    ValDel(e,v);
    ok(t, y->num == 10, "Parser.y=x.value");
    ValDel(e, y);
    ParserDel(p);
    RealmRelease(e, realm);   

    realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0 
    p = ParserNew(e);
    v = ParseA(p, "x=10;y=x*2;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ValDel(e, v);
    y = ValNewStrA(e, "y");
    v = GetIdentifierRef(e, realm->globalEnv, y, FALSE);
    ValDel(e, y);
    ok(t, v->type == TYPE_REF, "Parser.y=x*2.type");
    y = GetValue(e, v);
    ValDel(e,v);
    ok(t, y->num == 20, "Parser.y=x*2.value");
    ValDel(e, y);
    ParserDel(p);
    RealmRelease(e, realm);   

    
    bool_t oldWatcher = e->options.watcher;
    realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0 
    p = ParserNew(e);
    v = ParseA(p, "'use watcher';\nx=10;\ny=x*2;",0);
    
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ValDel(e, v);
    y = ValNewStrA(e, "line3");
    v = GetIdentifierRef(e, realm->globalEnv, y, FALSE);
    ValDel(e, y);
    ok(t, v->type == TYPE_REF, "Parser.line3.type");
    y = GetValue(e, v);
    ValDel(e,v);
    ok(t, y->num == 20, "Parser.line3.value");
    ValDel(e, y);
    ParserDel(p);
    RealmRelease(e, realm);    

    // reset watcher
    e->options.watcher = oldWatcher;
    realm = RealmNew(e);
    RealmRetain(e, realm);          // @note realms start with refCount 0 
    p = ParserNew(e);
    v = ParseA(p, "y=this; x=10;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ValDel(e, v);
    y = ValNewStrA(e, "y");
    v = GetIdentifierRef(e, realm->globalEnv, y, FALSE);
    ValDel(e, y);
    ok(t, v->type == TYPE_REF, "Parser.this.type");
    y = GetValue(e, v);
    ValDel(e,v);
    ok(t, ValIsObject(y), "Parser.this.isObject");
    Val* x = GetA(e, y, "x");
    ok(t, x->num == 10, "Parser.this.proeprties");
    ValDel(e, y);
    ValDel(e, x);
    ParserDel(p);
    // @note set y to null to avoid circular reference
    Val* othis = realm->globalThis;
    PutA(e, othis, "y", ValNew(e), TRUE);
    RealmRelease(e, realm);



    realm = RealmNew(e);
    RealmRetain(e, realm);
    p = ParserNew(e);
    v = ParseA(p, "x = [1,2,3];",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ValDel(e, v);
    x = ValNewStrA(e, "x");
    v = GetIdentifierRef(e, realm->globalEnv, x, FALSE);
    ValDel(e, x);
    x = GetValue(e, v);
    ValDel(e,v);
    ok(t, ValIsNumDel(e, GetA(e, x, "0"),1), "Array[1,2,3].0");
    ok(t, ValIsNumDel(e, GetA(e, x, "1"),2), "Array[1,2,3].1");
    ok(t, ValIsNumDel(e, GetA(e, x, "2"),3), "Array[1,2,3].2");
    ValDel(e, x);
    ParserDel(p);
    RealmRelease(e, realm);    

    realm = RealmNew(e);
    RealmRetain(e, realm);
    p = ParserNew(e);
    v = ParseA(p, "x = [1,,3,,,6,,];",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ValDel(e, v);
    x = ValNewStrA(e, "x");
    v = GetIdentifierRef(e, realm->globalEnv, x, FALSE);
    ValDel(e, x);
    x = GetValue(e, v);
    ValDel(e,v);
    ok(t, ValIsNumDel(e, GetA(e, x, "0"),1), "Array[1,,3,,,6,,].0");
    ok(t, ValIsNumDel(e, GetA(e, x, "2"),3), "Array[1,,3,,,6,,].1");
    ok(t, ValIsNumDel(e, GetA(e, x, "5"),6), "Array[1,,3,,,6,,].2");
    ok(t, ValIsNumDel(e, GetA(e, x, "length"), 7), "Array[1,,3,,,6,,].length");
    ValDel(e, x);
    ParserDel(p);
    RealmRelease(e, realm);  


    TestParseRun(e, &realm, &p, "x = [for (i of null) i ];");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x = [for (i of []) i ];");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "[for (i of [1,2]) i ];");
    TestParseRunClean(e, realm, p);
    
    TestParseRun(e, &realm, &p, "x = [for (i of [1, 2, 3]) i * i];");    
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","0"), 1), "ArrayComprehension.square.0");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","1"), 4), "ArrayComprehension.square.1");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","2"), 9), "ArrayComprehension.square.2");
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "x = [for (i of [1,4,2,3,-8]) if (i < 3) i];");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","0"), 1), "ArrayComprehension.if.0");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","1"), 2), "ArrayComprehension.if.1");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","2"), -8), "ArrayComprehension.if.2");
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "x = [for (i of [for (i of [1,4,2,3,-8]) if (i < 3) i]) i*i];");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","0"), 1), "ArrayComprehension.if.0");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","1"), 4), "ArrayComprehension.if.1");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","2"), 64), "ArrayComprehension.if.2");
    TestParseRunClean(e, realm, p);    
    

    TestParseRun(e, &realm, &p, "x = { a:1, b:2 };");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","a"), 1), "ObjectLiteral.x.a");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","b"), 2), "ObjectLiteral.x.b");
    TestParseRunClean(e, realm, p);    

                            //   0123 4 5 6 78 9
    TestParseRun(e, &realm, &p, "z=3; x = { z, b:2 };");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","z"), 3), "ObjectLiteral.x.z");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","b"), 2), "ObjectLiteral.x.b");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x = { 0:1, 1:2 };");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","0"), 1), "ObjectLiteral.x.0");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","1"), 2), "ObjectLiteral.x.1");
    TestParseRunClean(e, realm, p);    
    
    TestParseRun(e, &realm, &p, "x = { 'a':1, 'b':2 };");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","a"), 1), "ObjectLiteral.x.a");
    ok(t, ValIsNumDel(e, TestObjValue(e,realm,"x","b"), 2), "ObjectLiteral.x.b");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = /hello/gim;");
    x = TestVal(e, realm, "x");
    ok(t, ValEqStrA(e, ObjectGetSlot(e, x->obj, _OriginalSource_), "hello"), "RegExp.[[OriginalSource]]");
    ok(t, ValEqStrA(e, ObjectGetSlot(e, x->obj, _OriginalFlags_), "gim"), "RegExp.[[OriginalFlags]]");
    // ok(t, ValIsStrADel(e, TestObjValue(e,realm,"x","body"), "hello"), "RegExp.body");
    // ok(t, ValIsStrADel(e, TestObjValue(e,realm,"x","flags"), "gim"), "RegExp.flags");    
    ValDel(e, x);
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p,"x = `ABC`");
    ok(t, ValIsStrADel(e, TestVal(e,realm, "x"), "ABC"), "TemplateLiteral.NoSubstitution");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p,"x = `ABC${1}`");
    ok(t, ValIsStrADel(e, TestVal(e,realm, "x"), "ABC1"), "TemplateLiteral.SubstitutionHeadOnly");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p,"x = `A${1}B${2}C`");
    ok(t, ValIsStrADel(e, TestVal(e,realm, "x"), "A1B2C"), "TemplateLiteral.Substitution");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x = [1, 2, 3]; y = x[1]; z = x[2]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 2), "Array.Index1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Array.Index1");    
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x = {a:1, b:2, c:3}; y = x.a; z = x.b; w = x.c;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 1), "Object.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 2), "Object.b");    
    ok(t, ValIsNumDel(e, TestVal(e, realm, "w"), 3), "Object.c");        
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x = {a:1, b:[2,3], c:4}; y = x.b[1];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "Object.b[1]");
    TestParseRunClean(e, realm, p);        

    Val* cons = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, cons->obj, _Construct_, MockConstructTarget, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "testConstructor", cons, "x = new testConstructor;");
    ok(t, ValIsNumDel(e, TestObjValue(e, realm, "x", "Y"), 3.45), "Interpreter.new <constructor>;");
    TestParseRunClean(e, realm, p);            

    cons = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, cons->obj, _Construct_, MockConstructTarget, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "testConstructor", cons, "x = new testConstructor(7.8);");
    ok(t, ValIsNumDel(e, TestObjValue(e, realm, "x", "Y"), 7.8), "Interpreter.new <constructor>(Arguments);");
    TestParseRunClean(e, realm, p);                

    Val* call = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, call->obj, _Call_, TestCallSum, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "sum", call, "x = sum();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0), "Interpreter.Call sum();");
    TestParseRunClean(e, realm, p);                

    call = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, call->obj, _Call_, TestCallSum, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "sum", call, "x = sum(1,2,3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 6), "Interpreter.Call sum(1,2,3);");
    TestParseRunClean(e, realm, p);                

    call = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, call->obj, _Call_, TestCallSum, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "sum", call, "a = [5,6,7]; x = sum(... a);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 18), "Interpreter.Call sum(...a);");
    TestParseRunClean(e, realm, p);                    


    call = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, call->obj, _Call_, TestCallSum, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "sum", call, "a = [5,6,7]; x = sum(1,2, ... a);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 21), "Interpreter.Call sum(1, 2, ...a);");
    TestParseRunClean(e, realm, p);                    


   call = ObjectCreate(e, NULL, NULL);
   ObjectSetMethod(e, call->obj, _Call_, TestTemplateCall, FALSE);
   TestParseRunInitGlobal(e, &realm, &p, "test", call, "a = test`a${1}b${2}`;");
   ok(t, ValIsTrueDel(e, TestVal(e, realm, "a")), "Interpreter.Call templateLiteral");
   TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x = 7; x++;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 8), "Object.x++");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = 7; y = x++;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 7), "Object.y = x++");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "x = 7; x--;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 6), "Object.x--");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = 7; y = x--;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 7), "Object.y = x--");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "x = { a:1, b:2 }; delete x.a; y = x.a");
    v = TestVal(e, realm, "y");    
    ok(t, ValIsUndef(v), "Interpreter.delete object.member");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = 456; delete x; y = x");
    v = TestVal(e, realm, "y");        
    ok(t, ValIsThrow(e, v,  CurrentRealm(e)->referenceErrorObject), "Interpreter.delete global");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "x = 456; y = void x");
    v = TestVal(e, realm, "y");        
    ok(t, ValIsUndef(v), "Interpreter.void");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "x = 456; y = typeof x");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "number"), "Interpreter.typeof number");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "x = 'hello'; y = typeof x");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "string"), "Interpreter.typeof string");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "x = null; y = typeof x");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "null"), "Interpreter.typeof null");
    TestParseRunClean(e, realm, p);                                    

    TestParseRun(e, &realm, &p, "x = false; y = typeof x");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "boolean"), "Interpreter.typeof boolean");
    TestParseRunClean(e, realm, p);                                        

    TestParseRun(e, &realm, &p, "x = { a: 1, b: 2 }; y = typeof x.a");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "number"), "Interpreter.typeof reference");
    TestParseRunClean(e, realm, p);                                        

    TestParseRun(e, &realm, &p, "x = { a: 1, b: 2 }; y = typeof x");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "object"), "Interpreter.typeof object");
    TestParseRunClean(e, realm, p); 

    call = ObjectCreate(e, NULL, NULL);
    ObjectSetMethod(e, call->obj, _Call_, TestCallSum, FALSE);
    TestParseRunInitGlobal(e, &realm, &p, "sum", call, "x = typeof sum;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "function"), "Interpreter.typeof function");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = 7; ++x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 8), "++x");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = 7; y = ++x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 8), "Object.y = ++x");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "x = 7; --x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 6), "Unary.PreDecrement");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = 7; y = --x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 6), "Interpreter.PreDecrement.Value");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "x = '7'; y = +x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 7), "Interpreter.UnaryPlus");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "x = '7'; y = -x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), -7), "Interpreter.UnaryMinus");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = 0; y = ~x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), -1), "Interpreter.Tilde.0");
    TestParseRunClean(e, realm, p);                    
    TestParseRun(e, &realm, &p, "x = -1; y = ~x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 0), "Interpreter.Tilde.-1");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "x = true; y = !x;");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "y")), "Interpreter.Not.true");
    TestParseRunClean(e, realm, p);                    
    TestParseRun(e, &realm, &p, "x = false; y = !x;");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "y")), "Interpreter.Not.false");
    TestParseRunClean(e, realm, p);       


    TestParseRun(e, &realm, &p, "x = { a: 1, \nb: 2 }; y = typeof x");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "object"), "Interpreter.Object with LINETERM");
    TestParseRunClean(e, realm, p); 


    TestParseRun(e, &realm, &p, "x = {a:1, b:[2,\n3], c:4}; y = x.b[1];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "Object.b[1] with LINETERM");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = 200\ny=x*2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 400), "Parser.LineTerm Auto-Semi");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = 1 << 3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 8), "Parser.LeftShift");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "x = 8 >> 3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Parser.RightShift");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "x = 8 >>> 3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Parser.UnsignedRightShift");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = 7 >= 2");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Parser.Gte");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = 2 <= 2");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Parser.Lte");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = 2 <= 1");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Parser.Lte");
    TestParseRunClean(e, realm, p);                        

    Val* P = ObjectCreate(e, NULL, NULL);
    Val* C = ObjectCreate(e, NULL, NULL);
    PutA(e, C, "prototype", P, FALSE);
    ObjectSetMethod(e, C->obj, _Call_, TestCallSum, FALSE); // constructor must be callable
    Val* O = ObjectCreate(e, P, NULL);
    TestParseRunInitGlobal2(e, &realm, &p, "C", C, "O", O, "x = O instanceof C");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Interpreter.instanceof");
    ValDel(e, P);
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "x = { a:1 , b: 2 }; y = 'a' in x");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "y")), "Interpreter.in");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "x = { a:1 , b: 2 }; y = 'z' in x");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "y")), "Interpreter.in");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "x = 1; x +=2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 3), "Interpreter.+=");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "x = 3; x -=2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Interpreter.-=");
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "x = 3; x *=2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 6), "Interpreter.*=");
    TestParseRunClean(e, realm, p);           

    TestParseRun(e, &realm, &p, "x = 6; x /=2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 3), "Interpreter./=");
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "x = 1; x <<=1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Interpreter.<<=");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "x = 4; x >>=1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Interpreter.>>=");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "x = 4; x >>>=1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Interpreter.>>>=");
    TestParseRunClean(e, realm, p);                  

    TestParseRun(e, &realm, &p, "x = 0xff; x &=0xf0;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0xf0), "Interpreter.&=");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "x = 0xf0; x |=0xf;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0xff), "Interpreter.|=");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "x = 0xf0; x ^=0x1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 241), "Interpreter.^=");
    TestParseRunClean(e, realm, p);  

    TestParseRun(e, &realm, &p, "y = [1,2]; [] = y;");
    TestParseRunClean(e, realm, p);  

    TestParseRun(e, &realm, &p, "y = [1,2]; {} = y;");
    TestParseRunClean(e, realm, p);  

    TestParseRun(e, &realm, &p, "[a,b] = [1,2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Interpreter.ArrayDestructuring.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Interpreter.ArrayDestructuring.b");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "var [a,b] = [1,2]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Interpreter.ArrayDestructuring.var.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Interpreter.ArrayDestructuring.var.b");
    TestParseRunClean(e, realm, p);      


    TestParseRun(e, &realm, &p, "colors = [ 'r', 'g', 'b' ];\n[ fc, sc ] = colors;\n");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "fc"), "r"), "Interpreter.ArrayDestructuring.colors.fc");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "sc"), "g"), "Interpreter.ArrayDestructuring.colors.sc");
    TestParseRunClean(e, realm, p);      


     TestParseRun(e, &realm, &p, "var colors = [ 'r', 'g', 'b' ];\nvar [ fc, sc ] = colors;\n");
     ok(t, ValIsStrADel(e, TestVal(e, realm, "fc"), "r"), "Interpreter.ArrayDestructuring.var.colors.fc");
     ok(t, ValIsStrADel(e, TestVal(e, realm, "sc"), "g"), "Interpreter.ArrayDestructuring.var.colors.sc");
     TestParseRunClean(e, realm, p);      


    TestParseRun(e, &realm, &p, "[,,x] = [5,6, 7];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 7), "Interpreter.ArrayDestructuring.Elision");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "[head, ...tail] = [5, 6,7,8];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "head"), 5), "Interpreter.ArrayDestructuring.Spread.Head");
    Val* tail = TestVal(e, realm, "tail");
    Val* v0 = GetA(e, tail, "0");
    Val* v1 = GetA(e, tail, "1");
    Val* v2 = GetA(e, tail, "2");
    ok(t, ValIsNumDel(e, v0, 6), "Interpreter.ArrayDestructuring.Spread.Tail.0");
    ok(t, ValIsNumDel(e, v1, 7), "Interpreter.ArrayDestructuring.Spread.Tail.1");
    ok(t, ValIsNumDel(e, v2, 8), "Interpreter.ArrayDestructuring.Spread.Tail.2");
    ValDel(e, tail);
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "[,,x,y=9] = [5,6, 7];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 9), "Interpreter.ArrayDestructuring.Default");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "x = [1, [[2], 3]]; y = x[1][1]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "Interpreter.ComplexArray.1");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "x = [1, [[2], 3]]; y = x[1][0][0]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 2), "Interpreter.ComplexArray.2");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "[a, [[b], c]] = [1, [[2], 3]]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Interpreter.ArrayDestructuring.Nested.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Interpreter.ArrayDestructuring.Nested.b");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Interpreter.ArrayDestructuring.Nested.c");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "{a,b} = { a:1, b:2};");
    ok(t, p->error[0], "Interpreter.ObjectDestructuring.BlockConflict.#408");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "{a,b: { c } } = { a:1, b: { c:2} };");
    ok(t, p->error[0], "Interpreter.ObjectDestructuring.BlockConflict.Nested.#408");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "({a,b}) = { a:1, b:2};");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Interpreter.ObjectDestructuring.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Interpreter.ObjectDestructuring.b");
    TestParseRunClean(e, realm, p);      


    TestParseRun(e, &realm, &p, "var o = { a: 1, b: 0 }; var {a, b} = o;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Interpreter.ObjectDestructuring.var.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 0), "Interpreter.ObjectDestructuring.var.b");
    TestParseRunClean(e, realm, p);      


    TestParseRun(e, &realm, &p, "({a=7,b}) = { b:2};");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 7), "Interpreter.ObjectDestructuring.Default.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Interpreter.ObjectDestructuring.Default.b");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "o = { a:1, b:2}; ({a,b}) = o;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Interpreter.ObjectDestructuring.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Interpreter.ObjectDestructuring.b");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "([a, {b}]) = [1, {b:9}];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 9), "Interpreter.ArrayDestructuring.Nested.Object.b");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "o={a:[9]}; ({a:[f]}) =o;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "f"), 9), "Interpreter.ObjectDestructuring.Nested.Array.f");
    TestParseRunClean(e, realm, p);          

    v = TestParseRunVal(e, &realm, &p, "x = 1, 2+3, 4*5;");    
    ok(t, ValIsNumDel(e, v, 20), "Interpreter.Expression.Comma");
    TestParseRunClean(e, realm, p);              

    TestParseRun(e, &realm, &p, "x=0; if(x < 0) x = 1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0), "Interpreter.If.Simple.FALSE");
    TestParseRunClean(e, realm, p);              

    TestParseRun(e, &realm, &p, "x=0; if(x == 0) x = 1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Interpreter.If.Simple.TRUE");
    TestParseRunClean(e, realm, p);                  

    TestParseRun(e, &realm, &p, "x=0; if(x < 0) x = 1; else x = 2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Interpreter.If.Else.FALSE");
    TestParseRunClean(e, realm, p);                  

    TestParseRun(e, &realm, &p, "x=0; if(x == 0) x = 1; else x = 2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Interpreter.If.Else.TRUE");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "x=0; if(3) x = 1;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Interpreter.If.Simple.TRUE");
    TestParseRunClean(e, realm, p);              

    TestParseRun(e, &realm, &p, "x=0; if(3) { x = 1; y = 9; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 9), "Interpreter.Block");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Interpreter.Block");
    TestParseRunClean(e, realm, p);                  

    TestParseRun(e, &realm, &p, "x=0; if(0) { x = 1; y = 9; } else { x = 8; y = 10; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 10), "Interpreter.Block");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 8), "Interpreter.Block"); 
    TestParseRunClean(e, realm, p);                      

        //                       0123 45678 9 0 1 23 4 5 6
    TestParseRun(e, &realm, &p, "x=0; if(0) { x = 1; y = 9; } else { x = 8; y = 10; }");
    Node* n = p->X->L;
    ok(t, NodeHasFlag(p, n, Statement) != NULL, "Parser.NodeFlags.Statement");    
    n = p->X->R->L;
    ok(t, NodeHasFlag(p, n, Statement) != NULL, "Parser.NodeFlags.Statement");
    ok(t, NodeHasFlag(p, n->R->L, BlockStatement) != NULL, "Parser.NodeFlags.Block");
    ok(t, NodeHasFlag(p, n->R->R, BlockStatement) != NULL, "Parser.NodeFlags.Block");
    TestParseRunClean(e, realm, p);         

    TestParseRun(e, &realm, &p, "x=`${1}k`");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "1k"), "Interpreter.TemplateTail");
    TestParseRunClean(e, realm, p);             

    TestParseRun(e, &realm, &p, "x=1; { const y; } ");
    ok(t, p->error[0], "Parser.UninitializedConstant");
    TestParseRunClean(e, realm, p);                 

    TestParseRun(e, &realm, &p, "x=1; { const y = 2; } ");
    ok(t, !ValIsNumDel(e, TestVal(e, realm, "y"), 2), "Interpreter.BlockConstant.Invariant");
    TestParseRunClean(e, realm, p);                     

    TestParseRun(e, &realm, &p, "x=1; { const y = 2; x = y;} ");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Interpreter.BlockConstant.AssignToGlobal");
    TestParseRunClean(e, realm, p);                         

    TestParseRun(e, &realm, &p, "x=1; { const y = 2; let a; x = a;} ");
    v = TestVal(e, realm, "x");
    ok(t, ValIsUndef(v), "Interpreter.BlockLet.Uninitialized.AssignToGlobal");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                             

    TestParseRun(e, &realm, &p, "x=1; { const y = 2; let a =8; x = a;} ");
    ok(t,  ValIsNumDel(e, TestVal(e, realm, "x"), 8), "Interpreter.BlockLet.Initialized.AssignToGlobal");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "{ let undefined = 8; }");
    ok(t,  p->error[0], "Interpreter.let.keyword.error.#404");
    TestParseRunClean(e, realm, p);                                 


    TestParseRun(e, &realm, &p, "let a=20, a = 5;");
    ok(t,  p->error[0], "Interpreter.LexicalDeclaration.let.Binding.Duplicate.#403");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "var a=20; let a = 5;");
    ok(t,  strcmp(p->error, ":1 SyntaxError: duplicate entry: a") == 0, "Interpreter.GlobalDeclaration.LexNames.Duplicate.#403");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "a=y;\nlet y = 5;");
    ok(t, p->error[0], "Interpreter.ResolveBinding.Uninitialized.Lexical.#402");
    TestParseRunClean(e, realm, p);                                 


    TestParseRun(e, &realm, &p, "var x=1;");
    ok(t,  ValIsNumDel(e, TestVal(e, realm, "x"), 1), "Interpreter.Var.Initialized.AssignToGlobal.x");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "var x=1; { var y = 2, x = 8; } ");
    ok(t,  ValIsNumDel(e, TestVal(e, realm, "x"), 8), "Interpreter.Var.Initialized.AssignToGlobal.x");
    ok(t,  ValIsNumDel(e, TestVal(e, realm, "y"), 2), "Interpreter.Var.Initialized.AssignToGlobal.y");    
    TestParseRunClean(e, realm, p);                                     


    TestParseRun(e, &realm, &p, "let [a] = [3];");
    ok(t,  ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Interpreter.ArrayBindingPattern.let.global");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "x = 1; { let [a] = [4]; x = a; }");    
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 4), "Interpreter.ArrayBindingPattern.let.Single");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "x = 1; { let [a,b] = [4,3]; x = b; }");    
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 3), "Interpreter.ArrayBindingPattern.let.Multi");
    TestParseRunClean(e, realm, p);          


    TestParseRun(e, &realm, &p, "x = 1; { let [h, ...t] = [5, 6,7,8]; x = t[1]; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 7), "Interpreter.ArrayBindingPattern.let.Spread");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "let [,a] = [5,6];");    
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 6), "Interpreter.ArrayBindingPattern.let.Global.Elision");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "x = 1; { let [,,a,b=9] = [5,6, 7]; x = a;}");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 7), "Interpreter.ArrayBindingPattern.let.Elision");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "x = 1; { let [,,a,b=9] = [5,6, 7]; x = b;}");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 9), "Interpreter.ArrayBindingPattern.let.Default");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "let {a} = {a:6};");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 6), "Interpreter.ObjectBindingPattern.let.Global.Single");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "x=1;  { let {a, b} = {b:7}; x=b; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 7), "Interpreter.ObjectBindingPattern.let.Multi");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "x=1;  { let {a=2, b} = {b:7}; x=a; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Interpreter.ObjectBindingPattern.let.Default");
    v = TestVal(e, realm, "b");
    ok(t, ValIsAbrupt(e, v), "Interpreter.ObjectBindingPattern.let.internal");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x=1;  do { x++; } while(x < 10);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 10), "Interpreter.DoStatement.Block");    
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x=1;  do x++; while(x < 10);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 10), "Interpreter.DoStatement.Simple");    
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x=1;  while(x < 10) { x++; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 10), "Interpreter.WhileStatement.Block");    
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "for(x=0; x < 10; x++) y = x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 10), "Interpreter.ForEEE.x");    
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 9), "Interpreter.ForEEE.y");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "for(var x=0; x < 10; x++) y = x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 10), "Interpreter.ForVEE.x");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 9), "Interpreter.ForVEE.y");
    TestParseRunClean(e, realm, p);        

    realm = RealmNew(e);
    RealmRetain(e, realm);
    p = ParserNew(e);
    v = ParseA(p, "for(x=0; x < 10; x++) y = x;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ok(t, ValIsNumDel(e, v, 9), "Interpreter.ForEEE.Statement.value");
    ParserDel(p);
    RealmRelease(e, realm);    

    TestParseRun(e, &realm, &p, "for(let x=0; x < 10; x++) y = x;");
    v = TestVal(e, realm, "x");
    ok(t, ValIsAbrupt(e, v), "Interpreter.ForLEE.x");
    ValDel(e, v);
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 9), "Interpreter.ForLEE.y");
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "f = null; k = 9;\n for (let i=0; i < 1; i++) {\n f = function() { k = i; };\n }\n f();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 0), "ForBodyEvaluation.PerIterationBinding");
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "o={x:1, y:2}; z=0; for(p in o) z += o[p];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Interpreter.ForLIE.z");
    // @todo: dangerous since this depends on property iteration ending with the first
    // property
    ok(t, ValIsStrADel(e, TestVal(e, realm, "p"), "y"), "Interpreter.ForLIE.param");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o={x:1, y:2}; z=0; for(var p in o) z += o[p];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Interpreter.ForVIE.z");
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "o={x:1, y:2}; z=0; for(let p in o) z += o[p];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Interpreter.ForFIE.z");
    v = TestVal(e, realm, "p");
    ok(t, ValIsAbrupt(e, v), "Interpreter.ForFIE.let.binding");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o=[1,2]; z=0; for(p of o) z += p;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Interpreter.ForLOA.z");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "p"), 2), "Interpreter.ForLOA.param");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o=[1,2]; z=0; for(var p of o) z += p;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Interpreter.ForLOA.z");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "p"), 2), "Interpreter.ForLOA.param");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o=[1,2]; z=0; for(let p of o) z += p;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 3), "Interpreter.ForLOA.z");
    v = TestVal(e, realm, "p");
    ok(t, ValIsAbrupt(e,v), "Interpreter.ForLOA.param");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "for(let i=0; i < 10; i++) { if(i > 5) continue; y = i; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"),5), "Interpreter.ContinueStatement.NoLabel");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "for(i=0; i < 10; i++) { if(i > 5) break; y = i; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),6), "Interpreter.BreakStatement.NoLabel.Param");    
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"),5), "Interpreter.BreakStatement.NoLabel");
    TestParseRunClean(e, realm, p);            

    realm = RealmNew(e);
    RealmRetain(e, realm);
    p = ParserNew(e);
    v = ParseA(p, "x=1; return",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0,0);
    ok(t, ValIsAbrupt(e, v), "Interpreter.ReturnStatement.NotAbrupt");
    ok(t, ValIsUndef(v->completion->value), "Interpreter.ReturnStatement.Undefined");
    ValDel(e, v);
    ParserDel(p);
    RealmRelease(e, realm);    


    realm = RealmNew(e);
    RealmRetain(e, realm);
    p = ParserNew(e);
    v = ParseA(p, "x=1; return 9*2;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ok(t, ValIsAbrupt(e, v), "Interpreter.ReturnStatement.NotAbrupt");
    ok(t, ValIsNum(e, v->completion->value, 9*2), "Interpreter.ReturnStatement.Expression");
    ValDel(e, v);
    ParserDel(p);
    RealmRelease(e, realm);    

    TestParseRun(e, &realm, &p, "o = {a:1, b:2}; with(o) { y = a+b; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"),3), "Interpreter.WithStatement");
    TestParseRunClean(e, realm, p);            


    TestParseRun(e, &realm, &p, "switch(3) { case 1: x=1; break; case 3: x =2; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),2), "Interpreter.SwitchStatement.Cases");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "switch(3) { case 1: x=1; case 2: x =2; default: x = 3; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),3), "Interpreter.SwitchStatement.Cases.Default");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "switch(2) { case 1: x=1; default: x = 3; case 2: x =2; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),2), "Interpreter.SwitchStatement.Cases.Default.Cases.Found");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "switch(9) { case 1: x=1; default: x = 3; case 2: x =2; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),3), "Interpreter.SwitchStatement.Cases.Default.Cases.Default");
    TestParseRunClean(e, realm, p);  

    TestParseRun(e, &realm, &p, "L1: for(i=0; i < 30; i++) { if(i > 2) break L1; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),3), "Interpreter.LabelledStatement.Break");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "L1: for(i=0; i < 30; i++) { L2: for(j=i; j < 8; j++)\
                                 if(j > 2) break L1; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),0), "Interpreter.LabelledStatement.Break.Nest");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "j"),3), "Interpreter.LabelledStatement.Break.Nest");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "L1: for(i=0; i < 30; i++) { L2: for(j=i; j < 8; j++)\
                                 if(j > 2) continue L1; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),30), "Interpreter.LabelledStatement.Continue.Nest");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "j"),29), "Interpreter.LabelledStatement.Continue.Nest");
    TestParseRunClean(e, realm, p);   


    realm = RealmNew(e);
    RealmRetain(e, realm);
    p = ParserNew(e);
    v = ParseA(p, "throw 7;",0);
    ValDel(e, v);
    v = ScriptEval(p, realm, FALSE,0, 0);
    ok(t, ValIsNum(e, v->completion->value, 7), "Interpreter.ThrowStatement.Expression");
    ok(t, v->completion->type == COMP_THROW, "Interpreter.ThrowStatement.Type");
    ValDel(e, v);
    ParserDel(p);
    RealmRelease(e, realm);    

    TestParseRun(e, &realm, &p, "try { x = 1; } catch(e) { x = e;}");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),1), "Interpreter.TryStatement.Catch.Normal");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "try { x = 1; } catch(e) { x = e;} finally { x = 3; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),3), "Interpreter.TryStatement.Catch.Finally.Normal");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "try { throw 3; } catch(e) { x = e;}");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),3), "Interpreter.TryStatement.Catch.Throw");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "try { throw 3; } catch(e) { x = e;} finally { x++; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),4), "Interpreter.TryStatement.Catch.Finally.Throw");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "x = []; x[0]=1; y = x[0];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"),1), "Interpreter.Object[index].Assignment.#444");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x = {}; x['hello']=1; y = x.hello;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"),1), "Interpreter.Object[name].Assignment.#444");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "d = { n: { c: 1, s: 2 }}\n(d.n.s / d.n.c);");
    ok(t, p->error[0] != 0, "Interpreter.MemberExpression.AutoSemi.ShouldBeCall.#441");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "d = { n: { c: 1, s: 2 }};\n(d.n.s / d.n.c);");
    ok(t, p->error[0] == 0, "Interpreter.MemberExpression.AutoSemi.ShouldNotBeCall.#441");
    TestParseRunClean(e, realm, p);      

}


void StrTest(test* t) {
    Js* e = t->js;

    Str* s = StrNewLength(e, 10);
    ok(t, s->length == 10, "StrNewLength");
    StrDel(e, s);

    s = StrNewChars(e, "Hello");
    ok(t, s->length == 5, "StrNewChars.length");
    ok(t, s->chars[0] == 'H', "StrNewChars.0");
    ok(t, s->chars[1] == 'e', "StrNewChars.1");
    ok(t, s->chars[2] == 'l', "StrNewChars.2");
    ok(t, s->chars[3] == 'l', "StrNewChars.3");
    ok(t, s->chars[4] == 'o', "StrNewChars.4");
    StrDel(e, s);

    s = StrNewChars(e, "World");
    ok(t, StrEqChars(e,s,"World"), "Str.StrEqChars");
    StrDel(e,s);

    s = StrNewChars(e, "Hello");
    Str* s2 = StrNewChars(e, "World");
    ok(t, !StrEqStr(e,s,s2), "Str.StrEqSameLengthDifferent");
    StrDel(e, s);
    StrDel(e, s2);

    s = StrNewChars(e, "Hello");
    s2 = StrNewChars(e, "Hello2");
    ok(t, !StrEqStr(e,s,s2), "Str.StrEqStrDifferentLength");
    StrDel(e, s);
    StrDel(e, s2);

    s = StrNewChars(e, "Hello");
    char* c = StrGetChars(e, s);
    ok(t, 0 == strcmp(c, "Hello"), "Str.StrGetChars");
    StrDel(e, s);
    hfree(e->memory[ST].data, c);
    
    s = StrNewChars(e, "Hello");
    s2 = StrClone(e, s);
    ok(t, StrEqStr(e, s, s2), "Str.StrClone");
    StrDel(e,s);
    StrDel(e,s2);

    s = StrNewChars(e, "Hello");
    s2 = StrNewChars(e, "Hel");
    ok(t, !StrPrefix(e, s, s2), "Str.StrPrefix");
    ok(t, StrPrefix(e, s2, s), "Str.StrPrefix");
    StrDel(e,s);
    StrDel(e,s2);

    s = StrNewLength(e, 10);
    s->chars[0] = 'h';
    s->chars[1] = 'e';
    s->chars[2] = '\0';
    s->chars[3] = 'l';
    s->chars[4] = '\t';
    s->chars[5] = 'l';
    s->chars[6] = '\r';
    s->chars[7] = 'o';
    s->chars[8] = '\n';
    s->chars[9] = 0xdef1;
    char* chars = StrDecode(e, s);    
    s2 = StrNewChars(e, chars);
    ok(t, StrEqChars(e, s2, "he\\u0000l\\tl\\ro\\n\\udef1"), "Str.Decode");
    StrDel(e, s2);
    StrDel(e, s);
    hfree(e->memory[ST].data, chars);
    
    
    s = StrNewChars(e, "Hello");
    s2 = StrNewChars(e, "Hel");
    ok(t, StrStr(e, s, s2,0), "Str.StrStr");
    ok(t, !StrStr(e, s2, s,0), "Str.StrStr");
    StrDel(e,s);
    StrDel(e,s2);
    
    s = StrNewChars(e, "Myhello");
    s2 = StrNewChars(e, "hello");
    ok(t, StrStr(e, s, s2,0), "Str.StrStr");
    StrDel(e,s);
    StrDel(e,s2);

    s = StrNewChars(e, "hello");
    s2 = StrNewChars(e, "break");
    ok(t, !StrStr(e, s, s2,0), "Str.StrStr");
    StrDel(e,s);
    StrDel(e,s2);
    
    s = StrNewChars(e, "X");
    ok(t, !StrEqChars(e, s, "XY"), "Str.StrEqChars");
    StrDel(e,s);

    uchar ch[3];
    ch[0] = 'x';
    ch[1] = 'y';
    ch[2] = 0;
    s = StrFromUChars(e, ch);
    ok(t, StrLen(e,s) == 2, "Str.FromUChars.length");
    ok(t, StrEqChars(e, s, "xy"), "Str.FromUChars.chars");
    uchar* c2 = UCharsFromStr(e, s);
    ok(t, c2[0] == 'x' && c2[1] == 'y' && c2[2] == 0, "Str.UCharsFromStr");
    UCharsDel(e, c2);
    StrDel(e, s);



}

void FuncTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;
    TestParseRun(e, &realm, &p, "function a(x) { return x*2; } z = a(5);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 10), "Func.Simple.1");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "z = a(3); function a(x) { return x*2; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 6), "Func.Forward.1");
    TestParseRunClean(e, realm, p);            


    TestParseRun(e, &realm, &p, "function f1(x) { return x*2; } z = f1(5); function f2(w) { return w+3; } k = f2(6)");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 10), "Func.Simple.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 9), "Func.Simple.2");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "z = f1(5); k = f2(6); function f1(x) { return x*2; } function f2(w) { return w+3; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 10), "Func.Forward.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 9), "Func.Forward.2");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "function C() { return 1; } m = C();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "m"), 1), "Func.NoArgs.Simple");
    TestParseRunClean(e, realm, p);   
    
    TestParseRun(e, &realm, &p, "function C() { this.x = 1; } m = new C(); p = m.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "p"), 1), "Func.Constructor.Simple");
    TestParseRunClean(e, realm, p);                
    
    TestParseRun(e, &realm, &p, "function C() { this.x = 1; } C.prototype = { y:3 }; m = new C(); p = m.y;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "p"), 3), "Func.Constructor.Prototype");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "add = function(a,b) { return a+b; } x = add(1,3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 4), "Func.Function.Expression.Simple");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "o = { test: function(a, b) { return a+b; }}; k = o.test(1,2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 3), "Func.Function.Expression.ObjectDeclaration.Simple");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "function foo(a) { return a; } x = foo(19);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 19), "Func.Function.Return.Ref");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "function foo(a) { if(a > 10)\nreturn 'hello'; return a;} x = foo(19);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "hello"), "Func.Function.If.CR.Return");
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "function C(x) { this.x = x;} c = new C(9).x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 9), "Func.Constructor.Args");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "o = { x:1 }; k = f(o.x); function f(n) { return n*2; }");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 2), "Func.Object.Property.Argument");
    TestParseRunClean(e, realm, p);   

// #ifdef ISSUE_347
    int r = TestParseRun(e, &realm, &p, "function foo() { 'use strict'; const x = 123; x = 7 }; foo();");
    ok(t, r == FALSE, "Func.Strict.Const.AssignError");
    TestParseRunClean(e, realm, p);   
// #endif
    
    TestParseRun(e, &realm, &p, "function f(a, ...b) {\n return a + b.length;\n }\n x = f(3,1,2);");
    ok(t, p->root != 0 && ValIsNumDel(e, TestVal(e, realm, "x"), 5), "Arguments.Spread.#416");
    TestParseRunClean(e, realm, p);

#if 1
    TestParseRun(e, &realm, &p, "var o = {}; o.f = function() { var a = 1, b = 2; return a+b;}; x = o.f(1,2);");
    ok(t, p->root != 0 && ValIsNumDel(e, TestVal(e, realm, "x"), 3), "Function.Decl.Vars");
    TestParseRunClean(e, realm, p);
#endif    
}

void DefTest(test* t) {
    Js* e = t->js;
    Parser* p;
    p = ParserNew(e);
    ValDel(e, ParseA(p, "function foo(a,b) {\nreturn a+b;\n}", 0));
    FuncDef* fd = p->functions;
    ok(t, fd != NULL, "Def.Function.Simple.List");
    ok(t, fd->line == 1, "Def.Function.Simple.Line");
    ok(t, ValEqStrA(e, fd->name, "foo"), "Def.Function.Simple.Name");
    BlockDef* bd = p->blocks;
    ok(t, bd != NULL, "Def.Block.Simple.List");
    ok(t, bd->start == 1, "Def.Block.Simple.Start");
    ok(t, bd->end == 3, "Def.Block.Simple.End");
    ok(t, fd->block == bd, "Def.Function.Simple.Block");
    ParserDel(p);


    p = ParserNew(e);
    ValDel(e, ParseA(p, "function f1() {\nx=2;\n}\nfunction f2() {\ny=3;\n}", 0));
    FuncDef* f2 = p->functions;
    BlockDef* b2 = p->blocks;
    FuncDef* f1 = f2->next;
    BlockDef* b1 = b2->next;
    ok(t, f1->line == 1, "Def.Functions.Line.1");
    ok(t, ValEqStrA(e, f1->name, "f1"), "Def.Functions.Name.1");
    ok(t, f1->block == b1, "Def.Functions.Block.1");
    ok(t, b1->start == 1, "Def.Functions.Block.1.Start");
    ok(t, b1->end == 3, "Def.Functions.Block.1.End");

    ok(t, f2->line == 4, "Def.Functions.Line.2");
    ok(t, ValEqStrA(e, f2->name, "f2"), "Def.Functions.Name.2");
    ok(t, f2->block == b2, "Def.Functions.Block.2");
    ok(t, b2->start == 4, "Def.Functions.Block.2.Start");
    ok(t, b2->end == 6, "Def.Functions.Block.2.End");
    ParserDel(p);

    p = ParserNew(e);
    ValDel(e, ParseA(p, "{\nlet x = 1;\n{\nlet y = 2;\n}\n}", 0));
    b2 = p->blocks;
    b1 = b2->next;
    ok(t, b1->start == 1, "Def.NestedBlocks.Block.1.Start");
    ok(t, b1->end == 6, "Def.NestedBlocks.Block.1.End");

    ok(t, b2->start == 3, "Def.NestedBlocks.Block.2.Start");
    ok(t, b2->end == 5, "Def.NestedBlocks.Block.2.End");
    ok(t, b2->parent == b1, "Def.NestedBlocks.Block.2.Parent");
    ParserDel(p);

    p = ParserNew(e);
    ValDel(e, ParseA(p, "x = function(a,b) {\nreturn a+b;\n}", 0));
    fd = p->functions;
    ok(t, fd != NULL, "Def.Function.Simple.List");
    ok(t, fd->line == 1, "Def.Function.Simple.Line");
    ok(t, ValEqStrA(e, fd->name, "x"), "Def.Function.Expression.Simple.Name");
    ParserDel(p);

    p = ParserNew(e);
    ValDel(e, ParseA(p, "o= {}; o.x = function(a,b) {\nreturn a+b;\n}", 0));
    fd = p->functions;
    ok(t, ValEqStrA(e, fd->name, "o.x"), "Def.Function.Expression.Object.Name");
    ParserDel(p);


}

void WatcherTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    bool_t oldWatcher = e->options.watcher;
    e->options.watcher = TRUE;
    TestParseRun(e, &realm, &p, "x=1;\ny=2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line1"), 1), "Watcher.Line.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line2"), 2), "Watcher.Line.2");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "z = f1(5);\nfunction f1(x) {\nz=7;\nreturn x*2;\n}");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 10), "Watcher.Func.z");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line3"), 7), "Watcher.Func.Line.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line4"), 10), "Watcher.Func.Line.4");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "y=10;\nz='hello';\nx=Int8Array.from([3,4,5]);\nx.length;\ny=22;\nx[0];\nx[1];\nx[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line1"), 10), "Watcher.Int8Array.Line.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line4"), 3), "Watcher.Int8Array.Line.4");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line6"), 3), "Watcher.Func.Line.6");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line7"), 4), "Watcher.Func.Line.7");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line8"), 5), "Watcher.Func.Line.8");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "var x=1;\nvar y=2;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line1"), 1), "Watcher.var.line1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "line2"), 2), "Watcher.var.line2");
    TestParseRunClean(e, realm, p);            


    e->options.watcher = oldWatcher;

}

void GlobalTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "x=Infinity;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), INFINITY), "Global.Infinity");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "x=NaN;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), NAN), "Global.NaN");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "x=undefined;");
    Val* x = TestVal(e, realm, "x");
    ok(t, ValIsUndef(x), "Global.undefined");
    ValDel(e, x);
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "x = isFinite(10);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Global.isFinite.number");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "x = isNaN(NaN);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Global.isNaN.true");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = isNaN(20);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Global.isNaN.false");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = isFinite(NaN);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Global.isFinite.NaN");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = isFinite(+Infinity);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Global.isFinite.Infinity");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = isFinite(-Infinity);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Global.isFinite.NegativeInfinity");
    TestParseRunClean(e, realm, p);                                         

    TestParseRun(e, &realm, &p, "x = eval('2+3');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 5), "Global.eval.Expression");
    TestParseRunClean(e, realm, p);                                         

    TestParseRun(e, &realm, &p, "x=20; z=9; eval('x=30');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 30), "Global.eval.GlobalVar.x");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "z"), 9), "Global.eval.GlobalVar.z");
    TestParseRunClean(e, realm, p);                                             

    TestParseRun(e, &realm, &p, "x=20; eval('var x =30');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 30), "Global.eval.LocalVar");
    TestParseRunClean(e, realm, p);                                                 


    TestParseRun(e, &realm, &p, "eval('o = {}; o.func = function() { return 2};'); x = o.func()");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Global.eval.Method");
    TestParseRunClean(e, realm, p);                                         


    TestParseRun(e, &realm, &p, "x=parseFloat('abc');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), NAN), "Global.parseFloat.NAN");
    TestParseRunClean(e, realm, p);                                                     

    TestParseRun(e, &realm, &p, "x=parseFloat('12.345');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 12.345), "Global.parseFloat.12.345");
    TestParseRunClean(e, realm, p);                                                         

    TestParseRun(e, &realm, &p, "x=parseFloat('12');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 12), "Global.parseFloat.12");
    TestParseRunClean(e, realm, p);                                                             

    TestParseRun(e, &realm, &p, "x=parseFloat('-98.76');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), -98.76), "Global.parseFloat.-98.76");
    TestParseRunClean(e, realm, p);                                                                 

    TestParseRun(e, &realm, &p, "x=parseInt('20');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 20), "Global.parseInt.20");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=parseInt('20.98');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 20), "Global.parseInt.20.98");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=parseInt('-20');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), -20), "Global.parseInt.-20");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=parseInt('0xff');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0xff), "Global.parseInt.0xff");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=parseInt('-0xff');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), -0xff), "Global.parseInt.-0xff");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "x=parseInt('ff',16);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0xff), "Global.parseInt.ff.16");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=parseInt('1010',2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 10), "Global.parseInt.1010.2");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=parseInt('  ff',16);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 0xff), "Global.parseInt.ff.16");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=encodeURI('mytest.asp?name=stale&car=saab');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "mytest.asp?name=stale&car=saab"), "Global.encodeURI.simple");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=encodeURI('my test.asp?name=stale&car=saab');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "my%20test.asp?name=stale&car=saab"), "Global.encodeURI.space");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=encodeURI('my test.asp?name=st\\uc3a5le&car=saab');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "my%20test.asp?name=st%EC%8E%A5le&car=saab"), "Global.encodeURI.complex.2");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=decodeURI('mytest.asp?name=stale&car=saab');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "mytest.asp?name=stale&car=saab"), "Global.decodeURI.simple");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=decodeURI('my%20test.asp?name=stale&car=saab');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "my test.asp?name=stale&car=saab"), "Global.decodeURI.space");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=decodeURI('my%20test.asp?name=st%EC%8E%A5le&car=saab');");
    Val* v = TestVal(e, realm, "x");
    ok(t, v->type == TYPE_STR, "Global.decodeURI.complex.2.type");
    ok(t, v->str->chars[19] == 0xc3a5, "Global.decodeURI.complex.value");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=encodeURIComponent('http://mytest.asp');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "http%3A%2F%2Fmytest.asp"), "Global.encodeURIComponent.simple");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=decodeURIComponent('http%3A%2F%2Fmytest.asp');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "http://mytest.asp"), "Global.decodeURIComponent.simple");
    TestParseRunClean(e, realm, p);         

    TestParseRun(e, &realm, &p, "x=encodeURI('http://mytest.asp');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "http://mytest.asp"), "Global.encodeURI.noColon");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=Object({a:2}).a;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Global.Object.Call.Object");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x=Object();");
    v = TestVal(e, realm, "x");
    ok(t, ValIsObject(v), "Global.Object.Call.Empty");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x = new Object();");
    v = TestVal(e, realm, "x");
    ok(t, ValIsObject(v), "Global.Object.Construct.Empty");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x = Object.assign({}, {a:3}).a;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 3), "Global.Object.assign.Single");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x = Object.assign({z:4}, {a:3}, {b:6}).b;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 6), "Global.Object.assign.Multi");
    TestParseRunClean(e, realm, p);                                                                     

    TestParseRun(e, &realm, &p, "x = {}; Object.defineProperties(x, {a: {value: 1}, b: {value: 2}}); y = x.b;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 2), "Global.Object.defineProperties.2");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "p = {c:3}; x = Object.create(p, { b: {value: 2}}); y = x.b;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 2), "Global.Object.create.property");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "p = {c:3}; x = Object.create(p, { b: {value: 2}}); y = x.c;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "Global.Object.create.prototype.property");
    TestParseRunClean(e, realm, p);

    return;
}

void GlobalTest2(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;   
    Val* v; 

    TestParseRun(e, &realm, &p, "o = {}; Object.defineProperty(o, 'b', {get: function() { return 3; }, enumerable: true, configurable: true }); y = o.b;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "Global.Object.defineProperty.getter");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = {x:1}; Object.freeze(o); o.b = 4; y = o.b;");
    v = TestVal(e, realm, "y");
    ok(t, ValIsUndef(v), "Global.Object.freeze");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = {x:1}; d = Object.getOwnPropertyDescriptor(o,'x'); y = d.value;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"),1), "Global.Object.getOwnPropertyDescriptor");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "a = Object.getOwnPropertyNames({p1:1, p2:2}); y = a[0]; z = a[1]");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"),"p1"), "Global.Object.getOwnPropertyNames.0");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "z"),"p2"), "Global.Object.getOwnPropertyNames.1");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "p={}; function f() {}; f.prototype=p; o=new f(); k=Object.getPrototypeOf(o); i = (k == p);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.getPrototypeOf");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "i = Object.is(3, 3);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.is.true");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "i = Object.is(3, 4);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.is.false");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = {}; i = Object.isExtensible(o);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.isExtensible.true");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = 4; i = Object.isExtensible(o);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.isExtensible.false");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "o = {}; i = Object.isFrozen(o);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.isFrozen.false");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = 4; i = Object.isFrozen(o);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.isFrozen.true");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "o = {}; i = Object.isSealed(o);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.isSealed.false");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = 4; i = Object.isSealed(o);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Global.Object.isSealed.true");
    TestParseRunClean(e, realm, p);              

    TestParseRun(e, &realm, &p, "a = Object.keys({p1:1, p2:2}); y = a[0]; z = a[1]");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"),"p1"), "Global.Object.keys.0");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "z"),"p2"), "Global.Object.keys.1");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = {}; i = Object.preventExtensions(o);");
    v = TestVal(e, realm, "i");
    ok(t, ValIsObject(v), "Global.Object.preventExtensions.object");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                        


    TestParseRun(e, &realm, &p, "o = {x:1}; Object.seal(o); o.b = 4; y = o.b;");
    v = TestVal(e, realm, "y");
    ok(t, ValIsUndef(v), "Global.Object.seal");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o={}; p={x:2}; Object.setPrototypeOf(o,p);i=o.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 2), "Global.Object.setPrototypeOf");
    TestParseRunClean(e, realm, p);
}

void ObjProtoTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "o={x:1}; x=o.hasOwnProperty('x')");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "ObjProto.hasOwnProperty.true");
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "o={x:1}; x=o.hasOwnProperty('m')");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "ObjProto.hasOwnProperty.false");
    TestParseRunClean(e, realm, p);           

    TestParseRun(e, &realm, &p, "o={}; p={}; Object.setPrototypeOf(o,p);i=o.isPrototypeOf(p);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "ObjProto.isProrotypeOf.false");
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "o={}; p={}; Object.setPrototypeOf(o,p);i=p.isPrototypeOf(o);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "ObjProto.isProrotypeOf.true");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o={x:2}; i=o.propertyIsEnumerable('x');");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "ObjProto.propertyIsEnumerable.true");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o={x:2}; o.toString=function() { return 'hello';} i=o.toLocaleString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "hello"), "ObjProto.toLocaleString");
    TestParseRunClean(e, realm, p);                   


    TestParseRun(e, &realm, &p, "o={x:1}; i=o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "[object Object]"), "ObjProto.toString.Object");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o=[1,2]; i=o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "1,2"), "ObjProto.toString.Array");
    TestParseRunClean(e, realm, p);                   

    // Need Function.prototype.toString
    TestParseRun(e, &realm, &p, "function o() {}; i=o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "function o() {}"), "ObjProto.toString.Function");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o={x:2}; y=o.valueOf(); i=y.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 2), "ObjProto.valueOf");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o={}; p={x:2}; Object.setPrototypeOf(o,p);o.x=3; i=o.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 3), "ObjProto.override.child");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o={}; p={x:2}; Object.setPrototypeOf(o,p);o.x=3; i=p.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 2), "ObjProto.override.prototype");
    TestParseRunClean(e, realm, p);                   

}

void FuncConsTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "add = new Function('a', 'b', 'return a+b'); x = add(1,2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 3), "FuncCons.TwoPlusBody");
    TestParseRunClean(e, realm, p);           
    
    TestParseRun(e, &realm, &p, "f = new Function('return 2'); x = f();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "FuncCons.BodyOnly");
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "f = new Function(); x = f.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm,"x"),"anonymous"), "FuncCons.new.Empty.name");
    TestParseRunClean(e, realm, p);               


    int ret = TestParseRun(e, &realm, &p, "f = new Function('a', 'return 3*'); x = f(3);");
    ok(t, !ret, "FuncCons.Params.Error");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "a = ['x', 'return x*3']; f = new Function(...a); i = f(6);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 18), "FuncCons.Spread");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "function F(b=1) { u=b } F();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "u"), 1), "function.default.uninitialized");
    TestParseRunClean(e, realm, p);                       


    TestParseRun(e, &realm, &p, "function req(cb = function() {k=2;}){cb();}; req();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 2), "function.default.function.leak.#431");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "function f(a,b) { this.x = a*b; }; o={}; f.apply(o, [2,3]);i=o.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 6), "Function.prototype.apply");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "function f() { this.x = 9; }; o={}; j=f.bind(o); j(); i=o.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 9), "Function.prototype.bind");
    TestParseRunClean(e, realm, p);                           



    TestParseRun(e, &realm, &p, "function f() { this.x = 9; }; o={}; j=f.bind(o); j(); i=j.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "bound f"), "Function.prototype.bind.name");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "var f = function() {}; k = f.bind().name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "k"), "bound f"), "Function.prototype.var.bind.leak #421");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "function f(a) { this.x = a*9; }; o={}; j=f.call(o,2); i=o.x;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 18), "Function.prototype.call");
    TestParseRunClean(e, realm, p);                               

    // @todo: Not sure this is a correct test for toMethod
    TestParseRun(e, &realm, &p, "function f() { return 7; }; o={}; j = f.toMethod(o); i = j();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 7), "Function.prototype.toMethod");
    TestParseRunClean(e, realm, p);                               

    
    TestParseRun(e, &realm, &p, "function f() { return 7; }; i = f.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "function f() { return 7; }"), "Function.prototype.toString");
    TestParseRunClean(e, realm, p);                                   

    TestParseRun(e, &realm, &p, "function C() {  }; o = new C(); i = o instanceof C;");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Function.prototype.hasInstance");
    TestParseRunClean(e, realm, p);                                   

    TestParseRun(e, &realm, &p, "function C() {  }; o = new C(); i = o instanceof Number;");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Function.prototype.hasInstance");
    TestParseRunClean(e, realm, p);                                   

    TestParseRun(e, &realm, &p, "function f(a,b) {  }; i = f.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),2), "Function.length");
    TestParseRunClean(e, realm, p);                                   

    TestParseRun(e, &realm, &p, "function f(a,b) {  }; i = f.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"),"f"), "Function.name");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "function foo(a,b,c) { return a+b+c }; i = foo(1,1,1);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),3), "Function.arguments.3");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x = function f() {  }; i = x.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"),"f"), "Function.expression.name");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "var x = function f() {  }; i = x.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"),"f"), "Function.var.expression.name");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "x = new Function('return 2'); i = x.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"),"anonymous"), "Function.name.anonymous");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "x = function() {  }; i = x.name;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"),""), "function.expression.name.anonymous");
    TestParseRunClean(e, realm, p);        
}

void BooleanConsTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    

    TestParseRun(e, &realm, &p, "b = Boolean(false);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "b")), "Function.Boolean.false");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "b = Boolean(true);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "b")), "Function.Boolean.true");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "b = new Boolean(false);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "b")), "Function.Boolean.new.false");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "b = new Boolean(true);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "b")), "Function.Boolean.new.true");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "s = true.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "true"), "Function.bool.true.toString");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "s = false.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "false"), "Function.bool.false.toString");
    TestParseRunClean(e, realm, p);        



}

void SymbolConsTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    

    TestParseRun(e, &realm, &p, "s = Symbol('hello');");
    Val* v = TestVal(e, realm, "s");
    ok(t, v->type == TYPE_SYMA && StrEqChars(e, (Str*) v->descA, "hello"), "Symbol.function");
    ValDel(e, v);
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);

   ok(t, !TestParseRun(e, &realm, &p, "s = new Symbol('hello');"), "Symbol.new.TypeError");
   TestParseRunClean(e, realm, p);
    
    
    TestParseRun(e, &realm, &p, "s = Object(Symbol('hello'));");
    v = TestVal(e, realm, "s");
    ok(t, v->type == TYPE_OBJ , "Symbol.Object.type");
    Val* d = ObjectGetSlot(e, v->obj, _SymbolData_);
    ok(t, d->type == TYPE_SYMA && StrEqChars(e, (Str*) d->descA, "hello"), "Symbol.new.[[SymbolData]]");
    ValDel(e, v);
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "s = Symbol.for('hello');");
    v = TestVal(e, realm, "s");
    ok(t, v->type == TYPE_SYMA && StrEqChars(e, (Str*) v->descA, "hello"), "Symbol.for.new");
    ValDel(e, v);
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "s = Symbol.for('hello'); y = Symbol.for('hello')");
    v = TestVal(e, realm, "y");
    ok(t, v->type == TYPE_SYMA && StrEqChars(e, (Str*) v->descA, "hello"), "Symbol.for.existing");
    ValDel(e, v);
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "s = Symbol.for('hello'); y = Symbol.keyFor(s)");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "hello"), "Symbol.forKey");
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "s = Symbol('hello'); y = s.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "Symbol(hello)"), "Symbol.prototype.toString.object");
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p); 

    TestParseRun(e, &realm, &p, "s =  Symbol.for('hello'); y = s.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "Symbol(hello)"), "Symbol.prototype.toString.value");
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);     

    TestParseRun(e, &realm, &p, "s =  Symbol.for('hello'); y = s.valueOf(); y = y.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "Symbol(hello)"), "Symbol.prototype.valueOf.value");
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);     

    TestParseRun(e, &realm, &p, "s = Symbol('hello'); y = s.valueOf(); y = y.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "Symbol(hello)"), "Symbol.prototype.valueOf.object");
    SymbolEntryClear(e);
    TestParseRunClean(e, realm, p);         

}

void ErrorObjTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "o = new Error('hello'); x = o.message; y = o.name; z = o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "hello"), "Error.new.message");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "Error"), "Error.new.name");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "z"), "Error: hello"), "Error.new.toString");
    TestParseRunClean(e, realm, p);           

    TestParseRun(e, &realm, &p, "o = Error('hello'); x = o.message; y = o.name; z = o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "hello"), "Error.call.message");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "Error"), "Error.call.name");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "z"), "Error: hello"), "Error.call.toString");
    TestParseRunClean(e, realm, p);               


    TestParseRun(e, &realm, &p, "o = new URIError('hello'); x = o.message; y = o.name; z = o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "hello"), "URIError.new.message");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "URIError"), "URIError.new.name");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "z"), "URIError: hello"), "URIError.new.toString");
    TestParseRunClean(e, realm, p);           


    TestParseRun(e, &realm, &p, "o = TypeError('hello'); x = o.message; y = o.name; z = o.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "x"), "hello"), "TypeError.call.message");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "TypeError"), "TypeError.call.name");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "z"), "TypeError: hello"), "TypeError.call.toString");
    TestParseRunClean(e, realm, p);           
}


void NumObjTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "o = Number(5);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 5), "Number.call.value");
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "o = new Number(5);");
    Val* v = TestVal(e, realm, "o");
    ok(t, v->type == TYPE_OBJ, "Number.new.type");
    ok(t, ObjectGetSlotRef(e, v->obj, _NumberData_)->value->num == 5, "Number.new.value");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o = Number.EPSILON;");
    v = TestVal(e, realm, "o");
    ok(t, v->type == TYPE_NUM, "Number.EPSILON.type");
    ok(t, v->num >0 && v->num <= 0.00000001, "Number.EPSILON.value");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "x = Number.isFinite(10);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isFinite.number");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "x = Number.isFinite(NaN);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isFinite.NaN");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.isFinite(+Infinity);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isFinite.Infinity");
    TestParseRunClean(e, realm, p);                                     


    TestParseRun(e, &realm, &p, "x = Number.isInteger(10);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isInteger.int");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "x = Number.isInteger(NaN);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isInteger.NaN");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.isInteger(+Infinity);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isInteger.Infinity");
    TestParseRunClean(e, realm, p);             

    TestParseRun(e, &realm, &p, "x = Number.isInteger(10.7);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isInteger.nonInt");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "x = Number.isNaN(10.7);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isNan.number");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "x = Number.isNaN(NaN);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isNan.NaN");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.isSafeInteger(10.7);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isSafeInteger.nonInt");
    TestParseRunClean(e, realm, p);                                 

    TestParseRun(e, &realm, &p, "x = Number.isSafeInteger(10);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "x")), "Number.isSafeInteger.int");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.parseInt('10.3');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),10), "Number.parseInt");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.parseFloat('10.3');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),10.3), "Number.parseFloat");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.NaN;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),NAN), "Number.NaN");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.POSITIVE_INFINITY;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),INFINITY), "Number.POSITIVE_INFINITY");
    TestParseRunClean(e, realm, p);                                     

    TestParseRun(e, &realm, &p, "x = Number.NEGATIVE_INFINITY;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),-INFINITY), "Number.NEGATIVE_INFINITY");
    TestParseRunClean(e, realm, p);                                     


    TestParseRun(e, &realm, &p, "n = 123.456789; y = n.toExponential(5);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "1.23457e+2"), "Number.prototype.toExponential(?)");
    TestParseRunClean(e, realm, p);            
    
    TestParseRun(e, &realm, &p, "n = new Number(12.3456789); y = n.toExponential(5);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "1.23457e+1"), "Number.prototype.toExponential(5)");
    TestParseRunClean(e, realm, p);                                         

    TestParseRun(e, &realm, &p, "n = new Number(12.3456789); y = n.toExponential(4);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "1.2346e+1"), "Number.prototype.toExponential(4)");
    TestParseRunClean(e, realm, p);                                             

    TestParseRun(e, &realm, &p, "n = new Number(12.3456789); y = n.toExponential();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "1.23456789e+1"), "Number.prototype.toExponential()");
    TestParseRunClean(e, realm, p);                                         

    TestParseRun(e, &realm, &p, "n = 0.00006543; y = n.toExponential(3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "6.543e-5"), "Number.prototype.fraction.toExponential(3)");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "n = 0.2345; y = n.toFixed(2);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "0.23"), "Number.prototype.fraction.toFixed(2)");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "n = 123.456; y = n.toFixed(2);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "123.46"), "Number.prototype.toFixed(2)");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "n = 123.456; y = n.toLocaleString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "123.456"), "Number.prototype.toLocaleString");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "n = 123.456789; y = n.toPrecision(2);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "1.2e+2"), "Number.prototype.toPrecision(2)");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "n = 123.456789; y = n.toPrecision(5);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "123.46"), "Number.prototype.toPrecision(5)");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "n = 123.456789; y = n.valueOf();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 123.456789), "Number.prototype.valueOf");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "n = 129702.8533333333; y = n.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "129702.8533333333"), "Number.prototype.toString.129702.8533333333");
    TestParseRunClean(e, realm, p);                


    TestParseRun(e, &realm, &p, "n = -5286.4; y = n.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "-5286.4"), "Number.prototype.toString.-5286.4");
    TestParseRunClean(e, realm, p);                


    TestParseRun(e, &realm, &p, "n = 123.456789; y = n.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "123.456789"), "Number.prototype.toString.10");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "n = 1234567890123; y = n.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "1234567890123"), "Number.prototype.toString.longInt.10");
    TestParseRunClean(e, realm, p);                


    TestParseRun(e, &realm, &p, "n = 1234; y = n.toString(16);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "4d2"), "Number.prototype.toString.16");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "n = 1234; y = n.toString(8);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "y"), "2322"), "Number.prototype.toString.8");
    TestParseRunClean(e, realm, p);                    


    TestParseRun(e, &realm, &p, "n = 1234.345.toFixed(2);");
    ok(t, p->root && ValIsStrADel(e, TestVal(e, realm, "n"), "1234.35"), "Number.methodCall");
    TestParseRunClean(e, realm, p);                    

}

void DateTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    

    // Override localTZA to make tests run everywhere
    e->localTZA = -36000000;
    ok(t, YearFromTime(TimeFromYear(1999) == 1999), "TimeFromYear.1999");
    ok(t, YearFromTime(TimeFromYear(1966) == 1966), "TimeFromYear.1966");
    ok(t, YearFromTime(TimeFromYear(2024) == 2024), "TimeFromYear.2024");
    ok(t, YearFromTime(TimeFromYear(1970) == 1970), "TimeFromYear.1970");

    TestParseRun(e, &realm, &p, "o = Date(1999,2);");
    Val* v = TestVal(e, realm, "o");
    ok(t, v->type == TYPE_STR, "Date.function(y,m).type");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "o = Date(1999);");
    v = TestVal(e, realm, "o");
    ok(t, v->type == TYPE_STR, "Date.function(o).type");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o = Date();");
    v = TestVal(e, realm, "o");
    ok(t, v->type == TYPE_STR, "Date.function().type");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "o = Date.now();");
    v = TestVal(e, realm, "o");
    ok(t, v->type == TYPE_NUM, "Date.now().type");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "a = Date.parse('1999-02-03'); b=Date.parse('2012-12-31T19:14:33');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 918000000000), "Date.parse.YYYY-MM-DD");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 1356981273000), "Date.parse.YYYY-MM-DDTHH:mm:ss");
    TestParseRunClean(e, realm, p);                   
    TestParseRun(e, &realm, &p, "a=Date.parse('2012-12-31T19:14:33-08:30');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1357011873000), "Date.parse.YYYY-MM-DDTHH:mm:ss+HH:mm");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "a = Date.UTC(1966,3,22); b=Date.UTC(2014,11,13,16,45,22);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), -116640000000), "Date.UTC(1966,3,22)");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 1418489122000), "Date.UTC(2014,11,13,16,45,22)");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "d = new Date(2014,11,13,16,45,22); dt = d.getDate();\
                                 day = d.getDay(); y = d.getFullYear(); mo = d.getMonth();\
                                 h = d.getHours(); mn = d.getMinutes(); s = d.getSeconds();\
                                 ms = d.getMilliseconds(); t = d.getTime(); tz = d.getTimezoneOffset();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "dt"), 13), "Date.prototype.getDate");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 2014), "Date.prototype.getFullYear");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "mo"), 11), "Date.prototype.getMonth");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "h"), 16), "Date.prototype.getHours");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "mn"), 45), "Date.prototype.getMinutes");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "s"), 22), "Date.prototype.getSeconds");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "ms"), 0), "Date.prototype.getMilliseconds");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "t"), 1418525122000), "Date.prototype.getTime");
    v = TestVal(e, realm, "tz");
    ok(t, v->type == TYPE_NUM, "Date.prototype.getTimezoneOffset");
    ValDel(e, v);    
    TestParseRunClean(e, realm, p);   


    TestParseRun(e, &realm, &p, "d = new Date(2014,11,31,16,45,22); dt = d.getUTCDate();\
                                 day = d.getUTCDay(); y = d.getUTCFullYear(); mo = d.getUTCMonth();\
                                 h = d.getUTCHours(); mn = d.getUTCMinutes(); s = d.getUTCSeconds();\
                                 ms = d.getUTCMilliseconds();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "dt"), 1), "Date.prototype.getUTCDate");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 2015), "Date.prototype.getUTCFullYear");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "mo"), 0), "Date.prototype.getUTCMonth");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "h"), 2), "Date.prototype.getUTCHours");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "mn"), 45), "Date.prototype.getUTCMinutes");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "s"), 22), "Date.prototype.getUTCSeconds");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "ms"), 0), "Date.prototype.getUTCMilliseconds");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "d = new Date(2014,11,31,16,45,22);\
                                 d.setDate(22); \
                                 d.setFullYear(1999);\
                                 d.setMonth(3);\
                                 d.setHours(9);\
                                 d.setMinutes(10);\
                                 d.setSeconds(11);\
                                 d.setMilliseconds(12);\
                                 dt = d.getDate();\
                                 y = d.getFullYear();\
                                 m = d.getMonth();\
                                 h = d.getHours();\
                                 mn = d.getMinutes();\
                                 s = d.getSeconds();\
                                 ms = d.getMilliseconds();\
                                 d2 = Date.UTC(2011,3,7);\
                                 d.setTime(d2);\
                                 v = d.getFullYear();\
                                 ");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "dt"), 22), "Date.prototype.setDate");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 1999), "Date.prototype.setFullYear");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "m"), 3), "Date.prototype.setMonth");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "h"), 9), "Date.prototype.setHours");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "mn"), 10), "Date.prototype.setMinutes");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "s"), 11), "Date.prototype.setSeconds");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "ms"), 12), "Date.prototype.setMilliseconds");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "v"), 2011), "Date.prototype.setTime");
    TestParseRunClean(e, realm, p); 

    TestParseRun(e, &realm, &p, "d = new Date(2014,11,31,16,45,22);\
                                 d.setUTCDate(22); \
                                 d.setUTCFullYear(1999);\
                                 d.setUTCMonth(3);\
                                 d.setUTCHours(9);\
                                 d.setUTCMinutes(10);\
                                 d.setUTCSeconds(11);\
                                 d.setUTCMilliseconds(12);\
                                 dt = d.getUTCDate();\
                                 y = d.getUTCFullYear();\
                                 m = d.getUTCMonth();\
                                 h = d.getUTCHours();\
                                 mn = d.getUTCMinutes();\
                                 s = d.getUTCSeconds();\
                                 ms = d.getUTCMilliseconds();\
                                 ");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "dt"), 22), "Date.prototype.setUTCDate");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 1999), "Date.prototype.setUTCFullYear");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "m"), 3), "Date.prototype.setUTCMonth");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "h"), 9), "Date.prototype.setUTCHours");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "mn"), 10), "Date.prototype.setUTCMinutes");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "s"), 11), "Date.prototype.setUTCSeconds");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "ms"), 12), "Date.prototype.setUTCMilliseconds");
    TestParseRunClean(e, realm, p);  

    TestParseRun(e, &realm, &p, "d = new Date(2014,11,13,16,45,22); s = d.toDateString()");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "Sat Dec 13 2014"), "Date.prototype.toDateString");
    TestParseRunClean(e, realm, p);   

    TestParseRun(e, &realm, &p, "d = new Date(Date.UTC(2014,11,13,16,45,22)); s = d.toISOString()");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "2014-12-13T16:45:22.000Z"), "Date.prototype.toISOString");
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "d = new Date(Date.UTC(2014,11,13,16,45,22)); s = d.toLocaleDateString();\
                                 s2 = d.toString(); s3 = d.toLocaleString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "Sat Dec 13 2014"), "Date.prototype.toLocaleDateString");

    ok(t, ValIsStrADel(e, TestVal(e, realm, "s2"), "Sat Dec 13 2014 06:45:22 GMT-1000"), "Date.prototype.toString");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s3"), "Sat Dec 13 2014 06:45:22 GMT-1000"), "Date.prototype.toLocaleString");
    TestParseRunClean(e, realm, p);       

    TestParseRun(e, &realm, &p, "d = new Date(2014,11,13,16,45,22); s = d.toLocaleTimeString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "16:45:22"), "Date.prototype.toLocaleTimeString");
    TestParseRunClean(e, realm, p);       


    TestParseRun(e, &realm, &p, "d = new Date(Date.UTC(2014,11,13,16,45,22)); s = d.toUTCString();");
// v = TestVal(e, realm, "s"); vpl(e, v); ValDel(e, v);
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "Sat Dec 13 2014 16:45:22 GMT-1000"), "Date.prototype.toLocaleTimeString");
    TestParseRunClean(e, realm, p);           

    // Reset localTZA
    e->localTZA = NAN;
}


void MathTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "o = Math.E;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 2.7182818284590452354), "Math.E");
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "a = Math.LN10; b = Math.LN2; c = Math.LOG10E; d = Math.LOG2E;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 2.302585092994046), "Math.LN10");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 0.6931471805599453), "Math.LN2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 0.4342944819032518), "Math.LOG10E");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 1.4426950408889634), "Math.LOG2E");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "a = Math.PI; b = Math.SQRT1_2; c = Math.SQRT2; d = Math.toString();");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3.1415926535897932), "Math.PI");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 0.7071067811865476), "Math.SQRT1_2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 1.4142135623730951), "Math.SQRT2");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "d"), "[object Math]"), "Math.toString");
    TestParseRunClean(e, realm, p);                   

    TestParseRun(e, &realm, &p, "a = Math.abs(-1); b = Math.abs(3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Math.abs.negative");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 3), "Math.abs.positive");
    TestParseRunClean(e, realm, p);                       


    TestParseRun(e, &realm, &p, "a = Math.acos(0.1); b = Math.acosh(0.2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), acos(0.1)), "Math.acos");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), acosh(0.2)), "Math.acosh");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "a = Math.asin(0.1); b = Math.asinh(0.2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), asin(0.1)), "Math.asin");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), asinh(0.2)), "Math.asinh");
    TestParseRunClean(e, realm, p);                               

    TestParseRun(e, &realm, &p, "a=Math.atan(0.1); b=Math.atanh(0.2); c=Math.atan2(0.3,0.4); ");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), atan(0.1)), "Math.atan");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), atanh(0.2)), "Math.atang");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), atan2(0.3,0.4)), "Math.atan2");
    TestParseRunClean(e, realm, p);                                   


    TestParseRun(e, &realm, &p, "a=Math.cbrt(3); b=Math.ceil(3.2); c=Math.clz32(1000); ");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), cbrt(3)), "Math.cbrt");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), ceil(3.2)), "Math.ceil");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 22), "Math.clz32");
    TestParseRunClean(e, realm, p);                                       

    TestParseRun(e, &realm, &p, "a=Math.cos(0.1); b=Math.cosh(0.2); c=Math.exp(0.3); d=Math.expm1(0.4) ");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), cos(0.1)), "Math.cos");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), cosh(0.2)), "Math.cosh");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), exp(0.3)), "Math.exp");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), expm1(0.4)), "Math.expm1");
    TestParseRunClean(e, realm, p);                                       


    TestParseRun(e, &realm, &p, "a=Math.floor(3.1); b=Math.fround(0.23); c=Math.hypot(2,3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), floor(3.1)), "Math.floor");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), (float) 0.23), "Math.fround");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), sqrt(2*2+3*3)), "Math.hypot");
    TestParseRunClean(e, realm, p);                                       

    TestParseRun(e, &realm, &p, "a=Math.imul(2.1,3.2); b=Math.log(0.1); c=Math.log1p(0.2);d=Math.log10(0.3); e =Math.log2(0.4)");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 6), "Math.imul");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), log(0.1)), "Math.log");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), log1p(0.2)), "Math.log1p");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), log10(0.3)), "Math.log10");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), log2(0.4)), "Math.log2");
    TestParseRunClean(e, realm, p);                                           

    TestParseRun(e, &realm, &p, "a=Math.max(4,3,6,-9,2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 6), "Math.max");
    TestParseRunClean(e, realm, p);                                               

    TestParseRun(e, &realm, &p, "a=Math.min(4,3,6,-9,2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), -9), "Math.min");
    TestParseRunClean(e, realm, p);                                               

    TestParseRun(e, &realm, &p, "a=Math.pow(2,4);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), pow(2,4)), "Math.pow");
    TestParseRunClean(e, realm, p);                                                   

    TestParseRun(e, &realm, &p, "r=Math.random();");
    Val* v = TestVal(e, realm, "r");
    ok(t, v->num >= 0 && v->num < 1, "Math.random");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                                                       

    TestParseRun(e, &realm, &p, "m=Math;a=m.round(3.5);b=m.round(-3.5);c=m.sign(3);d=m.sign(-3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Math.round.positive");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), -3), "Math.round.negative");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 1), "Math.sign.positive");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), -1), "Math.sign.negative");
    TestParseRunClean(e, realm, p);                                                           


    TestParseRun(e, &realm, &p, "m=Math;a=m.sin(0.1);b=m.sinh(0.2);c=m.tan(0.3);d=m.tanh(0.4);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), sin(0.1)), "Math.round.sin");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), sinh(0.2)), "Math.round.sinh");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), tan(0.3)), "Math.sign.tan");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), tanh(0.4)), "Math.sign.tanh");
    TestParseRunClean(e, realm, p);                                                               

    TestParseRun(e, &realm, &p, "a=Math.trunc(3.56);b=Math.trunc(-3.56);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Math.trunc.positive");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), -3), "Math.trunc.negative");
    TestParseRunClean(e, realm, p); 

    TestParseRun(e, &realm, &p, "v=[-2, -4, -5]; a=Math.max(...v, 0);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 0), "Math.max.Spread.#419");
    TestParseRunClean(e, realm, p); 

}


void StrObjTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    
    TestParseRun(e, &realm, &p, "o = String(5);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "5"), "String.call.value");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = new String('hi');");
    Val* v =  TestVal(e, realm, "o");
    ok(t, v->type == TYPE_OBJ, "String.new.type");
    Val* len = GetA(e, v, "length");
    ok(t, ValIsNumDel(e, len, 2), "String.new.length");
    ok(t, ValEqStrA(e, ObjectGetSlotRef(e, v->obj, _StringData_)->value, "hi"), "String.new.[[StringData]]");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = String.fromCharCode(65,66,67);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "ABC"), "String.fromCharCode");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = String.fromCodePoint(65,66,67);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "ABC"), "String.fromCodePoint");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = String.raw`Hi\\n${2+3}!`;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hi\\n5!"), "String.raw");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = String('hello'); i = o.charAt(2);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "l"), "String.prototype.charAt");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = String('ABC'); i = o.charCodeAt(0);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 65), "String.prototype.charCodeAt");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = String('ABC'); i = o.codePointAt(1);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 66), "String.prototype.codePointAt");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "o = String('h'); o = o.concat('el', 'lo');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "hello"), "String.prototype.concat");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.contains('ell');");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.contains.true");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.contains('elo');");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.contains.false");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.contains('ell', 1);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.contains.offset.true");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.contains('ell', 2);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.contains.offset.false");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.contains('ell', 9);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.contains.offset.outOfBounds");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.endsWith('ell');");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.endsWith.false");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.endsWith('ello');");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.endsWith.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.endsWith('ello',2);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.endsWith.bounds.false");
    TestParseRunClean(e, realm, p);                       

    // @todo - validate that the end position is NOT inclusive of the search
    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.endsWith('el',3);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.endsWith.bounds.true");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o='Hello world'.includes('orl');");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.includes.true");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o='Hello world'.includes('orlz');");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.includes.false");
    TestParseRunClean(e, realm, p);                       


    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.indexOf('ello');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 1), "String.prototype.indexOf.true");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.indexOf('elli');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), -1), "String.prototype.indexOf.false");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.indexOf('ello',1);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 1), "String.prototype.indexOf.bounds.true");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.indexOf('ello',2);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), -1), "String.prototype.indexOf.bounds.false");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.lastIndexOf('l');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 3), "String.prototype.lastIndexOf.true");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.lastIndexOf('k');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), -1), "String.prototype.lastIndexOf.false");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('hello'); o = o.lastIndexOf('l',4);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), -1), "String.prototype.lastIndexOf.bounds.false");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('abc'); o = o.localeCompare('abc');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 0), "String.prototype.lastIndexOf.localeCompare.eq");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('abc'); o = o.localeCompare('Abc');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 32), "String.prototype.lastIndexOf.localeCompare.gt");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('Abc'); o = o.localeCompare('abc');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), -32), "String.prototype.lastIndexOf.localeCompare.lt");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('Abc'); o = o.match('hello');");
    v = TestVal(e, realm, "o");
    ok(t, TRUE, "String.prototype.match.NOT_IMPL.@todo");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = String('Abc'); o = o.normalize('NFC');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Abc"), "String.prototype.normalize.NOT_IMPL.@todo");
    TestParseRunClean(e, realm, p);                       


    TestParseRun(e, &realm, &p, "o = 'Abc'.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "o"), 3), "String.literal.toObject.length");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = 'AB'.repeat(3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "ABABAB"), "String.prototype.repeat");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = 'Hello'.replace('el', 'oo');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hoolo"), "String.prototype.replace.simple");
    TestParseRunClean(e, realm, p);                       

    TestParseRun(e, &realm, &p, "o = 'Hello'.replace('el', '$$');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "H$lo"), "String.prototype.replace.$");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "o = 'Hello'.replace('el', '$`');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "HHlo"), "String.prototype.replace.$`");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "o = 'Hello'.replace('el', '$\');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hlo"), "String.prototype.replace.$'");
    TestParseRunClean(e, realm, p);                           

    TestParseRun(e, &realm, &p, "o = 'Hello'.slice(1,3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "el"), "String.prototype.slice.1.3'");
    TestParseRunClean(e, realm, p);                               

    TestParseRun(e, &realm, &p, "o = 'Hello'.slice(-1,3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), ""), "String.prototype.slice.-1.3'");
    TestParseRunClean(e, realm, p);                               

    TestParseRun(e, &realm, &p, "o = 'Hello'.slice(-1);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "o"), "String.prototype.slice.-1");
    TestParseRunClean(e, realm, p);                                   

    TestParseRun(e, &realm, &p, "o = 'Hello'.slice(-3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "llo"), "String.prototype.slice.-3");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = '1,2,3'.split(',');");
    v = TestVal(e, realm, "o");
    ok(t, ValIsNumDel(e, GetA(e, v, "length"), 3), "String.prototype.split.length");
    ok(t, ValIsStrADel(e, GetA(e, v, "0"), "1"), "String.prototype.split.0");
    ok(t, ValIsStrADel(e, GetA(e, v, "1"), "2"), "String.prototype.split.1");
    ok(t, ValIsStrADel(e, GetA(e, v, "2"), "3"), "String.prototype.split.2");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);    


    TestParseRun(e, &realm, &p, "o = 'Hello'.startsWith('He');");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.startsWith.true");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.startsWith('ell');");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.startsWith.false");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.startsWith('ell', 1);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.startsWith.position.true");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.startsWith('ell', 2);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.startsWith.position.false");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.startsWith('Hello World');");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "o")), "String.prototype.startsWith.bounds");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.substring(3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "lo"), "String.prototype.substring.start");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.substring(1,3);");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "el"), "String.prototype.substring.start.end");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.toLocaleLowerCase();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "hello"), "String.prototype.toLocaleLowerCase");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.toLowerCase();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "hello"), "String.prototype.toLowerCase");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.toUpperCase();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "HELLO"), "String.prototype.toUpperCase");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = 'Hello'.toLocaleUpperCase();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "HELLO"), "String.prototype.toLocaleUpperCase");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = 'Hello'.toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello"), "String.prototype.toString");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = 'Hello'.trim();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello"), "String.prototype.trim.NoSpaces");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = 'Hello World'.trim();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello World"), "String.prototype.trim.Spaces");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = '  Hello World'.trim();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello World"), "String.prototype.trim.Spaces.Leading");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = 'Hello World   '.trim();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello World"), "String.prototype.trim.Spaces.Trailing");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = '   Hello World   '.trim();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello World"), "String.prototype.trim.Spaces.Both");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = 'Hello'.valueOf();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "o"), "Hello"), "String.prototype.valueOf");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "o = 'ABC'; m = ''; for(let k of o) m += k;");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "m"), "ABC"), "String.iterator");
    TestParseRunClean(e, realm, p);    

}




void ArrayObjTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    

    TestParseRun(e, &realm, &p, "o = Array(); l = o.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 0), "Array.call.empty.length");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = new Array(); l = o.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 0), "Array.new.empty.length");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = Array(3); l = o.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 3), "Array.call.len.length");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = new Array(3); l = o.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 3), "Array.new.len.length");
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "o = new Array('x'); l = o.length; i  = o[0]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 1), "Array.new.nonNum.length");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "x"), "Array.new.nonNum.item.0");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "o = new Array(1,2,3); l = o.length; i  = o[2]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 3), "Array.new.many.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 3), "Array.new.many.item.2");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "A = Array.from('ABC'); a = A[0]; b = A[1]; c = A[2]");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "a"), "A"), "Array.from.simple.a");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "b"), "B"), "Array.from.simple.b");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "c"), "C"), "Array.from.simple.c");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "A = Array.from([1,2], function(x) { return x + x; }); a = A[0]; b = A[1];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 2), "Array.from.mapfn.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 4), "Array.from.mapfn.b");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "b = Array.isArray([1,2]);");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "b")), "Array.isArray.true");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "b = Array.isArray('hello');");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "b")), "Array.isArray.false");
    TestParseRunClean(e, realm, p);    


    TestParseRun(e, &realm, &p, "A = Array.of(1,2,3); a = A[0]; b = A[1]; c = A[2]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Array.of.a");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.of.b");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.of.c");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "A=[1,2]; A=A.concat([3,4]);a = A[0]; b = A[1]; c = A[2]; d = A[3];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Array..prototypeconcat.Array.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array..prototypeconcat.Array.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array..prototypeconcat.Array.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Array..prototypeconcat.Array.3");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A=[1,2]; A=A.concat(3,4);a = A[0]; b = A[1]; c = A[2]; d = A[3];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Array..prototypeconcat.Args.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array..prototypeconcat.Args.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array..prototypeconcat.Args.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Array..prototypeconcat.Args.3");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A=[1, 2, 3, 4, 5].copyWithin(0, 3);a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Array.prototype.copyWithin.start.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Array.prototype.copyWithin.start.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.prototype.copyWithin.start.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Array.prototype.copyWithin.start.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Array.prototype.copyWithin.start.4");    
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A=[1, 2, 3, 4, 5].copyWithin(0, 3, 4);;a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Array.copyWithin.start.end.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.copyWithin.start.end.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.prototype.copyWithin.start..end.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Array.prototype.copyWithin.start.end.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Array.prototype.copyWithin.start..end.4");    
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "A=[1, 2, 3, 4, 5].copyWithin(0, -2, -1);a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Array.prototype.copyWithin.start.end.negative.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.copyWithin.start.end.negative.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.prototype.copyWithin.start..end.negative.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Array.prototype.copyWithin.start.end.negative.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Array.prototype.copyWithin.start..end.negative.4");    
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "i=['X', 'Y'].entries(); a = i.next().value[0]; b = i.next().value[1];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 0), "Array.entries.next.value.0");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "b"), "Y"), "Array.prototype.entries.next.value.1");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=[3, 4].every(function(a) { return a > 3 });");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Array.prototype.every.false");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=[3, 4].every(function(a) { return a > 2 });");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Array.prototype.every.true");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=[3, 4,5].fill(0); a=i[0]; b=i[1]; c=i[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),0), "Array.prototype.fill.all.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),0), "Array.prototype.fill.all.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),0), "Array.prototype.fill.all.2");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "i=[3, 4,5].fill(0,1,2); a=i[0]; b=i[1]; c=i[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),3), "Array.prototype.fill.partial.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),0), "Array.prototype.fill.partial.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),5), "Array.prototype.fill.partial.2");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "i=[3, 4,5].filter(function(a) { return a > 3}); a=i[0]; b=i[1]; c=i.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),4), "Array.prototype.filter.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),5), "Array.prototype.filter.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),2), "Array.prototype.filter.length");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "i=[4,5].find(function(a) { return a == 3;});");
    Val* v = TestVal(e, realm, "i");
    ok(t, ValIsUndef(v), "Array.prototype.find.false");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "i=[4,3,5].find(function(a) { return a == 3;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),3), "Array.prototype.find.true");
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "i=[4,3,5].findIndex(function(a) { return a == 3;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),1), "Array.prototype.findIndex.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=[4,5].findIndex(function(a) { return a == 3;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),-1), "Array.prototype.findIndex.false");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "x=0; i=[3, 4,5].forEach(function(a) { x += a;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),3+4+5), "Array.prototype.forEach");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "i=[4,3,5].indexOf(3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),1), "Array.prototype.indexOf.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=[4,3,5].indexOf(6);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),-1), "Array.prototype.indexOf.false");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "s=[4,3,5].join();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"),"4,3,5"), "Array.prototype.join.default");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "s=[4,3,5].join('**');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"),"4**3**5"), "Array.prototype.join.custom");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "i=['X', 'Y'].keys(); a = i.next().value; b = i.next().value;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 0), "Array.prototype.keys.next.value.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 1), "Array.prototype.keys.next.value.1");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=[4,3,5,3,6].lastIndexOf(3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),3), "Array.prototype.lastIndexOf.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=[4,3,5].lastIndexOf(6);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),-1), "Array.prototype.lastIndexOf.false");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=[3, 4,5].map(function(a) { return a*2;}); a=i[0]; b=i[1]; c=i[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),6), "Array.prototype.map.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),8), "Array.prototype.map.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),10), "Array.prototype.map.2");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "i=[].pop();");
    v = TestVal(e, realm, "i");
    ok(t, ValIsUndef(v), "Array.prototype.pop.empty");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "i=[1,2,3]; k = i.pop();x=i.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 3), "Array.prototype.pop.element");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 2), "Array.prototype.pop.length");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "i=[1,2,3]; k = i.push(4,5);x=i[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"), 5), "Array.prototype.push");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = [1, 2, 3].reduce(function(p, c, i, a) { return p + c; });");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 6), "Array.prototype.reduce");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = [1, 2, 3].reduceRight(function(p, c, i, a) { return p + c; });");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 6), "Array.prototype.reduceRight");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = [1, 2, 3].reverse(); a=k[0]; b=k[1];c=k[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Array.prototype.reverse.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.reverse.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 1), "Array.prototype.reverse.2");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = [1, 2, 3]; a = k.shift(); b=k[0]; c=k[1];l=k.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Array.prototype.shift.value");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.shift.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.prototype.shift.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 2), "Array.prototype.shift.length");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k=[1,2,3,4,5].slice(1,3); a=k[0]; b=k[1]; l=k.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 2), "Array.prototype.slice.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 3), "Array.prototype.slice.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 2), "Array.prototype.slice.length");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "i=[3, 4, 5].some(function(a) { return a > 3 });");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Array.prototype.some.true");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=[3, 4, 5].some(function(a) { return a < 2 });");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Array.prototype.some.false");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=[5, 3, 9].sort(); a=i[0];b=i[1];c=i[2]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Array.prototype.sort.std.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Array.prototype.sort.std.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 9), "Array.prototype.sort.std.2");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "i=[{v:5}, {v:3}, {v:9}].sort(function(x,y) { if(x.v > y.v) return 1; else if(x.v < y.v) return -1; else return 0}); a=i[0].v;b=i[1].v;c=i[2].v");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Array.prototype.sort.custom.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Array.prototype.sort.custom.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 9), "Array.prototype.sort.custom.2");
    TestParseRunClean(e, realm, p);                                    

    TestParseRun(e, &realm, &p, "i=[0, 1, 3]; r=i.splice(2,0,2);a=r.length;b=i[2];c=i[3];d=i.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 0), "Array.prototype.splice.simple.removed.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.splice.simple.inserted.value.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.prototype.splice.simple.inserted.value.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Array.prototype.splice.length");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "i=[0, 1, 3]; r=i.splice(2,1,2);a=r[0];b=i[2];c=i.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Array.prototype.splice.removed.value");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.splice.inserted.value.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Array.prototype.splice.length");
    TestParseRunClean(e, realm, p);                                    

    TestParseRun(e, &realm, &p, "i=[0, 1, 3].toLocaleString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "0,1,3"), "Array.prototype.toLocaleString");
    TestParseRunClean(e, realm, p);                                        

    TestParseRun(e, &realm, &p, "i=[0, 1, 3].toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "0,1,3"), "Array.prototype.toString");
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "k = [1, 2, 3]; a = k.unshift(0); b=k[0]; c=k[1];l=k.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Array.prototype.unshift.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 0), "Array.prototype.unshift.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 1), "Array.prototype.unshift.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 4), "Array.prototype.unshift.length");
    TestParseRunClean(e, realm, p); 

    TestParseRun(e, &realm, &p, "i=[1, 2].values(); a = i.next().value; b = i.next().value;");
    v =  TestVal(e, realm, "a");
    ok(t, ValIsNumDel(e,v, 1), "Array.prototype.entries.values.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Array.prototype.entries.value.1");
    TestParseRunClean(e, realm, p);        

}

void TypedArrayConsTest(test* t) {
    Realm* realm;
    Parser* p;    
    Js* e = t->js;

    TestParseRun(e, &realm, &p, "o = new Int8Array(3); l = o.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 3), "Int8Array.new.number.length");
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "A= new Int8Array([1, 2, 3, 4, 5]);a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Int8Array.new.Array.start.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.new.Array.start.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Int8Array.new.Array.start.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Int8Array.new.Array.start.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Int8Array.new.Array.start.4");    
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A= Int8Array.from([1, 2, 3, 4, 5]);a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Int8Array.from.Array.start.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.from.Array.start.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Int8Array.from.Array.start.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Int8Array.from.Array.start.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Int8Array.from.Array.start.4");    
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A=Int8Array.from([1, 2, 3, 4, 5]).copyWithin(0, 3);a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Int8Array.prototype.copyWithin.start.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Int8Array.prototype.copyWithin.start.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Int8Array.prototype.copyWithin.start.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Int8Array.prototype.copyWithin.start.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Int8Array.prototype.copyWithin.start.4");    
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A=Int8Array.from([1, 2, 3, 4, 5]).copyWithin(0, 3, 4);;a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Int8Array.copyWithin.start.end.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.prototype.copyWithin.start.end.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Int8Array.prototype.copyWithin.start..end.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Int8Array.prototype.copyWithin.start.end.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Int8Array.prototype.copyWithin.start..end.4");    
    TestParseRunClean(e, realm, p);        


    TestParseRun(e, &realm, &p, "A=Int8Array.from([1, 2, 3, 4, 5]).copyWithin(0, -2, -1);a = A[0]; b = A[1]; c = A[2]; d = A[3];e = A[4];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Int8Array.prototype.copyWithin.start.end.negative.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.prototype.copyWithin.start.end.negative.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 3), "Int8Array.prototype.copyWithin.start..end.negative.2");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "d"), 4), "Int8Array.prototype.copyWithin.start.end.negative.3");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "e"), 5), "Int8Array.prototype.copyWithin.start..end.negative.4");    
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "A= Int8Array.from([1, 2]); i = A.entries();  a = i.next().value[1]; b = i.next().value[1];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 1), "Int8Array.prototype.entries.next.value.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.prototype.entries.next.value.1");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4]).every(function(a) { return a > 3 });");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Int8Array.prototype.every.false");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4]).every(function(a) { return a > 2 });");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Int8Array.prototype.every.true");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4,5]).fill(0); a=i[0]; b=i[1]; c=i[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),0), "Int8Array.prototype.fill.all.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),0), "Int8Array.prototype.fill.all.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),0), "Int8Array.prototype.fill.all.2");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4,5]).fill(0,1,2); a=i[0]; b=i[1]; c=i[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),3), "Int8Array.prototype.fill.partial.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),0), "Int8Array.prototype.fill.partial.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),5), "Int8Array.prototype.fill.partial.2");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4,5]).filter(function(a) { return a > 3}); a=i[0]; b=i[1]; c=i.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),4), "Int8Array.prototype.filter.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),5), "Int8Array.prototype.filter.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),2), "Int8Array.prototype.filter.length");
    TestParseRunClean(e, realm, p);    

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,5]).find(function(a) { return a == 3;});");
    Val* v = TestVal(e, realm, "i");
    ok(t, ValIsUndef(v), "Int8Array.prototype.find.false");
    ValDel(e, v);
    TestParseRunClean(e, realm, p);                    

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,3,5]).find(function(a) { return a == 3;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),3), "Int8Array.prototype.find.true");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,3,5]).findIndex(function(a) { return a == 3;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),1), "Int8Array.prototype.findIndex.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,5]).findIndex(function(a) { return a == 3;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),-1), "Int8Array.prototype.findIndex.false");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "x=0; i=Int8Array.from([3, 4,5]).forEach(function(a) { x += a;});");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "x"),3+4+5), "Int8Array.prototype.forEach");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,3,5]).indexOf(3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),1), "Int8Array.prototype.indexOf.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,3,5]).indexOf(6);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),-1), "Int8Array.prototype.indexOf.false");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "s=Int8Array.from([4,3,5]).join();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"),"4,3,5"), "Int8Array.prototype.join.default");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "s=Int8Array.from([4,3,5]).join('**');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"),"4**3**5"), "Int8Array.prototype.join.custom");
    TestParseRunClean(e, realm, p);          

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4]).keys(); a = i.next().value; b = i.next().value;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 0), "Int8Array.prototype.keys.next.value.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 1), "Int8Array.prototype.keys.next.value.1");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,3,5,3,6]).lastIndexOf(3);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),3), "Int8Array.prototype.lastIndexOf.true");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([4,3,5]).lastIndexOf(6);");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"),-1), "Int8Array.prototype.lastIndexOf.false");
    TestParseRunClean(e, realm, p);                        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4,5]).map(function(a) { return a*2;}); a=i[0]; b=i[1]; c=i[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"),6), "Int8Array.prototype.map.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"),8), "Int8Array.prototype.map.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"),10), "Int8Array.prototype.map.2");
    TestParseRunClean(e, realm, p);                            

    TestParseRun(e, &realm, &p, "k = Int8Array.from([1, 2, 3]).reduce(function(p, c, i, a) { return p + c; });");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 6), "Int8Array.prototype.reduce");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = Int8Array.from([1, 2, 3]).reduceRight(function(p, c, i, a) { return p + c; });");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "k"), 6), "Int8Array.prototype.reduceRight");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = Int8Array.from([1, 2, 3]).reverse(); a=k[0]; b=k[1];c=k[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Int8Array.prototype.reverse.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.prototype.reverse.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 1), "Int8Array.prototype.reverse.2");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k = Int8Array.from([1, 2, 3]); k.set([4,5,6]); a=k[0]; b=k[1];c=k[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Int8Array.prototype.set.Array.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Int8Array.prototype.set.Array.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 6), "Int8Array.prototype.set.Array.2");
    TestParseRunClean(e, realm, p);                                


    TestParseRun(e, &realm, &p, "k = Int8Array.from([1, 2, 3]); k.set(Int8Array.from([4,5,6])); a=k[0]; b=k[1];c=k[2];");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 4), "Int8Array.prototype.set.TypedArray.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Int8Array.prototype.set.TypedArray.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 6), "Int8Array.prototype.set.TypedArray.2");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "k=Int8Array.from([1,2,3,4,5]).slice(1,3); a=k[0]; b=k[1]; l=k.length;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 2), "Int8Array.prototype.slice.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 3), "Int8Array.prototype.slice.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 2), "Int8Array.prototype.slice.length");
    TestParseRunClean(e, realm, p);                                


    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4, 5]).some(function(a) { return a > 3 });");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "Int8Array.prototype.some.true");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([3, 4, 5]).some(function(a) { return a < 2 });");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "i")), "Int8Array.prototype.some.false");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([5, 3, 9]).sort(); a=i[0];b=i[1];c=i[2]");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Int8Array.prototype.sort.std.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 5), "Int8Array.prototype.sort.std.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 9), "Int8Array.prototype.sort.std.2");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "i=Int8Array.from([5, 3, 9]).subarray(1,3); a=i[0];b=i[1];c=i.length");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "a"), 3), "Int8Array.prototype.subarray.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 9), "Int8Array.prototype.subarray.1");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 2), "Int8Array.prototype.subarray.2");
    TestParseRunClean(e, realm, p);                                

    TestParseRun(e, &realm, &p, "i=Int8Array.from([0, 1, 3]).toLocaleString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "0,1,3"), "Int8Array.prototype.toLocaleString");
    TestParseRunClean(e, realm, p);                                        

    TestParseRun(e, &realm, &p, "i=Int8Array.from([0, 1, 3]).toString();");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "i"), "0,1,3"), "Int8Array.prototype.toString");
    TestParseRunClean(e, realm, p);               

    TestParseRun(e, &realm, &p, "i=Int8Array.from([1, 2]).values(); a = i.next().value; b = i.next().value;");
    v =  TestVal(e, realm, "a");
    ok(t, ValIsNumDel(e,v, 1), "Int8Array.prototype.entries.values.0");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "b"), 2), "Int8Array.prototype.entries.value.1");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int8Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 1), "Int8Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);        
    TestParseRun(e, &realm, &p, "i=Uint8Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 1), "Uint8Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);        
    TestParseRun(e, &realm, &p, "i=Uint8ClampedArray.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 1), "Uint8ClampedArray.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "i=Int16Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 2), "Int16Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);        
    TestParseRun(e, &realm, &p, "i=Uint16Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 2), "Uint16Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "i=Int32Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 4), "Int32Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);        
    TestParseRun(e, &realm, &p, "i=Uint32Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 4), "Uint32Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);      

    TestParseRun(e, &realm, &p, "i=Float32Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 4), "Float32Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);        
    TestParseRun(e, &realm, &p, "i=Float64Array.BYTES_PER_ELEMENT");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "i"), 8), "Float64Array.BYTES_PER_ELEMENT");
    TestParseRunClean(e, realm, p);      

    // #521 IntegerIndexedOwnPropertyKeys test
    TestParseRun(e, &realm, &p, "i=Object.getOwnPropertyNames(Int8Array.from([3, 4, 5])); a=i[0];b=i[1];c=i[2];");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "a"), "0"), "IntegerIndexedOwnPropertyKeys.value.0");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "b"), "1"), "IntegerIndexedOwnPropertyKeys.value.1");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "c"), "2"), "IntegerIndexedOwnPropertyKeys.value.2");    
    TestParseRunClean(e, realm, p);        

}

void ArrayBufferConsTest(test* t) {
    Realm* realm;
    Parser* p;    
    Js* e = t->js;

    TestParseRun(e, &realm, &p, "o = new ArrayBuffer(10); l = ArrayBuffer.isView(o);");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "l")), "ArrayBuffer.isBuffer.false");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "o = new ArrayBuffer(10); l = o.byteLength;");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 10), "ArrayBuffer.prototype.byteLength");
    TestParseRunClean(e, realm, p);            


    TestParseRun(e, &realm, &p, "a = new ArrayBuffer(10); b = a.slice(2,4); c = b.byteLength");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "c"), 2), "ArrayBuffer.prototype.slice");
    TestParseRunClean(e, realm, p);            

}

void RegExpTestResI(test* t, Js* e, Parser* p, Realm* realm, char* cmd, int index, char* res, char* cmt) {
    char buffer[2048];
    sprintf(buffer, "s=%s", cmd);
    TestParseRun(e, &realm, &p, buffer);
    Val* s = TestVal(e, realm, "s");
    char ins[255];
    sprintf(ins, "%d", index);
    ok(t, ValIsStrADel(e, GetA(e, s, ins), res), cmt);
    ValDel(e, s);
    TestParseRunClean(e, realm, p);    
}

void RegExpTestRes(test* t, Js* e, Parser* p, Realm* realm, char* cmd, char* res0, char* cmt) {
    char buffer[2048];
    sprintf(buffer, "s=%s", cmd);
    TestParseRun(e, &realm, &p, buffer);
    Val* s = TestVal(e, realm, "s");
    ok(t, ValIsStrADel(e, GetA(e, s, "0"), res0), cmt);
    ValDel(e, s);
    TestParseRunClean(e, realm, p);    
}

void RegExpTestRes2(test* t, Js* e, Parser* p, Realm* realm, char* cmd, char* res0, char* res1, char* cmt) {
    char buffer[2048];
    sprintf(buffer, "s=%s", cmd);
    TestParseRun(e, &realm, &p, buffer);
    Val* s = TestVal(e, realm, "s");
    ok(t, ValIsStrADel(e, GetA(e, s, "0"), res0), cmt);
    ok(t, ValIsStrADel(e, GetA(e, s, "1"), res1), cmt);
    ValDel(e, s);
    TestParseRunClean(e, realm, p);   
}

void RegExpTest(test* t) {
    Realm* realm;
    Parser* p;    
    Js* e = t->js;
    Val* s;

    TestParseRun(e, &realm, &p, "re=/;/i; s=re.exec('one; two');");
    s = TestVal(e, realm, "s");
    ok(t, ValIsStrADel(e, GetA(e, s, "0"), ";"), "RegExp.pprototype.exec.0");
    ok(t, ValIsNumDel(e, GetA(e, s, "index"), 3), "RegExp.pprototype.exec.index");
    ok(t, ValIsStrADel(e, GetA(e, s, "input"), "one; two"), "RegExp.pprototype.exec.input");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "x = /hello/gim; i=x.ignoreCase; m=x.multiline; g=x.global; u=x.unicode;f=x.flags;");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "g")), "RegExp.prototype.global");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "i")), "RegExp.prototype.ignoreCase");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "m")), "RegExp.prototype.multiline");
    ok(t, !ValIsTrueDel(e, TestVal(e, realm, "u")), "RegExp.prototype.unicode");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "f"), "gim"), "RegExp.prototype.flags");
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "x = /hello/gim; i=x.ignoreCase; s = x.source; k = x.toString(); l=x.lastIndex");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "hello"), "RegExp.prototype.source");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "k"), "/hello/gim"), "RegExp.prototype.toString");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 0), "RegExp.prototype.lastIndex");
    TestParseRunClean(e, realm, p);                

    TestParseRun(e, &realm, &p, "x = /[hello/gim;");
    ok(t, p->root == 0, "RegExp.Parse.Error");
    TestParseRunClean(e, realm, p);            


    TestParseRun(e, &realm, &p, "re=/hello/g;\nres = re.exec('Hello');");   
    Val* res = TestVal(e, realm, "res");
    ok(t, p->root != 0, "RegExp.prototype.exec.null.parse");
    ok(t, ValIsNull(res), "RegExp..prototype.exec.null");
    ValDel(e, res);
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "re=/hello/gi;\nres = re.exec('Hello');");   
    res = TestVal(e, realm, "res");
    ok(t, p->root != 0, "RegExp.Exec.const.exec.Parse");
    ok(t, ValIsStrADel(e, GetA(e, res, "0"), "Hello"), "RegExp.prototype.exec.ignoreCase.[0]");
    ok(t, ValIsNumDel(e, GetA(e, res, "length"), 1), "RegExp.prototype.exec.ignoreCase.length");
    ok(t, ValIsStrADel(e, GetA(e, res, "input"), "Hello"), "RegExp.prototype.exec.ignoreCase.input");
    ValDel(e, res); 
    TestParseRunClean(e, realm, p);            

    TestParseRun(e, &realm, &p, "r=/abc/i;\nx=r.exec('do you know abc?');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.exec.simple");
    TestParseRunClean(e, realm, p);
 
    TestParseRun(e, &realm, &p, "x=/abc/i.exec('do you know abc?');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.exec.chained");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/ab*c/.exec('hello abbbc');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.exec.*");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/a\\*c/.exec('hello abbbc');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.noescape.*");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/a\\*c/.exec('hello a*c');");
    res = TestVal(e, realm, "x");
    ok(t, ValIsStrADel(e, GetA(e, res, "0"), "a*c"), "RegExp.literal.escape.*.0");
    ok(t, ValIsNumDel(e, GetA(e, res, "index"), 6), "RegExp.literal.escape.*.index");
    ValDel(e, res);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/^A/.exec('test Apple');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.^.nomatch");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/^A/.exec('Apple');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.^.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/t$/.exec('test Apple');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.$.nomatch");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/t$/.exec('Apple test');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.$.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/to*/.exec('cap');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.*.nomatch");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/to*/.exec('tap');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.*.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "n=/to+/i.exec('tap'); y=/to+/i.exec('top');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "n")), "RegExp.literal.+.nomatch");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "y")), "RegExp.literal.+.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "n=/hi?m/.exec('hiim'); y=/hi?m/.exec('hm');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "n")), "RegExp.literal.?.nomatch");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "y")), "RegExp.literal.?.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "n=/.h/.exec('hello'); y=/.h/.exec('oh hm');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "n")), "RegExp.literal.dot.nomatch");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "y")), "RegExp.literal.dot.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "n=/(foo) \\1/.exec('foo'); y=/(foo) \\1/.exec('foo foo');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "n")), "RegExp.literal.captures.nomatch");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "y")), "RegExp.literal.captures.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "n=/foo|bar/.exec('baz'); y=/foo|bar/.exec('fab bar');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "n")), "RegExp.literal.or.nomatch");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "y")), "RegExp.literal.or.match");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/a(b+)c/i.exec('abbc');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.captures.ignoreCase");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/ab/i.exec('ab');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.simple.ignoreCase");
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "re=/ab/gi; x=re.exec('abcd');l = re.lastIndex");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "l"), 2), "RegExp.prototype.exec.lastIndex");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "re=/(\\w+)\\s(\\w+)/i; s='one two'.replace(re, '$2, $1');");
    ok(t, ValIsStrADel(e, TestVal(e, realm, "s"), "two, one"), "RegExp.prototype.replace");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "re=/\\w+\\s/gi; s='one two three four'.match(re);");
    s = TestVal(e, realm, "s");
    ok(t, ValIsNumDel(e, GetA(e, s, "length"), 3), "RegExp.pprototype.match.length");
    ok(t, ValIsStrADel(e, GetA(e, s, "0"), "one "), "RegExp.pprototype.match.result.0");
    ok(t, ValIsStrADel(e, GetA(e, s, "1"), "two "), "RegExp.pprototype.match.result.1");
    ok(t, ValIsStrADel(e, GetA(e, s, "2"), "three "), "RegExp.pprototype.match.result.2");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "re=/\\s*;\\s*/i; s='one; two; three; four'.split(re);");
    s = TestVal(e, realm, "s");
    ok(t, ValIsNumDel(e, GetA(e, s, "length"), 4), "RegExp.pprototype.split.length");
    ok(t, ValIsStrADel(e, GetA(e, s, "0"), "one"), "RegExp.pprototype.split.result.0");
    ok(t, ValIsStrADel(e, GetA(e, s, "1"), "two"), "RegExp.pprototype.split.result.1");
    ok(t, ValIsStrADel(e, GetA(e, s, "2"), "three"), "RegExp.pprototype.split.result.2");
    ok(t, ValIsStrADel(e, GetA(e, s, "3"), "four"), "RegExp.pprototype.split.result.3");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "x=/ab/.exec('ab');");
    ok(t, !ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.literal.simple.regwnexec.REG_ICASE");
    TestParseRunClean(e, realm, p);


    RegExpTestRes(t, e, p, realm, "/a|b/.exec('abc');", "a", "RegExp.21.2.2.3 Disjunction");  
    RegExpTestRes(t, e, p, realm, "/a[a-z]{2,4}/.exec('abcdefghi')", "abcde", "RegExp.21.2.2.5.1__1");  
    RegExpTestRes(t, e, p, realm, "/a[a-z]{2,4}?/.exec('abcdefghi')", "abc", "RegExp.21.2.2.5.1__2");  
    RegExpTestRes(t, e, p, realm, "/(aa|aabaac|ba|b|c)*/.exec('aabaac')", "aaba", "RegExp.21.2.2.5.1__3");  
    RegExpTestRes(t, e, p, realm, "/(z)((a+)?(b+)?(c))*/.exec('zaacbbbcac')", "zaacbbbcac", "RegExp.21.2.2.5.1__4");  
    RegExpTestRes(t, e, p, realm, "/(a*)*/.exec('b')", "", "RegExp.21.2.2.5.1__5");  
    RegExpTestRes(t, e, p, realm, "/(a*)b\\1+/.exec('baaaac')", "b", "RegExp.21.2.2.5.1__6");  
    RegExpTestRes2(t, e, p, realm, "/(?=(a+))/.exec('baaabac')", "", "aaa", "RegExp.21.2.2.8.2__1");  
    RegExpTestRes2(t, e, p, realm, "/(?=(a+))a*b\\1/.exec('baaabac')", "aba", "a", "RegExp.21.2.2.8.2__2");  

    RegExpTestRes(t, e, p, realm, "/A(?!foo)/.exec('AB');", "A", "RegExp.NegativeLookahead.Match");  
    TestParseRun(e, &realm, &p, "x=/A(?!foo)/.exec('Afoo');");
    ok(t, ValIsNullDel(e, TestVal(e, realm, "x")), "RegExp.NegativeLookahead.NoMatch");
    TestParseRunClean(e, realm, p);

    RegExpTestResI(t, e, p, realm, "/(.*?)a(?!(a+)b\\2c)/.exec('baaabaac')", 0, "baa", "RegExp.NegativeLookahead.Capture.Match__1");  
    RegExpTestResI(t, e, p, realm, "/(.*?)a(?!(a+)b\\2c)/.exec('baaabaac')", 1, "ba", "RegExp.NegativeLookahead.Capture.Match__2");  

    RegExpTestResI(t, e, p, realm, "/(.*?)a(?!(a+)b\\2c)\\2(.*)/.exec('baaabaac')", 0, "baaabaac", "RegExp.21.2.2.8.2__3");  
    RegExpTestResI(t, e, p, realm, "/(.*?)a(?!(a+)b\\2c)\\2(.*)/.exec('baaabaac')", 1, "ba", "RegExp.21.2.2.8.2__4");  
    RegExpTestResI(t, e, p, realm, "/(.*?)a(?!(a+)b\\2c)\\2(.*)/.exec('baaabaac')", 3, "abaac", "RegExp.21.2.2.8.2__5");  
//  

}

void Utf8Test(test* t) {
    Js* e = t->js;
    Val* s = Utf8Decode(e, (uint8*) "hello");
    ok(t, !ValIsAbrupt(e, s), "Utf8.decode.8.return.type");
    ok(t, ValIsStrADel(e, s, "hello"), "Utf8.decode.8.return.value");
    
    s = Utf8Decode(e, (uint8*) "hel\xc2\xa2lo");
    ok(t, !ValIsAbrupt(e, s), "Utf8.decode.16.from.2.return.type");
    ok(t, s->str->length == 6, "Utf8.decode.16.from.2.return.length");
    ok(t, s->str->chars[0] == 'h', "Utf8.decode.16.from.2.return.0");
    ok(t, s->str->chars[1] == 'e', "Utf8.decode.16.from.2.return.1");
    ok(t, s->str->chars[2] == 'l', "Utf8.decode.16.from.2.return.2");
    ok(t, s->str->chars[3] == 0xA2, "Utf8.decode.16.from.2.return.3");
    ok(t, s->str->chars[4] == 'l', "Utf8.decode.16.from.2.return.4");
    ok(t, s->str->chars[5] == 'o', "Utf8.decode.16.from.2.return.5");
    ValDel(e, s);


    s = Utf8Decode(e, (uint8*) "hel\xe2\x82\xaclo");
    ok(t, !ValIsAbrupt(e, s), "Utf8.decode.16.from.3.return.type");
    ok(t, s->str->length == 6, "Utf8.decode.16.from.3.return.length");
    ok(t, s->str->chars[0] == 'h', "Utf8.decode.16.from.3.return.0");
    ok(t, s->str->chars[1] == 'e', "Utf8.decode.16.from.3.return.1");
    ok(t, s->str->chars[2] == 'l', "Utf8.decode.16.from.3.return.2");
    ok(t, s->str->chars[3] == 0x20AC, "Utf8.decode.16.from.3.return.3");
    ok(t, s->str->chars[4] == 'l', "Utf8.decode.16.from.3.return.4");
    ok(t, s->str->chars[5] == 'o', "Utf8.decode.16.from.3.return.5");
    ValDel(e, s);

    s = Utf8Decode(e, (uint8*) "hel\xf0\x90\x8d\x88lo");
    ok(t, !ValIsAbrupt(e, s), "Utf8.decode.16.from.4.return.type");
    ok(t, s->str->length == 7, "Utf8.decode.16.from.4.return.length");
    ok(t, s->str->chars[0] == 'h', "Utf8.decode.16.from.4.return.0");
    ok(t, s->str->chars[1] == 'e', "Utf8.decode.16.from.4.return.1");
    ok(t, s->str->chars[2] == 'l', "Utf8.decode.16.from.4.return.2");

    uchar c1 = s->str->chars[3];
    uchar c2 = s->str->chars[4];
    uint32 cp = Utf16Decode(c1, c2);

    ok(t, cp == 0x10348, "Utf8.decode.16.from.4.return.encoded");

    ok(t, s->str->chars[5] == 'l', "Utf8.decode.16.from.3.return.5");
    ok(t, s->str->chars[6] == 'o', "Utf8.decode.16.from.3.return.6");
    ValDel(e, s);    

}

void MethodParseTest(test* t) {
    Js* e = t->js;
    Parser* p = ParserNew(e); 
    Val* v = ParseA(p, "o = { foo(a, b) { return a*b } };", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.MethodDefinition.Standard");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "o = { foo(a, b) { let a = 9; return a*b } };", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.MethodDefinition.EarlyErrors");
    ValDel(e, v);
    ParserDel(p);


    p = ParserNew(e); 
    v = ParseA(p, "'use strict'; o = { get foo() { return 9; } };", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.MethodDefinition.get");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "'use strict'; o = { set foo(a) { return o = a; } };", 0);
    ok(t, !ValIsAbrupt(e, v), "Parser.MethodDefinition.set");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "'use strict'; o = { set foo(a, a) { return o = a; } };", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.MethodDefinition.set.EarlyErrors.duplicateParam");
    ValDel(e, v);
    ParserDel(p);

    p = ParserNew(e); 
    v = ParseA(p, "'use strict'; o = { set foo(a) { let a = 7; return o = a; } };", 0);
    ok(t, ValIsAbrupt(e, v), "Parser.MethodDefinition.set.EarlyErrors");
    ValDel(e, v);
    ParserDel(p);

}


void TagsTest(test* t) {
    Js* e = t->js;
    Realm* realm;
    Parser* p;    

    e->options.genTags = TRUE;
    TestParseRun(e, &realm, &p, "o = 1;");
    ok(t, e->ctags == 0, "Tags.Empty");
    TestParseRunClean(e, realm, p);        

    TestParseRun(e, &realm, &p, "function x() { return 1};");
    ok(t, e->ctags != 0, "Tags.function.root");
    ok(t, e->ctags->next == 0, "Tags.function.root.next");
    ok(t, StrEqChars(e, e->ctags->name, "x"), "Tags.function.name");    
    ok(t, StrEqChars(e, e->ctags->grep, "function x"), "Tags.function.grep");
    TestParseRunClean(e, realm, p);        
    CtagsDel(e);
    ok(t, e->ctags == 0, "Tags.delete.empty");

    TestParseRun(e, &realm, &p, "function x() { return 1}; function a() { }");
    ok(t, StrEqChars(e, e->ctags->name, "a"), "Tags.sort.name.1");    
    ok(t, StrEqChars(e, e->ctags->next->name, "x"), "Tags.sort.name.2");    
    TestParseRunClean(e, realm, p);        
    CtagsDel(e);

    TestParseRun(e, &realm, &p, "x = function() { };");
    ok(t, StrEqChars(e, e->ctags->name, "x"), "Tags.funcexpr.name");    
    ok(t, StrEqChars(e, e->ctags->grep, "x = function"), "Tags.funcexpr.grep");    
    TestParseRunClean(e, realm, p);        
    CtagsDel(e);

    TestParseRun(e, &realm, &p, "x = function() { }; a = function() {}");
    ok(t, StrEqChars(e, e->ctags->name, "a"), "Tags.funcexpr.sort.name.1");    
    ok(t, StrEqChars(e, e->ctags->next->name, "x"), "Tags.funcexpr.sort.name.2");    
    TestParseRunClean(e, realm, p);        
    CtagsDel(e);

    TestParseRun(e, &realm, &p, "x = function() { }; function a() {}");
    ok(t, StrEqChars(e, e->ctags->name, "a"), "Tags.funcexpr.sort.mixed.name.1");    
    ok(t, StrEqChars(e, e->ctags->next->name, "x"), "Tags.funcexpr.sort.mixed.name.2");    
    TestParseRunClean(e, realm, p);        
    CtagsDel(e);

    TestParseRun(e, &realm, &p, "o = { x: function() {} };");
    ok(t, StrEqChars(e, e->ctags->name, "x"), "Tags.propfunc.name");    
    ok(t, StrEqChars(e, e->ctags->grep, "o = { x: function"), "Tags.propfunc.grep");    
    TestParseRunClean(e, realm, p);        
    CtagsDel(e);

    e->options.genTags = FALSE;
}


void MethodDefTest(test* t) {
    Realm* realm;
    Parser* p;    
    Js* e = t->js;

    TestParseRun(e, &realm, &p, "'use strict'; o = { m() { return 3 } }; y = o.m()");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "MetdhoDefTest.normal");
    TestParseRunClean(e, realm, p);

   TestParseRun(e, &realm, &p, "o = { get x() { return 3 } }; y = o.x");
   ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "MetdhoDefTest.get");
   TestParseRunClean(e, realm, p);

   TestParseRun(e, &realm, &p, "o = { set x(a) { this.m = a } }; o.x = 3; y = o.m");
   ok(t, ValIsNumDel(e, TestVal(e, realm, "y"), 3), "MetdhoDefTest.set");
   TestParseRunClean(e, realm, p);
}


void JsonTest(test* t) {
    Js* e = t->js;
    Tokenizer* lex = TkNew(e);

    Val* j = ParseJsonChars(e, lex, "bad");
    ok(t, ValIsException(e, j), "Json.badData");
    ValDel(e, j);

    j = ParseJsonChars(e, lex, "{}");
    ok(t, ValIsObject(j), "Json.empty");
    ok(t, j->obj->properties == NULL, "Json.empty");
    ValDel(e, j);

    j = ParseJsonChars(e, lex, "{ 'x' :1 } ");
    ok(t, ValIsObject(j), "Json.one.type");
    Val* r = GetA(e, j, "x");
    ok(t, r->type == TYPE_NUM && r->num == 1, "Json.one.value");
    ValDel(e, j);
    ValDel(e, r);

    j = ParseJsonChars(e, lex, "{ 'x' :-1 } ");
    ok(t, ValIsObject(j), "Json.negative_one.type");
    r = GetA(e, j, "x");
    ok(t, r->type == TYPE_NUM && r->num == -1, "Json.negative_one.value");
    ValDel(e, j);
    ValDel(e, r);


    j = ParseJsonChars(e, lex, "{ 'x' :1, 'y':'hello' } ");
    ok(t, ValIsObject(j), "Json.two.type");
    r = GetA(e, j, "x");
    ok(t, r->type == TYPE_NUM && r->num == 1, "Json.two.value.x");
    ValDel(e, r);
    r = GetA(e, j, "y");
    ok(t, ValEqStrA(e, r, "hello"), "Json.two.value.y");
    ValDel(e, r);    
    ValDel(e, j);
    
    j = ParseJsonChars(e, lex, "{ 'x' :1, 'y' 'hello' } ");
    ok(t, !ValIsObject(j), "Json.noColon.type");
    ValDel(e, j);

    j = ParseJsonChars(e, lex, "{ 'a' :1, 'b': { 'x':2, 'y':3}, 'c': 4}");
    ok(t, ValIsObject(j), "Json.two.type");
    Val* a = GetA(e, j, "a");
    Val* b = GetA(e, j, "b");
    Val* c = GetA(e, j, "c");
    ok(t, a->type == TYPE_NUM && a->num ==1, "Json.object.a");    
    ok(t, ValIsObject(b), "Json.object.b.type");
    ok(t, c->type == TYPE_NUM && c->num ==4, "Json.object.c");
    Val* x = GetA(e, b, "x");
    ok(t, x->type == TYPE_NUM && x->num == 2, "Json.object.b.x");
    Val* y = GetA(e, b, "y");
    ok(t, y->type == TYPE_NUM && y->num == 3, "Json.object.b.y");
    ValDel(e, x);
    ValDel(e, y);
    ValDel(e, a);
    ValDel(e, b);
    ValDel(e, c);
    ValDel(e, j);

    j = ParseJsonChars(e, lex, "{ 'a' :[ 1,2,3] }");
    ok(t, ValIsObject(j), "Json.array.type");
    a = GetA(e, j, "a");
    ok(t, ValIsObject(a), "Json.array.a");
    x = GetA(e, a, "0");
    y = GetA(e, a, "1");
    Val* z = GetA(e, a, "2");
    ok(t, x->num == 1, "Json.array.a0");
    ok(t, y->num == 2, "Json.array.a1");
    ok(t, z->num == 3, "Json.array.a2");
    ValDel(e, z);
    ValDel(e, y);
    ValDel(e, x);
    ValDel(e, a);
    ValDel(e, j);

    j = ValNewObject(e);
    PutA(e, j, "x", ValNewNum(e, 1), TRUE);
    PutA(e, j, "y", ValNewNum(e, 2), TRUE);
    Val* s = JsonStringify(e, j);
    ValDel(e, j);
    j = ParseJsonStr(e, lex, StrClone(e, s->str));  // tokenizer needs a copy
    ok(t, ValIsObject(j), "Json.stringify.type");
    x = GetA(e, j, "x");
    ok(t, x->num == 1, "Json.stringify.x");
    y = GetA(e, j, "y");
    ok(t, y->num == 2, "Json.stringify.y");
    ValDel(e, x);
    ValDel(e, y);
    ValDel(e, j);
    ValDel(e, s);
    

    j = ParseJsonChars(e, lex, "{ 'a':1, 'b': {'x':2}, 'c':[3,4]}");
    ok(t, ValIsObject(j), "Json.complex.type");
    a = GetA(e, j, "a");
    b = GetA(e, j, "b");
    c = GetA(e, j, "c");
    ok(t, a->num ==1, "Json.complex.a");
    x = GetA(e, b, "x");
    ok(t, x->num ==2, "Json.complex.b.x");
    ok(t, IsArray(e, c), "Json.complex.c.isArray");
    Val* v0 = GetA(e, c, "0");
    Val* v1 = GetA(e, c, "1");
    ok(t, v0->num ==3, "Json.complex.c[0]");
    ok(t, v1->num ==4, "Json.complex.c[1]");
    ValDel(e, x);
    ValDel(e, v0);
    ValDel(e, v1);
    ValDel(e, a);
    ValDel(e, b);
    ValDel(e, c);

    s = JsonStringify(e, j);
    ValDel(e,j);
    j = ParseJsonStr(e, lex, StrClone(e, s->str)); 
    ValDel(e, s);
    ok(t, ValIsObject(j), "Json.complex.stringify.type");
    a = GetA(e, j, "a");
    b = GetA(e, j, "b");
    c = GetA(e, j, "c");
    ok(t, a->num ==1, "Json.complex.stringify.a");
    x = GetA(e, b, "x");
    ok(t, x->num ==2, "Json.complex.stringify.b.x");
    ok(t, IsArray(e, c), "Json.complex.stringify.c.isArray");
    v0 = GetA(e, c, "0");
    v1 = GetA(e, c, "1");
    ok(t, v0->num ==3, "Json.complex.stringify.c[0]");
    ok(t, v1->num ==4, "Json.complex.stringify.c[1]");
    ValDel(e, x);
    ValDel(e, v0);
    ValDel(e, v1);
    ValDel(e, a);
    ValDel(e, b);
    ValDel(e, c);
    ValDel(e, j);


    j = ValNewObject(e);
    PutA(e, j, "body", ValNewStrA(e, ""), TRUE);
    s = JsonStringify(e, j);
    ValDel(e, j);
    j = ParseJsonStr(e, lex, StrClone(e, s->str));  // tokenizer needs a copy
    ok(t, ValIsObject(j), "Json.stringify.emptyString.type");
    x = GetA(e, j, "body");
    ok(t, x->type == TYPE_STR, "Json.stringify.emptyString.value");
    ValDel(e, x);
    ValDel(e, j);
    ValDel(e, s);

    char * buffer = "{\"ignoreExceptions\":false,\"body\":{\"refs\":[{\"value\":3,\"type\":\"number\",\"handle\":0},{\"value\":2,\"type\":\"number\",\"handle\":1},{\"value\":1,\"type\":\"number\",\"handle\":2},{\"value\":3,\"type\":\"number\",\"handle\":3}],\"properties\":[{\"ref\":0,\"name\":\"2\"},{\"ref\":1,\"name\":\"1\"},{\"ref\":2,\"name\":\"0\"},{\"ref\":3,\"name\":\"length\"}],\"type\":\"object\",\"handle\":2,\"className\":\"Array\"},\"running\":true,\"success\":true,\"command\":\"evaluate\",\"request_seq\":1,\"type\":\"response\",\"seq\":17}";
    s = ValNewStrA(e, buffer);
    j = ParseJsonStr(e, lex, StrClone(e, s->str));
    x = GetA(e, j, "body");
    ok(t, ValIsObject(x), "Json.parse.complex");
    ValDel(e, s);
    ValDel(e, j);
    ValDel(e, x);

    TkDel(e, lex);

    Val* o = ValNewObject(e);
    PutA(e, o, "x", ValNewNum(e, INFINITY), 1);
    PutA(e, o, "y", ValNewNum(e, NAN), 1);
    j = JsonStringify(e, o);
    // ok(t, ValEqStrA(e, j, "{\"y\":\"NaN\",\"x\":\"Infinity\"}"), "Json.stringify.Infinity.#424");
    ok(t, ValEqStrA(e, j, "{\"x\":\"Infinity\",\"y\":\"NaN\"}"), "Json.stringify.Infinity.#424");
    ValDel(e, o);
    ValDel(e, j);


    Realm* realm;
    Parser* p;    

    TestParseRun(e, &realm, &p, "s = JSON.parse('{ \"a\" : 2 }');");
    s = TestVal(e, realm, "s");
    ok(t, ValIsNumDel(e, GetA(e, s, "a"), 2), "JSON.parse.object.simple");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "s = JSON.parse('9');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "s"), 9), "JSON.parse.primitive.number");
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "s = JSON.parse('\t1234');");
    ok(t, ValIsNumDel(e, TestVal(e, realm, "s"), 1234), "JSON.parse.primitive.leadingTab");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "s = JSON.parse('\\u000c1234');");
    ok(t, !ValIsNumDel(e, TestVal(e, realm, "s"), 1234), "JSON.parse.primitive.leading0xC");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "s = JSON.parse('\\u00a01234');");
    ok(t, !ValIsNumDel(e, TestVal(e, realm, "s"), 1234), "JSON.parse.primitive.leading0xa0");
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "s = JSON.parse('\"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\"');");
    s = TestVal(e, realm, "s");
    ok(t, ValIsException(e, s), "JSON.parse.primitive.stringAllEscapes");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "s = JSON.parse('\"\\\\u0X50\"') ");
    s = TestVal(e, realm, "s");
    ok(t, ValIsException(e, s), "JSON.parse.primitive.InvalidHexEscape");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "s = JSON.parse('\\u2028\\u20291234');");
    s = TestVal(e, realm, "s");
    ok(t, ValIsException(e, s), "JSON.parse.primitive.2028_2029");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);


    TestParseRun(e, &realm, &p, "o = JSON;\ns = Object.getOwnPropertyDescriptor(o, 'parse');c=s.configurable;");
    ok(t, ValIsTrueDel(e, TestVal(e, realm, "c")), "JSON.parse.getOwnPropertyDescriptor.configurable");
    TestParseRunClean(e, realm, p);



    TestParseRun(e, &realm, &p, "s = JSON.parse('[9,8]');");
    s = TestVal(e, realm, "s");
    ok(t, ValIsNumDel(e, GetA(e, s, "0"), 9), "JSON.parse.primitive.array.0");
    ok(t, ValIsNumDel(e, GetA(e, s, "1"), 8), "JSON.parse.primitive.array.1");
    ok(t, ValIsNumDel(e, GetA(e, s, "length"), 2), "JSON.parse.primitive.array.length");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);

    TestParseRun(e, &realm, &p, "function F(n,v) { if(n == '') return v; return v*2 }; s = JSON.parse('{\"a\":2, \"b\":3}', F);");
    s = TestVal(e, realm, "s");
    ok(t, ValIsNumDel(e, GetA(e, s, "a"), 4), "JSON.parse.object.reviver.a");
    ok(t, ValIsNumDel(e, GetA(e, s, "b"), 6), "JSON.parse.object.reviver.b");
    ValDel(e, s);
    TestParseRunClean(e, realm, p);    


}

typedef struct {
    DynStr* input;
    DynStr* output;
} TestSocket;

TestSocket* TestSocketNew(Js* e) {
    TestSocket* ts = (TestSocket*) _hallocsize(e->memory[XX].data, sizeof(TestSocket), __LINE__);
    ts->input = DynStrNew(e, 1000);
    ts->output = DynStrNew(e, 1000);
    return ts;
}

void* TestSocketInit(Js* e, void* d) {
    return (void*)(long)1;
}

int TestSocketListen(Js* e, void* fd, int count) {
    return 1;
}

int TestSocketRead(Js* e, void* socket, char* buffer, int count) {
    TestSocket* ts = (TestSocket*) socket;
#ifdef JSE_MAIN    
    errno = 0;
#endif    
    return DynStrReadA(e, ts->input, buffer, count);
}

int TestSocketWrite(Js* e, void* socket, char* buffer, int count) {
    TestSocket* ts = (TestSocket*) socket;
    DynStrWriteA(e, ts->output, buffer, count);
    return count;
}

void* TestSocketAccept(Js* e, int handle) {
    return TestSocketNew(e);
}

void TestSocketClose(Js* e, void* socket) {
    TestSocket* ts = (TestSocket*) socket;
    DynStrDel(e, ts->input);
    DynStrDel(e, ts->output);
    hfree(e->memory[XX].data, ts);
}

void TestPrint(Js* e, bool_t ext, const char * format, ... ) {
}

void TestVPrint(Js* e, char* prefix, Val* v, bool_t detail) {

}

#ifdef JSE_MAIN    

Val* DebuggerTestSendCore(DebugContext* dc, void* socket) {
    Js* e = dc->p->e;
    TestSocket* ts = (TestSocket*) socket;
    DynStrClear(e, ts->output);

    bool_t rb = DebugExec(dc);
    if(!rb) {
        return NULL;
    }
    int next;
    int contentLength = DebugContentLengthFromStr(e, ts->output->str, &next);
    if(contentLength <= 0)
        return ValNew(e);
    
    Str* s2 = StrNewLength(e, ts->output->str->length - next);
    for(int i=0; i < s2->length; i++)
        s2->chars[i] = ts->output->str->chars[next+i];

    Tokenizer* lex = TkNew(e);
    TkTokenizeS(e, lex, s2, 0, 0);
    Val* obj = JsonParse(e, lex, NULL);
    TkDel(e, lex);
    return obj;    
}

Val* DebuggerTestSend(DebugContext* dc, void* socket, char* buffer) {
    Js* e = dc->p->e;
    int len = (int) strlen(buffer);
    char* encoded = (char*) _hallocsize(e->memory[ST].data, len+1, __LINE__);
    // Replace all ' with " in the buffer
    char* target = encoded;
    for(char* p=buffer; *p; p++, target++) {
        if(*p == '\'') 
            *target = '"';
        else
            *target = *p;
    }
    *target = '\0';
    TestSocket* ts = (TestSocket*) socket;

    DynStrClear(e, ts->input);
    DynStrAddStrA(e, ts->input, encoded);
    hfree(e->memory[ST].data, encoded);
    return DebuggerTestSendCore(dc, socket);
}

bool_t DebugTestValidateResponse(DebugContext* dc, Val* res, char* cmd, int reqs, bool_t suc, bool_t run) {
    Js* e = dc->p->e;
    if(!ValIsObject(res)) 
        return FALSE;

    if(!ValIsStrADel(e, GetA(e, res, "type"), "response"))
        return FALSE;

    if(!ValIsNumDel(e, GetA(e, res, "request_seq"), reqs))
        return FALSE;

    if(!ValIsStrADel(e, GetA(e, res, "command"), cmd))
        return FALSE;

    bool_t b = ValIsTrueDel(e, GetA(e, res, "success"));
    if(b != suc)
        return FALSE;

    b = ValIsTrueDel(e, GetA(e, res, "running"));
    if(b != run)
        return FALSE;

    return TRUE;
}
#endif


Val* ArrayGetAt(Js* e, Val* array, int index) {
    char buff[20];
    sprintf(buff, "%d", index);
    return GetA(e, array, buff);
}

Val* DbgGetRefFromProp(Js* e, Val* properties, Val* refs, char* name) {
    int len = ArrayGetIntLen(e, properties);
    int handle = -1;
    for(int i=0; i < len; i++) {
        Val* ref = ArrayGetAt(e, properties, i);
        Val* refName = GetA(e, ref, "name");
        if(ValEqStrA(e, refName, name)) {
            Val* refHandle = GetA(e, ref, "ref");
            handle = (int) refHandle->num;
            ValDel(e, ref);
            ValDel(e, refHandle);
            ValDel(e, refName);
            break;
        }
        ValDel(e, refName);
        ValDel(e, ref);
    }    

    if(handle == -1)
        return ValNew(e);
    return ArrayGetAt(e, refs, handle);
}

void DbgTest(test* t) {
#ifdef JSE_MAIN    
    Js* e = t->js;

    DebugContext* dc = DebugContextNew(e);
    dc->appendCR = 0;
    dc->init = TestSocketInit;
    dc->listen = TestSocketListen;
    dc->accept = TestSocketAccept;
    dc->read = TestSocketRead;
    dc->write = TestSocketWrite;
    dc->close = TestSocketClose;
    dc->print = TestPrint;
    dc->vprint = TestVPrint;

    Debugger* dbg = DebuggerNew(e, dc);
    ParserSetFileName(dc->p, "*test*.js");
    Val* v = ParseA(dc->p, "x=20", 0);
    ValDel(e, v);

    int sockfd = DebugListenSocket(e, dc);
    ok(t, sockfd >= 0, "Dbg.Listen");
    void* new_fd = dc->accept(e, sockfd);
    ok(t, new_fd >= 0, "Dbg.Accept");
    dc->sock = new_fd;
    DebugSendConnected(dc);

    char* request = "{ 'seq': 1, 'type': 'request', 'command': 'continue' }";
    Val* res = DebuggerTestSend(dc, new_fd, request); 
    ok(t, DebugTestValidateResponse(dc,res,"continue", 1, TRUE, TRUE ), "Dbg.continue");
    ValDel(e, res);

    request = "{ 'seq': 1, 'type': 'request',  'command': 'evaluate', 'arguments': { 'expression' : '3*4' }}";
    res = DebuggerTestSend(dc, new_fd, request);
    ok(t, ValIsObject(res), "Dbg.Request.evaluate.response");
    Val* body = GetA(e, res, "body");
    ok(t, ValIsNumDel(e, GetA(e, body, "value"), 12), "Dbg.evaluate.simple.value");
    ok(t, ValIsStrADel(e, GetA(e, body, "type"), "number"), "Dbg.evaluate.simple.type");
    ValDel(e, body);
    ValDel(e, res);


    request = "{ 'seq': 1, 'type': 'request', 'command': 'disconnect' }";
    res = DebuggerTestSend(dc, new_fd, request);
    ok(t, !ValIsTrueDel(e, GetA(e, res, "running")), "Dbg.disconnect.running");
    ValDel(e, res);


    DebugContextResetParser(dc);
    ParserSetFileName(dc->p, "foo.js");
    v = ParseA(dc->p, "if(2", 0);
    ValDel(e, v);
    request = "{'seq': 1, 'type': 'request', 'command': 'continue' }";
    res = DebuggerTestSend(dc, new_fd, request); 
    ok(t, DebugTestValidateResponse(dc,res,"continue", 1, FALSE, FALSE ), "Dbg.continue.error");
    ok(t, ValIsStrADel(e, GetA(e, res, "message"), "foo.js:1 SyntaxError: ) expected"), "debug.continue.error.message");
    ValDel(e, res);


    DebugContextResetParser(dc);
    ParserSetFileName(dc->p, "foo.js");
    v = ParseA(dc->p, "a = [1,2,3]", 0);
    ValDel(e, v);
    request = "{ 'seq': 1, 'type': 'request', 'command': 'continue' }";
    res = DebuggerTestSend(dc, new_fd, request); 
    ok(t, DebugTestValidateResponse(dc,res,"continue", 1, TRUE, TRUE ), "Dbg.evaluate.array.continue");
    ValDel(e, res);
    request = "{ 'seq': 1, 'type': 'request',  'command': 'evaluate', 'arguments': { 'expression' : 'a' }}";
    res = DebuggerTestSend(dc, new_fd, request);
    ok(t, ValIsObject(res), "Dbg.evaluate.array.response");
    body = GetA(e, res, "body");
    ok(t, ValIsObject(body), "Dbg.evaluate.array.body");
    Val* props = GetA(e, body, "properties");    
    Val* refs = GetA(e, res, "refs");
    ok(t, ValIsObject(props), "Dbg.evaluate.array.body.properties");
    ok(t, ValIsObject(refs), "Dbg.evaluate.array.body.refs");
    Val* r0 = DbgGetRefFromProp(e, props, refs, "0");
    Val* r1 = DbgGetRefFromProp(e, props, refs, "1");
    Val* r2 = DbgGetRefFromProp(e, props, refs, "2");
    ok(t, ValIsNumDel(e, GetA(e, r0, "value"), 1), "Dbg.evaluate.array.refs.0");
    ok(t, ValIsNumDel(e, GetA(e, r1, "value"), 2), "Dbg.evaluate.array.refs.1");
    ok(t, ValIsNumDel(e, GetA(e, r2, "value"), 3), "Dbg.evaluate.array.refs.2");
    ok(t, ValIsStrADel(e, GetA(e, body, "className"), "Array"), "Dbg.evaluate.array.body.className");
    ok(t, ValIsStrADel(e, GetA(e, body, "type"), "object"), "Dbg.evaluate.array.body.type");    
    ValDel(e, r0);
    ValDel(e, r1);
    ValDel(e, r2);
    ValDel(e, props);
    ValDel(e, refs);
    ValDel(e, body);
    ValDel(e, res);


    DebugContextResetParser(dc);
    ParserSetFileName(dc->p, "foo.js");
    v = ParseA(dc->p, "a = { x: 'hello', y:2}", 0);
    ValDel(e, v);
    request = "{ 'seq': 1, 'type': 'request', 'command': 'continue' }";
    res = DebuggerTestSend(dc, new_fd, request); 
    ok(t, DebugTestValidateResponse(dc,res,"continue", 1, TRUE, TRUE ), "Dbg.evaluate.object.continue");
    ValDel(e, res);
    request = "{ 'seq': 1, 'type': 'request',  'command': 'evaluate', 'arguments': { 'expression' : 'a' }}";
    res = DebuggerTestSend(dc, new_fd, request);
    ok(t, ValIsObject(res), "Dbg.evaluate.object.response");
    body = GetA(e, res, "body");
    ok(t, ValIsObject(body), "Dbg.evaluate.object.body");
    props = GetA(e, body, "properties");    
    refs = GetA(e, res, "refs");
    ok(t, ValIsObject(props), "Dbg.evaluate.object.body.properties");
    ok(t, ValIsObject(refs), "Dbg.evaluate.object.body.refs");
    Val* rx = DbgGetRefFromProp(e, props, refs, "x");
    Val* ry = DbgGetRefFromProp(e, props, refs, "y");
    ok(t, ValIsStrADel(e, GetA(e, rx, "value"), "hello"), "Dbg.evaluate.object.refs.x.value");
    ok(t, ValIsNumDel(e, GetA(e, rx, "length"), 5), "Dbg.evaluate.object.refs.x.length");
    ok(t, ValIsNumDel(e, GetA(e, ry, "value"), 2), "Dbg.evaluate.object.refs.y.value");
    ok(t, ValIsStrADel(e, GetA(e, body, "className"), "Object"), "Dbg.evaluate.object.body.className");
    ok(t, ValIsStrADel(e, GetA(e, body, "type"), "object"), "Dbg.evaluate.object.body.type");
    ValDel(e, rx);
    ValDel(e, ry);
    ValDel(e, props);
    ValDel(e, refs);
    ValDel(e, body);
    ValDel(e, res);


    DebugContextResetParser(dc);
    ParserSetFileName(dc->p, "foo.js");
    v = ParseA(dc->p, "o = { x:[5, 6], y:{ x : 'Hello', z : 9 }, z:'Hello' };", 0);
    ValDel(e, v);
    request = "{ 'seq': 1, 'type': 'request', 'command': 'continue' }";
    res = DebuggerTestSend(dc, new_fd, request); 
    ok(t, DebugTestValidateResponse(dc,res,"continue", 1, TRUE, TRUE ), "Dbg.evaluate.complex.continue");
    ValDel(e, res);
    request = "{ 'seq': 1, 'type': 'request',  'command': 'evaluate', 'arguments': { 'expression' : 'o' }}";
    res = DebuggerTestSend(dc, new_fd, request);
    ok(t, ValIsObject(res), "Dbg.evaluate.complex.response");
    body = GetA(e, res, "body");
    ok(t, ValIsObject(body), "Dbg.evaluate.complex.body");
    props = GetA(e, body, "properties");    
    refs = GetA(e, res, "refs");
    ok(t, ValIsObject(props), "Dbg.evaluate.object.complex.properties");
    ok(t, ValIsObject(refs), "Dbg.evaluate.object.complex.refs");
    rx = DbgGetRefFromProp(e, props, refs, "x");
    ry = DbgGetRefFromProp(e, props, refs, "y");
    Val* rz = DbgGetRefFromProp(e, props, refs, "z");
    ok(t, ValIsStrADel(e, GetA(e, rz, "value"), "Hello"), "Dbg.evaluate.complex.refs.z.value");
    ok(t, ValIsNumDel(e, GetA(e, rz, "length"), 5), "Dbg.evaluate.complex.refs.z.length");
    Val* xprops = GetA(e, rx, "properties");
    Val* rx0 = DbgGetRefFromProp(e, xprops, refs, "0");
    Val* rx1 = DbgGetRefFromProp(e, xprops, refs, "1");
    ok(t, ValIsNumDel(e, GetA(e, rx0, "value"), 5), "Dbg.evaluate.complex.refs.x.0.value");
    ok(t, ValIsNumDel(e, GetA(e, rx1, "value"), 6), "Dbg.evaluate.complex.refs.x.1.value");
    ValDel(e, xprops);
    Val* yprops = GetA(e, ry, "properties");
    Val* ryx = DbgGetRefFromProp(e, yprops, refs, "x");
    Val* ryz = DbgGetRefFromProp(e, yprops, refs, "z");
    ok(t, ValIsStrADel(e, GetA(e, ryx, "value"), "Hello"), "Dbg.evaluate.complex.refs.y.x.value");
    ok(t, ValIsNumDel(e, GetA(e, ryz, "value"), 9), "Dbg.evaluate.complex.refs.y.z.value");
    ValDel(e, ryx);
    ValDel(e, ryz);
    ValDel(e, yprops);
    ValDel(e, rx0);
    ValDel(e, rx1);
    ValDel(e, rx);
    ValDel(e, ry);
    ValDel(e, rz);
    ValDel(e, props);
    ValDel(e, refs);
    ValDel(e, body);
    ValDel(e, res);


    DebugContextResetParser(dc);
    ParserSetFileName(dc->p, "foo.js");
    v = ParseA(dc->p, "function f(a) { return a*2};\nr = f(3);", 0);
    ValDel(e, v);
    request = "{ 'seq': 1, 'type': 'request', 'command': 'continue' }";
    res = DebuggerTestSend(dc, new_fd, request); 
    ok(t, DebugTestValidateResponse(dc,res,"continue", 1, TRUE, TRUE ), "Dbg.evaluate.function.continue");
    ValDel(e, res);
    request = "{ 'seq': 1, 'type': 'request',  'command': 'evaluate', 'arguments': { 'expression' : 'r' }}";
    res = DebuggerTestSend(dc, new_fd, request);
    ok(t, ValIsObject(res), "Dbg.evaluate.function.response");
    body = GetA(e, res, "body");
    ok(t, ValIsObject(body), "Dbg.evaluate.function.body");
    ok(t, ValIsStrADel(e, GetA(e, body, "type"), "number"), "Dbg.evaluate.function.body.type");
    ok(t, ValIsNumDel(e, GetA(e, body, "value"), 6), "Dbg.evaluate.function.body.value");
    ValDel(e, body);
    ValDel(e, res);

    dc->close(e, new_fd);    
    DebugContextDel(dc);
    DebuggerDel(e, dbg);
#endif    
}




typedef void(*test_func)(test* t);

typedef struct {
    int enable;
    char* title;
    test_func proc;
    bool_t needContext;
    uint32 noInit;
} test_unit;


//#define SCRATCH

test_unit all_tests[] = {
#ifdef SCRATCH
    { 1, "scratch", ScratchTest, 0 }
#else
    { 1, "code_point", CodePointTest, 0, NNN},
    { 1, "Str", StrTest , 0, NNN},
    { 1, "Val", ValTest, 0, NNN },
    { 1, "Strmap", StrMapTest , 0, NNN },
    { 1, "tk", TkTest , 0, NNN },
    { 1, "Property", PropTest , 1, NNN },
    { 1, "obj", ObjectTest , 0, NNN },
    { 1, "ordinary", OrdinaryTest , 1, NNN },
    { 1, "Js", EngineTest , 0, NNN },
    { 1, "Realm", RealmTest , 1, NNN },
    { 1, "Completion", CompTest , 0, NNN },
    { 1, "List", ListTest , 0, NNN },
    { 1, "Ref", RefTest , 1 , NNN},
    { 1, "Data", DataTest , 0, NNN },
    { 1, "conv", ConvTest , 1, NNN },
    { 1, "check", CheckTest , 1, NNN },
    { 1, "objops", ObjOpsTest , 1, NNN },
    { 1, "iter", IterTest , 1, NNN },
    { 0, "promise", PromiseTest , 0, NNN },
    { 1, "DeclEnv", DeclEnvTest , 1, NNN },
    { 1, "ObjEnv", ObjEnvTest , 0, NNN },
    { 0, "FuncEnv", FuncEnvTest , 0, NNN },
    { 1, "GlobalEnv", GlobalEnvTest , 0, NNN },
    { 0, "LexEnv", LexEnvTest , 0, NNN },
    { 1, "context", ContextTest , 1, NNN },
    { 1, "Task", TaskTest , 0, NNN },
    { 0, "function", FunctionTest , 1, NNN },
    { 1, "Builtin", BuiltinTest , 1, NNN },
    { 0, "BoundFunction", BoundFunctionTest , 1, NNN },
    { 1, "Array", ArrayTest , 1, NNN },
    { 1, "String", StringTest , 1, NNN },
    { 1, "Arguments", ArgumentsTest , 1, NNN },
    { 1, "IntegerIndexed", IntegerIndexedTest , 1, NNN },
    { 1, "Proxy", ProxyTest , 1, NNN },
    { 1, "Parser", ParserTest , 0, NNN },
    { 1, "Interpreter", InterpreterTest , 1, ONLY(NRE) },
    { 1, "Json", JsonTest , 1, ONLY(NJS) },
    { 1, "Dbg", DbgTest, 1, NNN },
    { 1, "Watcher", WatcherTest , 0, 0 },
    { 1, "Func", FuncTest , 0, NNN },
    { 1, "Def", DefTest, 0, NNN },
    { 1, "Global", GlobalTest,0, ONLY(NGF)},
    { 1, "Global2", GlobalTest2,0, ONLY(NGF)},
    { 1, "ObjProto", ObjProtoTest,0, 0 }, 
    { 1, "FunctionCons", FuncConsTest, 0, 0 },
    { 1, "BooleanCons", BooleanConsTest, 0, 0 },
    { 1, "SymbolCons", SymbolConsTest, 0, 0 },
    { 1, "ErrorObj", ErrorObjTest, 0, ONLY(NER) },
    { 1, "Number", NumObjTest, 0, 0 },
    { 1, "Math", MathTest, 0, ONLY(NMT)},
    { 1 , "Date", DateTest, 0, ONLY(NDT)},
    { 1 , "String", StrObjTest, 0, ONLY(NST)},
    { 1 , "Array", ArrayObjTest, 0, 0},
    { 1 , "Tags", TagsTest, 0, NNN},
    { 1, "TkRange", TkTest2 , 0, NNN},
    { 1, "TypedArray", TypedArrayConsTest, ONLY(NTA) | ONLY(NAT)} ,
    { 1, "ArrayBuffer", ArrayBufferConsTest, ONLY(NTA) },
    { 1, "RegExp", RegExpTest, ONLY(NRE) },
    { 1, "Utf8Test", Utf8Test, 0},
    { 1, "MethodParse", MethodParseTest , 0, NNN },
    { 1, "MethodDef", MethodDefTest , 0, NNN },    

#endif
};

int MainTest(Js* e) {
    bool_t verbose = e->options.verbose;    
    test t;
    test_init(e, &t);
    t.verbose = verbose;
    int skipped = 0;
    number start = now();
    if(!e->options.opml)
        jprintf(e,0,"running tests...\n");
    
    int count = sizeof(all_tests) / sizeof(test_unit);
    for(int i=0; i < count; i++) {
        test_unit* tu = &all_tests[i];

        if(tu->enable == 1) {
            int counts[HEAPS];
            for(int i=0; i < HEAPS; i++) 
                counts[i] = e->memory[i].data->allocs;

            e->noInit = tu->noInit;
            if(tu->needContext) {
                EnsureContext(e);
            }            
            tu->proc(&t);
            if(tu->needContext) {
                EndContext(e);
            }                        
            gc(e, NULL);

            char testName[255];
            int leaks = 0;
            for(int i=0; i < HEAPS; i++) {
                counts[i] = e->memory[i].data->allocs - counts[i];
                leaks += counts[i];
                if(counts[i] != 0)
                    printf("%s %d %s leaks\n", tu->title, counts[i], e->memory[i].name);
            }
            sprintf(testName, "%s.memory %d leak(s)", tu->title, leaks);
            ok(&t, leaks == 0, testName);
        }
        else
            skipped++;
    }
    
    number end = now();
    if(!e->options.opml)
        jprintf(e,0,"%spassed:%d %sfailed:%d %sskipped:%d %.2fs\n",
            e->colors.green, t.passed,
            (t.failed)? e->colors.red : e->colors.green, t.failed,
            e->colors.yellow, skipped,
            e->colors.normal, 
            (end - start) / 1000);
    if(t.failed > 0)
        return -1;
    return 0;
}

#endif // JSE_TEST
/////////////////////////////////////////////////////////////////////////////////

